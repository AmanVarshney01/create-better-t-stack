/**
 * Build script to embed templates at build time
 * Generates a TypeScript file with all templates as a Map<string, string>
 * This allows the package to work in browsers without filesystem access
 */

import fs from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";
import { glob } from "tinyglobby";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const TEMPLATES_DIR = path.join(__dirname, "../templates");
const OUTPUT_FILE = path.join(__dirname, "../src/templates.generated.ts");

const BINARY_EXTENSIONS = [
  ".png",
  ".ico",
  ".svg",
  ".jpg",
  ".jpeg",
  ".gif",
  ".webp",
  ".woff",
  ".woff2",
  ".ttf",
  ".eot",
  ".mp4",
  ".webm",
];

function isBinaryFile(filePath: string): boolean {
  const ext = path.extname(filePath).toLowerCase();
  return BINARY_EXTENSIONS.includes(ext);
}

async function generateTemplates() {
  console.log("üì¶ Generating embedded templates...");

  const files = await glob("**/*", {
    cwd: TEMPLATES_DIR,
    dot: true,
    onlyFiles: true,
  });

  console.log(`üìÇ Found ${files.length} template files`);

  const entries: string[] = [];

  for (const file of files) {
    const fullPath = path.join(TEMPLATES_DIR, file);
    const normalizedPath = file.replace(/\\/g, "/");

    let content: string;
    if (isBinaryFile(file)) {
      content = "[Binary file]";
    } else {
      content = fs.readFileSync(fullPath, "utf-8");
    }

    // Escape backticks and ${} for template literal
    const escapedContent = content
      .replace(/\\/g, "\\\\")
      .replace(/`/g, "\\`")
      .replace(/\$\{/g, "\\${");

    entries.push(`  ["${normalizedPath}", \`${escapedContent}\`]`);
  }

  const output = `/**
 * Auto-generated embedded templates
 * DO NOT EDIT - This file is generated by scripts/generate-templates.ts
 * Run 'bun run generate-templates' to regenerate
 */

export const EMBEDDED_TEMPLATES: Map<string, string> = new Map([
${entries.join(",\n")}
]);

export const TEMPLATE_COUNT = ${files.length};
`;

  fs.writeFileSync(OUTPUT_FILE, output);

  const stats = fs.statSync(OUTPUT_FILE);
  const sizeMB = (stats.size / (1024 * 1024)).toFixed(2);

  console.log(`‚úÖ Generated ${OUTPUT_FILE}`);
  console.log(`üìä File size: ${sizeMB} MB (${files.length} templates)`);
}

generateTemplates().catch((err) => {
  console.error("‚ùå Failed to generate templates:", err);
  process.exit(1);
});
