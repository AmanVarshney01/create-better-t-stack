"""Main application entry point."""

import os

from dotenv import load_dotenv

load_dotenv()

{{#if (eq pythonWebFramework "fastapi")}}
from contextlib import asynccontextmanager

from fastapi import FastAPI{{#if (or (eq pythonOrm "sqlalchemy") (eq pythonOrm "sqlmodel"))}}, Depends, HTTPException{{/if}}{{#if (and (eq pythonOrm "none") (eq pythonValidation "pydantic"))}}, HTTPException{{/if}}
from fastapi.middleware.cors import CORSMiddleware
{{#if (eq pythonValidation "pydantic")}}
from app.settings import get_settings
{{#if (eq pythonOrm "none")}}
from app.schemas import ItemCreate, ItemResponse, MessageCreate, MessageResponse
{{/if}}
{{/if}}
{{#if (eq pythonOrm "sqlalchemy")}}
from sqlalchemy.orm import Session

from app import crud
from app.database import get_db, init_db
{{#if (eq pythonValidation "pydantic")}}
from app.schemas import PostCreate, PostResponse, PostUpdate, UserCreate, UserResponse, UserUpdate
{{/if}}
{{/if}}
{{#if (eq pythonOrm "sqlmodel")}}
from sqlmodel import Session

from app import crud
from app.database import get_db, init_db
from app.models import (
    PostCreate,
    PostResponse,
    PostUpdate,
    UserCreate,
    UserResponse,
    UserUpdate,
)
{{/if}}
{{#if (includes pythonAi "langchain")}}
from fastapi.responses import StreamingResponse

from app.langchain_client import chat, chat_stream, simple_completion
from app.langchain_schemas import (
    ChatRequest,
    ChatResponse,
    CompletionRequest,
    CompletionResponse,
)
{{/if}}


@asynccontextmanager
async def lifespan(app: FastAPI):
    """Application lifespan handler."""
{{#if (or (eq pythonOrm "sqlalchemy") (eq pythonOrm "sqlmodel"))}}
    # Initialize database tables on startup
    init_db()
{{/if}}
    yield


{{#if (eq pythonValidation "pydantic")}}
settings = get_settings()

app = FastAPI(
    title=settings.app_name,
    description="A Python API built with Better Fullstack",
    version="0.1.0",
    lifespan=lifespan,
)
{{else}}
app = FastAPI(
    title="{{projectName}}",
    description="A Python API built with Better Fullstack",
    version="0.1.0",
    lifespan=lifespan,
)
{{/if}}

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


@app.get("/")
async def root():
    """Root endpoint."""
    return {"message": "Welcome to {{projectName}}!"}


@app.get("/health")
async def health():
    """Health check endpoint."""
    return {"status": "healthy"}

{{#if (includes pythonAi "langchain")}}

# LangChain AI endpoints
@app.post("/ai/chat", response_model=ChatResponse)
async def langchain_chat(request: ChatRequest):
    """Chat with an AI assistant using LangChain.

    Supports conversation history for multi-turn conversations.
    """
    history = None
    if request.history:
        history = [{"role": msg.role, "content": msg.content} for msg in request.history]

    response = await chat(
        message=request.message,
        history=history,
        system_prompt=request.system_prompt or "You are a helpful assistant.",
        model=request.model or "gpt-4o-mini",
        temperature=request.temperature or 0.7,
    )
    return ChatResponse(response=response)


@app.post("/ai/chat/stream")
async def langchain_chat_stream(request: ChatRequest):
    """Chat with an AI assistant using LangChain with streaming response.

    Returns a Server-Sent Events stream of the response.
    """
    history = None
    if request.history:
        history = [{"role": msg.role, "content": msg.content} for msg in request.history]

    async def generate():
        async for chunk in chat_stream(
            message=request.message,
            history=history,
            system_prompt=request.system_prompt or "You are a helpful assistant.",
            model=request.model or "gpt-4o-mini",
            temperature=request.temperature or 0.7,
        ):
            yield f"data: {chunk}\n\n"
        yield "data: [DONE]\n\n"

    return StreamingResponse(generate(), media_type="text/event-stream")


@app.post("/ai/completion", response_model=CompletionResponse)
async def langchain_completion(request: CompletionRequest):
    """Get a simple completion from the AI without conversation history."""
    completion = simple_completion(
        prompt=request.prompt,
        model=request.model or "gpt-4o-mini",
        temperature=request.temperature or 0.7,
    )
    return CompletionResponse(completion=completion)
{{/if}}
{{#if (and (eq pythonOrm "none") (eq pythonValidation "pydantic"))}}

# In-memory storage for demo (replace with database in production)
_items: dict[int, ItemResponse] = {}
_next_id = 1


@app.post("/items", response_model=ItemResponse, status_code=201)
async def create_item(item: ItemCreate):
    """Create a new item with validated data."""
    global _next_id
    item_response = ItemResponse(
        id=_next_id,
        name=item.name,
        description=item.description,
        price=item.price,
        quantity=item.quantity,
    )
    _items[_next_id] = item_response
    _next_id += 1
    return item_response


@app.get("/items", response_model=list[ItemResponse])
async def list_items():
    """List all items."""
    return list(_items.values())


@app.get("/items/{item_id}", response_model=ItemResponse)
async def get_item(item_id: int):
    """Get an item by ID."""
    if item_id not in _items:
        raise HTTPException(status_code=404, detail="Item not found")
    return _items[item_id]


@app.post("/contact", response_model=MessageResponse)
async def send_message(message: MessageCreate):
    """Send a contact message with validated email."""
    # In a real app, this would send an email or store the message
    return MessageResponse(
        success=True,
        message=f"Message received from {message.email}",
    )
{{/if}}
{{#if (eq pythonOrm "sqlalchemy")}}

# User endpoints
{{#if (eq pythonValidation "pydantic")}}
@app.post("/users", response_model=UserResponse, status_code=201)
async def create_user(user: UserCreate, db: Session = Depends(get_db)):
    """Create a new user."""
    existing = crud.get_user_by_email(db, user.email)
    if existing:
        raise HTTPException(status_code=400, detail="Email already registered")
    return crud.create_user(db, user)


@app.get("/users", response_model=list[UserResponse])
async def list_users(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
    """List all users."""
    return crud.get_users(db, skip=skip, limit=limit)


@app.get("/users/{user_id}", response_model=UserResponse)
async def get_user(user_id: int, db: Session = Depends(get_db)):
    """Get a user by ID."""
    user = crud.get_user(db, user_id)
    if user is None:
        raise HTTPException(status_code=404, detail="User not found")
    return user


@app.patch("/users/{user_id}", response_model=UserResponse)
async def update_user(user_id: int, user: UserUpdate, db: Session = Depends(get_db)):
    """Update a user."""
    updated = crud.update_user(db, user_id, user)
    if updated is None:
        raise HTTPException(status_code=404, detail="User not found")
    return updated


@app.delete("/users/{user_id}", status_code=204)
async def delete_user(user_id: int, db: Session = Depends(get_db)):
    """Delete a user."""
    if not crud.delete_user(db, user_id):
        raise HTTPException(status_code=404, detail="User not found")


# Post endpoints
@app.post("/posts", response_model=PostResponse, status_code=201)
async def create_post(post: PostCreate, db: Session = Depends(get_db)):
    """Create a new post."""
    # Verify author exists
    if crud.get_user(db, post.author_id) is None:
        raise HTTPException(status_code=400, detail="Author not found")
    return crud.create_post(db, post)


@app.get("/posts", response_model=list[PostResponse])
async def list_posts(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
    """List all posts."""
    return crud.get_posts(db, skip=skip, limit=limit)


@app.get("/posts/{post_id}", response_model=PostResponse)
async def get_post(post_id: int, db: Session = Depends(get_db)):
    """Get a post by ID."""
    post = crud.get_post(db, post_id)
    if post is None:
        raise HTTPException(status_code=404, detail="Post not found")
    return post


@app.patch("/posts/{post_id}", response_model=PostResponse)
async def update_post(post_id: int, post: PostUpdate, db: Session = Depends(get_db)):
    """Update a post."""
    updated = crud.update_post(db, post_id, post)
    if updated is None:
        raise HTTPException(status_code=404, detail="Post not found")
    return updated


@app.delete("/posts/{post_id}", status_code=204)
async def delete_post(post_id: int, db: Session = Depends(get_db)):
    """Delete a post."""
    if not crud.delete_post(db, post_id):
        raise HTTPException(status_code=404, detail="Post not found")
{{/if}}
{{/if}}
{{#if (eq pythonOrm "sqlmodel")}}

# User endpoints
@app.post("/users", response_model=UserResponse, status_code=201)
async def create_user(user: UserCreate, db: Session = Depends(get_db)):
    """Create a new user."""
    existing = crud.get_user_by_email(db, user.email)
    if existing:
        raise HTTPException(status_code=400, detail="Email already registered")
    return crud.create_user(db, user)


@app.get("/users", response_model=list[UserResponse])
async def list_users(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
    """List all users."""
    return crud.get_users(db, skip=skip, limit=limit)


@app.get("/users/{user_id}", response_model=UserResponse)
async def get_user(user_id: int, db: Session = Depends(get_db)):
    """Get a user by ID."""
    user = crud.get_user(db, user_id)
    if user is None:
        raise HTTPException(status_code=404, detail="User not found")
    return user


@app.patch("/users/{user_id}", response_model=UserResponse)
async def update_user(user_id: int, user: UserUpdate, db: Session = Depends(get_db)):
    """Update a user."""
    updated = crud.update_user(db, user_id, user)
    if updated is None:
        raise HTTPException(status_code=404, detail="User not found")
    return updated


@app.delete("/users/{user_id}", status_code=204)
async def delete_user(user_id: int, db: Session = Depends(get_db)):
    """Delete a user."""
    if not crud.delete_user(db, user_id):
        raise HTTPException(status_code=404, detail="User not found")


# Post endpoints
@app.post("/posts", response_model=PostResponse, status_code=201)
async def create_post(post: PostCreate, db: Session = Depends(get_db)):
    """Create a new post."""
    # Verify author exists
    if crud.get_user(db, post.author_id) is None:
        raise HTTPException(status_code=400, detail="Author not found")
    return crud.create_post(db, post)


@app.get("/posts", response_model=list[PostResponse])
async def list_posts(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
    """List all posts."""
    return crud.get_posts(db, skip=skip, limit=limit)


@app.get("/posts/{post_id}", response_model=PostResponse)
async def get_post(post_id: int, db: Session = Depends(get_db)):
    """Get a post by ID."""
    post = crud.get_post(db, post_id)
    if post is None:
        raise HTTPException(status_code=404, detail="Post not found")
    return post


@app.patch("/posts/{post_id}", response_model=PostResponse)
async def update_post(post_id: int, post: PostUpdate, db: Session = Depends(get_db)):
    """Update a post."""
    updated = crud.update_post(db, post_id, post)
    if updated is None:
        raise HTTPException(status_code=404, detail="Post not found")
    return updated


@app.delete("/posts/{post_id}", status_code=204)
async def delete_post(post_id: int, db: Session = Depends(get_db)):
    """Delete a post."""
    if not crud.delete_post(db, post_id):
        raise HTTPException(status_code=404, detail="Post not found")
{{/if}}


if __name__ == "__main__":
    import uvicorn

    uvicorn.run(
        "app.main:app",
        host=os.getenv("HOST", "0.0.0.0"),
        port=int(os.getenv("PORT", "8000")),
        reload=True,
    )
{{/if}}
{{#if (eq pythonWebFramework "django")}}
import django
from django.conf import settings
from django.http import JsonResponse
from django.urls import path

if not settings.configured:
    settings.configure(
        DEBUG=os.getenv("DEBUG", "true").lower() == "true",
        ROOT_URLCONF=__name__,
        SECRET_KEY=os.getenv("SECRET_KEY", "change-me-in-production"),
        ALLOWED_HOSTS=["*"],
        INSTALLED_APPS=[
            "django.contrib.contenttypes",
            "django.contrib.auth",
            "corsheaders",
        ],
        MIDDLEWARE=[
            "corsheaders.middleware.CorsMiddleware",
            "django.middleware.common.CommonMiddleware",
        ],
        CORS_ALLOW_ALL_ORIGINS=True,
    )
    django.setup()


def root(request):
    """Root endpoint."""
    return JsonResponse({"message": "Welcome to {{projectName}}!"})


def health(request):
    """Health check endpoint."""
    return JsonResponse({"status": "healthy"})


urlpatterns = [
    path("", root),
    path("health", health),
]


if __name__ == "__main__":
    from django.core.management import execute_from_command_line
    import sys

    sys.argv = ["manage.py", "runserver", f"{os.getenv('HOST', '0.0.0.0')}:{os.getenv('PORT', '8000')}"]
    execute_from_command_line(sys.argv)
{{/if}}
{{#if (eq pythonWebFramework "none")}}
def main():
    """Main entry point."""
    print("Welcome to {{projectName}}!")
    print("Add your application logic here.")


if __name__ == "__main__":
    main()
{{/if}}
