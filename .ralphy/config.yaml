# Ralphy Configuration
# https://github.com/michaelshimeles/ralphy

# Project info
project:
  name: "better-fullstack"
  language: "TypeScript"
  framework: "TanStack Start, Convex, Bun"
  description: "Full-stack CLI scaffolding tool - fork of Better-T-Stack for creating full-stack projects"

# Commands
commands:
  test: "bun test"
  lint: "bun run check"
  build: "bun run build"

# Rules - instructions the AI MUST follow
# These are injected into every prompt
rules:
  # Core philosophy
  - "This is a full-stack CLI tool for creating full-stack projects. Every new library, framework, or language added MUST be tested with comprehensive tests before moving to the next task."
  - "Never ask for user confirmation or commands. Execute everything autonomously. If something fails, fix it and retry."
  - "Write the BEST possible tests for any new functionality - unit tests, integration tests, and E2E tests where applicable."

  # ============================================================
  # ADDING NEW LIBRARIES - COMPLETE WORKFLOW
  # ============================================================
  - |
    ## ADDING A NEW LIBRARY - COMPLETE STEP-BY-STEP GUIDE

    When adding ANY new library, option, or category, follow these 8 steps IN ORDER:

    ### STEP 1: Add Schema Type (packages/types/src/schemas.ts)
    ```typescript
    // Add new schema enum
    export const NewLibrarySchema = z
      .enum(["option1", "option2", "option3", "none"])
      .describe("Description for CLI help text");

    // Add to CreateInputSchema
    newLibrary: NewLibrarySchema.optional(),

    // Add to ProjectConfigSchema
    newLibrary: NewLibrarySchema,

    // Add export at bottom
    export const NEW_LIBRARY_VALUES = NewLibrarySchema.options;
    ```

    ### STEP 2: Export Type (packages/types/src/index.ts)
    ```typescript
    export { NewLibrarySchema, type NewLibrary, NEW_LIBRARY_VALUES } from "./schemas";
    ```

    ### STEP 3: Add CLI Router Flag (apps/cli/src/index.ts)
    ```typescript
    // In the router schema z.object({...})
    newLibrary: NewLibrarySchema.optional().describe("Description shown in --help"),
    ```

    ### STEP 4: Create Prompt File (apps/cli/src/prompts/new-library.ts)
    ```typescript
    import type { Backend, NewLibrary } from "../types";
    import { exitCancelled } from "../utils/errors";
    import { isCancel, navigableSelect } from "./navigable";

    export async function getNewLibraryChoice(
      newLibrary?: NewLibrary,
      backend?: Backend,  // Add dependencies as needed
    ) {
      // Return early if flag provided
      if (newLibrary !== undefined) return newLibrary;

      // Skip if incompatible (adjust condition as needed)
      if (backend === "none" || backend === "convex") {
        return "none" as NewLibrary;
      }

      const options = [
        {
          value: "option1" as NewLibrary,
          label: "Option 1",
          hint: "Description of option 1",
        },
        {
          value: "option2" as NewLibrary,
          label: "Option 2",
          hint: "Description of option 2",
        },
        {
          value: "none" as NewLibrary,
          label: "None",
          hint: "Skip this feature",
        },
      ];

      const response = await navigableSelect<NewLibrary>({
        message: "Select new library",
        options,
        initialValue: "none",
      });

      if (isCancel(response)) return exitCancelled("Operation cancelled");
      return response;
    }
    ```

    ### STEP 5: Wire Prompt (apps/cli/src/prompts/config-prompts.ts)
    ```typescript
    // Add import
    import { getNewLibraryChoice } from "./new-library";

    // Add to PromptGroupResults type
    newLibrary: NewLibrary;

    // Add in navigableGroup (maintain category order)
    newLibrary: ({ results }) => {
      if (results.ecosystem === "rust") return Promise.resolve("none" as NewLibrary);
      return getNewLibraryChoice(flags.newLibrary, results.backend);
    },

    // Add to return object
    newLibrary: result.newLibrary,
    ```

    ### STEP 6: Add Template Generator (packages/template-generator/)
    ```typescript
    // Create: src/processors/new-library-deps.ts
    import type { ProjectConfig } from "@better-fullstack/types";
    import { addDeps } from "../utils/add-deps";

    export function processNewLibraryDeps(config: ProjectConfig) {
      const { newLibrary, backend, frontend } = config;
      if (newLibrary === "none") return;

      // Add dependencies based on selection
      if (newLibrary === "option1") {
        addDeps("server", { "option1-package": "^1.0.0" });
        // Add to specific app if needed
        const webFrontend = frontend.find(f => !f.startsWith("native"));
        if (webFrontend) {
          addDeps(webFrontend, { "option1-client": "^1.0.0" });
        }
      }
    }

    // Register in src/processors/index.ts
    export { processNewLibraryDeps } from "./new-library-deps";

    // Call from src/generator.ts (in processConfig function)
    processNewLibraryDeps(config);
    ```

    ### STEP 7: Update Builder (apps/web/src/lib/)

    **constant.ts:**
    ```typescript
    // Add to StackState type
    newLibrary: NewLibrary;

    // Add to DEFAULT_STACK
    newLibrary: "none",

    // Add to TECH_OPTIONS
    newLibrary: [
      { id: "option1", name: "Option 1", description: "...", icon: "..." },
      { id: "option2", name: "Option 2", description: "...", icon: "..." },
      { id: "none", name: "None", description: "Skip", icon: "..." },
    ],
    ```

    **stack-url-keys.ts:**
    ```typescript
    newLibrary: "nl",  // Short 2-3 char key
    ```

    **stack-search-schema.ts:**
    ```typescript
    newLibrary: NewLibrarySchema.optional(),
    ```

    **stack-url-state.ts:**
    - Add to `parseSync` return object
    - Add to `serializeStackParams` function

    **stack-url-state.client.ts:**
    - Add to `searchToStack` function

    **stack-utils.ts:**
    - Add to `generateStackCommand` (add --new-library flag)
    - Add to `TYPESCRIPT_CATEGORY_ORDER` array

    ### STEP 8: Test Everything
    ```bash
    # Build CLI
    cd apps/cli && bun run build

    # Run sync test (catches missing options)
    bun test cli-builder-sync

    # Test CLI flag
    bun run apps/cli/src/cli.ts --help | grep new-library
    bun run apps/cli/src/cli.ts --new-library option1

    # Test interactive prompt
    bun run apps/cli/src/cli.ts  # Navigate through prompts

    # Build Builder
    cd apps/web && bun run build
    ```

  # ============================================================
  # COMPATIBILITY RULES
  # ============================================================
  - |
    ## COMPATIBILITY RULES

    When adding libraries with compatibility constraints:

    ### 1. Frontend Compatibility
    ```typescript
    // In apps/cli/src/utils/compatibility-rules.ts

    // Define which frontends the library supports
    const REACT_FRONTENDS = ["tanstack-router", "react-router", "tanstack-start", "next"];
    const ALL_WEB_FRONTENDS = [...REACT_FRONTENDS, "nuxt", "svelte", "solid", "astro"];

    // Create validation function
    export function validateNewLibraryCompatibility(
      library: NewLibrary,
      frontends: Frontend[],
    ) {
      if (library === "react-specific-lib") {
        const hasReact = frontends.some(f => REACT_FRONTENDS.includes(f));
        if (!hasReact) {
          exitWithError("This library requires a React-based frontend.");
        }
      }
    }

    // Create filter function for prompts
    export function getCompatibleNewLibraries(frontends: Frontend[]): NewLibrary[] {
      const hasReact = frontends.some(f => REACT_FRONTENDS.includes(f));
      const all: NewLibrary[] = ["option1", "option2", "none"];
      return hasReact ? all : all.filter(l => l !== "react-specific-lib");
    }
    ```

    ### 2. Backend Compatibility
    - Convex has its own patterns - many libraries don't apply
    - "none" backend means frontend-only - skip server-side libraries
    - "self" backend uses framework's built-in API routes

    ### 3. Compatibility Constants (apps/cli/src/constants.ts)
    ```typescript
    export const NEW_LIBRARY_COMPATIBILITY: Record<NewLibrary, {
      frontends: readonly Frontend[];
      backends: readonly Backend[];
    }> = {
      "option1": {
        frontends: ["tanstack-router", "react-router", "next"],
        backends: ["hono", "express", "fastify"],
      },
      // ...
    };
    ```

  # ============================================================
  # TESTING PATTERNS
  # ============================================================
  - |
    ## TESTING NEW LIBRARIES

    ### 1. Sync Test (ALWAYS RUN)
    ```bash
    cd apps/cli && bun test cli-builder-sync
    ```
    This catches missing options between CLI prompts, schemas, and Builder.

    ### 2. Create Integration Test
    ```typescript
    // apps/cli/test/new-library.test.ts
    import { describe, expect, it } from "bun:test";
    import { expectSuccess, runTRPCTest } from "./test-utils";

    describe("New Library Integration", () => {
      it("should scaffold project with option1", async () => {
        const result = await runTRPCTest({
          frontend: ["tanstack-router"],
          backend: "hono",
          newLibrary: "option1",
        });
        expectSuccess(result);

        // Verify dependencies added
        expect(result.files["apps/server/package.json"]).toContain("option1-package");
      });

      it("should skip when backend is none", async () => {
        const result = await runTRPCTest({
          frontend: ["tanstack-router"],
          backend: "none",
          newLibrary: "option1",  // Should be ignored
        });
        expectSuccess(result);

        // Verify NOT added
        expect(result.files["apps/server/package.json"] ?? "").not.toContain("option1");
      });
    });
    ```

    ### 3. Test Compatibility Rules
    ```typescript
    describe("Compatibility", () => {
      it("should reject incompatible frontend", async () => {
        const result = await runTRPCTest({
          frontend: ["nuxt"],  // Vue-based
          newLibrary: "react-only-option",  // React-only
        });
        // Expect error or auto-correction
      });
    });
    ```

  # ============================================================
  # TEMPLATE GENERATOR PATTERNS
  # ============================================================
  - |
    ## TEMPLATE GENERATOR

    The template generator lives in `packages/template-generator/`:

    ### Adding Dependencies
    ```typescript
    import { addDeps } from "../utils/add-deps";

    // Add to server package
    addDeps("server", { "package-name": "^1.0.0" });

    // Add to frontend package
    addDeps("tanstack-router", { "package-name": "^1.0.0" });

    // Add dev dependency
    addDeps("server", { "package-name": "^1.0.0" }, true);
    ```

    ### Adding Template Files
    Templates are in `packages/template-generator/templates/`

    ```typescript
    // In template handler
    import { copyTemplateDir } from "../core/template-reader";

    if (config.newLibrary === "option1") {
      await copyTemplateDir("new-library/option1", "apps/server/src/lib");
    }
    ```

    ### Dependency Version Map
    All versions are in `packages/template-generator/src/utils/add-deps.ts`
    ```typescript
    export const dependencyVersionMap = {
      "new-package": "^1.0.0",
      // Add new dependencies here
    };
    ```

  # Testing requirements
  - "When adding a new library/framework: 1) Add the dependency 2) Write tests proving it works 3) Run tests 4) Only proceed if tests pass"
  - "Use Bun's built-in test runner (bun test) for all tests"
  - "Test files should be in apps/cli/test/ as *.test.ts"
  - "ALWAYS run 'bun test cli-builder-sync' after adding new options - this catches missing sync issues"
  - "Tests must cover: happy path, edge cases, error handling, and integration with existing code"

  # Tech stack rules
  - "Use Bun for all package management and scripts (not npm/yarn/pnpm)"
  - "Use TailwindCSS v4 syntax for styling (not v3)"
  - "Use TanStack Router file-based routing conventions for the web app"
  - "Use Convex patterns: query for reads, mutation for writes, action for external APIs"
  - "Use TypeScript strict mode - no 'any' types"

  # Code quality
  - "Run 'bun run check' (oxfmt + oxlint) before considering any task complete"
  - "Run 'bun run build' to verify the build passes"
  - "Follow existing patterns in the codebase - check similar files first"
  - "Keep components small and focused - split large components"

  # Monorepo structure
  - |
    ## MONOREPO STRUCTURE
    ```
    apps/
      cli/                    # CLI tool
        src/
          prompts/            # Interactive prompts
          utils/              # Utilities including compatibility-rules.ts
        test/                 # Tests
      web/                    # Builder website
        src/lib/              # State, URL handling, constants

    packages/
      types/                  # Shared TypeScript types + Zod schemas
        src/schemas.ts        # ALL schema definitions
      template-generator/     # Template generation
        src/processors/       # Dependency processors
        src/template-handlers/ # Template file handlers
        templates/            # Handlebars templates
      backend/                # Convex backend
    ```

  # Git workflow
  - "Make atomic commits with clear messages"
  - "Commit after each completed story/task"

  # NPM Release workflow
  - |
    To publish a new version to npm, run: bun run bump
    This creates a PR with version bumps. When merged, GitHub Actions auto-publishes to npm.
    Packages published: create-better-fullstack, create-bfs, @better-fullstack/types, @better-fullstack/template-generator
    See AGENTS.md "Publishing to NPM" section for full details.

# Boundaries - files/folders the AI should not modify
boundaries:
  never_touch:
    - "*.lock"
    - "bun.lock"
    - "node_modules/**"
    - ".git/**"
    - "packages/backend/convex/_generated/**"
    - "apps/web/src/routeTree.gen.ts"
