var Zh = Object.defineProperty;
var Jh = (e, t, n) =>
  t in e ? Zh(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (e[t] = n);
var Ae = (e, t, n) => Jh(e, typeof t != "symbol" ? t + "" : t, n);
import { C as Yc } from "./check-DWEmbU_d.js";
import {
  c as Ot,
  r as h,
  j as T,
  R as Uc,
  a as Rt,
  b as em,
  w as tm,
  D as fe,
  u as nm,
  i as rm,
  P as _c,
  T as om,
  d as Cn,
  t as sr,
  E as sm,
  I as Aa,
} from "./main-BHLV-i_6.js";
/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const im = [["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }]],
  qc = Ot("chevron-down", im);
/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const am = [
    ["rect", { width: "8", height: "4", x: "8", y: "2", rx: "1", ry: "1", key: "tgr4d6" }],
    ["path", { d: "M8 4H6a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-2", key: "4jdomd" }],
    ["path", { d: "M16 4h2a2 2 0 0 1 2 2v4", key: "3hqy98" }],
    ["path", { d: "M21 14H11", key: "1bme5i" }],
    ["path", { d: "m15 10-4 4 4 4", key: "5dvupr" }],
  ],
  lm = Ot("clipboard-copy", am);
/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const cm = [
    ["path", { d: "M3 5h.01", key: "18ugdj" }],
    ["path", { d: "M3 12h.01", key: "nlz23k" }],
    ["path", { d: "M3 19h.01", key: "noohij" }],
    ["path", { d: "M8 5h13", key: "1pao27" }],
    ["path", { d: "M8 12h13", key: "1za7za" }],
    ["path", { d: "M8 19h13", key: "m83p4d" }],
  ],
  um = Ot("list", cm);
/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const dm = [
    ["path", { d: "M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8", key: "v9h5vc" }],
    ["path", { d: "M21 3v5h-5", key: "1q7to0" }],
    ["path", { d: "M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16", key: "3uifl3" }],
    ["path", { d: "M8 16H3v5", key: "1cv678" }],
  ],
  fm = Ot("refresh-cw", dm);
/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const hm = [
    [
      "path",
      {
        d: "M9.671 4.136a2.34 2.34 0 0 1 4.659 0 2.34 2.34 0 0 0 3.319 1.915 2.34 2.34 0 0 1 2.33 4.033 2.34 2.34 0 0 0 0 3.831 2.34 2.34 0 0 1-2.33 4.033 2.34 2.34 0 0 0-3.319 1.915 2.34 2.34 0 0 1-4.659 0 2.34 2.34 0 0 0-3.32-1.915 2.34 2.34 0 0 1-2.33-4.033 2.34 2.34 0 0 0 0-3.831A2.34 2.34 0 0 1 6.35 6.051a2.34 2.34 0 0 0 3.319-1.915",
        key: "1i5ecw",
      },
    ],
    ["circle", { cx: "12", cy: "12", r: "3", key: "1v7zrd" }],
  ],
  Xc = Ot("settings", hm);
/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const mm = [
    ["circle", { cx: "18", cy: "5", r: "3", key: "gq8acd" }],
    ["circle", { cx: "6", cy: "12", r: "3", key: "w7nqdw" }],
    ["circle", { cx: "18", cy: "19", r: "3", key: "1xt0gg" }],
    ["line", { x1: "8.59", x2: "15.42", y1: "13.51", y2: "17.49", key: "47mynk" }],
    ["line", { x1: "15.41", x2: "8.59", y1: "6.51", y2: "10.49", key: "1n3mei" }],
  ],
  pm = Ot("share-2", mm);
/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const gm = [
    ["path", { d: "m18 14 4 4-4 4", key: "10pe0f" }],
    ["path", { d: "m18 2 4 4-4 4", key: "pucp1d" }],
    ["path", { d: "M2 18h1.973a4 4 0 0 0 3.3-1.7l5.454-8.6a4 4 0 0 1 3.3-1.7H22", key: "1ailkh" }],
    ["path", { d: "M2 6h1.972a4 4 0 0 1 3.6 2.2", key: "km57vx" }],
    ["path", { d: "M22 18h-6.041a4 4 0 0 1-3.3-1.8l-.359-.45", key: "os18l9" }],
  ],
  bm = Ot("shuffle", gm);
/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const ym = [
    [
      "path",
      {
        d: "M11.525 2.295a.53.53 0 0 1 .95 0l2.31 4.679a2.123 2.123 0 0 0 1.595 1.16l5.166.756a.53.53 0 0 1 .294.904l-3.736 3.638a2.123 2.123 0 0 0-.611 1.878l.882 5.14a.53.53 0 0 1-.771.56l-4.618-2.428a2.122 2.122 0 0 0-1.973 0L6.396 21.01a.53.53 0 0 1-.77-.56l.881-5.139a2.122 2.122 0 0 0-.611-1.879L2.16 9.795a.53.53 0 0 1 .294-.906l5.165-.755a2.122 2.122 0 0 0 1.597-1.16z",
        key: "r04s7s",
      },
    ],
  ],
  xm = Ot("star", ym);
/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const vm = [
    ["path", { d: "M12 19h8", key: "baeox8" }],
    ["path", { d: "m4 17 6-6-6-6", key: "1yngyt" }],
  ],
  ln = Ot("terminal", vm);
/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const wm = [
    [
      "path",
      {
        d: "M4 14a1 1 0 0 1-.78-1.63l9.9-10.2a.5.5 0 0 1 .86.46l-1.92 6.02A1 1 0 0 0 13 10h7a1 1 0 0 1 .78 1.63l-9.9 10.2a.5.5 0 0 1-.86-.46l1.92-6.02A1 1 0 0 0 11 14z",
        key: "1xq2db",
      },
    ],
  ],
  Sm = Ot("zap", wm),
  yi = h.createContext({});
function xi(e) {
  const t = h.useRef(null);
  return (t.current === null && (t.current = e()), t.current);
}
const Gc = typeof window < "u",
  Kc = Gc ? h.useLayoutEffect : h.useEffect,
  No = h.createContext(null);
function vi(e, t) {
  e.indexOf(t) === -1 && e.push(t);
}
function wi(e, t) {
  const n = e.indexOf(t);
  n > -1 && e.splice(n, 1);
}
const Mt = (e, t, n) => (n > t ? t : n < e ? e : n);
let Si = () => {};
const jt = {},
  Qc = (e) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(e);
function Zc(e) {
  return typeof e == "object" && e !== null;
}
const Jc = (e) => /^0[^.\s]+$/u.test(e);
function Ti(e) {
  let t;
  return () => (t === void 0 && (t = e()), t);
}
const yt = (e) => e,
  Tm = (e, t) => (n) => t(e(n)),
  kr = (...e) => e.reduce(Tm),
  vr = (e, t, n) => {
    const r = t - e;
    return r === 0 ? 1 : (n - e) / r;
  };
class Ri {
  constructor() {
    this.subscriptions = [];
  }
  add(t) {
    return (vi(this.subscriptions, t), () => wi(this.subscriptions, t));
  }
  notify(t, n, r) {
    const o = this.subscriptions.length;
    if (o)
      if (o === 1) this.subscriptions[0](t, n, r);
      else
        for (let s = 0; s < o; s++) {
          const i = this.subscriptions[s];
          i && i(t, n, r);
        }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
const Lt = (e) => e * 1e3,
  pt = (e) => e / 1e3;
function eu(e, t) {
  return t ? e * (1e3 / t) : 0;
}
const tu = (e, t, n) => (((1 - 3 * n + 3 * t) * e + (3 * n - 6 * t)) * e + 3 * t) * e,
  Rm = 1e-7,
  Em = 12;
function Cm(e, t, n, r, o) {
  let s,
    i,
    a = 0;
  do ((i = t + (n - t) / 2), (s = tu(i, r, o) - e), s > 0 ? (n = i) : (t = i));
  while (Math.abs(s) > Rm && ++a < Em);
  return i;
}
function Mr(e, t, n, r) {
  if (e === t && n === r) return yt;
  const o = (s) => Cm(s, 0, 1, e, n);
  return (s) => (s === 0 || s === 1 ? s : tu(o(s), t, r));
}
const nu = (e) => (t) => (t <= 0.5 ? e(2 * t) / 2 : (2 - e(2 * (1 - t))) / 2),
  ru = (e) => (t) => 1 - e(1 - t),
  ou = Mr(0.33, 1.53, 0.69, 0.99),
  Ei = ru(ou),
  su = nu(Ei),
  iu = (e) => ((e *= 2) < 1 ? 0.5 * Ei(e) : 0.5 * (2 - Math.pow(2, -10 * (e - 1)))),
  Ci = (e) => 1 - Math.sin(Math.acos(e)),
  au = ru(Ci),
  lu = nu(Ci),
  Pm = Mr(0.42, 0, 1, 1),
  km = Mr(0, 0, 0.58, 1),
  cu = Mr(0.42, 0, 0.58, 1),
  Mm = (e) => Array.isArray(e) && typeof e[0] != "number",
  uu = (e) => Array.isArray(e) && typeof e[0] == "number",
  Am = {
    linear: yt,
    easeIn: Pm,
    easeInOut: cu,
    easeOut: km,
    circIn: Ci,
    circInOut: lu,
    circOut: au,
    backIn: Ei,
    backInOut: su,
    backOut: ou,
    anticipate: iu,
  },
  Om = (e) => typeof e == "string",
  Oa = (e) => {
    if (uu(e)) {
      Si(e.length === 4);
      const [t, n, r, o] = e;
      return Mr(t, n, r, o);
    } else if (Om(e)) return Am[e];
    return e;
  },
  Vr = [
    "setup",
    "read",
    "resolveKeyframes",
    "preUpdate",
    "update",
    "preRender",
    "render",
    "postRender",
  ];
function Im(e, t) {
  let n = new Set(),
    r = new Set(),
    o = !1,
    s = !1;
  const i = new WeakSet();
  let a = { delta: 0, timestamp: 0, isProcessing: !1 };
  function l(u) {
    (i.has(u) && (c.schedule(u), e()), u(a));
  }
  const c = {
    schedule: (u, d = !1, f = !1) => {
      const g = f && o ? n : r;
      return (d && i.add(u), g.has(u) || g.add(u), u);
    },
    cancel: (u) => {
      (r.delete(u), i.delete(u));
    },
    process: (u) => {
      if (((a = u), o)) {
        s = !0;
        return;
      }
      ((o = !0),
        ([n, r] = [r, n]),
        n.forEach(l),
        n.clear(),
        (o = !1),
        s && ((s = !1), c.process(u)));
    },
  };
  return c;
}
const Dm = 40;
function du(e, t) {
  let n = !1,
    r = !0;
  const o = { delta: 0, timestamp: 0, isProcessing: !1 },
    s = () => (n = !0),
    i = Vr.reduce((w, R) => ((w[R] = Im(s)), w), {}),
    {
      setup: a,
      read: l,
      resolveKeyframes: c,
      preUpdate: u,
      update: d,
      preRender: f,
      render: m,
      postRender: g,
    } = i,
    p = () => {
      const w = jt.useManualTiming ? o.timestamp : performance.now();
      ((n = !1),
        jt.useManualTiming || (o.delta = r ? 1e3 / 60 : Math.max(Math.min(w - o.timestamp, Dm), 1)),
        (o.timestamp = w),
        (o.isProcessing = !0),
        a.process(o),
        l.process(o),
        c.process(o),
        u.process(o),
        d.process(o),
        f.process(o),
        m.process(o),
        g.process(o),
        (o.isProcessing = !1),
        n && t && ((r = !1), e(p)));
    },
    v = () => {
      ((n = !0), (r = !0), o.isProcessing || e(p));
    };
  return {
    schedule: Vr.reduce((w, R) => {
      const x = i[R];
      return ((w[R] = (A, I = !1, P = !1) => (n || v(), x.schedule(A, I, P))), w);
    }, {}),
    cancel: (w) => {
      for (let R = 0; R < Vr.length; R++) i[Vr[R]].cancel(w);
    },
    state: o,
    steps: i,
  };
}
const {
  schedule: De,
  cancel: Qt,
  state: Qe,
  steps: Zo,
} = du(typeof requestAnimationFrame < "u" ? requestAnimationFrame : yt, !0);
let no;
function Nm() {
  no = void 0;
}
const ot = {
    now: () => (
      no === void 0 &&
        ot.set(Qe.isProcessing || jt.useManualTiming ? Qe.timestamp : performance.now()),
      no
    ),
    set: (e) => {
      ((no = e), queueMicrotask(Nm));
    },
  },
  fu = (e) => (t) => typeof t == "string" && t.startsWith(e),
  hu = fu("--"),
  Fm = fu("var(--"),
  Pi = (e) => (Fm(e) ? Lm.test(e.split("/*")[0].trim()) : !1),
  Lm = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu;
function Ia(e) {
  return typeof e != "string" ? !1 : e.split("/*")[0].includes("var(--");
}
const Kn = { test: (e) => typeof e == "number", parse: parseFloat, transform: (e) => e },
  wr = { ...Kn, transform: (e) => Mt(0, 1, e) },
  Br = { ...Kn, default: 1 },
  hr = (e) => Math.round(e * 1e5) / 1e5,
  ki = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
function jm(e) {
  return e == null;
}
const Vm =
    /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu,
  Mi = (e, t) => (n) =>
    !!(
      (typeof n == "string" && Vm.test(n) && n.startsWith(e)) ||
      (t && !jm(n) && Object.prototype.hasOwnProperty.call(n, t))
    ),
  mu = (e, t, n) => (r) => {
    if (typeof r != "string") return r;
    const [o, s, i, a] = r.match(ki);
    return {
      [e]: parseFloat(o),
      [t]: parseFloat(s),
      [n]: parseFloat(i),
      alpha: a !== void 0 ? parseFloat(a) : 1,
    };
  },
  Bm = (e) => Mt(0, 255, e),
  Jo = { ...Kn, transform: (e) => Math.round(Bm(e)) },
  mn = {
    test: Mi("rgb", "red"),
    parse: mu("red", "green", "blue"),
    transform: ({ red: e, green: t, blue: n, alpha: r = 1 }) =>
      "rgba(" +
      Jo.transform(e) +
      ", " +
      Jo.transform(t) +
      ", " +
      Jo.transform(n) +
      ", " +
      hr(wr.transform(r)) +
      ")",
  };
function $m(e) {
  let t = "",
    n = "",
    r = "",
    o = "";
  return (
    e.length > 5
      ? ((t = e.substring(1, 3)),
        (n = e.substring(3, 5)),
        (r = e.substring(5, 7)),
        (o = e.substring(7, 9)))
      : ((t = e.substring(1, 2)),
        (n = e.substring(2, 3)),
        (r = e.substring(3, 4)),
        (o = e.substring(4, 5)),
        (t += t),
        (n += n),
        (r += r),
        (o += o)),
    {
      red: parseInt(t, 16),
      green: parseInt(n, 16),
      blue: parseInt(r, 16),
      alpha: o ? parseInt(o, 16) / 255 : 1,
    }
  );
}
const Ps = { test: Mi("#"), parse: $m, transform: mn.transform },
  Ar = (e) => ({
    test: (t) => typeof t == "string" && t.endsWith(e) && t.split(" ").length === 1,
    parse: parseFloat,
    transform: (t) => `${t}${e}`,
  }),
  zt = Ar("deg"),
  Ct = Ar("%"),
  se = Ar("px"),
  Wm = Ar("vh"),
  zm = Ar("vw"),
  Da = { ...Ct, parse: (e) => Ct.parse(e) / 100, transform: (e) => Ct.transform(e * 100) },
  Mn = {
    test: Mi("hsl", "hue"),
    parse: mu("hue", "saturation", "lightness"),
    transform: ({ hue: e, saturation: t, lightness: n, alpha: r = 1 }) =>
      "hsla(" +
      Math.round(e) +
      ", " +
      Ct.transform(hr(t)) +
      ", " +
      Ct.transform(hr(n)) +
      ", " +
      hr(wr.transform(r)) +
      ")",
  },
  Ue = {
    test: (e) => mn.test(e) || Ps.test(e) || Mn.test(e),
    parse: (e) => (mn.test(e) ? mn.parse(e) : Mn.test(e) ? Mn.parse(e) : Ps.parse(e)),
    transform: (e) =>
      typeof e == "string" ? e : e.hasOwnProperty("red") ? mn.transform(e) : Mn.transform(e),
    getAnimatableNone: (e) => {
      const t = Ue.parse(e);
      return ((t.alpha = 0), Ue.transform(t));
    },
  },
  Hm =
    /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
function Um(e) {
  var t, n;
  return (
    isNaN(e) &&
    typeof e == "string" &&
    (((t = e.match(ki)) == null ? void 0 : t.length) || 0) +
      (((n = e.match(Hm)) == null ? void 0 : n.length) || 0) >
      0
  );
}
const pu = "number",
  gu = "color",
  _m = "var",
  Ym = "var(",
  Na = "${}",
  qm =
    /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function Sr(e) {
  const t = e.toString(),
    n = [],
    r = { color: [], number: [], var: [] },
    o = [];
  let s = 0;
  const a = t
    .replace(
      qm,
      (l) => (
        Ue.test(l)
          ? (r.color.push(s), o.push(gu), n.push(Ue.parse(l)))
          : l.startsWith(Ym)
            ? (r.var.push(s), o.push(_m), n.push(l))
            : (r.number.push(s), o.push(pu), n.push(parseFloat(l))),
        ++s,
        Na
      ),
    )
    .split(Na);
  return { values: n, split: a, indexes: r, types: o };
}
function bu(e) {
  return Sr(e).values;
}
function yu(e) {
  const { split: t, types: n } = Sr(e),
    r = t.length;
  return (o) => {
    let s = "";
    for (let i = 0; i < r; i++)
      if (((s += t[i]), o[i] !== void 0)) {
        const a = n[i];
        a === pu ? (s += hr(o[i])) : a === gu ? (s += Ue.transform(o[i])) : (s += o[i]);
      }
    return s;
  };
}
const Xm = (e) => (typeof e == "number" ? 0 : Ue.test(e) ? Ue.getAnimatableNone(e) : e);
function Gm(e) {
  const t = bu(e);
  return yu(e)(t.map(Xm));
}
const Zt = { test: Um, parse: bu, createTransformer: yu, getAnimatableNone: Gm };
function es(e, t, n) {
  return (
    n < 0 && (n += 1),
    n > 1 && (n -= 1),
    n < 1 / 6 ? e + (t - e) * 6 * n : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e
  );
}
function Km({ hue: e, saturation: t, lightness: n, alpha: r }) {
  ((e /= 360), (t /= 100), (n /= 100));
  let o = 0,
    s = 0,
    i = 0;
  if (!t) o = s = i = n;
  else {
    const a = n < 0.5 ? n * (1 + t) : n + t - n * t,
      l = 2 * n - a;
    ((o = es(l, a, e + 1 / 3)), (s = es(l, a, e)), (i = es(l, a, e - 1 / 3)));
  }
  return {
    red: Math.round(o * 255),
    green: Math.round(s * 255),
    blue: Math.round(i * 255),
    alpha: r,
  };
}
function mo(e, t) {
  return (n) => (n > 0 ? t : e);
}
const Fe = (e, t, n) => e + (t - e) * n,
  ts = (e, t, n) => {
    const r = e * e,
      o = n * (t * t - r) + r;
    return o < 0 ? 0 : Math.sqrt(o);
  },
  Qm = [Ps, mn, Mn],
  Zm = (e) => Qm.find((t) => t.test(e));
function Fa(e) {
  const t = Zm(e);
  if (!t) return !1;
  let n = t.parse(e);
  return (t === Mn && (n = Km(n)), n);
}
const La = (e, t) => {
    const n = Fa(e),
      r = Fa(t);
    if (!n || !r) return mo(e, t);
    const o = { ...n };
    return (s) => (
      (o.red = ts(n.red, r.red, s)),
      (o.green = ts(n.green, r.green, s)),
      (o.blue = ts(n.blue, r.blue, s)),
      (o.alpha = Fe(n.alpha, r.alpha, s)),
      mn.transform(o)
    );
  },
  ks = new Set(["none", "hidden"]);
function Jm(e, t) {
  return ks.has(e) ? (n) => (n <= 0 ? e : t) : (n) => (n >= 1 ? t : e);
}
function ep(e, t) {
  return (n) => Fe(e, t, n);
}
function Ai(e) {
  return typeof e == "number"
    ? ep
    : typeof e == "string"
      ? Pi(e)
        ? mo
        : Ue.test(e)
          ? La
          : rp
      : Array.isArray(e)
        ? xu
        : typeof e == "object"
          ? Ue.test(e)
            ? La
            : tp
          : mo;
}
function xu(e, t) {
  const n = [...e],
    r = n.length,
    o = e.map((s, i) => Ai(s)(s, t[i]));
  return (s) => {
    for (let i = 0; i < r; i++) n[i] = o[i](s);
    return n;
  };
}
function tp(e, t) {
  const n = { ...e, ...t },
    r = {};
  for (const o in n) e[o] !== void 0 && t[o] !== void 0 && (r[o] = Ai(e[o])(e[o], t[o]));
  return (o) => {
    for (const s in r) n[s] = r[s](o);
    return n;
  };
}
function np(e, t) {
  const n = [],
    r = { color: 0, var: 0, number: 0 };
  for (let o = 0; o < t.values.length; o++) {
    const s = t.types[o],
      i = e.indexes[s][r[s]],
      a = e.values[i] ?? 0;
    ((n[o] = a), r[s]++);
  }
  return n;
}
const rp = (e, t) => {
  const n = Zt.createTransformer(t),
    r = Sr(e),
    o = Sr(t);
  return r.indexes.var.length === o.indexes.var.length &&
    r.indexes.color.length === o.indexes.color.length &&
    r.indexes.number.length >= o.indexes.number.length
    ? (ks.has(e) && !o.values.length) || (ks.has(t) && !r.values.length)
      ? Jm(e, t)
      : kr(xu(np(r, o), o.values), n)
    : mo(e, t);
};
function vu(e, t, n) {
  return typeof e == "number" && typeof t == "number" && typeof n == "number"
    ? Fe(e, t, n)
    : Ai(e)(e, t);
}
const op = (e) => {
    const t = ({ timestamp: n }) => e(n);
    return {
      start: (n = !0) => De.update(t, n),
      stop: () => Qt(t),
      now: () => (Qe.isProcessing ? Qe.timestamp : ot.now()),
    };
  },
  wu = (e, t, n = 10) => {
    let r = "";
    const o = Math.max(Math.round(t / n), 2);
    for (let s = 0; s < o; s++) r += Math.round(e(s / (o - 1)) * 1e4) / 1e4 + ", ";
    return `linear(${r.substring(0, r.length - 2)})`;
  },
  po = 2e4;
function Oi(e) {
  let t = 0;
  const n = 50;
  let r = e.next(t);
  for (; !r.done && t < po; ) ((t += n), (r = e.next(t)));
  return t >= po ? 1 / 0 : t;
}
function sp(e, t = 100, n) {
  const r = n({ ...e, keyframes: [0, t] }),
    o = Math.min(Oi(r), po);
  return { type: "keyframes", ease: (s) => r.next(o * s).value / t, duration: pt(o) };
}
const ip = 5;
function Su(e, t, n) {
  const r = Math.max(t - ip, 0);
  return eu(n - e(r), t - r);
}
const Le = {
    stiffness: 100,
    damping: 10,
    mass: 1,
    velocity: 0,
    duration: 800,
    bounce: 0.3,
    visualDuration: 0.3,
    restSpeed: { granular: 0.01, default: 2 },
    restDelta: { granular: 0.005, default: 0.5 },
    minDuration: 0.01,
    maxDuration: 10,
    minDamping: 0.05,
    maxDamping: 1,
  },
  ns = 0.001;
function ap({
  duration: e = Le.duration,
  bounce: t = Le.bounce,
  velocity: n = Le.velocity,
  mass: r = Le.mass,
}) {
  let o,
    s,
    i = 1 - t;
  ((i = Mt(Le.minDamping, Le.maxDamping, i)),
    (e = Mt(Le.minDuration, Le.maxDuration, pt(e))),
    i < 1
      ? ((o = (c) => {
          const u = c * i,
            d = u * e,
            f = u - n,
            m = Ms(c, i),
            g = Math.exp(-d);
          return ns - (f / m) * g;
        }),
        (s = (c) => {
          const d = c * i * e,
            f = d * n + n,
            m = Math.pow(i, 2) * Math.pow(c, 2) * e,
            g = Math.exp(-d),
            p = Ms(Math.pow(c, 2), i);
          return ((-o(c) + ns > 0 ? -1 : 1) * ((f - m) * g)) / p;
        }))
      : ((o = (c) => {
          const u = Math.exp(-c * e),
            d = (c - n) * e + 1;
          return -ns + u * d;
        }),
        (s = (c) => {
          const u = Math.exp(-c * e),
            d = (n - c) * (e * e);
          return u * d;
        })));
  const a = 5 / e,
    l = cp(o, s, a);
  if (((e = Lt(e)), isNaN(l))) return { stiffness: Le.stiffness, damping: Le.damping, duration: e };
  {
    const c = Math.pow(l, 2) * r;
    return { stiffness: c, damping: i * 2 * Math.sqrt(r * c), duration: e };
  }
}
const lp = 12;
function cp(e, t, n) {
  let r = n;
  for (let o = 1; o < lp; o++) r = r - e(r) / t(r);
  return r;
}
function Ms(e, t) {
  return e * Math.sqrt(1 - t * t);
}
const up = ["duration", "bounce"],
  dp = ["stiffness", "damping", "mass"];
function ja(e, t) {
  return t.some((n) => e[n] !== void 0);
}
function fp(e) {
  let t = {
    velocity: Le.velocity,
    stiffness: Le.stiffness,
    damping: Le.damping,
    mass: Le.mass,
    isResolvedFromDuration: !1,
    ...e,
  };
  if (!ja(e, dp) && ja(e, up))
    if (e.visualDuration) {
      const n = e.visualDuration,
        r = (2 * Math.PI) / (n * 1.2),
        o = r * r,
        s = 2 * Mt(0.05, 1, 1 - (e.bounce || 0)) * Math.sqrt(o);
      t = { ...t, mass: Le.mass, stiffness: o, damping: s };
    } else {
      const n = ap(e);
      ((t = { ...t, ...n, mass: Le.mass }), (t.isResolvedFromDuration = !0));
    }
  return t;
}
function go(e = Le.visualDuration, t = Le.bounce) {
  const n = typeof e != "object" ? { visualDuration: e, keyframes: [0, 1], bounce: t } : e;
  let { restSpeed: r, restDelta: o } = n;
  const s = n.keyframes[0],
    i = n.keyframes[n.keyframes.length - 1],
    a = { done: !1, value: s },
    {
      stiffness: l,
      damping: c,
      mass: u,
      duration: d,
      velocity: f,
      isResolvedFromDuration: m,
    } = fp({ ...n, velocity: -pt(n.velocity || 0) }),
    g = f || 0,
    p = c / (2 * Math.sqrt(l * u)),
    v = i - s,
    b = pt(Math.sqrt(l / u)),
    y = Math.abs(v) < 5;
  (r || (r = y ? Le.restSpeed.granular : Le.restSpeed.default),
    o || (o = y ? Le.restDelta.granular : Le.restDelta.default));
  let w;
  if (p < 1) {
    const x = Ms(b, p);
    w = (A) => {
      const I = Math.exp(-p * b * A);
      return i - I * (((g + p * b * v) / x) * Math.sin(x * A) + v * Math.cos(x * A));
    };
  } else if (p === 1) w = (x) => i - Math.exp(-b * x) * (v + (g + b * v) * x);
  else {
    const x = b * Math.sqrt(p * p - 1);
    w = (A) => {
      const I = Math.exp(-p * b * A),
        P = Math.min(x * A, 300);
      return i - (I * ((g + p * b * v) * Math.sinh(P) + x * v * Math.cosh(P))) / x;
    };
  }
  const R = {
    calculatedDuration: (m && d) || null,
    next: (x) => {
      const A = w(x);
      if (m) a.done = x >= d;
      else {
        let I = x === 0 ? g : 0;
        p < 1 && (I = x === 0 ? Lt(g) : Su(w, x, A));
        const P = Math.abs(I) <= r,
          D = Math.abs(i - A) <= o;
        a.done = P && D;
      }
      return ((a.value = a.done ? i : A), a);
    },
    toString: () => {
      const x = Math.min(Oi(R), po),
        A = wu((I) => R.next(x * I).value, x, 30);
      return x + "ms " + A;
    },
    toTransition: () => {},
  };
  return R;
}
go.applyToOptions = (e) => {
  const t = sp(e, 100, go);
  return ((e.ease = t.ease), (e.duration = Lt(t.duration)), (e.type = "keyframes"), e);
};
function As({
  keyframes: e,
  velocity: t = 0,
  power: n = 0.8,
  timeConstant: r = 325,
  bounceDamping: o = 10,
  bounceStiffness: s = 500,
  modifyTarget: i,
  min: a,
  max: l,
  restDelta: c = 0.5,
  restSpeed: u,
}) {
  const d = e[0],
    f = { done: !1, value: d },
    m = (P) => (a !== void 0 && P < a) || (l !== void 0 && P > l),
    g = (P) => (a === void 0 ? l : l === void 0 || Math.abs(a - P) < Math.abs(l - P) ? a : l);
  let p = n * t;
  const v = d + p,
    b = i === void 0 ? v : i(v);
  b !== v && (p = b - d);
  const y = (P) => -p * Math.exp(-P / r),
    w = (P) => b + y(P),
    R = (P) => {
      const D = y(P),
        V = w(P);
      ((f.done = Math.abs(D) <= c), (f.value = f.done ? b : V));
    };
  let x, A;
  const I = (P) => {
    m(f.value) &&
      ((x = P),
      (A = go({
        keyframes: [f.value, g(f.value)],
        velocity: Su(w, P, f.value),
        damping: o,
        stiffness: s,
        restDelta: c,
        restSpeed: u,
      })));
  };
  return (
    I(0),
    {
      calculatedDuration: null,
      next: (P) => {
        let D = !1;
        return (
          !A && x === void 0 && ((D = !0), R(P), I(P)),
          x !== void 0 && P >= x ? A.next(P - x) : (!D && R(P), f)
        );
      },
    }
  );
}
function hp(e, t, n) {
  const r = [],
    o = n || jt.mix || vu,
    s = e.length - 1;
  for (let i = 0; i < s; i++) {
    let a = o(e[i], e[i + 1]);
    if (t) {
      const l = Array.isArray(t) ? t[i] || yt : t;
      a = kr(l, a);
    }
    r.push(a);
  }
  return r;
}
function mp(e, t, { clamp: n = !0, ease: r, mixer: o } = {}) {
  const s = e.length;
  if ((Si(s === t.length), s === 1)) return () => t[0];
  if (s === 2 && t[0] === t[1]) return () => t[1];
  const i = e[0] === e[1];
  e[0] > e[s - 1] && ((e = [...e].reverse()), (t = [...t].reverse()));
  const a = hp(t, r, o),
    l = a.length,
    c = (u) => {
      if (i && u < e[0]) return t[0];
      let d = 0;
      if (l > 1) for (; d < e.length - 2 && !(u < e[d + 1]); d++);
      const f = vr(e[d], e[d + 1], u);
      return a[d](f);
    };
  return n ? (u) => c(Mt(e[0], e[s - 1], u)) : c;
}
function pp(e, t) {
  const n = e[e.length - 1];
  for (let r = 1; r <= t; r++) {
    const o = vr(0, t, r);
    e.push(Fe(n, 1, o));
  }
}
function gp(e) {
  const t = [0];
  return (pp(t, e.length - 1), t);
}
function bp(e, t) {
  return e.map((n) => n * t);
}
function yp(e, t) {
  return e.map(() => t || cu).splice(0, e.length - 1);
}
function mr({ duration: e = 300, keyframes: t, times: n, ease: r = "easeInOut" }) {
  const o = Mm(r) ? r.map(Oa) : Oa(r),
    s = { done: !1, value: t[0] },
    i = bp(n && n.length === t.length ? n : gp(t), e),
    a = mp(i, t, { ease: Array.isArray(o) ? o : yp(t, o) });
  return { calculatedDuration: e, next: (l) => ((s.value = a(l)), (s.done = l >= e), s) };
}
const xp = (e) => e !== null;
function Ii(e, { repeat: t, repeatType: n = "loop" }, r, o = 1) {
  const s = e.filter(xp),
    a = o < 0 || (t && n !== "loop" && t % 2 === 1) ? 0 : s.length - 1;
  return !a || r === void 0 ? s[a] : r;
}
const vp = { decay: As, inertia: As, tween: mr, keyframes: mr, spring: go };
function Tu(e) {
  typeof e.type == "string" && (e.type = vp[e.type]);
}
class Di {
  constructor() {
    this.updateFinished();
  }
  get finished() {
    return this._finished;
  }
  updateFinished() {
    this._finished = new Promise((t) => {
      this.resolve = t;
    });
  }
  notifyFinished() {
    this.resolve();
  }
  then(t, n) {
    return this.finished.then(t, n);
  }
}
const wp = (e) => e / 100;
class Ni extends Di {
  constructor(t) {
    (super(),
      (this.state = "idle"),
      (this.startTime = null),
      (this.isStopped = !1),
      (this.currentTime = 0),
      (this.holdTime = null),
      (this.playbackSpeed = 1),
      (this.stop = () => {
        var r, o;
        const { motionValue: n } = this.options;
        (n && n.updatedAt !== ot.now() && this.tick(ot.now()),
          (this.isStopped = !0),
          this.state !== "idle" &&
            (this.teardown(), (o = (r = this.options).onStop) == null || o.call(r)));
      }),
      (this.options = t),
      this.initAnimation(),
      this.play(),
      t.autoplay === !1 && this.pause());
  }
  initAnimation() {
    const { options: t } = this;
    Tu(t);
    const { type: n = mr, repeat: r = 0, repeatDelay: o = 0, repeatType: s, velocity: i = 0 } = t;
    let { keyframes: a } = t;
    const l = n || mr;
    l !== mr &&
      typeof a[0] != "number" &&
      ((this.mixKeyframes = kr(wp, vu(a[0], a[1]))), (a = [0, 100]));
    const c = l({ ...t, keyframes: a });
    (s === "mirror" &&
      (this.mirroredGenerator = l({ ...t, keyframes: [...a].reverse(), velocity: -i })),
      c.calculatedDuration === null && (c.calculatedDuration = Oi(c)));
    const { calculatedDuration: u } = c;
    ((this.calculatedDuration = u),
      (this.resolvedDuration = u + o),
      (this.totalDuration = this.resolvedDuration * (r + 1) - o),
      (this.generator = c));
  }
  updateTime(t) {
    const n = Math.round(t - this.startTime) * this.playbackSpeed;
    this.holdTime !== null ? (this.currentTime = this.holdTime) : (this.currentTime = n);
  }
  tick(t, n = !1) {
    const {
      generator: r,
      totalDuration: o,
      mixKeyframes: s,
      mirroredGenerator: i,
      resolvedDuration: a,
      calculatedDuration: l,
    } = this;
    if (this.startTime === null) return r.next(0);
    const {
      delay: c = 0,
      keyframes: u,
      repeat: d,
      repeatType: f,
      repeatDelay: m,
      type: g,
      onUpdate: p,
      finalKeyframe: v,
    } = this.options;
    (this.speed > 0
      ? (this.startTime = Math.min(this.startTime, t))
      : this.speed < 0 && (this.startTime = Math.min(t - o / this.speed, this.startTime)),
      n ? (this.currentTime = t) : this.updateTime(t));
    const b = this.currentTime - c * (this.playbackSpeed >= 0 ? 1 : -1),
      y = this.playbackSpeed >= 0 ? b < 0 : b > o;
    ((this.currentTime = Math.max(b, 0)),
      this.state === "finished" && this.holdTime === null && (this.currentTime = o));
    let w = this.currentTime,
      R = r;
    if (d) {
      const P = Math.min(this.currentTime, o) / a;
      let D = Math.floor(P),
        V = P % 1;
      (!V && P >= 1 && (V = 1),
        V === 1 && D--,
        (D = Math.min(D, d + 1)),
        !!(D % 2) &&
          (f === "reverse" ? ((V = 1 - V), m && (V -= m / a)) : f === "mirror" && (R = i)),
        (w = Mt(0, 1, V) * a));
    }
    const x = y ? { done: !1, value: u[0] } : R.next(w);
    s && (x.value = s(x.value));
    let { done: A } = x;
    !y &&
      l !== null &&
      (A = this.playbackSpeed >= 0 ? this.currentTime >= o : this.currentTime <= 0);
    const I =
      this.holdTime === null && (this.state === "finished" || (this.state === "running" && A));
    return (
      I && g !== As && (x.value = Ii(u, this.options, v, this.speed)),
      p && p(x.value),
      I && this.finish(),
      x
    );
  }
  then(t, n) {
    return this.finished.then(t, n);
  }
  get duration() {
    return pt(this.calculatedDuration);
  }
  get iterationDuration() {
    const { delay: t = 0 } = this.options || {};
    return this.duration + pt(t);
  }
  get time() {
    return pt(this.currentTime);
  }
  set time(t) {
    var n;
    ((t = Lt(t)),
      (this.currentTime = t),
      this.startTime === null || this.holdTime !== null || this.playbackSpeed === 0
        ? (this.holdTime = t)
        : this.driver && (this.startTime = this.driver.now() - t / this.playbackSpeed),
      (n = this.driver) == null || n.start(!1));
  }
  get speed() {
    return this.playbackSpeed;
  }
  set speed(t) {
    this.updateTime(ot.now());
    const n = this.playbackSpeed !== t;
    ((this.playbackSpeed = t), n && (this.time = pt(this.currentTime)));
  }
  play() {
    var o, s;
    if (this.isStopped) return;
    const { driver: t = op, startTime: n } = this.options;
    (this.driver || (this.driver = t((i) => this.tick(i))),
      (s = (o = this.options).onPlay) == null || s.call(o));
    const r = this.driver.now();
    (this.state === "finished"
      ? (this.updateFinished(), (this.startTime = r))
      : this.holdTime !== null
        ? (this.startTime = r - this.holdTime)
        : this.startTime || (this.startTime = n ?? r),
      this.state === "finished" && this.speed < 0 && (this.startTime += this.calculatedDuration),
      (this.holdTime = null),
      (this.state = "running"),
      this.driver.start());
  }
  pause() {
    ((this.state = "paused"), this.updateTime(ot.now()), (this.holdTime = this.currentTime));
  }
  complete() {
    (this.state !== "running" && this.play(), (this.state = "finished"), (this.holdTime = null));
  }
  finish() {
    var t, n;
    (this.notifyFinished(),
      this.teardown(),
      (this.state = "finished"),
      (n = (t = this.options).onComplete) == null || n.call(t));
  }
  cancel() {
    var t, n;
    ((this.holdTime = null),
      (this.startTime = 0),
      this.tick(0),
      this.teardown(),
      (n = (t = this.options).onCancel) == null || n.call(t));
  }
  teardown() {
    ((this.state = "idle"), this.stopDriver(), (this.startTime = this.holdTime = null));
  }
  stopDriver() {
    this.driver && (this.driver.stop(), (this.driver = void 0));
  }
  sample(t) {
    return ((this.startTime = 0), this.tick(t, !0));
  }
  attachTimeline(t) {
    var n;
    return (
      this.options.allowFlatten &&
        ((this.options.type = "keyframes"), (this.options.ease = "linear"), this.initAnimation()),
      (n = this.driver) == null || n.stop(),
      t.observe(this)
    );
  }
}
function Sp(e) {
  for (let t = 1; t < e.length; t++) e[t] ?? (e[t] = e[t - 1]);
}
const pn = (e) => (e * 180) / Math.PI,
  Os = (e) => {
    const t = pn(Math.atan2(e[1], e[0]));
    return Is(t);
  },
  Tp = {
    x: 4,
    y: 5,
    translateX: 4,
    translateY: 5,
    scaleX: 0,
    scaleY: 3,
    scale: (e) => (Math.abs(e[0]) + Math.abs(e[3])) / 2,
    rotate: Os,
    rotateZ: Os,
    skewX: (e) => pn(Math.atan(e[1])),
    skewY: (e) => pn(Math.atan(e[2])),
    skew: (e) => (Math.abs(e[1]) + Math.abs(e[2])) / 2,
  },
  Is = (e) => ((e = e % 360), e < 0 && (e += 360), e),
  Va = Os,
  Ba = (e) => Math.sqrt(e[0] * e[0] + e[1] * e[1]),
  $a = (e) => Math.sqrt(e[4] * e[4] + e[5] * e[5]),
  Rp = {
    x: 12,
    y: 13,
    z: 14,
    translateX: 12,
    translateY: 13,
    translateZ: 14,
    scaleX: Ba,
    scaleY: $a,
    scale: (e) => (Ba(e) + $a(e)) / 2,
    rotateX: (e) => Is(pn(Math.atan2(e[6], e[5]))),
    rotateY: (e) => Is(pn(Math.atan2(-e[2], e[0]))),
    rotateZ: Va,
    rotate: Va,
    skewX: (e) => pn(Math.atan(e[4])),
    skewY: (e) => pn(Math.atan(e[1])),
    skew: (e) => (Math.abs(e[1]) + Math.abs(e[4])) / 2,
  };
function Ds(e) {
  return e.includes("scale") ? 1 : 0;
}
function Ns(e, t) {
  if (!e || e === "none") return Ds(t);
  const n = e.match(/^matrix3d\(([-\d.e\s,]+)\)$/u);
  let r, o;
  if (n) ((r = Rp), (o = n));
  else {
    const a = e.match(/^matrix\(([-\d.e\s,]+)\)$/u);
    ((r = Tp), (o = a));
  }
  if (!o) return Ds(t);
  const s = r[t],
    i = o[1].split(",").map(Cp);
  return typeof s == "function" ? s(i) : i[s];
}
const Ep = (e, t) => {
  const { transform: n = "none" } = getComputedStyle(e);
  return Ns(n, t);
};
function Cp(e) {
  return parseFloat(e.trim());
}
const Qn = [
    "transformPerspective",
    "x",
    "y",
    "z",
    "translateX",
    "translateY",
    "translateZ",
    "scale",
    "scaleX",
    "scaleY",
    "rotate",
    "rotateX",
    "rotateY",
    "rotateZ",
    "skew",
    "skewX",
    "skewY",
  ],
  Zn = new Set(Qn),
  Wa = (e) => e === Kn || e === se,
  Pp = new Set(["x", "y", "z"]),
  kp = Qn.filter((e) => !Pp.has(e));
function Mp(e) {
  const t = [];
  return (
    kp.forEach((n) => {
      const r = e.getValue(n);
      r !== void 0 && (t.push([n, r.get()]), r.set(n.startsWith("scale") ? 1 : 0));
    }),
    t
  );
}
const Ht = {
  width: ({ x: e }, { paddingLeft: t = "0", paddingRight: n = "0" }) =>
    e.max - e.min - parseFloat(t) - parseFloat(n),
  height: ({ y: e }, { paddingTop: t = "0", paddingBottom: n = "0" }) =>
    e.max - e.min - parseFloat(t) - parseFloat(n),
  top: (e, { top: t }) => parseFloat(t),
  left: (e, { left: t }) => parseFloat(t),
  bottom: ({ y: e }, { top: t }) => parseFloat(t) + (e.max - e.min),
  right: ({ x: e }, { left: t }) => parseFloat(t) + (e.max - e.min),
  x: (e, { transform: t }) => Ns(t, "x"),
  y: (e, { transform: t }) => Ns(t, "y"),
};
Ht.translateX = Ht.x;
Ht.translateY = Ht.y;
const bn = new Set();
let Fs = !1,
  Ls = !1,
  js = !1;
function Ru() {
  if (Ls) {
    const e = Array.from(bn).filter((r) => r.needsMeasurement),
      t = new Set(e.map((r) => r.element)),
      n = new Map();
    (t.forEach((r) => {
      const o = Mp(r);
      o.length && (n.set(r, o), r.render());
    }),
      e.forEach((r) => r.measureInitialState()),
      t.forEach((r) => {
        r.render();
        const o = n.get(r);
        o &&
          o.forEach(([s, i]) => {
            var a;
            (a = r.getValue(s)) == null || a.set(i);
          });
      }),
      e.forEach((r) => r.measureEndState()),
      e.forEach((r) => {
        r.suspendedScrollY !== void 0 && window.scrollTo(0, r.suspendedScrollY);
      }));
  }
  ((Ls = !1), (Fs = !1), bn.forEach((e) => e.complete(js)), bn.clear());
}
function Eu() {
  bn.forEach((e) => {
    (e.readKeyframes(), e.needsMeasurement && (Ls = !0));
  });
}
function Ap() {
  ((js = !0), Eu(), Ru(), (js = !1));
}
class Fi {
  constructor(t, n, r, o, s, i = !1) {
    ((this.state = "pending"),
      (this.isAsync = !1),
      (this.needsMeasurement = !1),
      (this.unresolvedKeyframes = [...t]),
      (this.onComplete = n),
      (this.name = r),
      (this.motionValue = o),
      (this.element = s),
      (this.isAsync = i));
  }
  scheduleResolve() {
    ((this.state = "scheduled"),
      this.isAsync
        ? (bn.add(this), Fs || ((Fs = !0), De.read(Eu), De.resolveKeyframes(Ru)))
        : (this.readKeyframes(), this.complete()));
  }
  readKeyframes() {
    const { unresolvedKeyframes: t, name: n, element: r, motionValue: o } = this;
    if (t[0] === null) {
      const s = o == null ? void 0 : o.get(),
        i = t[t.length - 1];
      if (s !== void 0) t[0] = s;
      else if (r && n) {
        const a = r.readValue(n, i);
        a != null && (t[0] = a);
      }
      (t[0] === void 0 && (t[0] = i), o && s === void 0 && o.set(t[0]));
    }
    Sp(t);
  }
  setFinalKeyframe() {}
  measureInitialState() {}
  renderEndStyles() {}
  measureEndState() {}
  complete(t = !1) {
    ((this.state = "complete"),
      this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, t),
      bn.delete(this));
  }
  cancel() {
    this.state === "scheduled" && (bn.delete(this), (this.state = "pending"));
  }
  resume() {
    this.state === "pending" && this.scheduleResolve();
  }
}
const Op = (e) => e.startsWith("--");
function Ip(e, t, n) {
  Op(t) ? e.style.setProperty(t, n) : (e.style[t] = n);
}
const Dp = Ti(() => window.ScrollTimeline !== void 0),
  Np = {};
function Fp(e, t) {
  const n = Ti(e);
  return () => Np[t] ?? n();
}
const Cu = Fp(() => {
    try {
      document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" });
    } catch {
      return !1;
    }
    return !0;
  }, "linearEasing"),
  ur = ([e, t, n, r]) => `cubic-bezier(${e}, ${t}, ${n}, ${r})`,
  za = {
    linear: "linear",
    ease: "ease",
    easeIn: "ease-in",
    easeOut: "ease-out",
    easeInOut: "ease-in-out",
    circIn: ur([0, 0.65, 0.55, 1]),
    circOut: ur([0.55, 0, 1, 0.45]),
    backIn: ur([0.31, 0.01, 0.66, -0.59]),
    backOut: ur([0.33, 1.53, 0.69, 0.99]),
  };
function Pu(e, t) {
  if (e)
    return typeof e == "function"
      ? Cu()
        ? wu(e, t)
        : "ease-out"
      : uu(e)
        ? ur(e)
        : Array.isArray(e)
          ? e.map((n) => Pu(n, t) || za.easeOut)
          : za[e];
}
function Lp(
  e,
  t,
  n,
  {
    delay: r = 0,
    duration: o = 300,
    repeat: s = 0,
    repeatType: i = "loop",
    ease: a = "easeOut",
    times: l,
  } = {},
  c = void 0,
) {
  const u = { [t]: n };
  l && (u.offset = l);
  const d = Pu(a, o);
  Array.isArray(d) && (u.easing = d);
  const f = {
    delay: r,
    duration: o,
    easing: Array.isArray(d) ? "linear" : d,
    fill: "both",
    iterations: s + 1,
    direction: i === "reverse" ? "alternate" : "normal",
  };
  return (c && (f.pseudoElement = c), e.animate(u, f));
}
function ku(e) {
  return typeof e == "function" && "applyToOptions" in e;
}
function jp({ type: e, ...t }) {
  return ku(e) && Cu()
    ? e.applyToOptions(t)
    : (t.duration ?? (t.duration = 300), t.ease ?? (t.ease = "easeOut"), t);
}
class Vp extends Di {
  constructor(t) {
    if (
      (super(),
      (this.finishedTime = null),
      (this.isStopped = !1),
      (this.manualStartTime = null),
      !t)
    )
      return;
    const {
      element: n,
      name: r,
      keyframes: o,
      pseudoElement: s,
      allowFlatten: i = !1,
      finalKeyframe: a,
      onComplete: l,
    } = t;
    ((this.isPseudoElement = !!s),
      (this.allowFlatten = i),
      (this.options = t),
      Si(typeof t.type != "string"));
    const c = jp(t);
    ((this.animation = Lp(n, r, o, c, s)),
      c.autoplay === !1 && this.animation.pause(),
      (this.animation.onfinish = () => {
        if (((this.finishedTime = this.time), !s)) {
          const u = Ii(o, this.options, a, this.speed);
          (this.updateMotionValue ? this.updateMotionValue(u) : Ip(n, r, u),
            this.animation.cancel());
        }
        (l == null || l(), this.notifyFinished());
      }));
  }
  play() {
    this.isStopped ||
      ((this.manualStartTime = null),
      this.animation.play(),
      this.state === "finished" && this.updateFinished());
  }
  pause() {
    this.animation.pause();
  }
  complete() {
    var t, n;
    (n = (t = this.animation).finish) == null || n.call(t);
  }
  cancel() {
    try {
      this.animation.cancel();
    } catch {}
  }
  stop() {
    if (this.isStopped) return;
    this.isStopped = !0;
    const { state: t } = this;
    t === "idle" ||
      t === "finished" ||
      (this.updateMotionValue ? this.updateMotionValue() : this.commitStyles(),
      this.isPseudoElement || this.cancel());
  }
  commitStyles() {
    var t, n;
    this.isPseudoElement || (n = (t = this.animation).commitStyles) == null || n.call(t);
  }
  get duration() {
    var n, r;
    const t =
      ((r = (n = this.animation.effect) == null ? void 0 : n.getComputedTiming) == null
        ? void 0
        : r.call(n).duration) || 0;
    return pt(Number(t));
  }
  get iterationDuration() {
    const { delay: t = 0 } = this.options || {};
    return this.duration + pt(t);
  }
  get time() {
    return pt(Number(this.animation.currentTime) || 0);
  }
  set time(t) {
    ((this.manualStartTime = null),
      (this.finishedTime = null),
      (this.animation.currentTime = Lt(t)));
  }
  get speed() {
    return this.animation.playbackRate;
  }
  set speed(t) {
    (t < 0 && (this.finishedTime = null), (this.animation.playbackRate = t));
  }
  get state() {
    return this.finishedTime !== null ? "finished" : this.animation.playState;
  }
  get startTime() {
    return this.manualStartTime ?? Number(this.animation.startTime);
  }
  set startTime(t) {
    this.manualStartTime = this.animation.startTime = t;
  }
  attachTimeline({ timeline: t, observe: n }) {
    var r;
    return (
      this.allowFlatten &&
        ((r = this.animation.effect) == null || r.updateTiming({ easing: "linear" })),
      (this.animation.onfinish = null),
      t && Dp() ? ((this.animation.timeline = t), yt) : n(this)
    );
  }
}
const Mu = { anticipate: iu, backInOut: su, circInOut: lu };
function Bp(e) {
  return e in Mu;
}
function $p(e) {
  typeof e.ease == "string" && Bp(e.ease) && (e.ease = Mu[e.ease]);
}
const rs = 10;
class Wp extends Vp {
  constructor(t) {
    ($p(t),
      Tu(t),
      super(t),
      t.startTime !== void 0 && (this.startTime = t.startTime),
      (this.options = t));
  }
  updateMotionValue(t) {
    const { motionValue: n, onUpdate: r, onComplete: o, element: s, ...i } = this.options;
    if (!n) return;
    if (t !== void 0) {
      n.set(t);
      return;
    }
    const a = new Ni({ ...i, autoplay: !1 }),
      l = Math.max(rs, ot.now() - this.startTime),
      c = Mt(0, rs, l - rs);
    (n.setWithVelocity(a.sample(Math.max(0, l - c)).value, a.sample(l).value, c), a.stop());
  }
}
const Ha = (e, t) =>
  t === "zIndex"
    ? !1
    : !!(
        typeof e == "number" ||
        Array.isArray(e) ||
        (typeof e == "string" && (Zt.test(e) || e === "0") && !e.startsWith("url("))
      );
function zp(e) {
  const t = e[0];
  if (e.length === 1) return !0;
  for (let n = 0; n < e.length; n++) if (e[n] !== t) return !0;
}
function Hp(e, t, n, r) {
  const o = e[0];
  if (o === null) return !1;
  if (t === "display" || t === "visibility") return !0;
  const s = e[e.length - 1],
    i = Ha(o, t),
    a = Ha(s, t);
  return !i || !a ? !1 : zp(e) || ((n === "spring" || ku(n)) && r);
}
function Vs(e) {
  ((e.duration = 0), (e.type = "keyframes"));
}
const Up = new Set(["opacity", "clipPath", "filter", "transform"]),
  _p = Ti(() => Object.hasOwnProperty.call(Element.prototype, "animate"));
function Yp(e) {
  var u;
  const { motionValue: t, name: n, repeatDelay: r, repeatType: o, damping: s, type: i } = e;
  if (!(((u = t == null ? void 0 : t.owner) == null ? void 0 : u.current) instanceof HTMLElement))
    return !1;
  const { onUpdate: l, transformTemplate: c } = t.owner.getProps();
  return (
    _p() &&
    n &&
    Up.has(n) &&
    (n !== "transform" || !c) &&
    !l &&
    !r &&
    o !== "mirror" &&
    s !== 0 &&
    i !== "inertia"
  );
}
const qp = 40;
class Xp extends Di {
  constructor({
    autoplay: t = !0,
    delay: n = 0,
    type: r = "keyframes",
    repeat: o = 0,
    repeatDelay: s = 0,
    repeatType: i = "loop",
    keyframes: a,
    name: l,
    motionValue: c,
    element: u,
    ...d
  }) {
    var g;
    (super(),
      (this.stop = () => {
        var p, v;
        (this._animation &&
          (this._animation.stop(), (p = this.stopTimeline) == null || p.call(this)),
          (v = this.keyframeResolver) == null || v.cancel());
      }),
      (this.createdAt = ot.now()));
    const f = {
        autoplay: t,
        delay: n,
        type: r,
        repeat: o,
        repeatDelay: s,
        repeatType: i,
        name: l,
        motionValue: c,
        element: u,
        ...d,
      },
      m = (u == null ? void 0 : u.KeyframeResolver) || Fi;
    ((this.keyframeResolver = new m(
      a,
      (p, v, b) => this.onKeyframesResolved(p, v, f, !b),
      l,
      c,
      u,
    )),
      (g = this.keyframeResolver) == null || g.scheduleResolve());
  }
  onKeyframesResolved(t, n, r, o) {
    var v, b;
    this.keyframeResolver = void 0;
    const { name: s, type: i, velocity: a, delay: l, isHandoff: c, onUpdate: u } = r;
    ((this.resolvedAt = ot.now()),
      Hp(t, s, i, a) ||
        ((jt.instantAnimations || !l) && (u == null || u(Ii(t, r, n))),
        (t[0] = t[t.length - 1]),
        Vs(r),
        (r.repeat = 0)));
    const f = {
        startTime: o
          ? this.resolvedAt
            ? this.resolvedAt - this.createdAt > qp
              ? this.resolvedAt
              : this.createdAt
            : this.createdAt
          : void 0,
        finalKeyframe: n,
        ...r,
        keyframes: t,
      },
      m = !c && Yp(f),
      g = (b = (v = f.motionValue) == null ? void 0 : v.owner) == null ? void 0 : b.current,
      p = m ? new Wp({ ...f, element: g }) : new Ni(f);
    (p.finished
      .then(() => {
        this.notifyFinished();
      })
      .catch(yt),
      this.pendingTimeline &&
        ((this.stopTimeline = p.attachTimeline(this.pendingTimeline)),
        (this.pendingTimeline = void 0)),
      (this._animation = p));
  }
  get finished() {
    return this._animation ? this.animation.finished : this._finished;
  }
  then(t, n) {
    return this.finished.finally(t).then(() => {});
  }
  get animation() {
    var t;
    return (
      this._animation || ((t = this.keyframeResolver) == null || t.resume(), Ap()), this._animation
    );
  }
  get duration() {
    return this.animation.duration;
  }
  get iterationDuration() {
    return this.animation.iterationDuration;
  }
  get time() {
    return this.animation.time;
  }
  set time(t) {
    this.animation.time = t;
  }
  get speed() {
    return this.animation.speed;
  }
  get state() {
    return this.animation.state;
  }
  set speed(t) {
    this.animation.speed = t;
  }
  get startTime() {
    return this.animation.startTime;
  }
  attachTimeline(t) {
    return (
      this._animation
        ? (this.stopTimeline = this.animation.attachTimeline(t))
        : (this.pendingTimeline = t),
      () => this.stop()
    );
  }
  play() {
    this.animation.play();
  }
  pause() {
    this.animation.pause();
  }
  complete() {
    this.animation.complete();
  }
  cancel() {
    var t;
    (this._animation && this.animation.cancel(), (t = this.keyframeResolver) == null || t.cancel());
  }
}
function Au(e, t, n, r = 0, o = 1) {
  const s = Array.from(e)
      .sort((c, u) => c.sortNodePosition(u))
      .indexOf(t),
    i = e.size,
    a = (i - 1) * r;
  return typeof n == "function" ? n(s, i) : o === 1 ? s * r : a - s * r;
}
const Gp = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;
function Kp(e) {
  const t = Gp.exec(e);
  if (!t) return [,];
  const [, n, r, o] = t;
  return [`--${n ?? r}`, o];
}
function Ou(e, t, n = 1) {
  const [r, o] = Kp(e);
  if (!r) return;
  const s = window.getComputedStyle(t).getPropertyValue(r);
  if (s) {
    const i = s.trim();
    return Qc(i) ? parseFloat(i) : i;
  }
  return Pi(o) ? Ou(o, t, n + 1) : o;
}
const Qp = { type: "spring", stiffness: 500, damping: 25, restSpeed: 10 },
  Zp = (e) => ({
    type: "spring",
    stiffness: 550,
    damping: e === 0 ? 2 * Math.sqrt(550) : 30,
    restSpeed: 10,
  }),
  Jp = { type: "keyframes", duration: 0.8 },
  eg = { type: "keyframes", ease: [0.25, 0.1, 0.35, 1], duration: 0.3 },
  tg = (e, { keyframes: t }) =>
    t.length > 2 ? Jp : Zn.has(e) ? (e.startsWith("scale") ? Zp(t[1]) : Qp) : eg,
  ng = (e) => e !== null;
function rg(e, { repeat: t, repeatType: n = "loop" }, r) {
  const o = e.filter(ng),
    s = t && n !== "loop" && t % 2 === 1 ? 0 : o.length - 1;
  return o[s];
}
function Li(e, t) {
  return (e == null ? void 0 : e[t]) ?? (e == null ? void 0 : e.default) ?? e;
}
function og({
  when: e,
  delay: t,
  delayChildren: n,
  staggerChildren: r,
  staggerDirection: o,
  repeat: s,
  repeatType: i,
  repeatDelay: a,
  from: l,
  elapsed: c,
  ...u
}) {
  return !!Object.keys(u).length;
}
const ji =
  (e, t, n, r = {}, o, s) =>
  (i) => {
    const a = Li(r, e) || {},
      l = a.delay || r.delay || 0;
    let { elapsed: c = 0 } = r;
    c = c - Lt(l);
    const u = {
      keyframes: Array.isArray(n) ? n : [null, n],
      ease: "easeOut",
      velocity: t.getVelocity(),
      ...a,
      delay: -c,
      onUpdate: (f) => {
        (t.set(f), a.onUpdate && a.onUpdate(f));
      },
      onComplete: () => {
        (i(), a.onComplete && a.onComplete());
      },
      name: e,
      motionValue: t,
      element: s ? void 0 : o,
    };
    (og(a) || Object.assign(u, tg(e, u)),
      u.duration && (u.duration = Lt(u.duration)),
      u.repeatDelay && (u.repeatDelay = Lt(u.repeatDelay)),
      u.from !== void 0 && (u.keyframes[0] = u.from));
    let d = !1;
    if (
      ((u.type === !1 || (u.duration === 0 && !u.repeatDelay)) &&
        (Vs(u), u.delay === 0 && (d = !0)),
      (jt.instantAnimations || jt.skipAnimations) && ((d = !0), Vs(u), (u.delay = 0)),
      (u.allowFlatten = !a.type && !a.ease),
      d && !s && t.get() !== void 0)
    ) {
      const f = rg(u.keyframes, a);
      if (f !== void 0) {
        De.update(() => {
          (u.onUpdate(f), u.onComplete());
        });
        return;
      }
    }
    return a.isSync ? new Ni(u) : new Xp(u);
  };
function Ua(e) {
  const t = [{}, {}];
  return (
    e == null ||
      e.values.forEach((n, r) => {
        ((t[0][r] = n.get()), (t[1][r] = n.getVelocity()));
      }),
    t
  );
}
function Vi(e, t, n, r) {
  if (typeof t == "function") {
    const [o, s] = Ua(r);
    t = t(n !== void 0 ? n : e.custom, o, s);
  }
  if ((typeof t == "string" && (t = e.variants && e.variants[t]), typeof t == "function")) {
    const [o, s] = Ua(r);
    t = t(n !== void 0 ? n : e.custom, o, s);
  }
  return t;
}
function Nn(e, t, n) {
  const r = e.getProps();
  return Vi(r, t, n !== void 0 ? n : r.custom, e);
}
const Iu = new Set(["width", "height", "top", "left", "right", "bottom", ...Qn]),
  _a = 30,
  sg = (e) => !isNaN(parseFloat(e));
class ig {
  constructor(t, n = {}) {
    ((this.canTrackVelocity = null),
      (this.events = {}),
      (this.updateAndNotify = (r) => {
        var s;
        const o = ot.now();
        if (
          (this.updatedAt !== o && this.setPrevFrameValue(),
          (this.prev = this.current),
          this.setCurrent(r),
          this.current !== this.prev &&
            ((s = this.events.change) == null || s.notify(this.current), this.dependents))
        )
          for (const i of this.dependents) i.dirty();
      }),
      (this.hasAnimated = !1),
      this.setCurrent(t),
      (this.owner = n.owner));
  }
  setCurrent(t) {
    ((this.current = t),
      (this.updatedAt = ot.now()),
      this.canTrackVelocity === null && t !== void 0 && (this.canTrackVelocity = sg(this.current)));
  }
  setPrevFrameValue(t = this.current) {
    ((this.prevFrameValue = t), (this.prevUpdatedAt = this.updatedAt));
  }
  onChange(t) {
    return this.on("change", t);
  }
  on(t, n) {
    this.events[t] || (this.events[t] = new Ri());
    const r = this.events[t].add(n);
    return t === "change"
      ? () => {
          (r(),
            De.read(() => {
              this.events.change.getSize() || this.stop();
            }));
        }
      : r;
  }
  clearListeners() {
    for (const t in this.events) this.events[t].clear();
  }
  attach(t, n) {
    ((this.passiveEffect = t), (this.stopPassiveEffect = n));
  }
  set(t) {
    this.passiveEffect ? this.passiveEffect(t, this.updateAndNotify) : this.updateAndNotify(t);
  }
  setWithVelocity(t, n, r) {
    (this.set(n),
      (this.prev = void 0),
      (this.prevFrameValue = t),
      (this.prevUpdatedAt = this.updatedAt - r));
  }
  jump(t, n = !0) {
    (this.updateAndNotify(t),
      (this.prev = t),
      (this.prevUpdatedAt = this.prevFrameValue = void 0),
      n && this.stop(),
      this.stopPassiveEffect && this.stopPassiveEffect());
  }
  dirty() {
    var t;
    (t = this.events.change) == null || t.notify(this.current);
  }
  addDependent(t) {
    (this.dependents || (this.dependents = new Set()), this.dependents.add(t));
  }
  removeDependent(t) {
    this.dependents && this.dependents.delete(t);
  }
  get() {
    return this.current;
  }
  getPrevious() {
    return this.prev;
  }
  getVelocity() {
    const t = ot.now();
    if (!this.canTrackVelocity || this.prevFrameValue === void 0 || t - this.updatedAt > _a)
      return 0;
    const n = Math.min(this.updatedAt - this.prevUpdatedAt, _a);
    return eu(parseFloat(this.current) - parseFloat(this.prevFrameValue), n);
  }
  start(t) {
    return (
      this.stop(),
      new Promise((n) => {
        ((this.hasAnimated = !0),
          (this.animation = t(n)),
          this.events.animationStart && this.events.animationStart.notify());
      }).then(() => {
        (this.events.animationComplete && this.events.animationComplete.notify(),
          this.clearAnimation());
      })
    );
  }
  stop() {
    (this.animation &&
      (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()),
      this.clearAnimation());
  }
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  destroy() {
    var t, n;
    ((t = this.dependents) == null || t.clear(),
      (n = this.events.destroy) == null || n.notify(),
      this.clearListeners(),
      this.stop(),
      this.stopPassiveEffect && this.stopPassiveEffect());
  }
}
function zn(e, t) {
  return new ig(e, t);
}
const Bs = (e) => Array.isArray(e);
function ag(e, t, n) {
  e.hasValue(t) ? e.getValue(t).set(n) : e.addValue(t, zn(n));
}
function lg(e) {
  return Bs(e) ? e[e.length - 1] || 0 : e;
}
function cg(e, t) {
  const n = Nn(e, t);
  let { transitionEnd: r = {}, transition: o = {}, ...s } = n || {};
  s = { ...s, ...r };
  for (const i in s) {
    const a = lg(s[i]);
    ag(e, i, a);
  }
}
const nt = (e) => !!(e && e.getVelocity);
function ug(e) {
  return !!(nt(e) && e.add);
}
function $s(e, t) {
  const n = e.getValue("willChange");
  if (ug(n)) return n.add(t);
  if (!n && jt.WillChange) {
    const r = new jt.WillChange("auto");
    (e.addValue("willChange", r), r.add(t));
  }
}
function Bi(e) {
  return e.replace(/([A-Z])/g, (t) => `-${t.toLowerCase()}`);
}
const dg = "framerAppearId",
  Du = "data-" + Bi(dg);
function Nu(e) {
  return e.props[Du];
}
function fg({ protectedKeys: e, needsAnimating: t }, n) {
  const r = e.hasOwnProperty(n) && t[n] !== !0;
  return ((t[n] = !1), r);
}
function Fu(e, t, { delay: n = 0, transitionOverride: r, type: o } = {}) {
  let { transition: s = e.getDefaultTransition(), transitionEnd: i, ...a } = t;
  r && (s = r);
  const l = [],
    c = o && e.animationState && e.animationState.getState()[o];
  for (const u in a) {
    const d = e.getValue(u, e.latestValues[u] ?? null),
      f = a[u];
    if (f === void 0 || (c && fg(c, u))) continue;
    const m = { delay: n, ...Li(s || {}, u) },
      g = d.get();
    if (g !== void 0 && !d.isAnimating && !Array.isArray(f) && f === g && !m.velocity) continue;
    let p = !1;
    if (window.MotionHandoffAnimation) {
      const b = Nu(e);
      if (b) {
        const y = window.MotionHandoffAnimation(b, u, De);
        y !== null && ((m.startTime = y), (p = !0));
      }
    }
    ($s(e, u), d.start(ji(u, d, f, e.shouldReduceMotion && Iu.has(u) ? { type: !1 } : m, e, p)));
    const v = d.animation;
    v && l.push(v);
  }
  return (
    i &&
      Promise.all(l).then(() => {
        De.update(() => {
          i && cg(e, i);
        });
      }),
    l
  );
}
function Ws(e, t, n = {}) {
  var l;
  const r = Nn(
    e,
    t,
    n.type === "exit" ? ((l = e.presenceContext) == null ? void 0 : l.custom) : void 0,
  );
  let { transition: o = e.getDefaultTransition() || {} } = r || {};
  n.transitionOverride && (o = n.transitionOverride);
  const s = r ? () => Promise.all(Fu(e, r, n)) : () => Promise.resolve(),
    i =
      e.variantChildren && e.variantChildren.size
        ? (c = 0) => {
            const { delayChildren: u = 0, staggerChildren: d, staggerDirection: f } = o;
            return hg(e, t, c, u, d, f, n);
          }
        : () => Promise.resolve(),
    { when: a } = o;
  if (a) {
    const [c, u] = a === "beforeChildren" ? [s, i] : [i, s];
    return c().then(() => u());
  } else return Promise.all([s(), i(n.delay)]);
}
function hg(e, t, n = 0, r = 0, o = 0, s = 1, i) {
  const a = [];
  for (const l of e.variantChildren)
    (l.notify("AnimationStart", t),
      a.push(
        Ws(l, t, {
          ...i,
          delay: n + (typeof r == "function" ? 0 : r) + Au(e.variantChildren, l, r, o, s),
        }).then(() => l.notify("AnimationComplete", t)),
      ));
  return Promise.all(a);
}
function mg(e, t, n = {}) {
  e.notify("AnimationStart", t);
  let r;
  if (Array.isArray(t)) {
    const o = t.map((s) => Ws(e, s, n));
    r = Promise.all(o);
  } else if (typeof t == "string") r = Ws(e, t, n);
  else {
    const o = typeof t == "function" ? Nn(e, t, n.custom) : t;
    r = Promise.all(Fu(e, o, n));
  }
  return r.then(() => {
    e.notify("AnimationComplete", t);
  });
}
const pg = { test: (e) => e === "auto", parse: (e) => e },
  Lu = (e) => (t) => t.test(e),
  ju = [Kn, se, Ct, zt, zm, Wm, pg],
  Ya = (e) => ju.find(Lu(e));
function gg(e) {
  return typeof e == "number" ? e === 0 : e !== null ? e === "none" || e === "0" || Jc(e) : !0;
}
const bg = new Set(["brightness", "contrast", "saturate", "opacity"]);
function yg(e) {
  const [t, n] = e.slice(0, -1).split("(");
  if (t === "drop-shadow") return e;
  const [r] = n.match(ki) || [];
  if (!r) return e;
  const o = n.replace(r, "");
  let s = bg.has(t) ? 1 : 0;
  return (r !== n && (s *= 100), t + "(" + s + o + ")");
}
const xg = /\b([a-z-]*)\(.*?\)/gu,
  zs = {
    ...Zt,
    getAnimatableNone: (e) => {
      const t = e.match(xg);
      return t ? t.map(yg).join(" ") : e;
    },
  },
  qa = { ...Kn, transform: Math.round },
  vg = {
    rotate: zt,
    rotateX: zt,
    rotateY: zt,
    rotateZ: zt,
    scale: Br,
    scaleX: Br,
    scaleY: Br,
    scaleZ: Br,
    skew: zt,
    skewX: zt,
    skewY: zt,
    distance: se,
    translateX: se,
    translateY: se,
    translateZ: se,
    x: se,
    y: se,
    z: se,
    perspective: se,
    transformPerspective: se,
    opacity: wr,
    originX: Da,
    originY: Da,
    originZ: se,
  },
  $i = {
    borderWidth: se,
    borderTopWidth: se,
    borderRightWidth: se,
    borderBottomWidth: se,
    borderLeftWidth: se,
    borderRadius: se,
    radius: se,
    borderTopLeftRadius: se,
    borderTopRightRadius: se,
    borderBottomRightRadius: se,
    borderBottomLeftRadius: se,
    width: se,
    maxWidth: se,
    height: se,
    maxHeight: se,
    top: se,
    right: se,
    bottom: se,
    left: se,
    inset: se,
    insetBlock: se,
    insetBlockStart: se,
    insetBlockEnd: se,
    insetInline: se,
    insetInlineStart: se,
    insetInlineEnd: se,
    padding: se,
    paddingTop: se,
    paddingRight: se,
    paddingBottom: se,
    paddingLeft: se,
    paddingBlock: se,
    paddingBlockStart: se,
    paddingBlockEnd: se,
    paddingInline: se,
    paddingInlineStart: se,
    paddingInlineEnd: se,
    margin: se,
    marginTop: se,
    marginRight: se,
    marginBottom: se,
    marginLeft: se,
    marginBlock: se,
    marginBlockStart: se,
    marginBlockEnd: se,
    marginInline: se,
    marginInlineStart: se,
    marginInlineEnd: se,
    backgroundPositionX: se,
    backgroundPositionY: se,
    ...vg,
    zIndex: qa,
    fillOpacity: wr,
    strokeOpacity: wr,
    numOctaves: qa,
  },
  wg = {
    ...$i,
    color: Ue,
    backgroundColor: Ue,
    outlineColor: Ue,
    fill: Ue,
    stroke: Ue,
    borderColor: Ue,
    borderTopColor: Ue,
    borderRightColor: Ue,
    borderBottomColor: Ue,
    borderLeftColor: Ue,
    filter: zs,
    WebkitFilter: zs,
  },
  Vu = (e) => wg[e];
function Bu(e, t) {
  let n = Vu(e);
  return (n !== zs && (n = Zt), n.getAnimatableNone ? n.getAnimatableNone(t) : void 0);
}
const Sg = new Set(["auto", "none", "0"]);
function Tg(e, t, n) {
  let r = 0,
    o;
  for (; r < e.length && !o; ) {
    const s = e[r];
    (typeof s == "string" && !Sg.has(s) && Sr(s).values.length && (o = e[r]), r++);
  }
  if (o && n) for (const s of t) e[s] = Bu(n, o);
}
class Rg extends Fi {
  constructor(t, n, r, o, s) {
    super(t, n, r, o, s, !0);
  }
  readKeyframes() {
    const { unresolvedKeyframes: t, element: n, name: r } = this;
    if (!n || !n.current) return;
    super.readKeyframes();
    for (let u = 0; u < t.length; u++) {
      let d = t[u];
      if (typeof d == "string" && ((d = d.trim()), Pi(d))) {
        const f = Ou(d, n.current);
        (f !== void 0 && (t[u] = f), u === t.length - 1 && (this.finalKeyframe = d));
      }
    }
    if ((this.resolveNoneKeyframes(), !Iu.has(r) || t.length !== 2)) return;
    const [o, s] = t,
      i = Ya(o),
      a = Ya(s),
      l = Ia(o),
      c = Ia(s);
    if (l !== c && Ht[r]) {
      this.needsMeasurement = !0;
      return;
    }
    if (i !== a)
      if (Wa(i) && Wa(a))
        for (let u = 0; u < t.length; u++) {
          const d = t[u];
          typeof d == "string" && (t[u] = parseFloat(d));
        }
      else Ht[r] && (this.needsMeasurement = !0);
  }
  resolveNoneKeyframes() {
    const { unresolvedKeyframes: t, name: n } = this,
      r = [];
    for (let o = 0; o < t.length; o++) (t[o] === null || gg(t[o])) && r.push(o);
    r.length && Tg(t, r, n);
  }
  measureInitialState() {
    const { element: t, unresolvedKeyframes: n, name: r } = this;
    if (!t || !t.current) return;
    (r === "height" && (this.suspendedScrollY = window.pageYOffset),
      (this.measuredOrigin = Ht[r](t.measureViewportBox(), window.getComputedStyle(t.current))),
      (n[0] = this.measuredOrigin));
    const o = n[n.length - 1];
    o !== void 0 && t.getValue(r, o).jump(o, !1);
  }
  measureEndState() {
    var a;
    const { element: t, name: n, unresolvedKeyframes: r } = this;
    if (!t || !t.current) return;
    const o = t.getValue(n);
    o && o.jump(this.measuredOrigin, !1);
    const s = r.length - 1,
      i = r[s];
    ((r[s] = Ht[n](t.measureViewportBox(), window.getComputedStyle(t.current))),
      i !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = i),
      (a = this.removedTransforms) != null &&
        a.length &&
        this.removedTransforms.forEach(([l, c]) => {
          t.getValue(l).set(c);
        }),
      this.resolveNoneKeyframes());
  }
}
function Eg(e, t, n) {
  if (e == null) return [];
  if (e instanceof EventTarget) return [e];
  if (typeof e == "string") {
    let r = document;
    const o = (n == null ? void 0 : n[e]) ?? r.querySelectorAll(e);
    return o ? Array.from(o) : [];
  }
  return Array.from(e).filter((r) => r != null);
}
const $u = (e, t) => (t && typeof e == "number" ? t.transform(e) : e);
function Hs(e) {
  return Zc(e) && "offsetHeight" in e;
}
const { schedule: Wi } = du(queueMicrotask, !1),
  St = { x: !1, y: !1 };
function Wu() {
  return St.x || St.y;
}
function Cg(e) {
  return e === "x" || e === "y"
    ? St[e]
      ? null
      : ((St[e] = !0),
        () => {
          St[e] = !1;
        })
    : St.x || St.y
      ? null
      : ((St.x = St.y = !0),
        () => {
          St.x = St.y = !1;
        });
}
function zu(e, t) {
  const n = Eg(e),
    r = new AbortController(),
    o = { passive: !0, ...t, signal: r.signal };
  return [n, o, () => r.abort()];
}
function Xa(e) {
  return !(e.pointerType === "touch" || Wu());
}
function Pg(e, t, n = {}) {
  const [r, o, s] = zu(e, n),
    i = (a) => {
      if (!Xa(a)) return;
      const { target: l } = a,
        c = t(l, a);
      if (typeof c != "function" || !l) return;
      const u = (d) => {
        Xa(d) && (c(d), l.removeEventListener("pointerleave", u));
      };
      l.addEventListener("pointerleave", u, o);
    };
  return (
    r.forEach((a) => {
      a.addEventListener("pointerenter", i, o);
    }),
    s
  );
}
const Hu = (e, t) => (t ? (e === t ? !0 : Hu(e, t.parentElement)) : !1),
  zi = (e) =>
    e.pointerType === "mouse" ? typeof e.button != "number" || e.button <= 0 : e.isPrimary !== !1,
  kg = new Set(["BUTTON", "INPUT", "SELECT", "TEXTAREA", "A"]);
function Uu(e) {
  return kg.has(e.tagName) || e.isContentEditable === !0;
}
const ro = new WeakSet();
function Ga(e) {
  return (t) => {
    t.key === "Enter" && e(t);
  };
}
function os(e, t) {
  e.dispatchEvent(new PointerEvent("pointer" + t, { isPrimary: !0, bubbles: !0 }));
}
const Mg = (e, t) => {
  const n = e.currentTarget;
  if (!n) return;
  const r = Ga(() => {
    if (ro.has(n)) return;
    os(n, "down");
    const o = Ga(() => {
        os(n, "up");
      }),
      s = () => os(n, "cancel");
    (n.addEventListener("keyup", o, t), n.addEventListener("blur", s, t));
  });
  (n.addEventListener("keydown", r, t),
    n.addEventListener("blur", () => n.removeEventListener("keydown", r), t));
};
function Ka(e) {
  return zi(e) && !Wu();
}
function Ag(e, t, n = {}) {
  const [r, o, s] = zu(e, n),
    i = (a) => {
      const l = a.currentTarget;
      if (!Ka(a)) return;
      ro.add(l);
      const c = t(l, a),
        u = (m, g) => {
          (window.removeEventListener("pointerup", d),
            window.removeEventListener("pointercancel", f),
            ro.has(l) && ro.delete(l),
            Ka(m) && typeof c == "function" && c(m, { success: g }));
        },
        d = (m) => {
          u(m, l === window || l === document || n.useGlobalTarget || Hu(l, m.target));
        },
        f = (m) => {
          u(m, !1);
        };
      (window.addEventListener("pointerup", d, o), window.addEventListener("pointercancel", f, o));
    };
  return (
    r.forEach((a) => {
      ((n.useGlobalTarget ? window : a).addEventListener("pointerdown", i, o),
        Hs(a) &&
          (a.addEventListener("focus", (c) => Mg(c, o)),
          !Uu(a) && !a.hasAttribute("tabindex") && (a.tabIndex = 0)));
    }),
    s
  );
}
function _u(e) {
  return Zc(e) && "ownerSVGElement" in e;
}
function Og(e) {
  return _u(e) && e.tagName === "svg";
}
const Ig = [...ju, Ue, Zt],
  Dg = (e) => Ig.find(Lu(e)),
  Qa = () => ({ translate: 0, scale: 1, origin: 0, originPoint: 0 }),
  An = () => ({ x: Qa(), y: Qa() }),
  Za = () => ({ min: 0, max: 0 }),
  Xe = () => ({ x: Za(), y: Za() }),
  Us = { current: null },
  Yu = { current: !1 },
  Ng = typeof window < "u";
function Fg() {
  if (((Yu.current = !0), !!Ng))
    if (window.matchMedia) {
      const e = window.matchMedia("(prefers-reduced-motion)"),
        t = () => (Us.current = e.matches);
      (e.addEventListener("change", t), t());
    } else Us.current = !1;
}
const Lg = new WeakMap();
function Fo(e) {
  return e !== null && typeof e == "object" && typeof e.start == "function";
}
function Tr(e) {
  return typeof e == "string" || Array.isArray(e);
}
const Hi = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"],
  Ui = ["initial", ...Hi];
function Lo(e) {
  return Fo(e.animate) || Ui.some((t) => Tr(e[t]));
}
function qu(e) {
  return !!(Lo(e) || e.variants);
}
function jg(e, t, n) {
  for (const r in t) {
    const o = t[r],
      s = n[r];
    if (nt(o)) e.addValue(r, o);
    else if (nt(s)) e.addValue(r, zn(o, { owner: e }));
    else if (s !== o)
      if (e.hasValue(r)) {
        const i = e.getValue(r);
        i.liveStyle === !0 ? i.jump(o) : i.hasAnimated || i.set(o);
      } else {
        const i = e.getStaticValue(r);
        e.addValue(r, zn(i !== void 0 ? i : o, { owner: e }));
      }
  }
  for (const r in n) t[r] === void 0 && e.removeValue(r);
  return t;
}
const Ja = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete",
];
let bo = {};
function Xu(e) {
  bo = e;
}
function Vg() {
  return bo;
}
class Bg {
  scrapeMotionValuesFromProps(t, n, r) {
    return {};
  }
  constructor(
    {
      parent: t,
      props: n,
      presenceContext: r,
      reducedMotionConfig: o,
      blockInitialAnimation: s,
      visualState: i,
    },
    a = {},
  ) {
    ((this.current = null),
      (this.children = new Set()),
      (this.isVariantNode = !1),
      (this.isControllingVariants = !1),
      (this.shouldReduceMotion = null),
      (this.values = new Map()),
      (this.KeyframeResolver = Fi),
      (this.features = {}),
      (this.valueSubscriptions = new Map()),
      (this.prevMotionValues = {}),
      (this.events = {}),
      (this.propEventSubscriptions = {}),
      (this.notifyUpdate = () => this.notify("Update", this.latestValues)),
      (this.render = () => {
        this.current &&
          (this.triggerBuild(),
          this.renderInstance(this.current, this.renderState, this.props.style, this.projection));
      }),
      (this.renderScheduledAt = 0),
      (this.scheduleRender = () => {
        const f = ot.now();
        this.renderScheduledAt < f &&
          ((this.renderScheduledAt = f), De.render(this.render, !1, !0));
      }));
    const { latestValues: l, renderState: c } = i;
    ((this.latestValues = l),
      (this.baseTarget = { ...l }),
      (this.initialValues = n.initial ? { ...l } : {}),
      (this.renderState = c),
      (this.parent = t),
      (this.props = n),
      (this.presenceContext = r),
      (this.depth = t ? t.depth + 1 : 0),
      (this.reducedMotionConfig = o),
      (this.options = a),
      (this.blockInitialAnimation = !!s),
      (this.isControllingVariants = Lo(n)),
      (this.isVariantNode = qu(n)),
      this.isVariantNode && (this.variantChildren = new Set()),
      (this.manuallyAnimateOnMount = !!(t && t.current)));
    const { willChange: u, ...d } = this.scrapeMotionValuesFromProps(n, {}, this);
    for (const f in d) {
      const m = d[f];
      l[f] !== void 0 && nt(m) && m.set(l[f]);
    }
  }
  mount(t) {
    var n;
    ((this.current = t),
      Lg.set(t, this),
      this.projection && !this.projection.instance && this.projection.mount(t),
      this.parent &&
        this.isVariantNode &&
        !this.isControllingVariants &&
        (this.removeFromVariantTree = this.parent.addVariantChild(this)),
      this.values.forEach((r, o) => this.bindToMotionValue(o, r)),
      this.reducedMotionConfig === "never"
        ? (this.shouldReduceMotion = !1)
        : this.reducedMotionConfig === "always"
          ? (this.shouldReduceMotion = !0)
          : (Yu.current || Fg(), (this.shouldReduceMotion = Us.current)),
      (n = this.parent) == null || n.addChild(this),
      this.update(this.props, this.presenceContext));
  }
  unmount() {
    var t;
    (this.projection && this.projection.unmount(),
      Qt(this.notifyUpdate),
      Qt(this.render),
      this.valueSubscriptions.forEach((n) => n()),
      this.valueSubscriptions.clear(),
      this.removeFromVariantTree && this.removeFromVariantTree(),
      (t = this.parent) == null || t.removeChild(this));
    for (const n in this.events) this.events[n].clear();
    for (const n in this.features) {
      const r = this.features[n];
      r && (r.unmount(), (r.isMounted = !1));
    }
    this.current = null;
  }
  addChild(t) {
    (this.children.add(t),
      this.enteringChildren ?? (this.enteringChildren = new Set()),
      this.enteringChildren.add(t));
  }
  removeChild(t) {
    (this.children.delete(t), this.enteringChildren && this.enteringChildren.delete(t));
  }
  bindToMotionValue(t, n) {
    this.valueSubscriptions.has(t) && this.valueSubscriptions.get(t)();
    const r = Zn.has(t);
    r && this.onBindTransform && this.onBindTransform();
    const o = n.on("change", (i) => {
      ((this.latestValues[t] = i),
        this.props.onUpdate && De.preRender(this.notifyUpdate),
        r && this.projection && (this.projection.isTransformDirty = !0),
        this.scheduleRender());
    });
    let s;
    (typeof window < "u" &&
      window.MotionCheckAppearSync &&
      (s = window.MotionCheckAppearSync(this, t, n)),
      this.valueSubscriptions.set(t, () => {
        (o(), s && s(), n.owner && n.stop());
      }));
  }
  sortNodePosition(t) {
    return !this.current || !this.sortInstanceNodePosition || this.type !== t.type
      ? 0
      : this.sortInstanceNodePosition(this.current, t.current);
  }
  updateFeatures() {
    let t = "animation";
    for (t in bo) {
      const n = bo[t];
      if (!n) continue;
      const { isEnabled: r, Feature: o } = n;
      if (
        (!this.features[t] && o && r(this.props) && (this.features[t] = new o(this)),
        this.features[t])
      ) {
        const s = this.features[t];
        s.isMounted ? s.update() : (s.mount(), (s.isMounted = !0));
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.props);
  }
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : Xe();
  }
  getStaticValue(t) {
    return this.latestValues[t];
  }
  setStaticValue(t, n) {
    this.latestValues[t] = n;
  }
  update(t, n) {
    ((t.transformTemplate || this.props.transformTemplate) && this.scheduleRender(),
      (this.prevProps = this.props),
      (this.props = t),
      (this.prevPresenceContext = this.presenceContext),
      (this.presenceContext = n));
    for (let r = 0; r < Ja.length; r++) {
      const o = Ja[r];
      this.propEventSubscriptions[o] &&
        (this.propEventSubscriptions[o](), delete this.propEventSubscriptions[o]);
      const s = "on" + o,
        i = t[s];
      i && (this.propEventSubscriptions[o] = this.on(o, i));
    }
    ((this.prevMotionValues = jg(
      this,
      this.scrapeMotionValuesFromProps(t, this.prevProps || {}, this),
      this.prevMotionValues,
    )),
      this.handleChildMotionValue && this.handleChildMotionValue());
  }
  getProps() {
    return this.props;
  }
  getVariant(t) {
    return this.props.variants ? this.props.variants[t] : void 0;
  }
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
  }
  addVariantChild(t) {
    const n = this.getClosestVariantNode();
    if (n)
      return (n.variantChildren && n.variantChildren.add(t), () => n.variantChildren.delete(t));
  }
  addValue(t, n) {
    const r = this.values.get(t);
    n !== r &&
      (r && this.removeValue(t),
      this.bindToMotionValue(t, n),
      this.values.set(t, n),
      (this.latestValues[t] = n.get()));
  }
  removeValue(t) {
    this.values.delete(t);
    const n = this.valueSubscriptions.get(t);
    (n && (n(), this.valueSubscriptions.delete(t)),
      delete this.latestValues[t],
      this.removeValueFromRenderState(t, this.renderState));
  }
  hasValue(t) {
    return this.values.has(t);
  }
  getValue(t, n) {
    if (this.props.values && this.props.values[t]) return this.props.values[t];
    let r = this.values.get(t);
    return (
      r === void 0 &&
        n !== void 0 &&
        ((r = zn(n === null ? void 0 : n, { owner: this })), this.addValue(t, r)),
      r
    );
  }
  readValue(t, n) {
    let r =
      this.latestValues[t] !== void 0 || !this.current
        ? this.latestValues[t]
        : (this.getBaseTargetFromProps(this.props, t) ??
          this.readValueFromInstance(this.current, t, this.options));
    return (
      r != null &&
        (typeof r == "string" && (Qc(r) || Jc(r))
          ? (r = parseFloat(r))
          : !Dg(r) && Zt.test(n) && (r = Bu(t, n)),
        this.setBaseTarget(t, nt(r) ? r.get() : r)),
      nt(r) ? r.get() : r
    );
  }
  setBaseTarget(t, n) {
    this.baseTarget[t] = n;
  }
  getBaseTarget(t) {
    var s;
    const { initial: n } = this.props;
    let r;
    if (typeof n == "string" || typeof n == "object") {
      const i = Vi(this.props, n, (s = this.presenceContext) == null ? void 0 : s.custom);
      i && (r = i[t]);
    }
    if (n && r !== void 0) return r;
    const o = this.getBaseTargetFromProps(this.props, t);
    return o !== void 0 && !nt(o)
      ? o
      : this.initialValues[t] !== void 0 && r === void 0
        ? void 0
        : this.baseTarget[t];
  }
  on(t, n) {
    return (this.events[t] || (this.events[t] = new Ri()), this.events[t].add(n));
  }
  notify(t, ...n) {
    this.events[t] && this.events[t].notify(...n);
  }
  scheduleRenderMicrotask() {
    Wi.render(this.render);
  }
}
class Gu extends Bg {
  constructor() {
    (super(...arguments), (this.KeyframeResolver = Rg));
  }
  sortInstanceNodePosition(t, n) {
    return t.compareDocumentPosition(n) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(t, n) {
    const r = t.style;
    return r ? r[n] : void 0;
  }
  removeValueFromRenderState(t, { vars: n, style: r }) {
    (delete n[t], delete r[t]);
  }
  handleChildMotionValue() {
    this.childSubscription && (this.childSubscription(), delete this.childSubscription);
    const { children: t } = this.props;
    nt(t) &&
      (this.childSubscription = t.on("change", (n) => {
        this.current && (this.current.textContent = `${n}`);
      }));
  }
}
class tn {
  constructor(t) {
    ((this.isMounted = !1), (this.node = t));
  }
  update() {}
}
function Ku({ top: e, left: t, right: n, bottom: r }) {
  return { x: { min: t, max: n }, y: { min: e, max: r } };
}
function $g({ x: e, y: t }) {
  return { top: t.min, right: e.max, bottom: t.max, left: e.min };
}
function Wg(e, t) {
  if (!t) return e;
  const n = t({ x: e.left, y: e.top }),
    r = t({ x: e.right, y: e.bottom });
  return { top: n.y, left: n.x, bottom: r.y, right: r.x };
}
function ss(e) {
  return e === void 0 || e === 1;
}
function _s({ scale: e, scaleX: t, scaleY: n }) {
  return !ss(e) || !ss(t) || !ss(n);
}
function hn(e) {
  return _s(e) || Qu(e) || e.z || e.rotate || e.rotateX || e.rotateY || e.skewX || e.skewY;
}
function Qu(e) {
  return el(e.x) || el(e.y);
}
function el(e) {
  return e && e !== "0%";
}
function yo(e, t, n) {
  const r = e - n,
    o = t * r;
  return n + o;
}
function tl(e, t, n, r, o) {
  return (o !== void 0 && (e = yo(e, o, r)), yo(e, n, r) + t);
}
function Ys(e, t = 0, n = 1, r, o) {
  ((e.min = tl(e.min, t, n, r, o)), (e.max = tl(e.max, t, n, r, o)));
}
function Zu(e, { x: t, y: n }) {
  (Ys(e.x, t.translate, t.scale, t.originPoint), Ys(e.y, n.translate, n.scale, n.originPoint));
}
const nl = 0.999999999999,
  rl = 1.0000000000001;
function zg(e, t, n, r = !1) {
  const o = n.length;
  if (!o) return;
  t.x = t.y = 1;
  let s, i;
  for (let a = 0; a < o; a++) {
    ((s = n[a]), (i = s.projectionDelta));
    const { visualElement: l } = s.options;
    (l && l.props.style && l.props.style.display === "contents") ||
      (r &&
        s.options.layoutScroll &&
        s.scroll &&
        s !== s.root &&
        In(e, { x: -s.scroll.offset.x, y: -s.scroll.offset.y }),
      i && ((t.x *= i.x.scale), (t.y *= i.y.scale), Zu(e, i)),
      r && hn(s.latestValues) && In(e, s.latestValues));
  }
  (t.x < rl && t.x > nl && (t.x = 1), t.y < rl && t.y > nl && (t.y = 1));
}
function On(e, t) {
  ((e.min = e.min + t), (e.max = e.max + t));
}
function ol(e, t, n, r, o = 0.5) {
  const s = Fe(e.min, e.max, o);
  Ys(e, t, n, s, r);
}
function In(e, t) {
  (ol(e.x, t.x, t.scaleX, t.scale, t.originX), ol(e.y, t.y, t.scaleY, t.scale, t.originY));
}
function Ju(e, t) {
  return Ku(Wg(e.getBoundingClientRect(), t));
}
function Hg(e, t, n) {
  const r = Ju(e, n),
    { scroll: o } = t;
  return (o && (On(r.x, o.offset.x), On(r.y, o.offset.y)), r);
}
const Ug = {
    x: "translateX",
    y: "translateY",
    z: "translateZ",
    transformPerspective: "perspective",
  },
  _g = Qn.length;
function Yg(e, t, n) {
  let r = "",
    o = !0;
  for (let s = 0; s < _g; s++) {
    const i = Qn[s],
      a = e[i];
    if (a === void 0) continue;
    let l = !0;
    if (
      (typeof a == "number"
        ? (l = a === (i.startsWith("scale") ? 1 : 0))
        : (l = parseFloat(a) === 0),
      !l || n)
    ) {
      const c = $u(a, $i[i]);
      if (!l) {
        o = !1;
        const u = Ug[i] || i;
        r += `${u}(${c}) `;
      }
      n && (t[i] = c);
    }
  }
  return ((r = r.trim()), n ? (r = n(t, o ? "" : r)) : o && (r = "none"), r);
}
function _i(e, t, n) {
  const { style: r, vars: o, transformOrigin: s } = e;
  let i = !1,
    a = !1;
  for (const l in t) {
    const c = t[l];
    if (Zn.has(l)) {
      i = !0;
      continue;
    } else if (hu(l)) {
      o[l] = c;
      continue;
    } else {
      const u = $u(c, $i[l]);
      l.startsWith("origin") ? ((a = !0), (s[l] = u)) : (r[l] = u);
    }
  }
  if (
    (t.transform ||
      (i || n ? (r.transform = Yg(t, e.transform, n)) : r.transform && (r.transform = "none")),
    a)
  ) {
    const { originX: l = "50%", originY: c = "50%", originZ: u = 0 } = s;
    r.transformOrigin = `${l} ${c} ${u}`;
  }
}
function ed(e, { style: t, vars: n }, r, o) {
  const s = e.style;
  let i;
  for (i in t) s[i] = t[i];
  o == null || o.applyProjectionStyles(s, r);
  for (i in n) s.setProperty(i, n[i]);
}
function sl(e, t) {
  return t.max === t.min ? 0 : (e / (t.max - t.min)) * 100;
}
const ir = {
    correct: (e, t) => {
      if (!t.target) return e;
      if (typeof e == "string")
        if (se.test(e)) e = parseFloat(e);
        else return e;
      const n = sl(e, t.target.x),
        r = sl(e, t.target.y);
      return `${n}% ${r}%`;
    },
  },
  qg = {
    correct: (e, { treeScale: t, projectionDelta: n }) => {
      const r = e,
        o = Zt.parse(e);
      if (o.length > 5) return r;
      const s = Zt.createTransformer(e),
        i = typeof o[0] != "number" ? 1 : 0,
        a = n.x.scale * t.x,
        l = n.y.scale * t.y;
      ((o[0 + i] /= a), (o[1 + i] /= l));
      const c = Fe(a, l, 0.5);
      return (
        typeof o[2 + i] == "number" && (o[2 + i] /= c),
        typeof o[3 + i] == "number" && (o[3 + i] /= c),
        s(o)
      );
    },
  },
  qs = {
    borderRadius: {
      ...ir,
      applyTo: [
        "borderTopLeftRadius",
        "borderTopRightRadius",
        "borderBottomLeftRadius",
        "borderBottomRightRadius",
      ],
    },
    borderTopLeftRadius: ir,
    borderTopRightRadius: ir,
    borderBottomLeftRadius: ir,
    borderBottomRightRadius: ir,
    boxShadow: qg,
  };
function td(e, { layout: t, layoutId: n }) {
  return (
    Zn.has(e) || e.startsWith("origin") || ((t || n !== void 0) && (!!qs[e] || e === "opacity"))
  );
}
function Yi(e, t, n) {
  var i;
  const r = e.style,
    o = t == null ? void 0 : t.style,
    s = {};
  if (!r) return s;
  for (const a in r)
    (nt(r[a]) ||
      (o && nt(o[a])) ||
      td(a, e) ||
      ((i = n == null ? void 0 : n.getValue(a)) == null ? void 0 : i.liveStyle) !== void 0) &&
      (s[a] = r[a]);
  return s;
}
function Xg(e) {
  return window.getComputedStyle(e);
}
class Gg extends Gu {
  constructor() {
    (super(...arguments), (this.type = "html"), (this.renderInstance = ed));
  }
  readValueFromInstance(t, n) {
    var r;
    if (Zn.has(n)) return (r = this.projection) != null && r.isProjecting ? Ds(n) : Ep(t, n);
    {
      const o = Xg(t),
        s = (hu(n) ? o.getPropertyValue(n) : o[n]) || 0;
      return typeof s == "string" ? s.trim() : s;
    }
  }
  measureInstanceViewportBox(t, { transformPagePoint: n }) {
    return Ju(t, n);
  }
  build(t, n, r) {
    _i(t, n, r.transformTemplate);
  }
  scrapeMotionValuesFromProps(t, n, r) {
    return Yi(t, n, r);
  }
}
const Kg = { offset: "stroke-dashoffset", array: "stroke-dasharray" },
  Qg = { offset: "strokeDashoffset", array: "strokeDasharray" };
function Zg(e, t, n = 1, r = 0, o = !0) {
  e.pathLength = 1;
  const s = o ? Kg : Qg;
  ((e[s.offset] = `${-r}`), (e[s.array] = `${t} ${n}`));
}
const Jg = ["offsetDistance", "offsetPath", "offsetRotate", "offsetAnchor"];
function nd(
  e,
  { attrX: t, attrY: n, attrScale: r, pathLength: o, pathSpacing: s = 1, pathOffset: i = 0, ...a },
  l,
  c,
  u,
) {
  if ((_i(e, a, c), l)) {
    e.style.viewBox && (e.attrs.viewBox = e.style.viewBox);
    return;
  }
  ((e.attrs = e.style), (e.style = {}));
  const { attrs: d, style: f } = e;
  (d.transform && ((f.transform = d.transform), delete d.transform),
    (f.transform || d.transformOrigin) &&
      ((f.transformOrigin = d.transformOrigin ?? "50% 50%"), delete d.transformOrigin),
    f.transform &&
      ((f.transformBox = (u == null ? void 0 : u.transformBox) ?? "fill-box"),
      delete d.transformBox));
  for (const m of Jg) d[m] !== void 0 && ((f[m] = d[m]), delete d[m]);
  (t !== void 0 && (d.x = t),
    n !== void 0 && (d.y = n),
    r !== void 0 && (d.scale = r),
    o !== void 0 && Zg(d, o, s, i, !1));
}
const rd = new Set([
    "baseFrequency",
    "diffuseConstant",
    "kernelMatrix",
    "kernelUnitLength",
    "keySplines",
    "keyTimes",
    "limitingConeAngle",
    "markerHeight",
    "markerWidth",
    "numOctaves",
    "targetX",
    "targetY",
    "surfaceScale",
    "specularConstant",
    "specularExponent",
    "stdDeviation",
    "tableValues",
    "viewBox",
    "gradientTransform",
    "pathLength",
    "startOffset",
    "textLength",
    "lengthAdjust",
  ]),
  od = (e) => typeof e == "string" && e.toLowerCase() === "svg";
function eb(e, t, n, r) {
  ed(e, t, void 0, r);
  for (const o in t.attrs) e.setAttribute(rd.has(o) ? o : Bi(o), t.attrs[o]);
}
function sd(e, t, n) {
  const r = Yi(e, t, n);
  for (const o in e)
    if (nt(e[o]) || nt(t[o])) {
      const s = Qn.indexOf(o) !== -1 ? "attr" + o.charAt(0).toUpperCase() + o.substring(1) : o;
      r[s] = e[o];
    }
  return r;
}
class tb extends Gu {
  constructor() {
    (super(...arguments),
      (this.type = "svg"),
      (this.isSVGTag = !1),
      (this.measureInstanceViewportBox = Xe));
  }
  getBaseTargetFromProps(t, n) {
    return t[n];
  }
  readValueFromInstance(t, n) {
    if (Zn.has(n)) {
      const r = Vu(n);
      return (r && r.default) || 0;
    }
    return ((n = rd.has(n) ? n : Bi(n)), t.getAttribute(n));
  }
  scrapeMotionValuesFromProps(t, n, r) {
    return sd(t, n, r);
  }
  build(t, n, r) {
    nd(t, n, this.isSVGTag, r.transformTemplate, r.style);
  }
  renderInstance(t, n, r, o) {
    eb(t, n, r, o);
  }
  mount(t) {
    ((this.isSVGTag = od(t.tagName)), super.mount(t));
  }
}
const nb = Ui.length;
function id(e) {
  if (!e) return;
  if (!e.isControllingVariants) {
    const n = e.parent ? id(e.parent) || {} : {};
    return (e.props.initial !== void 0 && (n.initial = e.props.initial), n);
  }
  const t = {};
  for (let n = 0; n < nb; n++) {
    const r = Ui[n],
      o = e.props[r];
    (Tr(o) || o === !1) && (t[r] = o);
  }
  return t;
}
function ad(e, t) {
  if (!Array.isArray(t)) return !1;
  const n = t.length;
  if (n !== e.length) return !1;
  for (let r = 0; r < n; r++) if (t[r] !== e[r]) return !1;
  return !0;
}
const rb = [...Hi].reverse(),
  ob = Hi.length;
function sb(e) {
  return (t) => Promise.all(t.map(({ animation: n, options: r }) => mg(e, n, r)));
}
function ib(e) {
  let t = sb(e),
    n = il(),
    r = !0;
  const o = (l) => (c, u) => {
    var f;
    const d = Nn(
      e,
      u,
      l === "exit" ? ((f = e.presenceContext) == null ? void 0 : f.custom) : void 0,
    );
    if (d) {
      const { transition: m, transitionEnd: g, ...p } = d;
      c = { ...c, ...p, ...g };
    }
    return c;
  };
  function s(l) {
    t = l(e);
  }
  function i(l) {
    const { props: c } = e,
      u = id(e.parent) || {},
      d = [],
      f = new Set();
    let m = {},
      g = 1 / 0;
    for (let v = 0; v < ob; v++) {
      const b = rb[v],
        y = n[b],
        w = c[b] !== void 0 ? c[b] : u[b],
        R = Tr(w),
        x = b === l ? y.isActive : null;
      x === !1 && (g = v);
      let A = w === u[b] && w !== c[b] && R;
      if (
        (A && r && e.manuallyAnimateOnMount && (A = !1),
        (y.protectedKeys = { ...m }),
        (!y.isActive && x === null) || (!w && !y.prevProp) || Fo(w) || typeof w == "boolean")
      )
        continue;
      const I = ab(y.prevProp, w);
      let P = I || (b === l && y.isActive && !A && R) || (v > g && R),
        D = !1;
      const V = Array.isArray(w) ? w : [w];
      let B = V.reduce(o(b), {});
      x === !1 && (B = {});
      const { prevResolvedValues: M = {} } = y,
        C = { ...M, ...B },
        L = (E) => {
          ((P = !0), f.has(E) && ((D = !0), f.delete(E)), (y.needsAnimating[E] = !0));
          const S = e.getValue(E);
          S && (S.liveStyle = !1);
        };
      for (const E in C) {
        const S = B[E],
          O = M[E];
        if (m.hasOwnProperty(E)) continue;
        let j = !1;
        (Bs(S) && Bs(O) ? (j = !ad(S, O)) : (j = S !== O),
          j
            ? S != null
              ? L(E)
              : f.add(E)
            : S !== void 0 && f.has(E)
              ? L(E)
              : (y.protectedKeys[E] = !0));
      }
      ((y.prevProp = w),
        (y.prevResolvedValues = B),
        y.isActive && (m = { ...m, ...B }),
        r && e.blockInitialAnimation && (P = !1));
      const k = A && I;
      P &&
        (!k || D) &&
        d.push(
          ...V.map((E) => {
            const S = { type: b };
            if (typeof E == "string" && r && !k && e.manuallyAnimateOnMount && e.parent) {
              const { parent: O } = e,
                j = Nn(O, E);
              if (O.enteringChildren && j) {
                const { delayChildren: _ } = j.transition || {};
                S.delay = Au(O.enteringChildren, e, _);
              }
            }
            return { animation: E, options: S };
          }),
        );
    }
    if (f.size) {
      const v = {};
      if (typeof c.initial != "boolean") {
        const b = Nn(e, Array.isArray(c.initial) ? c.initial[0] : c.initial);
        b && b.transition && (v.transition = b.transition);
      }
      (f.forEach((b) => {
        const y = e.getBaseTarget(b),
          w = e.getValue(b);
        (w && (w.liveStyle = !0), (v[b] = y ?? null));
      }),
        d.push({ animation: v }));
    }
    let p = !!d.length;
    return (
      r && (c.initial === !1 || c.initial === c.animate) && !e.manuallyAnimateOnMount && (p = !1),
      (r = !1),
      p ? t(d) : Promise.resolve()
    );
  }
  function a(l, c) {
    var d;
    if (n[l].isActive === c) return Promise.resolve();
    ((d = e.variantChildren) == null ||
      d.forEach((f) => {
        var m;
        return (m = f.animationState) == null ? void 0 : m.setActive(l, c);
      }),
      (n[l].isActive = c));
    const u = i(l);
    for (const f in n) n[f].protectedKeys = {};
    return u;
  }
  return {
    animateChanges: i,
    setActive: a,
    setAnimateFunction: s,
    getState: () => n,
    reset: () => {
      n = il();
    },
  };
}
function ab(e, t) {
  return typeof t == "string" ? t !== e : Array.isArray(t) ? !ad(t, e) : !1;
}
function cn(e = !1) {
  return { isActive: e, protectedKeys: {}, needsAnimating: {}, prevResolvedValues: {} };
}
function il() {
  return {
    animate: cn(!0),
    whileInView: cn(),
    whileHover: cn(),
    whileTap: cn(),
    whileDrag: cn(),
    whileFocus: cn(),
    exit: cn(),
  };
}
function al(e, t) {
  ((e.min = t.min), (e.max = t.max));
}
function vt(e, t) {
  (al(e.x, t.x), al(e.y, t.y));
}
function ll(e, t) {
  ((e.translate = t.translate),
    (e.scale = t.scale),
    (e.originPoint = t.originPoint),
    (e.origin = t.origin));
}
const ld = 1e-4,
  lb = 1 - ld,
  cb = 1 + ld,
  cd = 0.01,
  ub = 0 - cd,
  db = 0 + cd;
function st(e) {
  return e.max - e.min;
}
function fb(e, t, n) {
  return Math.abs(e - t) <= n;
}
function cl(e, t, n, r = 0.5) {
  ((e.origin = r),
    (e.originPoint = Fe(t.min, t.max, e.origin)),
    (e.scale = st(n) / st(t)),
    (e.translate = Fe(n.min, n.max, e.origin) - e.originPoint),
    ((e.scale >= lb && e.scale <= cb) || isNaN(e.scale)) && (e.scale = 1),
    ((e.translate >= ub && e.translate <= db) || isNaN(e.translate)) && (e.translate = 0));
}
function pr(e, t, n, r) {
  (cl(e.x, t.x, n.x, r ? r.originX : void 0), cl(e.y, t.y, n.y, r ? r.originY : void 0));
}
function ul(e, t, n) {
  ((e.min = n.min + t.min), (e.max = e.min + st(t)));
}
function hb(e, t, n) {
  (ul(e.x, t.x, n.x), ul(e.y, t.y, n.y));
}
function dl(e, t, n) {
  ((e.min = t.min - n.min), (e.max = e.min + st(t)));
}
function xo(e, t, n) {
  (dl(e.x, t.x, n.x), dl(e.y, t.y, n.y));
}
function fl(e, t, n, r, o) {
  return ((e -= t), (e = yo(e, 1 / n, r)), o !== void 0 && (e = yo(e, 1 / o, r)), e);
}
function mb(e, t = 0, n = 1, r = 0.5, o, s = e, i = e) {
  if (
    (Ct.test(t) && ((t = parseFloat(t)), (t = Fe(i.min, i.max, t / 100) - i.min)),
    typeof t != "number")
  )
    return;
  let a = Fe(s.min, s.max, r);
  (e === s && (a -= t), (e.min = fl(e.min, t, n, a, o)), (e.max = fl(e.max, t, n, a, o)));
}
function hl(e, t, [n, r, o], s, i) {
  mb(e, t[n], t[r], t[o], t.scale, s, i);
}
const pb = ["x", "scaleX", "originX"],
  gb = ["y", "scaleY", "originY"];
function ml(e, t, n, r) {
  (hl(e.x, t, pb, n ? n.x : void 0, r ? r.x : void 0),
    hl(e.y, t, gb, n ? n.y : void 0, r ? r.y : void 0));
}
function pl(e) {
  return e.translate === 0 && e.scale === 1;
}
function ud(e) {
  return pl(e.x) && pl(e.y);
}
function gl(e, t) {
  return e.min === t.min && e.max === t.max;
}
function bb(e, t) {
  return gl(e.x, t.x) && gl(e.y, t.y);
}
function bl(e, t) {
  return Math.round(e.min) === Math.round(t.min) && Math.round(e.max) === Math.round(t.max);
}
function dd(e, t) {
  return bl(e.x, t.x) && bl(e.y, t.y);
}
function yl(e) {
  return st(e.x) / st(e.y);
}
function xl(e, t) {
  return e.translate === t.translate && e.scale === t.scale && e.originPoint === t.originPoint;
}
function mt(e) {
  return [e("x"), e("y")];
}
function yb(e, t, n) {
  let r = "";
  const o = e.x.translate / t.x,
    s = e.y.translate / t.y,
    i = (n == null ? void 0 : n.z) || 0;
  if (
    ((o || s || i) && (r = `translate3d(${o}px, ${s}px, ${i}px) `),
    (t.x !== 1 || t.y !== 1) && (r += `scale(${1 / t.x}, ${1 / t.y}) `),
    n)
  ) {
    const { transformPerspective: c, rotate: u, rotateX: d, rotateY: f, skewX: m, skewY: g } = n;
    (c && (r = `perspective(${c}px) ${r}`),
      u && (r += `rotate(${u}deg) `),
      d && (r += `rotateX(${d}deg) `),
      f && (r += `rotateY(${f}deg) `),
      m && (r += `skewX(${m}deg) `),
      g && (r += `skewY(${g}deg) `));
  }
  const a = e.x.scale * t.x,
    l = e.y.scale * t.y;
  return ((a !== 1 || l !== 1) && (r += `scale(${a}, ${l})`), r || "none");
}
const fd = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"],
  xb = fd.length,
  vl = (e) => (typeof e == "string" ? parseFloat(e) : e),
  wl = (e) => typeof e == "number" || se.test(e);
function vb(e, t, n, r, o, s) {
  o
    ? ((e.opacity = Fe(0, n.opacity ?? 1, wb(r))), (e.opacityExit = Fe(t.opacity ?? 1, 0, Sb(r))))
    : s && (e.opacity = Fe(t.opacity ?? 1, n.opacity ?? 1, r));
  for (let i = 0; i < xb; i++) {
    const a = `border${fd[i]}Radius`;
    let l = Sl(t, a),
      c = Sl(n, a);
    if (l === void 0 && c === void 0) continue;
    (l || (l = 0),
      c || (c = 0),
      l === 0 || c === 0 || wl(l) === wl(c)
        ? ((e[a] = Math.max(Fe(vl(l), vl(c), r), 0)), (Ct.test(c) || Ct.test(l)) && (e[a] += "%"))
        : (e[a] = c));
  }
  (t.rotate || n.rotate) && (e.rotate = Fe(t.rotate || 0, n.rotate || 0, r));
}
function Sl(e, t) {
  return e[t] !== void 0 ? e[t] : e.borderRadius;
}
const wb = hd(0, 0.5, au),
  Sb = hd(0.5, 0.95, yt);
function hd(e, t, n) {
  return (r) => (r < e ? 0 : r > t ? 1 : n(vr(e, t, r)));
}
function Tb(e, t, n) {
  const r = nt(e) ? e : zn(e);
  return (r.start(ji("", r, t, n)), r.animation);
}
function Rr(e, t, n, r = { passive: !0 }) {
  return (e.addEventListener(t, n, r), () => e.removeEventListener(t, n));
}
const Rb = (e, t) => e.depth - t.depth;
class Eb {
  constructor() {
    ((this.children = []), (this.isDirty = !1));
  }
  add(t) {
    (vi(this.children, t), (this.isDirty = !0));
  }
  remove(t) {
    (wi(this.children, t), (this.isDirty = !0));
  }
  forEach(t) {
    (this.isDirty && this.children.sort(Rb), (this.isDirty = !1), this.children.forEach(t));
  }
}
function Cb(e, t) {
  const n = ot.now(),
    r = ({ timestamp: o }) => {
      const s = o - n;
      s >= t && (Qt(r), e(s - t));
    };
  return (De.setup(r, !0), () => Qt(r));
}
function oo(e) {
  return nt(e) ? e.get() : e;
}
class Pb {
  constructor() {
    this.members = [];
  }
  add(t) {
    (vi(this.members, t), t.scheduleRender());
  }
  remove(t) {
    if ((wi(this.members, t), t === this.prevLead && (this.prevLead = void 0), t === this.lead)) {
      const n = this.members[this.members.length - 1];
      n && this.promote(n);
    }
  }
  relegate(t) {
    const n = this.members.findIndex((o) => t === o);
    if (n === 0) return !1;
    let r;
    for (let o = n; o >= 0; o--) {
      const s = this.members[o];
      if (s.isPresent !== !1) {
        r = s;
        break;
      }
    }
    return r ? (this.promote(r), !0) : !1;
  }
  promote(t, n) {
    const r = this.lead;
    if (t !== r && ((this.prevLead = r), (this.lead = t), t.show(), r)) {
      (r.instance && r.scheduleRender(),
        t.scheduleRender(),
        (t.resumeFrom = r),
        n && (t.resumeFrom.preserveOpacity = !0),
        r.snapshot &&
          ((t.snapshot = r.snapshot),
          (t.snapshot.latestValues = r.animationValues || r.latestValues)),
        t.root && t.root.isUpdating && (t.isLayoutDirty = !0));
      const { crossfade: o } = t.options;
      o === !1 && r.hide();
    }
  }
  exitAnimationComplete() {
    this.members.forEach((t) => {
      const { options: n, resumingFrom: r } = t;
      (n.onExitComplete && n.onExitComplete(),
        r && r.options.onExitComplete && r.options.onExitComplete());
    });
  }
  scheduleRender() {
    this.members.forEach((t) => {
      t.instance && t.scheduleRender(!1);
    });
  }
  removeLeadSnapshot() {
    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
  }
}
const so = { hasAnimatedSinceResize: !0, hasEverUpdated: !1 },
  is = ["", "X", "Y", "Z"],
  kb = 1e3;
let Mb = 0;
function as(e, t, n, r) {
  const { latestValues: o } = t;
  o[e] && ((n[e] = o[e]), t.setStaticValue(e, 0), r && (r[e] = 0));
}
function md(e) {
  if (((e.hasCheckedOptimisedAppear = !0), e.root === e)) return;
  const { visualElement: t } = e.options;
  if (!t) return;
  const n = Nu(t);
  if (window.MotionHasOptimisedAnimation(n, "transform")) {
    const { layout: o, layoutId: s } = e.options;
    window.MotionCancelOptimisedAnimation(n, "transform", De, !(o || s));
  }
  const { parent: r } = e;
  r && !r.hasCheckedOptimisedAppear && md(r);
}
function pd({
  attachResizeListener: e,
  defaultParent: t,
  measureScroll: n,
  checkIsScrollRoot: r,
  resetTransform: o,
}) {
  return class {
    constructor(i = {}, a = t == null ? void 0 : t()) {
      ((this.id = Mb++),
        (this.animationId = 0),
        (this.animationCommitId = 0),
        (this.children = new Set()),
        (this.options = {}),
        (this.isTreeAnimating = !1),
        (this.isAnimationBlocked = !1),
        (this.isLayoutDirty = !1),
        (this.isProjectionDirty = !1),
        (this.isSharedProjectionDirty = !1),
        (this.isTransformDirty = !1),
        (this.updateManuallyBlocked = !1),
        (this.updateBlockedByResize = !1),
        (this.isUpdating = !1),
        (this.isSVG = !1),
        (this.needsReset = !1),
        (this.shouldResetTransform = !1),
        (this.hasCheckedOptimisedAppear = !1),
        (this.treeScale = { x: 1, y: 1 }),
        (this.eventHandlers = new Map()),
        (this.hasTreeAnimated = !1),
        (this.layoutVersion = 0),
        (this.updateScheduled = !1),
        (this.scheduleUpdate = () => this.update()),
        (this.projectionUpdateScheduled = !1),
        (this.checkUpdateFailed = () => {
          this.isUpdating && ((this.isUpdating = !1), this.clearAllSnapshots());
        }),
        (this.updateProjection = () => {
          ((this.projectionUpdateScheduled = !1),
            this.nodes.forEach(Ib),
            this.nodes.forEach(Lb),
            this.nodes.forEach(jb),
            this.nodes.forEach(Db));
        }),
        (this.resolvedRelativeTargetAt = 0),
        (this.linkedParentVersion = 0),
        (this.hasProjected = !1),
        (this.isVisible = !0),
        (this.animationProgress = 0),
        (this.sharedNodes = new Map()),
        (this.latestValues = i),
        (this.root = a ? a.root || a : this),
        (this.path = a ? [...a.path, a] : []),
        (this.parent = a),
        (this.depth = a ? a.depth + 1 : 0));
      for (let l = 0; l < this.path.length; l++) this.path[l].shouldResetTransform = !0;
      this.root === this && (this.nodes = new Eb());
    }
    addEventListener(i, a) {
      return (
        this.eventHandlers.has(i) || this.eventHandlers.set(i, new Ri()),
        this.eventHandlers.get(i).add(a)
      );
    }
    notifyListeners(i, ...a) {
      const l = this.eventHandlers.get(i);
      l && l.notify(...a);
    }
    hasListeners(i) {
      return this.eventHandlers.has(i);
    }
    mount(i) {
      if (this.instance) return;
      ((this.isSVG = _u(i) && !Og(i)), (this.instance = i));
      const { layoutId: a, layout: l, visualElement: c } = this.options;
      if (
        (c && !c.current && c.mount(i),
        this.root.nodes.add(this),
        this.parent && this.parent.children.add(this),
        this.root.hasTreeAnimated && (l || a) && (this.isLayoutDirty = !0),
        e)
      ) {
        let u,
          d = 0;
        const f = () => (this.root.updateBlockedByResize = !1);
        (De.read(() => {
          d = window.innerWidth;
        }),
          e(i, () => {
            const m = window.innerWidth;
            m !== d &&
              ((d = m),
              (this.root.updateBlockedByResize = !0),
              u && u(),
              (u = Cb(f, 250)),
              so.hasAnimatedSinceResize &&
                ((so.hasAnimatedSinceResize = !1), this.nodes.forEach(El)));
          }));
      }
      (a && this.root.registerSharedNode(a, this),
        this.options.animate !== !1 &&
          c &&
          (a || l) &&
          this.addEventListener(
            "didUpdate",
            ({ delta: u, hasLayoutChanged: d, hasRelativeLayoutChanged: f, layout: m }) => {
              if (this.isTreeAnimationBlocked()) {
                ((this.target = void 0), (this.relativeTarget = void 0));
                return;
              }
              const g = this.options.transition || c.getDefaultTransition() || zb,
                { onLayoutAnimationStart: p, onLayoutAnimationComplete: v } = c.getProps(),
                b = !this.targetLayout || !dd(this.targetLayout, m),
                y = !d && f;
              if (
                this.options.layoutRoot ||
                this.resumeFrom ||
                y ||
                (d && (b || !this.currentAnimation))
              ) {
                this.resumeFrom &&
                  ((this.resumingFrom = this.resumeFrom),
                  (this.resumingFrom.resumingFrom = void 0));
                const w = { ...Li(g, "layout"), onPlay: p, onComplete: v };
                ((c.shouldReduceMotion || this.options.layoutRoot) &&
                  ((w.delay = 0), (w.type = !1)),
                  this.startAnimation(w),
                  this.setAnimationOrigin(u, y));
              } else
                (d || El(this),
                  this.isLead() && this.options.onExitComplete && this.options.onExitComplete());
              this.targetLayout = m;
            },
          ));
    }
    unmount() {
      (this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this));
      const i = this.getStack();
      (i && i.remove(this),
        this.parent && this.parent.children.delete(this),
        (this.instance = void 0),
        this.eventHandlers.clear(),
        Qt(this.updateProjection));
    }
    blockUpdate() {
      this.updateManuallyBlocked = !0;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || (this.parent && this.parent.isTreeAnimationBlocked()) || !1;
    }
    startUpdate() {
      this.isUpdateBlocked() ||
        ((this.isUpdating = !0), this.nodes && this.nodes.forEach(Vb), this.animationId++);
    }
    getTransformTemplate() {
      const { visualElement: i } = this.options;
      return i && i.getProps().transformTemplate;
    }
    willUpdate(i = !0) {
      if (((this.root.hasTreeAnimated = !0), this.root.isUpdateBlocked())) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (
        (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && md(this),
        !this.root.isUpdating && this.root.startUpdate(),
        this.isLayoutDirty)
      )
        return;
      this.isLayoutDirty = !0;
      for (let u = 0; u < this.path.length; u++) {
        const d = this.path[u];
        ((d.shouldResetTransform = !0),
          d.updateScroll("snapshot"),
          d.options.layoutRoot && d.willUpdate(!1));
      }
      const { layoutId: a, layout: l } = this.options;
      if (a === void 0 && !l) return;
      const c = this.getTransformTemplate();
      ((this.prevTransformTemplateValue = c ? c(this.latestValues, "") : void 0),
        this.updateSnapshot(),
        i && this.notifyListeners("willUpdate"));
    }
    update() {
      if (((this.updateScheduled = !1), this.isUpdateBlocked())) {
        (this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(Tl));
        return;
      }
      if (this.animationId <= this.animationCommitId) {
        this.nodes.forEach(Rl);
        return;
      }
      ((this.animationCommitId = this.animationId),
        this.isUpdating
          ? ((this.isUpdating = !1),
            this.nodes.forEach(Fb),
            this.nodes.forEach(Ab),
            this.nodes.forEach(Ob))
          : this.nodes.forEach(Rl),
        this.clearAllSnapshots());
      const a = ot.now();
      ((Qe.delta = Mt(0, 1e3 / 60, a - Qe.timestamp)),
        (Qe.timestamp = a),
        (Qe.isProcessing = !0),
        Zo.update.process(Qe),
        Zo.preRender.process(Qe),
        Zo.render.process(Qe),
        (Qe.isProcessing = !1));
    }
    didUpdate() {
      this.updateScheduled || ((this.updateScheduled = !0), Wi.read(this.scheduleUpdate));
    }
    clearAllSnapshots() {
      (this.nodes.forEach(Nb), this.sharedNodes.forEach(Bb));
    }
    scheduleUpdateProjection() {
      this.projectionUpdateScheduled ||
        ((this.projectionUpdateScheduled = !0), De.preRender(this.updateProjection, !1, !0));
    }
    scheduleCheckAfterUnmount() {
      De.postRender(() => {
        this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed();
      });
    }
    updateSnapshot() {
      this.snapshot ||
        !this.instance ||
        ((this.snapshot = this.measure()),
        this.snapshot &&
          !st(this.snapshot.measuredBox.x) &&
          !st(this.snapshot.measuredBox.y) &&
          (this.snapshot = void 0));
    }
    updateLayout() {
      if (
        !this.instance ||
        (this.updateScroll(),
        !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty)
      )
        return;
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let l = 0; l < this.path.length; l++) this.path[l].updateScroll();
      const i = this.layout;
      ((this.layout = this.measure(!1)),
        this.layoutVersion++,
        (this.layoutCorrected = Xe()),
        (this.isLayoutDirty = !1),
        (this.projectionDelta = void 0),
        this.notifyListeners("measure", this.layout.layoutBox));
      const { visualElement: a } = this.options;
      a && a.notify("LayoutMeasure", this.layout.layoutBox, i ? i.layoutBox : void 0);
    }
    updateScroll(i = "measure") {
      let a = !!(this.options.layoutScroll && this.instance);
      if (
        (this.scroll &&
          this.scroll.animationId === this.root.animationId &&
          this.scroll.phase === i &&
          (a = !1),
        a && this.instance)
      ) {
        const l = r(this.instance);
        this.scroll = {
          animationId: this.root.animationId,
          phase: i,
          isRoot: l,
          offset: n(this.instance),
          wasRoot: this.scroll ? this.scroll.isRoot : l,
        };
      }
    }
    resetTransform() {
      if (!o) return;
      const i = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout,
        a = this.projectionDelta && !ud(this.projectionDelta),
        l = this.getTransformTemplate(),
        c = l ? l(this.latestValues, "") : void 0,
        u = c !== this.prevTransformTemplateValue;
      i &&
        this.instance &&
        (a || hn(this.latestValues) || u) &&
        (o(this.instance, c), (this.shouldResetTransform = !1), this.scheduleRender());
    }
    measure(i = !0) {
      const a = this.measurePageBox();
      let l = this.removeElementScroll(a);
      return (
        i && (l = this.removeTransform(l)),
        Hb(l),
        {
          animationId: this.root.animationId,
          measuredBox: a,
          layoutBox: l,
          latestValues: {},
          source: this.id,
        }
      );
    }
    measurePageBox() {
      var c;
      const { visualElement: i } = this.options;
      if (!i) return Xe();
      const a = i.measureViewportBox();
      if (!(((c = this.scroll) == null ? void 0 : c.wasRoot) || this.path.some(Ub))) {
        const { scroll: u } = this.root;
        u && (On(a.x, u.offset.x), On(a.y, u.offset.y));
      }
      return a;
    }
    removeElementScroll(i) {
      var l;
      const a = Xe();
      if ((vt(a, i), (l = this.scroll) != null && l.wasRoot)) return a;
      for (let c = 0; c < this.path.length; c++) {
        const u = this.path[c],
          { scroll: d, options: f } = u;
        u !== this.root &&
          d &&
          f.layoutScroll &&
          (d.wasRoot && vt(a, i), On(a.x, d.offset.x), On(a.y, d.offset.y));
      }
      return a;
    }
    applyTransform(i, a = !1) {
      const l = Xe();
      vt(l, i);
      for (let c = 0; c < this.path.length; c++) {
        const u = this.path[c];
        (!a &&
          u.options.layoutScroll &&
          u.scroll &&
          u !== u.root &&
          In(l, { x: -u.scroll.offset.x, y: -u.scroll.offset.y }),
          hn(u.latestValues) && In(l, u.latestValues));
      }
      return (hn(this.latestValues) && In(l, this.latestValues), l);
    }
    removeTransform(i) {
      const a = Xe();
      vt(a, i);
      for (let l = 0; l < this.path.length; l++) {
        const c = this.path[l];
        if (!c.instance || !hn(c.latestValues)) continue;
        _s(c.latestValues) && c.updateSnapshot();
        const u = Xe(),
          d = c.measurePageBox();
        (vt(u, d), ml(a, c.latestValues, c.snapshot ? c.snapshot.layoutBox : void 0, u));
      }
      return (hn(this.latestValues) && ml(a, this.latestValues), a);
    }
    setTargetDelta(i) {
      ((this.targetDelta = i), this.root.scheduleUpdateProjection(), (this.isProjectionDirty = !0));
    }
    setOptions(i) {
      this.options = {
        ...this.options,
        ...i,
        crossfade: i.crossfade !== void 0 ? i.crossfade : !0,
      };
    }
    clearMeasurements() {
      ((this.scroll = void 0),
        (this.layout = void 0),
        (this.snapshot = void 0),
        (this.prevTransformTemplateValue = void 0),
        (this.targetDelta = void 0),
        (this.target = void 0),
        (this.isLayoutDirty = !1));
    }
    forceRelativeParentToResolveTarget() {
      this.relativeParent &&
        this.relativeParent.resolvedRelativeTargetAt !== Qe.timestamp &&
        this.relativeParent.resolveTargetDelta(!0);
    }
    resolveTargetDelta(i = !1) {
      var m;
      const a = this.getLead();
      (this.isProjectionDirty || (this.isProjectionDirty = a.isProjectionDirty),
        this.isTransformDirty || (this.isTransformDirty = a.isTransformDirty),
        this.isSharedProjectionDirty || (this.isSharedProjectionDirty = a.isSharedProjectionDirty));
      const l = !!this.resumingFrom || this !== a;
      if (
        !(
          i ||
          (l && this.isSharedProjectionDirty) ||
          this.isProjectionDirty ||
          ((m = this.parent) != null && m.isProjectionDirty) ||
          this.attemptToResolveRelativeTarget ||
          this.root.updateBlockedByResize
        )
      )
        return;
      const { layout: u, layoutId: d } = this.options;
      if (!this.layout || !(u || d)) return;
      this.resolvedRelativeTargetAt = Qe.timestamp;
      const f = this.getClosestProjectingParent();
      (f &&
        this.linkedParentVersion !== f.layoutVersion &&
        !f.options.layoutRoot &&
        this.removeRelativeTarget(),
        !this.targetDelta &&
          !this.relativeTarget &&
          (f && f.layout
            ? this.createRelativeTarget(f, this.layout.layoutBox, f.layout.layoutBox)
            : this.removeRelativeTarget()),
        !(!this.relativeTarget && !this.targetDelta) &&
          (this.target || ((this.target = Xe()), (this.targetWithTransforms = Xe())),
          this.relativeTarget &&
          this.relativeTargetOrigin &&
          this.relativeParent &&
          this.relativeParent.target
            ? (this.forceRelativeParentToResolveTarget(),
              hb(this.target, this.relativeTarget, this.relativeParent.target))
            : this.targetDelta
              ? (this.resumingFrom
                  ? (this.target = this.applyTransform(this.layout.layoutBox))
                  : vt(this.target, this.layout.layoutBox),
                Zu(this.target, this.targetDelta))
              : vt(this.target, this.layout.layoutBox),
          this.attemptToResolveRelativeTarget &&
            ((this.attemptToResolveRelativeTarget = !1),
            f &&
            !!f.resumingFrom == !!this.resumingFrom &&
            !f.options.layoutScroll &&
            f.target &&
            this.animationProgress !== 1
              ? this.createRelativeTarget(f, this.target, f.target)
              : (this.relativeParent = this.relativeTarget = void 0))));
    }
    getClosestProjectingParent() {
      if (!(!this.parent || _s(this.parent.latestValues) || Qu(this.parent.latestValues)))
        return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent();
    }
    isProjecting() {
      return !!(
        (this.relativeTarget || this.targetDelta || this.options.layoutRoot) &&
        this.layout
      );
    }
    createRelativeTarget(i, a, l) {
      ((this.relativeParent = i),
        (this.linkedParentVersion = i.layoutVersion),
        this.forceRelativeParentToResolveTarget(),
        (this.relativeTarget = Xe()),
        (this.relativeTargetOrigin = Xe()),
        xo(this.relativeTargetOrigin, a, l),
        vt(this.relativeTarget, this.relativeTargetOrigin));
    }
    removeRelativeTarget() {
      this.relativeParent = this.relativeTarget = void 0;
    }
    calcProjection() {
      var g;
      const i = this.getLead(),
        a = !!this.resumingFrom || this !== i;
      let l = !0;
      if (
        ((this.isProjectionDirty || ((g = this.parent) != null && g.isProjectionDirty)) && (l = !1),
        a && (this.isSharedProjectionDirty || this.isTransformDirty) && (l = !1),
        this.resolvedRelativeTargetAt === Qe.timestamp && (l = !1),
        l)
      )
        return;
      const { layout: c, layoutId: u } = this.options;
      if (
        ((this.isTreeAnimating = !!(
          (this.parent && this.parent.isTreeAnimating) ||
          this.currentAnimation ||
          this.pendingAnimation
        )),
        this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0),
        !this.layout || !(c || u))
      )
        return;
      vt(this.layoutCorrected, this.layout.layoutBox);
      const d = this.treeScale.x,
        f = this.treeScale.y;
      (zg(this.layoutCorrected, this.treeScale, this.path, a),
        i.layout &&
          !i.target &&
          (this.treeScale.x !== 1 || this.treeScale.y !== 1) &&
          ((i.target = i.layout.layoutBox), (i.targetWithTransforms = Xe())));
      const { target: m } = i;
      if (!m) {
        this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender());
        return;
      }
      (!this.projectionDelta || !this.prevProjectionDelta
        ? this.createProjectionDeltas()
        : (ll(this.prevProjectionDelta.x, this.projectionDelta.x),
          ll(this.prevProjectionDelta.y, this.projectionDelta.y)),
        pr(this.projectionDelta, this.layoutCorrected, m, this.latestValues),
        (this.treeScale.x !== d ||
          this.treeScale.y !== f ||
          !xl(this.projectionDelta.x, this.prevProjectionDelta.x) ||
          !xl(this.projectionDelta.y, this.prevProjectionDelta.y)) &&
          ((this.hasProjected = !0),
          this.scheduleRender(),
          this.notifyListeners("projectionUpdate", m)));
    }
    hide() {
      this.isVisible = !1;
    }
    show() {
      this.isVisible = !0;
    }
    scheduleRender(i = !0) {
      var a;
      if (((a = this.options.visualElement) == null || a.scheduleRender(), i)) {
        const l = this.getStack();
        l && l.scheduleRender();
      }
      this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0);
    }
    createProjectionDeltas() {
      ((this.prevProjectionDelta = An()),
        (this.projectionDelta = An()),
        (this.projectionDeltaWithTransform = An()));
    }
    setAnimationOrigin(i, a = !1) {
      const l = this.snapshot,
        c = l ? l.latestValues : {},
        u = { ...this.latestValues },
        d = An();
      ((!this.relativeParent || !this.relativeParent.options.layoutRoot) &&
        (this.relativeTarget = this.relativeTargetOrigin = void 0),
        (this.attemptToResolveRelativeTarget = !a));
      const f = Xe(),
        m = l ? l.source : void 0,
        g = this.layout ? this.layout.source : void 0,
        p = m !== g,
        v = this.getStack(),
        b = !v || v.members.length <= 1,
        y = !!(p && !b && this.options.crossfade === !0 && !this.path.some(Wb));
      this.animationProgress = 0;
      let w;
      ((this.mixTargetDelta = (R) => {
        const x = R / 1e3;
        (Cl(d.x, i.x, x),
          Cl(d.y, i.y, x),
          this.setTargetDelta(d),
          this.relativeTarget &&
            this.relativeTargetOrigin &&
            this.layout &&
            this.relativeParent &&
            this.relativeParent.layout &&
            (xo(f, this.layout.layoutBox, this.relativeParent.layout.layoutBox),
            $b(this.relativeTarget, this.relativeTargetOrigin, f, x),
            w && bb(this.relativeTarget, w) && (this.isProjectionDirty = !1),
            w || (w = Xe()),
            vt(w, this.relativeTarget)),
          p && ((this.animationValues = u), vb(u, c, this.latestValues, x, y, b)),
          this.root.scheduleUpdateProjection(),
          this.scheduleRender(),
          (this.animationProgress = x));
      }),
        this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0));
    }
    startAnimation(i) {
      var a, l, c;
      (this.notifyListeners("animationStart"),
        (a = this.currentAnimation) == null || a.stop(),
        (c = (l = this.resumingFrom) == null ? void 0 : l.currentAnimation) == null || c.stop(),
        this.pendingAnimation && (Qt(this.pendingAnimation), (this.pendingAnimation = void 0)),
        (this.pendingAnimation = De.update(() => {
          ((so.hasAnimatedSinceResize = !0),
            this.motionValue || (this.motionValue = zn(0)),
            (this.currentAnimation = Tb(this.motionValue, [0, 1e3], {
              ...i,
              velocity: 0,
              isSync: !0,
              onUpdate: (u) => {
                (this.mixTargetDelta(u), i.onUpdate && i.onUpdate(u));
              },
              onStop: () => {},
              onComplete: () => {
                (i.onComplete && i.onComplete(), this.completeAnimation());
              },
            })),
            this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation),
            (this.pendingAnimation = void 0));
        })));
    }
    completeAnimation() {
      this.resumingFrom &&
        ((this.resumingFrom.currentAnimation = void 0),
        (this.resumingFrom.preserveOpacity = void 0));
      const i = this.getStack();
      (i && i.exitAnimationComplete(),
        (this.resumingFrom = this.currentAnimation = this.animationValues = void 0),
        this.notifyListeners("animationComplete"));
    }
    finishAnimation() {
      (this.currentAnimation &&
        (this.mixTargetDelta && this.mixTargetDelta(kb), this.currentAnimation.stop()),
        this.completeAnimation());
    }
    applyTransformsToTarget() {
      const i = this.getLead();
      let { targetWithTransforms: a, target: l, layout: c, latestValues: u } = i;
      if (!(!a || !l || !c)) {
        if (
          this !== i &&
          this.layout &&
          c &&
          gd(this.options.animationType, this.layout.layoutBox, c.layoutBox)
        ) {
          l = this.target || Xe();
          const d = st(this.layout.layoutBox.x);
          ((l.x.min = i.target.x.min), (l.x.max = l.x.min + d));
          const f = st(this.layout.layoutBox.y);
          ((l.y.min = i.target.y.min), (l.y.max = l.y.min + f));
        }
        (vt(a, l), In(a, u), pr(this.projectionDeltaWithTransform, this.layoutCorrected, a, u));
      }
    }
    registerSharedNode(i, a) {
      (this.sharedNodes.has(i) || this.sharedNodes.set(i, new Pb()),
        this.sharedNodes.get(i).add(a));
      const c = a.options.initialPromotionConfig;
      a.promote({
        transition: c ? c.transition : void 0,
        preserveFollowOpacity:
          c && c.shouldPreserveFollowOpacity ? c.shouldPreserveFollowOpacity(a) : void 0,
      });
    }
    isLead() {
      const i = this.getStack();
      return i ? i.lead === this : !0;
    }
    getLead() {
      var a;
      const { layoutId: i } = this.options;
      return i ? ((a = this.getStack()) == null ? void 0 : a.lead) || this : this;
    }
    getPrevLead() {
      var a;
      const { layoutId: i } = this.options;
      return i ? ((a = this.getStack()) == null ? void 0 : a.prevLead) : void 0;
    }
    getStack() {
      const { layoutId: i } = this.options;
      if (i) return this.root.sharedNodes.get(i);
    }
    promote({ needsReset: i, transition: a, preserveFollowOpacity: l } = {}) {
      const c = this.getStack();
      (c && c.promote(this, l),
        i && ((this.projectionDelta = void 0), (this.needsReset = !0)),
        a && this.setOptions({ transition: a }));
    }
    relegate() {
      const i = this.getStack();
      return i ? i.relegate(this) : !1;
    }
    resetSkewAndRotation() {
      const { visualElement: i } = this.options;
      if (!i) return;
      let a = !1;
      const { latestValues: l } = i;
      if (
        ((l.z || l.rotate || l.rotateX || l.rotateY || l.rotateZ || l.skewX || l.skewY) && (a = !0),
        !a)
      )
        return;
      const c = {};
      l.z && as("z", i, c, this.animationValues);
      for (let u = 0; u < is.length; u++)
        (as(`rotate${is[u]}`, i, c, this.animationValues),
          as(`skew${is[u]}`, i, c, this.animationValues));
      i.render();
      for (const u in c)
        (i.setStaticValue(u, c[u]), this.animationValues && (this.animationValues[u] = c[u]));
      i.scheduleRender();
    }
    applyProjectionStyles(i, a) {
      if (!this.instance || this.isSVG) return;
      if (!this.isVisible) {
        i.visibility = "hidden";
        return;
      }
      const l = this.getTransformTemplate();
      if (this.needsReset) {
        ((this.needsReset = !1),
          (i.visibility = ""),
          (i.opacity = ""),
          (i.pointerEvents = oo(a == null ? void 0 : a.pointerEvents) || ""),
          (i.transform = l ? l(this.latestValues, "") : "none"));
        return;
      }
      const c = this.getLead();
      if (!this.projectionDelta || !this.layout || !c.target) {
        (this.options.layoutId &&
          ((i.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1),
          (i.pointerEvents = oo(a == null ? void 0 : a.pointerEvents) || "")),
          this.hasProjected &&
            !hn(this.latestValues) &&
            ((i.transform = l ? l({}, "") : "none"), (this.hasProjected = !1)));
        return;
      }
      i.visibility = "";
      const u = c.animationValues || c.latestValues;
      this.applyTransformsToTarget();
      let d = yb(this.projectionDeltaWithTransform, this.treeScale, u);
      (l && (d = l(u, d)), (i.transform = d));
      const { x: f, y: m } = this.projectionDelta;
      ((i.transformOrigin = `${f.origin * 100}% ${m.origin * 100}% 0`),
        c.animationValues
          ? (i.opacity =
              c === this
                ? (u.opacity ?? this.latestValues.opacity ?? 1)
                : this.preserveOpacity
                  ? this.latestValues.opacity
                  : u.opacityExit)
          : (i.opacity =
              c === this
                ? u.opacity !== void 0
                  ? u.opacity
                  : ""
                : u.opacityExit !== void 0
                  ? u.opacityExit
                  : 0));
      for (const g in qs) {
        if (u[g] === void 0) continue;
        const { correct: p, applyTo: v, isCSSVariable: b } = qs[g],
          y = d === "none" ? u[g] : p(u[g], c);
        if (v) {
          const w = v.length;
          for (let R = 0; R < w; R++) i[v[R]] = y;
        } else b ? (this.options.visualElement.renderState.vars[g] = y) : (i[g] = y);
      }
      this.options.layoutId &&
        (i.pointerEvents = c === this ? oo(a == null ? void 0 : a.pointerEvents) || "" : "none");
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    resetTree() {
      (this.root.nodes.forEach((i) => {
        var a;
        return (a = i.currentAnimation) == null ? void 0 : a.stop();
      }),
        this.root.nodes.forEach(Tl),
        this.root.sharedNodes.clear());
    }
  };
}
function Ab(e) {
  e.updateLayout();
}
function Ob(e) {
  var n;
  const t = ((n = e.resumeFrom) == null ? void 0 : n.snapshot) || e.snapshot;
  if (e.isLead() && e.layout && t && e.hasListeners("didUpdate")) {
    const { layoutBox: r, measuredBox: o } = e.layout,
      { animationType: s } = e.options,
      i = t.source !== e.layout.source;
    s === "size"
      ? mt((d) => {
          const f = i ? t.measuredBox[d] : t.layoutBox[d],
            m = st(f);
          ((f.min = r[d].min), (f.max = f.min + m));
        })
      : gd(s, t.layoutBox, r) &&
        mt((d) => {
          const f = i ? t.measuredBox[d] : t.layoutBox[d],
            m = st(r[d]);
          ((f.max = f.min + m),
            e.relativeTarget &&
              !e.currentAnimation &&
              ((e.isProjectionDirty = !0),
              (e.relativeTarget[d].max = e.relativeTarget[d].min + m)));
        });
    const a = An();
    pr(a, r, t.layoutBox);
    const l = An();
    i ? pr(l, e.applyTransform(o, !0), t.measuredBox) : pr(l, r, t.layoutBox);
    const c = !ud(a);
    let u = !1;
    if (!e.resumeFrom) {
      const d = e.getClosestProjectingParent();
      if (d && !d.resumeFrom) {
        const { snapshot: f, layout: m } = d;
        if (f && m) {
          const g = Xe();
          xo(g, t.layoutBox, f.layoutBox);
          const p = Xe();
          (xo(p, r, m.layoutBox),
            dd(g, p) || (u = !0),
            d.options.layoutRoot &&
              ((e.relativeTarget = p), (e.relativeTargetOrigin = g), (e.relativeParent = d)));
        }
      }
    }
    e.notifyListeners("didUpdate", {
      layout: r,
      snapshot: t,
      delta: l,
      layoutDelta: a,
      hasLayoutChanged: c,
      hasRelativeLayoutChanged: u,
    });
  } else if (e.isLead()) {
    const { onExitComplete: r } = e.options;
    r && r();
  }
  e.options.transition = void 0;
}
function Ib(e) {
  e.parent &&
    (e.isProjecting() || (e.isProjectionDirty = e.parent.isProjectionDirty),
    e.isSharedProjectionDirty ||
      (e.isSharedProjectionDirty = !!(
        e.isProjectionDirty ||
        e.parent.isProjectionDirty ||
        e.parent.isSharedProjectionDirty
      )),
    e.isTransformDirty || (e.isTransformDirty = e.parent.isTransformDirty));
}
function Db(e) {
  e.isProjectionDirty = e.isSharedProjectionDirty = e.isTransformDirty = !1;
}
function Nb(e) {
  e.clearSnapshot();
}
function Tl(e) {
  e.clearMeasurements();
}
function Rl(e) {
  e.isLayoutDirty = !1;
}
function Fb(e) {
  const { visualElement: t } = e.options;
  (t && t.getProps().onBeforeLayoutMeasure && t.notify("BeforeLayoutMeasure"), e.resetTransform());
}
function El(e) {
  (e.finishAnimation(),
    (e.targetDelta = e.relativeTarget = e.target = void 0),
    (e.isProjectionDirty = !0));
}
function Lb(e) {
  e.resolveTargetDelta();
}
function jb(e) {
  e.calcProjection();
}
function Vb(e) {
  e.resetSkewAndRotation();
}
function Bb(e) {
  e.removeLeadSnapshot();
}
function Cl(e, t, n) {
  ((e.translate = Fe(t.translate, 0, n)),
    (e.scale = Fe(t.scale, 1, n)),
    (e.origin = t.origin),
    (e.originPoint = t.originPoint));
}
function Pl(e, t, n, r) {
  ((e.min = Fe(t.min, n.min, r)), (e.max = Fe(t.max, n.max, r)));
}
function $b(e, t, n, r) {
  (Pl(e.x, t.x, n.x, r), Pl(e.y, t.y, n.y, r));
}
function Wb(e) {
  return e.animationValues && e.animationValues.opacityExit !== void 0;
}
const zb = { duration: 0.45, ease: [0.4, 0, 0.1, 1] },
  kl = (e) =>
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(e),
  Ml = kl("applewebkit/") && !kl("chrome/") ? Math.round : yt;
function Al(e) {
  ((e.min = Ml(e.min)), (e.max = Ml(e.max)));
}
function Hb(e) {
  (Al(e.x), Al(e.y));
}
function gd(e, t, n) {
  return e === "position" || (e === "preserve-aspect" && !fb(yl(t), yl(n), 0.2));
}
function Ub(e) {
  var t;
  return e !== e.root && ((t = e.scroll) == null ? void 0 : t.wasRoot);
}
const _b = pd({
    attachResizeListener: (e, t) => Rr(e, "resize", t),
    measureScroll: () => {
      var e, t;
      return {
        x:
          document.documentElement.scrollLeft ||
          ((e = document.body) == null ? void 0 : e.scrollLeft) ||
          0,
        y:
          document.documentElement.scrollTop ||
          ((t = document.body) == null ? void 0 : t.scrollTop) ||
          0,
      };
    },
    checkIsScrollRoot: () => !0,
  }),
  ls = { current: void 0 },
  bd = pd({
    measureScroll: (e) => ({ x: e.scrollLeft, y: e.scrollTop }),
    defaultParent: () => {
      if (!ls.current) {
        const e = new _b({});
        (e.mount(window), e.setOptions({ layoutScroll: !0 }), (ls.current = e));
      }
      return ls.current;
    },
    resetTransform: (e, t) => {
      e.style.transform = t !== void 0 ? t : "none";
    },
    checkIsScrollRoot: (e) => window.getComputedStyle(e).position === "fixed",
  }),
  qi = h.createContext({ transformPagePoint: (e) => e, isStatic: !1, reducedMotion: "never" });
function Ol(e, t) {
  if (typeof e == "function") return e(t);
  e != null && (e.current = t);
}
function Yb(...e) {
  return (t) => {
    let n = !1;
    const r = e.map((o) => {
      const s = Ol(o, t);
      return (!n && typeof s == "function" && (n = !0), s);
    });
    if (n)
      return () => {
        for (let o = 0; o < r.length; o++) {
          const s = r[o];
          typeof s == "function" ? s() : Ol(e[o], null);
        }
      };
  };
}
function qb(...e) {
  return h.useCallback(Yb(...e), e);
}
class Xb extends h.Component {
  getSnapshotBeforeUpdate(t) {
    const n = this.props.childRef.current;
    if (n && t.isPresent && !this.props.isPresent) {
      const r = n.offsetParent,
        o = (Hs(r) && r.offsetWidth) || 0,
        s = (Hs(r) && r.offsetHeight) || 0,
        i = this.props.sizeRef.current;
      ((i.height = n.offsetHeight || 0),
        (i.width = n.offsetWidth || 0),
        (i.top = n.offsetTop),
        (i.left = n.offsetLeft),
        (i.right = o - i.width - i.left),
        (i.bottom = s - i.height - i.top));
    }
    return null;
  }
  componentDidUpdate() {}
  render() {
    return this.props.children;
  }
}
function Gb({ children: e, isPresent: t, anchorX: n, anchorY: r, root: o }) {
  var d;
  const s = h.useId(),
    i = h.useRef(null),
    a = h.useRef({ width: 0, height: 0, top: 0, left: 0, right: 0, bottom: 0 }),
    { nonce: l } = h.useContext(qi),
    c = ((d = e.props) == null ? void 0 : d.ref) ?? (e == null ? void 0 : e.ref),
    u = qb(i, c);
  return (
    h.useInsertionEffect(() => {
      const { width: f, height: m, top: g, left: p, right: v, bottom: b } = a.current;
      if (t || !i.current || !f || !m) return;
      const y = n === "left" ? `left: ${p}` : `right: ${v}`,
        w = r === "bottom" ? `bottom: ${b}` : `top: ${g}`;
      i.current.dataset.motionPopId = s;
      const R = document.createElement("style");
      l && (R.nonce = l);
      const x = o ?? document.head;
      return (
        x.appendChild(R),
        R.sheet &&
          R.sheet.insertRule(`
          [data-motion-pop-id="${s}"] {
            position: absolute !important;
            width: ${f}px !important;
            height: ${m}px !important;
            ${y}px !important;
            ${w}px !important;
          }
        `),
        () => {
          x.contains(R) && x.removeChild(R);
        }
      );
    }, [t]),
    T.jsx(Xb, { isPresent: t, childRef: i, sizeRef: a, children: h.cloneElement(e, { ref: u }) })
  );
}
const Kb = ({
  children: e,
  initial: t,
  isPresent: n,
  onExitComplete: r,
  custom: o,
  presenceAffectsLayout: s,
  mode: i,
  anchorX: a,
  anchorY: l,
  root: c,
}) => {
  const u = xi(Qb),
    d = h.useId();
  let f = !0,
    m = h.useMemo(
      () => (
        (f = !1),
        {
          id: d,
          initial: t,
          isPresent: n,
          custom: o,
          onExitComplete: (g) => {
            u.set(g, !0);
            for (const p of u.values()) if (!p) return;
            r && r();
          },
          register: (g) => (u.set(g, !1), () => u.delete(g)),
        }
      ),
      [n, u, r],
    );
  return (
    s && f && (m = { ...m }),
    h.useMemo(() => {
      u.forEach((g, p) => u.set(p, !1));
    }, [n]),
    h.useEffect(() => {
      !n && !u.size && r && r();
    }, [n]),
    i === "popLayout" &&
      (e = T.jsx(Gb, { isPresent: n, anchorX: a, anchorY: l, root: c, children: e })),
    T.jsx(No.Provider, { value: m, children: e })
  );
};
function Qb() {
  return new Map();
}
function yd(e = !0) {
  const t = h.useContext(No);
  if (t === null) return [!0, null];
  const { isPresent: n, onExitComplete: r, register: o } = t,
    s = h.useId();
  h.useEffect(() => {
    if (e) return o(s);
  }, [e]);
  const i = h.useCallback(() => e && r && r(s), [s, r, e]);
  return !n && r ? [!1, i] : [!0];
}
const $r = (e) => e.key || "";
function Il(e) {
  const t = [];
  return (
    h.Children.forEach(e, (n) => {
      h.isValidElement(n) && t.push(n);
    }),
    t
  );
}
const Dl = ({
    children: e,
    custom: t,
    initial: n = !0,
    onExitComplete: r,
    presenceAffectsLayout: o = !0,
    mode: s = "sync",
    propagate: i = !1,
    anchorX: a = "left",
    anchorY: l = "top",
    root: c,
  }) => {
    const [u, d] = yd(i),
      f = h.useMemo(() => Il(e), [e]),
      m = i && !u ? [] : f.map($r),
      g = h.useRef(!0),
      p = h.useRef(f),
      v = xi(() => new Map()),
      b = h.useRef(new Set()),
      [y, w] = h.useState(f),
      [R, x] = h.useState(f);
    Kc(() => {
      ((g.current = !1), (p.current = f));
      for (let P = 0; P < R.length; P++) {
        const D = $r(R[P]);
        m.includes(D) ? (v.delete(D), b.current.delete(D)) : v.get(D) !== !0 && v.set(D, !1);
      }
    }, [R, m.length, m.join("-")]);
    const A = [];
    if (f !== y) {
      let P = [...f];
      for (let D = 0; D < R.length; D++) {
        const V = R[D],
          B = $r(V);
        m.includes(B) || (P.splice(D, 0, V), A.push(V));
      }
      return (s === "wait" && A.length && (P = A), x(Il(P)), w(f), null);
    }
    const { forceRender: I } = h.useContext(yi);
    return T.jsx(T.Fragment, {
      children: R.map((P) => {
        const D = $r(P),
          V = i && !u ? !1 : f === R || m.includes(D),
          B = () => {
            if (b.current.has(D)) return;
            if ((b.current.add(D), v.has(D))) v.set(D, !0);
            else return;
            let M = !0;
            (v.forEach((C) => {
              C || (M = !1);
            }),
              M && (I == null || I(), x(p.current), i && (d == null || d()), r && r()));
          };
        return T.jsx(
          Kb,
          {
            isPresent: V,
            initial: !g.current || n ? void 0 : !1,
            custom: t,
            presenceAffectsLayout: o,
            mode: s,
            root: c,
            onExitComplete: V ? void 0 : B,
            anchorX: a,
            anchorY: l,
            children: P,
          },
          D,
        );
      }),
    });
  },
  xd = h.createContext({ strict: !1 }),
  Nl = {
    animation: [
      "animate",
      "variants",
      "whileHover",
      "whileTap",
      "exit",
      "whileInView",
      "whileFocus",
      "whileDrag",
    ],
    exit: ["exit"],
    drag: ["drag", "dragControls"],
    focus: ["whileFocus"],
    hover: ["whileHover", "onHoverStart", "onHoverEnd"],
    tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
    pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
    inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
    layout: ["layout", "layoutId"],
  };
let Fl = !1;
function Zb() {
  if (Fl) return;
  const e = {};
  for (const t in Nl) e[t] = { isEnabled: (n) => Nl[t].some((r) => !!n[r]) };
  (Xu(e), (Fl = !0));
}
function vd() {
  return (Zb(), Vg());
}
function Jb(e) {
  const t = vd();
  for (const n in e) t[n] = { ...t[n], ...e[n] };
  Xu(t);
}
const ey = new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "custom",
  "inherit",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "globalTapTarget",
  "ignoreStrict",
  "viewport",
]);
function vo(e) {
  return (
    e.startsWith("while") ||
    (e.startsWith("drag") && e !== "draggable") ||
    e.startsWith("layout") ||
    e.startsWith("onTap") ||
    e.startsWith("onPan") ||
    e.startsWith("onLayout") ||
    ey.has(e)
  );
}
let wd = (e) => !vo(e);
function ty(e) {
  typeof e == "function" && (wd = (t) => (t.startsWith("on") ? !vo(t) : e(t)));
}
try {
  ty(require("@emotion/is-prop-valid").default);
} catch {}
function ny(e, t, n) {
  const r = {};
  for (const o in e)
    (o === "values" && typeof e.values == "object") ||
      ((wd(o) ||
        (n === !0 && vo(o)) ||
        (!t && !vo(o)) ||
        (e.draggable && o.startsWith("onDrag"))) &&
        (r[o] = e[o]));
  return r;
}
const jo = h.createContext({});
function ry(e, t) {
  if (Lo(e)) {
    const { initial: n, animate: r } = e;
    return { initial: n === !1 || Tr(n) ? n : void 0, animate: Tr(r) ? r : void 0 };
  }
  return e.inherit !== !1 ? t : {};
}
function oy(e) {
  const { initial: t, animate: n } = ry(e, h.useContext(jo));
  return h.useMemo(() => ({ initial: t, animate: n }), [Ll(t), Ll(n)]);
}
function Ll(e) {
  return Array.isArray(e) ? e.join(" ") : e;
}
const Xi = () => ({ style: {}, transform: {}, transformOrigin: {}, vars: {} });
function Sd(e, t, n) {
  for (const r in t) !nt(t[r]) && !td(r, n) && (e[r] = t[r]);
}
function sy({ transformTemplate: e }, t) {
  return h.useMemo(() => {
    const n = Xi();
    return (_i(n, t, e), Object.assign({}, n.vars, n.style));
  }, [t]);
}
function iy(e, t) {
  const n = e.style || {},
    r = {};
  return (Sd(r, n, e), Object.assign(r, sy(e, t)), r);
}
function ay(e, t) {
  const n = {},
    r = iy(e, t);
  return (
    e.drag &&
      e.dragListener !== !1 &&
      ((n.draggable = !1),
      (r.userSelect = r.WebkitUserSelect = r.WebkitTouchCallout = "none"),
      (r.touchAction = e.drag === !0 ? "none" : `pan-${e.drag === "x" ? "y" : "x"}`)),
    e.tabIndex === void 0 && (e.onTap || e.onTapStart || e.whileTap) && (n.tabIndex = 0),
    (n.style = r),
    n
  );
}
const Td = () => ({ ...Xi(), attrs: {} });
function ly(e, t, n, r) {
  const o = h.useMemo(() => {
    const s = Td();
    return (nd(s, t, od(r), e.transformTemplate, e.style), { ...s.attrs, style: { ...s.style } });
  }, [t]);
  if (e.style) {
    const s = {};
    (Sd(s, e.style, e), (o.style = { ...s, ...o.style }));
  }
  return o;
}
const cy = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view",
];
function Gi(e) {
  return typeof e != "string" || e.includes("-") ? !1 : !!(cy.indexOf(e) > -1 || /[A-Z]/u.test(e));
}
function uy(e, t, n, { latestValues: r }, o, s = !1, i) {
  const l = ((i ?? Gi(e)) ? ly : ay)(t, r, o, e),
    c = ny(t, typeof e == "string", s),
    u = e !== h.Fragment ? { ...c, ...l, ref: n } : {},
    { children: d } = t,
    f = h.useMemo(() => (nt(d) ? d.get() : d), [d]);
  return h.createElement(e, { ...u, children: f });
}
function dy({ scrapeMotionValuesFromProps: e, createRenderState: t }, n, r, o) {
  return { latestValues: fy(n, r, o, e), renderState: t() };
}
function fy(e, t, n, r) {
  const o = {},
    s = r(e, {});
  for (const f in s) o[f] = oo(s[f]);
  let { initial: i, animate: a } = e;
  const l = Lo(e),
    c = qu(e);
  t &&
    c &&
    !l &&
    e.inherit !== !1 &&
    (i === void 0 && (i = t.initial), a === void 0 && (a = t.animate));
  let u = n ? n.initial === !1 : !1;
  u = u || i === !1;
  const d = u ? a : i;
  if (d && typeof d != "boolean" && !Fo(d)) {
    const f = Array.isArray(d) ? d : [d];
    for (let m = 0; m < f.length; m++) {
      const g = Vi(e, f[m]);
      if (g) {
        const { transitionEnd: p, transition: v, ...b } = g;
        for (const y in b) {
          let w = b[y];
          if (Array.isArray(w)) {
            const R = u ? w.length - 1 : 0;
            w = w[R];
          }
          w !== null && (o[y] = w);
        }
        for (const y in p) o[y] = p[y];
      }
    }
  }
  return o;
}
const Rd = (e) => (t, n) => {
    const r = h.useContext(jo),
      o = h.useContext(No),
      s = () => dy(e, t, r, o);
    return n ? s() : xi(s);
  },
  hy = Rd({ scrapeMotionValuesFromProps: Yi, createRenderState: Xi }),
  my = Rd({ scrapeMotionValuesFromProps: sd, createRenderState: Td }),
  py = Symbol.for("motionComponentSymbol");
function gy(e, t, n) {
  const r = h.useRef(n);
  h.useInsertionEffect(() => {
    r.current = n;
  });
  const o = h.useRef(null);
  return h.useCallback(
    (s) => {
      var a;
      (s && ((a = e.onMount) == null || a.call(e, s)), t && (s ? t.mount(s) : t.unmount()));
      const i = r.current;
      if (typeof i == "function")
        if (s) {
          const l = i(s);
          typeof l == "function" && (o.current = l);
        } else o.current ? (o.current(), (o.current = null)) : i(s);
      else i && (i.current = s);
    },
    [t],
  );
}
const Ed = h.createContext({});
function dr(e) {
  return e && typeof e == "object" && Object.prototype.hasOwnProperty.call(e, "current");
}
function by(e, t, n, r, o, s) {
  var v, b;
  const { visualElement: i } = h.useContext(jo),
    a = h.useContext(xd),
    l = h.useContext(No),
    c = h.useContext(qi).reducedMotion,
    u = h.useRef(null);
  ((r = r || a.renderer),
    !u.current &&
      r &&
      (u.current = r(e, {
        visualState: t,
        parent: i,
        props: n,
        presenceContext: l,
        blockInitialAnimation: l ? l.initial === !1 : !1,
        reducedMotionConfig: c,
        isSVG: s,
      })));
  const d = u.current,
    f = h.useContext(Ed);
  d && !d.projection && o && (d.type === "html" || d.type === "svg") && yy(u.current, n, o, f);
  const m = h.useRef(!1);
  h.useInsertionEffect(() => {
    d && m.current && d.update(n, l);
  });
  const g = n[Du],
    p = h.useRef(
      !!g &&
        !((v = window.MotionHandoffIsComplete) != null && v.call(window, g)) &&
        ((b = window.MotionHasOptimisedAnimation) == null ? void 0 : b.call(window, g)),
    );
  return (
    Kc(() => {
      d &&
        ((m.current = !0),
        (window.MotionIsMounted = !0),
        d.updateFeatures(),
        d.scheduleRenderMicrotask(),
        p.current && d.animationState && d.animationState.animateChanges());
    }),
    h.useEffect(() => {
      d &&
        (!p.current && d.animationState && d.animationState.animateChanges(),
        p.current &&
          (queueMicrotask(() => {
            var y;
            (y = window.MotionHandoffMarkAsComplete) == null || y.call(window, g);
          }),
          (p.current = !1)),
        (d.enteringChildren = void 0));
    }),
    d
  );
}
function yy(e, t, n, r) {
  const {
    layoutId: o,
    layout: s,
    drag: i,
    dragConstraints: a,
    layoutScroll: l,
    layoutRoot: c,
    layoutCrossfade: u,
  } = t;
  ((e.projection = new n(e.latestValues, t["data-framer-portal-id"] ? void 0 : Cd(e.parent))),
    e.projection.setOptions({
      layoutId: o,
      layout: s,
      alwaysMeasureLayout: !!i || (a && dr(a)),
      visualElement: e,
      animationType: typeof s == "string" ? s : "both",
      initialPromotionConfig: r,
      crossfade: u,
      layoutScroll: l,
      layoutRoot: c,
    }));
}
function Cd(e) {
  if (e) return e.options.allowProjection !== !1 ? e.projection : Cd(e.parent);
}
function cs(e, { forwardMotionProps: t = !1, type: n } = {}, r, o) {
  r && Jb(r);
  const s = n ? n === "svg" : Gi(e),
    i = s ? my : hy;
  function a(c, u) {
    let d;
    const f = { ...h.useContext(qi), ...c, layoutId: xy(c) },
      { isStatic: m } = f,
      g = oy(c),
      p = i(c, m);
    if (!m && Gc) {
      vy();
      const v = wy(f);
      ((d = v.MeasureLayout), (g.visualElement = by(e, p, f, o, v.ProjectionNode, s)));
    }
    return T.jsxs(jo.Provider, {
      value: g,
      children: [
        d && g.visualElement ? T.jsx(d, { visualElement: g.visualElement, ...f }) : null,
        uy(e, c, gy(p, g.visualElement, u), p, m, t, s),
      ],
    });
  }
  a.displayName = `motion.${typeof e == "string" ? e : `create(${e.displayName ?? e.name ?? ""})`}`;
  const l = h.forwardRef(a);
  return ((l[py] = e), l);
}
function xy({ layoutId: e }) {
  const t = h.useContext(yi).id;
  return t && e !== void 0 ? t + "-" + e : e;
}
function vy(e, t) {
  h.useContext(xd).strict;
}
function wy(e) {
  const t = vd(),
    { drag: n, layout: r } = t;
  if (!n && !r) return {};
  const o = { ...n, ...r };
  return {
    MeasureLayout:
      (n != null && n.isEnabled(e)) || (r != null && r.isEnabled(e)) ? o.MeasureLayout : void 0,
    ProjectionNode: o.ProjectionNode,
  };
}
function Sy(e, t) {
  if (typeof Proxy > "u") return cs;
  const n = new Map(),
    r = (s, i) => cs(s, i, e, t),
    o = (s, i) => r(s, i);
  return new Proxy(o, {
    get: (s, i) => (i === "create" ? r : (n.has(i) || n.set(i, cs(i, void 0, e, t)), n.get(i))),
  });
}
const Ty = (e, t) =>
  (t.isSVG ?? Gi(e)) ? new tb(t) : new Gg(t, { allowProjection: e !== h.Fragment });
class Ry extends tn {
  constructor(t) {
    (super(t), t.animationState || (t.animationState = ib(t)));
  }
  updateAnimationControlsSubscription() {
    const { animate: t } = this.node.getProps();
    Fo(t) && (this.unmountControls = t.subscribe(this.node));
  }
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate: t } = this.node.getProps(),
      { animate: n } = this.node.prevProps || {};
    t !== n && this.updateAnimationControlsSubscription();
  }
  unmount() {
    var t;
    (this.node.animationState.reset(), (t = this.unmountControls) == null || t.call(this));
  }
}
let Ey = 0;
class Cy extends tn {
  constructor() {
    (super(...arguments), (this.id = Ey++));
  }
  update() {
    if (!this.node.presenceContext) return;
    const { isPresent: t, onExitComplete: n } = this.node.presenceContext,
      { isPresent: r } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || t === r) return;
    const o = this.node.animationState.setActive("exit", !t);
    n &&
      !t &&
      o.then(() => {
        n(this.id);
      });
  }
  mount() {
    const { register: t, onExitComplete: n } = this.node.presenceContext || {};
    (n && n(this.id), t && (this.unmount = t(this.id)));
  }
  unmount() {}
}
const Py = { animation: { Feature: Ry }, exit: { Feature: Cy } };
function Or(e) {
  return { point: { x: e.pageX, y: e.pageY } };
}
const ky = (e) => (t) => zi(t) && e(t, Or(t));
function gr(e, t, n, r) {
  return Rr(e, t, ky(n), r);
}
const Pd = ({ current: e }) => (e ? e.ownerDocument.defaultView : null),
  jl = (e, t) => Math.abs(e - t);
function My(e, t) {
  const n = jl(e.x, t.x),
    r = jl(e.y, t.y);
  return Math.sqrt(n ** 2 + r ** 2);
}
const Vl = new Set(["auto", "scroll"]);
class kd {
  constructor(
    t,
    n,
    {
      transformPagePoint: r,
      contextWindow: o = window,
      dragSnapToOrigin: s = !1,
      distanceThreshold: i = 3,
      element: a,
    } = {},
  ) {
    if (
      ((this.startEvent = null),
      (this.lastMoveEvent = null),
      (this.lastMoveEventInfo = null),
      (this.handlers = {}),
      (this.contextWindow = window),
      (this.scrollPositions = new Map()),
      (this.removeScrollListeners = null),
      (this.onElementScroll = (m) => {
        this.handleScroll(m.target);
      }),
      (this.onWindowScroll = () => {
        this.handleScroll(window);
      }),
      (this.updatePoint = () => {
        if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;
        const m = ds(this.lastMoveEventInfo, this.history),
          g = this.startEvent !== null,
          p = My(m.offset, { x: 0, y: 0 }) >= this.distanceThreshold;
        if (!g && !p) return;
        const { point: v } = m,
          { timestamp: b } = Qe;
        this.history.push({ ...v, timestamp: b });
        const { onStart: y, onMove: w } = this.handlers;
        (g || (y && y(this.lastMoveEvent, m), (this.startEvent = this.lastMoveEvent)),
          w && w(this.lastMoveEvent, m));
      }),
      (this.handlePointerMove = (m, g) => {
        ((this.lastMoveEvent = m),
          (this.lastMoveEventInfo = us(g, this.transformPagePoint)),
          De.update(this.updatePoint, !0));
      }),
      (this.handlePointerUp = (m, g) => {
        this.end();
        const { onEnd: p, onSessionEnd: v, resumeAnimation: b } = this.handlers;
        if (
          ((this.dragSnapToOrigin || !this.startEvent) && b && b(),
          !(this.lastMoveEvent && this.lastMoveEventInfo))
        )
          return;
        const y = ds(
          m.type === "pointercancel" ? this.lastMoveEventInfo : us(g, this.transformPagePoint),
          this.history,
        );
        (this.startEvent && p && p(m, y), v && v(m, y));
      }),
      !zi(t))
    )
      return;
    ((this.dragSnapToOrigin = s),
      (this.handlers = n),
      (this.transformPagePoint = r),
      (this.distanceThreshold = i),
      (this.contextWindow = o || window));
    const l = Or(t),
      c = us(l, this.transformPagePoint),
      { point: u } = c,
      { timestamp: d } = Qe;
    this.history = [{ ...u, timestamp: d }];
    const { onSessionStart: f } = n;
    (f && f(t, ds(c, this.history)),
      (this.removeListeners = kr(
        gr(this.contextWindow, "pointermove", this.handlePointerMove),
        gr(this.contextWindow, "pointerup", this.handlePointerUp),
        gr(this.contextWindow, "pointercancel", this.handlePointerUp),
      )),
      a && this.startScrollTracking(a));
  }
  startScrollTracking(t) {
    let n = t.parentElement;
    for (; n; ) {
      const r = getComputedStyle(n);
      ((Vl.has(r.overflowX) || Vl.has(r.overflowY)) &&
        this.scrollPositions.set(n, { x: n.scrollLeft, y: n.scrollTop }),
        (n = n.parentElement));
    }
    (this.scrollPositions.set(window, { x: window.scrollX, y: window.scrollY }),
      window.addEventListener("scroll", this.onElementScroll, { capture: !0, passive: !0 }),
      window.addEventListener("scroll", this.onWindowScroll, { passive: !0 }),
      (this.removeScrollListeners = () => {
        (window.removeEventListener("scroll", this.onElementScroll, { capture: !0 }),
          window.removeEventListener("scroll", this.onWindowScroll));
      }));
  }
  handleScroll(t) {
    const n = this.scrollPositions.get(t);
    if (!n) return;
    const r = t === window,
      o = r ? { x: window.scrollX, y: window.scrollY } : { x: t.scrollLeft, y: t.scrollTop },
      s = { x: o.x - n.x, y: o.y - n.y };
    (s.x === 0 && s.y === 0) ||
      (r
        ? this.lastMoveEventInfo &&
          ((this.lastMoveEventInfo.point.x += s.x), (this.lastMoveEventInfo.point.y += s.y))
        : this.history.length > 0 && ((this.history[0].x -= s.x), (this.history[0].y -= s.y)),
      this.scrollPositions.set(t, o),
      De.update(this.updatePoint, !0));
  }
  updateHandlers(t) {
    this.handlers = t;
  }
  end() {
    (this.removeListeners && this.removeListeners(),
      this.removeScrollListeners && this.removeScrollListeners(),
      this.scrollPositions.clear(),
      Qt(this.updatePoint));
  }
}
function us(e, t) {
  return t ? { point: t(e.point) } : e;
}
function Bl(e, t) {
  return { x: e.x - t.x, y: e.y - t.y };
}
function ds({ point: e }, t) {
  return { point: e, delta: Bl(e, Md(t)), offset: Bl(e, Ay(t)), velocity: Oy(t, 0.1) };
}
function Ay(e) {
  return e[0];
}
function Md(e) {
  return e[e.length - 1];
}
function Oy(e, t) {
  if (e.length < 2) return { x: 0, y: 0 };
  let n = e.length - 1,
    r = null;
  const o = Md(e);
  for (; n >= 0 && ((r = e[n]), !(o.timestamp - r.timestamp > Lt(t))); ) n--;
  if (!r) return { x: 0, y: 0 };
  const s = pt(o.timestamp - r.timestamp);
  if (s === 0) return { x: 0, y: 0 };
  const i = { x: (o.x - r.x) / s, y: (o.y - r.y) / s };
  return (i.x === 1 / 0 && (i.x = 0), i.y === 1 / 0 && (i.y = 0), i);
}
function Iy(e, { min: t, max: n }, r) {
  return (
    t !== void 0 && e < t
      ? (e = r ? Fe(t, e, r.min) : Math.max(e, t))
      : n !== void 0 && e > n && (e = r ? Fe(n, e, r.max) : Math.min(e, n)),
    e
  );
}
function $l(e, t, n) {
  return {
    min: t !== void 0 ? e.min + t : void 0,
    max: n !== void 0 ? e.max + n - (e.max - e.min) : void 0,
  };
}
function Dy(e, { top: t, left: n, bottom: r, right: o }) {
  return { x: $l(e.x, n, o), y: $l(e.y, t, r) };
}
function Wl(e, t) {
  let n = t.min - e.min,
    r = t.max - e.max;
  return (t.max - t.min < e.max - e.min && ([n, r] = [r, n]), { min: n, max: r });
}
function Ny(e, t) {
  return { x: Wl(e.x, t.x), y: Wl(e.y, t.y) };
}
function Fy(e, t) {
  let n = 0.5;
  const r = st(e),
    o = st(t);
  return (
    o > r ? (n = vr(t.min, t.max - r, e.min)) : r > o && (n = vr(e.min, e.max - o, t.min)),
    Mt(0, 1, n)
  );
}
function Ly(e, t) {
  const n = {};
  return (
    t.min !== void 0 && (n.min = t.min - e.min), t.max !== void 0 && (n.max = t.max - e.min), n
  );
}
const Xs = 0.35;
function jy(e = Xs) {
  return (
    e === !1 ? (e = 0) : e === !0 && (e = Xs),
    { x: zl(e, "left", "right"), y: zl(e, "top", "bottom") }
  );
}
function zl(e, t, n) {
  return { min: Hl(e, t), max: Hl(e, n) };
}
function Hl(e, t) {
  return typeof e == "number" ? e : e[t] || 0;
}
const Vy = new WeakMap();
class By {
  constructor(t) {
    ((this.openDragLock = null),
      (this.isDragging = !1),
      (this.currentDirection = null),
      (this.originPoint = { x: 0, y: 0 }),
      (this.constraints = !1),
      (this.hasMutatedConstraints = !1),
      (this.elastic = Xe()),
      (this.latestPointerEvent = null),
      (this.latestPanInfo = null),
      (this.visualElement = t));
  }
  start(t, { snapToCursor: n = !1, distanceThreshold: r } = {}) {
    const { presenceContext: o } = this.visualElement;
    if (o && o.isPresent === !1) return;
    const s = (d) => {
        n ? (this.stopAnimation(), this.snapToCursor(Or(d).point)) : this.pauseAnimation();
      },
      i = (d, f) => {
        this.stopAnimation();
        const { drag: m, dragPropagation: g, onDragStart: p } = this.getProps();
        if (
          m &&
          !g &&
          (this.openDragLock && this.openDragLock(),
          (this.openDragLock = Cg(m)),
          !this.openDragLock)
        )
          return;
        ((this.latestPointerEvent = d),
          (this.latestPanInfo = f),
          (this.isDragging = !0),
          (this.currentDirection = null),
          this.resolveConstraints(),
          this.visualElement.projection &&
            ((this.visualElement.projection.isAnimationBlocked = !0),
            (this.visualElement.projection.target = void 0)),
          mt((b) => {
            let y = this.getAxisMotionValue(b).get() || 0;
            if (Ct.test(y)) {
              const { projection: w } = this.visualElement;
              if (w && w.layout) {
                const R = w.layout.layoutBox[b];
                R && (y = st(R) * (parseFloat(y) / 100));
              }
            }
            this.originPoint[b] = y;
          }),
          p && De.postRender(() => p(d, f)),
          $s(this.visualElement, "transform"));
        const { animationState: v } = this.visualElement;
        v && v.setActive("whileDrag", !0);
      },
      a = (d, f) => {
        ((this.latestPointerEvent = d), (this.latestPanInfo = f));
        const {
          dragPropagation: m,
          dragDirectionLock: g,
          onDirectionLock: p,
          onDrag: v,
        } = this.getProps();
        if (!m && !this.openDragLock) return;
        const { offset: b } = f;
        if (g && this.currentDirection === null) {
          ((this.currentDirection = $y(b)),
            this.currentDirection !== null && p && p(this.currentDirection));
          return;
        }
        (this.updateAxis("x", f.point, b),
          this.updateAxis("y", f.point, b),
          this.visualElement.render(),
          v && v(d, f));
      },
      l = (d, f) => {
        ((this.latestPointerEvent = d),
          (this.latestPanInfo = f),
          this.stop(d, f),
          (this.latestPointerEvent = null),
          (this.latestPanInfo = null));
      },
      c = () =>
        mt((d) => {
          var f;
          return (
            this.getAnimationState(d) === "paused" &&
            ((f = this.getAxisMotionValue(d).animation) == null ? void 0 : f.play())
          );
        }),
      { dragSnapToOrigin: u } = this.getProps();
    this.panSession = new kd(
      t,
      { onSessionStart: s, onStart: i, onMove: a, onSessionEnd: l, resumeAnimation: c },
      {
        transformPagePoint: this.visualElement.getTransformPagePoint(),
        dragSnapToOrigin: u,
        distanceThreshold: r,
        contextWindow: Pd(this.visualElement),
        element: this.visualElement.current,
      },
    );
  }
  stop(t, n) {
    const r = t || this.latestPointerEvent,
      o = n || this.latestPanInfo,
      s = this.isDragging;
    if ((this.cancel(), !s || !o || !r)) return;
    const { velocity: i } = o;
    this.startAnimation(i);
    const { onDragEnd: a } = this.getProps();
    a && De.postRender(() => a(r, o));
  }
  cancel() {
    this.isDragging = !1;
    const { projection: t, animationState: n } = this.visualElement;
    (t && (t.isAnimationBlocked = !1), this.endPanSession());
    const { dragPropagation: r } = this.getProps();
    (!r && this.openDragLock && (this.openDragLock(), (this.openDragLock = null)),
      n && n.setActive("whileDrag", !1));
  }
  endPanSession() {
    (this.panSession && this.panSession.end(), (this.panSession = void 0));
  }
  updateAxis(t, n, r) {
    const { drag: o } = this.getProps();
    if (!r || !Wr(t, o, this.currentDirection)) return;
    const s = this.getAxisMotionValue(t);
    let i = this.originPoint[t] + r[t];
    (this.constraints && this.constraints[t] && (i = Iy(i, this.constraints[t], this.elastic[t])),
      s.set(i));
  }
  resolveConstraints() {
    var s;
    const { dragConstraints: t, dragElastic: n } = this.getProps(),
      r =
        this.visualElement.projection && !this.visualElement.projection.layout
          ? this.visualElement.projection.measure(!1)
          : (s = this.visualElement.projection) == null
            ? void 0
            : s.layout,
      o = this.constraints;
    (t && dr(t)
      ? this.constraints || (this.constraints = this.resolveRefConstraints())
      : t && r
        ? (this.constraints = Dy(r.layoutBox, t))
        : (this.constraints = !1),
      (this.elastic = jy(n)),
      o !== this.constraints &&
        r &&
        this.constraints &&
        !this.hasMutatedConstraints &&
        mt((i) => {
          this.constraints !== !1 &&
            this.getAxisMotionValue(i) &&
            (this.constraints[i] = Ly(r.layoutBox[i], this.constraints[i]));
        }));
  }
  resolveRefConstraints() {
    const { dragConstraints: t, onMeasureDragConstraints: n } = this.getProps();
    if (!t || !dr(t)) return !1;
    const r = t.current,
      { projection: o } = this.visualElement;
    if (!o || !o.layout) return !1;
    const s = Hg(r, o.root, this.visualElement.getTransformPagePoint());
    let i = Ny(o.layout.layoutBox, s);
    if (n) {
      const a = n($g(i));
      ((this.hasMutatedConstraints = !!a), a && (i = Ku(a)));
    }
    return i;
  }
  startAnimation(t) {
    const {
        drag: n,
        dragMomentum: r,
        dragElastic: o,
        dragTransition: s,
        dragSnapToOrigin: i,
        onDragTransitionEnd: a,
      } = this.getProps(),
      l = this.constraints || {},
      c = mt((u) => {
        if (!Wr(u, n, this.currentDirection)) return;
        let d = (l && l[u]) || {};
        i && (d = { min: 0, max: 0 });
        const f = o ? 200 : 1e6,
          m = o ? 40 : 1e7,
          g = {
            type: "inertia",
            velocity: r ? t[u] : 0,
            bounceStiffness: f,
            bounceDamping: m,
            timeConstant: 750,
            restDelta: 1,
            restSpeed: 10,
            ...s,
            ...d,
          };
        return this.startAxisValueAnimation(u, g);
      });
    return Promise.all(c).then(a);
  }
  startAxisValueAnimation(t, n) {
    const r = this.getAxisMotionValue(t);
    return ($s(this.visualElement, t), r.start(ji(t, r, 0, n, this.visualElement, !1)));
  }
  stopAnimation() {
    mt((t) => this.getAxisMotionValue(t).stop());
  }
  pauseAnimation() {
    mt((t) => {
      var n;
      return (n = this.getAxisMotionValue(t).animation) == null ? void 0 : n.pause();
    });
  }
  getAnimationState(t) {
    var n;
    return (n = this.getAxisMotionValue(t).animation) == null ? void 0 : n.state;
  }
  getAxisMotionValue(t) {
    const n = `_drag${t.toUpperCase()}`,
      r = this.visualElement.getProps(),
      o = r[n];
    return o || this.visualElement.getValue(t, (r.initial ? r.initial[t] : void 0) || 0);
  }
  snapToCursor(t) {
    mt((n) => {
      const { drag: r } = this.getProps();
      if (!Wr(n, r, this.currentDirection)) return;
      const { projection: o } = this.visualElement,
        s = this.getAxisMotionValue(n);
      if (o && o.layout) {
        const { min: i, max: a } = o.layout.layoutBox[n],
          l = s.get() || 0;
        s.set(t[n] - Fe(i, a, 0.5) + l);
      }
    });
  }
  scalePositionWithinConstraints() {
    if (!this.visualElement.current) return;
    const { drag: t, dragConstraints: n } = this.getProps(),
      { projection: r } = this.visualElement;
    if (!dr(n) || !r || !this.constraints) return;
    this.stopAnimation();
    const o = { x: 0, y: 0 };
    mt((i) => {
      const a = this.getAxisMotionValue(i);
      if (a && this.constraints !== !1) {
        const l = a.get();
        o[i] = Fy({ min: l, max: l }, this.constraints[i]);
      }
    });
    const { transformTemplate: s } = this.visualElement.getProps();
    ((this.visualElement.current.style.transform = s ? s({}, "") : "none"),
      r.root && r.root.updateScroll(),
      r.updateLayout(),
      this.resolveConstraints(),
      mt((i) => {
        if (!Wr(i, t, null)) return;
        const a = this.getAxisMotionValue(i),
          { min: l, max: c } = this.constraints[i];
        a.set(Fe(l, c, o[i]));
      }));
  }
  addListeners() {
    if (!this.visualElement.current) return;
    Vy.set(this.visualElement, this);
    const t = this.visualElement.current,
      n = gr(t, "pointerdown", (l) => {
        const { drag: c, dragListener: u = !0 } = this.getProps(),
          d = l.target,
          f = d !== t && Uu(d);
        c && u && !f && this.start(l);
      }),
      r = () => {
        const { dragConstraints: l } = this.getProps();
        dr(l) && l.current && (this.constraints = this.resolveRefConstraints());
      },
      { projection: o } = this.visualElement,
      s = o.addEventListener("measure", r);
    (o && !o.layout && (o.root && o.root.updateScroll(), o.updateLayout()), De.read(r));
    const i = Rr(window, "resize", () => this.scalePositionWithinConstraints()),
      a = o.addEventListener("didUpdate", ({ delta: l, hasLayoutChanged: c }) => {
        this.isDragging &&
          c &&
          (mt((u) => {
            const d = this.getAxisMotionValue(u);
            d && ((this.originPoint[u] += l[u].translate), d.set(d.get() + l[u].translate));
          }),
          this.visualElement.render());
      });
    return () => {
      (i(), n(), s(), a && a());
    };
  }
  getProps() {
    const t = this.visualElement.getProps(),
      {
        drag: n = !1,
        dragDirectionLock: r = !1,
        dragPropagation: o = !1,
        dragConstraints: s = !1,
        dragElastic: i = Xs,
        dragMomentum: a = !0,
      } = t;
    return {
      ...t,
      drag: n,
      dragDirectionLock: r,
      dragPropagation: o,
      dragConstraints: s,
      dragElastic: i,
      dragMomentum: a,
    };
  }
}
function Wr(e, t, n) {
  return (t === !0 || t === e) && (n === null || n === e);
}
function $y(e, t = 10) {
  let n = null;
  return (Math.abs(e.y) > t ? (n = "y") : Math.abs(e.x) > t && (n = "x"), n);
}
class Wy extends tn {
  constructor(t) {
    (super(t),
      (this.removeGroupControls = yt),
      (this.removeListeners = yt),
      (this.controls = new By(t)));
  }
  mount() {
    const { dragControls: t } = this.node.getProps();
    (t && (this.removeGroupControls = t.subscribe(this.controls)),
      (this.removeListeners = this.controls.addListeners() || yt));
  }
  update() {
    const { dragControls: t } = this.node.getProps(),
      { dragControls: n } = this.node.prevProps || {};
    t !== n &&
      (this.removeGroupControls(), t && (this.removeGroupControls = t.subscribe(this.controls)));
  }
  unmount() {
    (this.removeGroupControls(), this.removeListeners(), this.controls.endPanSession());
  }
}
const Ul = (e) => (t, n) => {
  e && De.postRender(() => e(t, n));
};
class zy extends tn {
  constructor() {
    (super(...arguments), (this.removePointerDownListener = yt));
  }
  onPointerDown(t) {
    this.session = new kd(t, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: Pd(this.node),
    });
  }
  createPanHandlers() {
    const { onPanSessionStart: t, onPanStart: n, onPan: r, onPanEnd: o } = this.node.getProps();
    return {
      onSessionStart: Ul(t),
      onStart: Ul(n),
      onMove: r,
      onEnd: (s, i) => {
        (delete this.session, o && De.postRender(() => o(s, i)));
      },
    };
  }
  mount() {
    this.removePointerDownListener = gr(this.node.current, "pointerdown", (t) =>
      this.onPointerDown(t),
    );
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    (this.removePointerDownListener(), this.session && this.session.end());
  }
}
let fs = !1;
class Hy extends h.Component {
  componentDidMount() {
    const { visualElement: t, layoutGroup: n, switchLayoutGroup: r, layoutId: o } = this.props,
      { projection: s } = t;
    (s &&
      (n.group && n.group.add(s),
      r && r.register && o && r.register(s),
      fs && s.root.didUpdate(),
      s.addEventListener("animationComplete", () => {
        this.safeToRemove();
      }),
      s.setOptions({ ...s.options, onExitComplete: () => this.safeToRemove() })),
      (so.hasEverUpdated = !0));
  }
  getSnapshotBeforeUpdate(t) {
    const { layoutDependency: n, visualElement: r, drag: o, isPresent: s } = this.props,
      { projection: i } = r;
    return (
      i &&
        ((i.isPresent = s),
        (fs = !0),
        o || t.layoutDependency !== n || n === void 0 || t.isPresent !== s
          ? i.willUpdate()
          : this.safeToRemove(),
        t.isPresent !== s &&
          (s
            ? i.promote()
            : i.relegate() ||
              De.postRender(() => {
                const a = i.getStack();
                (!a || !a.members.length) && this.safeToRemove();
              }))),
      null
    );
  }
  componentDidUpdate() {
    const { projection: t } = this.props.visualElement;
    t &&
      (t.root.didUpdate(),
      Wi.postRender(() => {
        !t.currentAnimation && t.isLead() && this.safeToRemove();
      }));
  }
  componentWillUnmount() {
    const { visualElement: t, layoutGroup: n, switchLayoutGroup: r } = this.props,
      { projection: o } = t;
    ((fs = !0),
      o &&
        (o.scheduleCheckAfterUnmount(),
        n && n.group && n.group.remove(o),
        r && r.deregister && r.deregister(o)));
  }
  safeToRemove() {
    const { safeToRemove: t } = this.props;
    t && t();
  }
  render() {
    return null;
  }
}
function Ad(e) {
  const [t, n] = yd(),
    r = h.useContext(yi);
  return T.jsx(Hy, {
    ...e,
    layoutGroup: r,
    switchLayoutGroup: h.useContext(Ed),
    isPresent: t,
    safeToRemove: n,
  });
}
const Uy = { pan: { Feature: zy }, drag: { Feature: Wy, ProjectionNode: bd, MeasureLayout: Ad } };
function _l(e, t, n) {
  const { props: r } = e;
  e.animationState && r.whileHover && e.animationState.setActive("whileHover", n === "Start");
  const o = "onHover" + n,
    s = r[o];
  s && De.postRender(() => s(t, Or(t)));
}
class _y extends tn {
  mount() {
    const { current: t } = this.node;
    t &&
      (this.unmount = Pg(t, (n, r) => (_l(this.node, r, "Start"), (o) => _l(this.node, o, "End"))));
  }
  unmount() {}
}
class Yy extends tn {
  constructor() {
    (super(...arguments), (this.isActive = !1));
  }
  onFocus() {
    let t = !1;
    try {
      t = this.node.current.matches(":focus-visible");
    } catch {
      t = !0;
    }
    !t ||
      !this.node.animationState ||
      (this.node.animationState.setActive("whileFocus", !0), (this.isActive = !0));
  }
  onBlur() {
    !this.isActive ||
      !this.node.animationState ||
      (this.node.animationState.setActive("whileFocus", !1), (this.isActive = !1));
  }
  mount() {
    this.unmount = kr(
      Rr(this.node.current, "focus", () => this.onFocus()),
      Rr(this.node.current, "blur", () => this.onBlur()),
    );
  }
  unmount() {}
}
function Yl(e, t, n) {
  const { props: r } = e;
  if (e.current instanceof HTMLButtonElement && e.current.disabled) return;
  e.animationState && r.whileTap && e.animationState.setActive("whileTap", n === "Start");
  const o = "onTap" + (n === "End" ? "" : n),
    s = r[o];
  s && De.postRender(() => s(t, Or(t)));
}
class qy extends tn {
  mount() {
    const { current: t } = this.node;
    t &&
      (this.unmount = Ag(
        t,
        (n, r) => (
          Yl(this.node, r, "Start"), (o, { success: s }) => Yl(this.node, o, s ? "End" : "Cancel")
        ),
        { useGlobalTarget: this.node.props.globalTapTarget },
      ));
  }
  unmount() {}
}
const Gs = new WeakMap(),
  hs = new WeakMap(),
  Xy = (e) => {
    const t = Gs.get(e.target);
    t && t(e);
  },
  Gy = (e) => {
    e.forEach(Xy);
  };
function Ky({ root: e, ...t }) {
  const n = e || document;
  hs.has(n) || hs.set(n, {});
  const r = hs.get(n),
    o = JSON.stringify(t);
  return (r[o] || (r[o] = new IntersectionObserver(Gy, { root: e, ...t })), r[o]);
}
function Qy(e, t, n) {
  const r = Ky(t);
  return (
    Gs.set(e, n),
    r.observe(e),
    () => {
      (Gs.delete(e), r.unobserve(e));
    }
  );
}
const Zy = { some: 0, all: 1 };
class Jy extends tn {
  constructor() {
    (super(...arguments), (this.hasEnteredView = !1), (this.isInView = !1));
  }
  startObserver() {
    this.unmount();
    const { viewport: t = {} } = this.node.getProps(),
      { root: n, margin: r, amount: o = "some", once: s } = t,
      i = {
        root: n ? n.current : void 0,
        rootMargin: r,
        threshold: typeof o == "number" ? o : Zy[o],
      },
      a = (l) => {
        const { isIntersecting: c } = l;
        if (this.isInView === c || ((this.isInView = c), s && !c && this.hasEnteredView)) return;
        (c && (this.hasEnteredView = !0),
          this.node.animationState && this.node.animationState.setActive("whileInView", c));
        const { onViewportEnter: u, onViewportLeave: d } = this.node.getProps(),
          f = c ? u : d;
        f && f(l);
      };
    return Qy(this.node.current, i, a);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver > "u") return;
    const { props: t, prevProps: n } = this.node;
    ["amount", "margin", "root"].some(ex(t, n)) && this.startObserver();
  }
  unmount() {}
}
function ex({ viewport: e = {} }, { viewport: t = {} } = {}) {
  return (n) => e[n] !== t[n];
}
const tx = {
    inView: { Feature: Jy },
    tap: { Feature: qy },
    focus: { Feature: Yy },
    hover: { Feature: _y },
  },
  nx = { layout: { ProjectionNode: bd, MeasureLayout: Ad } },
  rx = { ...Py, ...tx, ...Uy, ...nx },
  un = Sy(rx, Ty);
function Ke(e, ...t) {
  const n = new URL("https://base-ui.com/production-error");
  return (
    n.searchParams.set("code", e.toString()),
    t.forEach((r) => n.searchParams.append("args[]", r)),
    `Base UI error #${e}; visit ${n} for the full message.`
  );
}
const Od = h.createContext(void 0);
function Id(e) {
  const t = h.useContext(Od);
  if (t === void 0 && !e) throw new Error(Ke(33));
  return t;
}
const Dd = h.createContext(void 0);
function Sn(e) {
  const t = h.useContext(Dd);
  if (t === void 0 && !e) throw new Error(Ke(36));
  return t;
}
const ql = {};
function ft(e, t) {
  const n = h.useRef(ql);
  return (n.current === ql && (n.current = e(t)), n);
}
function Jt(e, t, n, r) {
  const o = ft(Nd).current;
  return (sx(o, e, t, n, r) && Fd(o, [e, t, n, r]), o.callback);
}
function ox(e) {
  const t = ft(Nd).current;
  return (ix(t, e) && Fd(t, e), t.callback);
}
function Nd() {
  return { callback: null, cleanup: null, refs: [] };
}
function sx(e, t, n, r, o) {
  return e.refs[0] !== t || e.refs[1] !== n || e.refs[2] !== r || e.refs[3] !== o;
}
function ix(e, t) {
  return e.refs.length !== t.length || e.refs.some((n, r) => n !== t[r]);
}
function Fd(e, t) {
  if (((e.refs = t), t.every((n) => n == null))) {
    e.callback = null;
    return;
  }
  e.callback = (n) => {
    if ((e.cleanup && (e.cleanup(), (e.cleanup = null)), n != null)) {
      const r = Array(t.length).fill(null);
      for (let o = 0; o < t.length; o += 1) {
        const s = t[o];
        if (s != null)
          switch (typeof s) {
            case "function": {
              const i = s(n);
              typeof i == "function" && (r[o] = i);
              break;
            }
            case "object": {
              s.current = n;
              break;
            }
          }
      }
      e.cleanup = () => {
        for (let o = 0; o < t.length; o += 1) {
          const s = t[o];
          if (s != null)
            switch (typeof s) {
              case "function": {
                const i = r[o];
                typeof i == "function" ? i() : s(null);
                break;
              }
              case "object": {
                s.current = null;
                break;
              }
            }
        }
      };
    }
  };
}
const ax = parseInt(h.version, 10);
function Ki(e) {
  return ax >= e;
}
function Xl(e) {
  if (!h.isValidElement(e)) return null;
  const t = e,
    n = t.props;
  return (Ki(19) ? (n == null ? void 0 : n.ref) : t.ref) ?? null;
}
function Ks(e, t) {
  if (e && !t) return e;
  if (!e && t) return t;
  if (e || t) return { ...e, ...t };
}
function lx(e, t) {
  const n = {};
  for (const r in e) {
    const o = e[r];
    if (t != null && t.hasOwnProperty(r)) {
      const s = t[r](o);
      s != null && Object.assign(n, s);
      continue;
    }
    o === !0
      ? (n[`data-${r.toLowerCase()}`] = "")
      : o && (n[`data-${r.toLowerCase()}`] = o.toString());
  }
  return n;
}
function cx(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function ux(e, t) {
  return typeof e == "function" ? e(t) : e;
}
const br = {};
function Hn(e, t, n, r, o) {
  let s = { ...Qs(e, br) };
  return (t && (s = io(s, t)), n && (s = io(s, n)), r && (s = io(s, r)), s);
}
function dx(e) {
  if (e.length === 0) return br;
  if (e.length === 1) return Qs(e[0], br);
  let t = { ...Qs(e[0], br) };
  for (let n = 1; n < e.length; n += 1) t = io(t, e[n]);
  return t;
}
function io(e, t) {
  return Ld(t) ? t(e) : fx(e, t);
}
function fx(e, t) {
  if (!t) return e;
  for (const n in t) {
    const r = t[n];
    switch (n) {
      case "style": {
        e[n] = Ks(e.style, r);
        break;
      }
      case "className": {
        e[n] = jd(e.className, r);
        break;
      }
      default:
        hx(n, r) ? (e[n] = mx(e[n], r)) : (e[n] = r);
    }
  }
  return e;
}
function hx(e, t) {
  const n = e.charCodeAt(0),
    r = e.charCodeAt(1),
    o = e.charCodeAt(2);
  return n === 111 && r === 110 && o >= 65 && o <= 90 && (typeof t == "function" || typeof t > "u");
}
function Ld(e) {
  return typeof e == "function";
}
function Qs(e, t) {
  return Ld(e) ? e(t) : (e ?? br);
}
function mx(e, t) {
  return t
    ? e
      ? (n) => {
          if (px(n)) {
            const o = n;
            Zs(o);
            const s = t(o);
            return (o.baseUIHandlerPrevented || e == null || e(o), s);
          }
          const r = t(n);
          return (e == null || e(n), r);
        }
      : t
    : e;
}
function Zs(e) {
  return (
    (e.preventBaseUIHandler = () => {
      e.baseUIHandlerPrevented = !0;
    }),
    e
  );
}
function jd(e, t) {
  return t ? (e ? t + " " + e : t) : e;
}
function px(e) {
  return e != null && typeof e == "object" && "nativeEvent" in e;
}
function dt() {}
const xn = Object.freeze([]),
  je = Object.freeze({}),
  gx = 500,
  bx = 500,
  yx = { style: { transition: "none" } },
  xx = "data-base-ui-click-trigger",
  vx = { fallbackAxisSide: "none" },
  Vd = { fallbackAxisSide: "end" },
  wx = { clipPath: "inset(50%)", position: "fixed", top: 0, left: 0 };
function We(e, t, n = {}) {
  const r = t.render,
    o = Sx(t, n);
  if (n.enabled === !1) return null;
  const s = n.state ?? je;
  return Tx(e, r, o, s);
}
function Sx(e, t = {}) {
  const { className: n, style: r, render: o } = e,
    { state: s = je, ref: i, props: a, stateAttributesMapping: l, enabled: c = !0 } = t,
    u = c ? cx(n, s) : void 0,
    d = c ? ux(r, s) : void 0,
    f = c ? lx(s, l) : je,
    m = c ? (Ks(f, Array.isArray(a) ? dx(a) : a) ?? je) : je;
  return (
    typeof document < "u" &&
      (c
        ? Array.isArray(i)
          ? (m.ref = ox([m.ref, Xl(o), ...i]))
          : (m.ref = Jt(m.ref, Xl(o), i))
        : Jt(null, null)),
    c
      ? (u !== void 0 && (m.className = jd(m.className, u)),
        d !== void 0 && (m.style = Ks(m.style, d)),
        m)
      : je
  );
}
function Tx(e, t, n, r) {
  if (t) {
    if (typeof t == "function") return t(n, r);
    const o = Hn(n, t.props);
    return ((o.ref = n.ref), h.cloneElement(t, o));
  }
  if (e && typeof e == "string") return Rx(e, n);
  throw new Error(Ke(8));
}
function Rx(e, t) {
  return e === "button"
    ? h.createElement("button", { type: "button", ...t, key: t.key })
    : e === "img"
      ? h.createElement("img", { alt: "", ...t, key: t.key })
      : h.createElement(e, t);
}
let Er = (function (e) {
  return ((e.startingStyle = "data-starting-style"), (e.endingStyle = "data-ending-style"), e);
})({});
const Ex = { [Er.startingStyle]: "" },
  Cx = { [Er.endingStyle]: "" },
  Bd = {
    transitionStatus(e) {
      return e === "starting" ? Ex : e === "ending" ? Cx : null;
    },
  };
let Qi = (function (e) {
    return (
      (e.open = "data-open"),
      (e.closed = "data-closed"),
      (e[(e.startingStyle = Er.startingStyle)] = "startingStyle"),
      (e[(e.endingStyle = Er.endingStyle)] = "endingStyle"),
      (e.anchorHidden = "data-anchor-hidden"),
      e
    );
  })({}),
  Js = (function (e) {
    return ((e.popupOpen = "data-popup-open"), (e.pressed = "data-pressed"), e);
  })({});
const Px = { [Js.popupOpen]: "" },
  kx = { [Js.popupOpen]: "", [Js.pressed]: "" },
  Mx = { [Qi.open]: "" },
  Ax = { [Qi.closed]: "" },
  Ox = { [Qi.anchorHidden]: "" },
  Ix = {
    open(e) {
      return e ? Px : null;
    },
  },
  Gl = {
    open(e) {
      return e ? kx : null;
    },
  },
  Ir = {
    open(e) {
      return e ? Mx : Ax;
    },
    anchorHidden(e) {
      return e ? Ox : null;
    },
  },
  Dx = h.createContext(void 0);
function Vo(e = !0) {
  const t = h.useContext(Dx);
  if (t === void 0 && !e) throw new Error(Ke(25));
  return t;
}
const Un = "none",
  Yt = "trigger-press",
  et = "trigger-hover",
  Fn = "trigger-focus",
  Zi = "outside-press",
  $d = "item-press",
  _n = "focus-out",
  Bo = "escape-key",
  ao = "list-navigation",
  Nx = "cancel-open",
  fr = "sibling-open",
  Fx = "disabled",
  Wd = "imperative-action",
  ms = Uc[`useInsertionEffect${Math.random().toFixed(1)}`.slice(0, -3)],
  Lx = ms && ms !== h.useLayoutEffect ? ms : (e) => e();
function J(e) {
  const t = ft(jx).current;
  return ((t.next = e), Lx(t.effect), t.trampoline);
}
function jx() {
  const e = {
    next: void 0,
    callback: Vx,
    trampoline: (...t) => {
      var n;
      return (n = e.callback) == null ? void 0 : n.call(e, ...t);
    },
    effect: () => {
      e.callback = e.next;
    },
  };
  return e;
}
function Vx() {}
function zd({ controlled: e, default: t, name: n, state: r = "value" }) {
  const { current: o } = h.useRef(e !== void 0),
    [s, i] = h.useState(t),
    a = o ? e : s,
    l = h.useCallback((c) => {
      o || i(c);
    }, []);
  return [a, l];
}
function $o() {
  return typeof window < "u";
}
function nn(e) {
  return Ji(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function _e(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function It(e) {
  var t;
  return (t = (Ji(e) ? e.ownerDocument : e.document) || window.document) == null
    ? void 0
    : t.documentElement;
}
function Ji(e) {
  return $o() ? e instanceof Node || e instanceof _e(e).Node : !1;
}
function ke(e) {
  return $o() ? e instanceof Element || e instanceof _e(e).Element : !1;
}
function Ne(e) {
  return $o() ? e instanceof HTMLElement || e instanceof _e(e).HTMLElement : !1;
}
function ei(e) {
  return !$o() || typeof ShadowRoot > "u"
    ? !1
    : e instanceof ShadowRoot || e instanceof _e(e).ShadowRoot;
}
const Bx = new Set(["inline", "contents"]);
function Tn(e) {
  const { overflow: t, overflowX: n, overflowY: r, display: o } = ht(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !Bx.has(o);
}
const $x = new Set(["table", "td", "th"]);
function Wx(e) {
  return $x.has(nn(e));
}
const zx = [":popover-open", ":modal"];
function Wo(e) {
  return zx.some((t) => {
    try {
      return e.matches(t);
    } catch {
      return !1;
    }
  });
}
const Hx = ["transform", "translate", "scale", "rotate", "perspective"],
  Ux = ["transform", "translate", "scale", "rotate", "perspective", "filter"],
  _x = ["paint", "layout", "strict", "content"];
function ea(e) {
  const t = zo(),
    n = ke(e) ? ht(e) : e;
  return (
    Hx.some((r) => (n[r] ? n[r] !== "none" : !1)) ||
    (n.containerType ? n.containerType !== "normal" : !1) ||
    (!t && (n.backdropFilter ? n.backdropFilter !== "none" : !1)) ||
    (!t && (n.filter ? n.filter !== "none" : !1)) ||
    Ux.some((r) => (n.willChange || "").includes(r)) ||
    _x.some((r) => (n.contain || "").includes(r))
  );
}
function Yx(e) {
  let t = At(e);
  for (; Ne(t) && !Pt(t); ) {
    if (ea(t)) return t;
    if (Wo(t)) return null;
    t = At(t);
  }
  return null;
}
function zo() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
const qx = new Set(["html", "body", "#document"]);
function Pt(e) {
  return qx.has(nn(e));
}
function ht(e) {
  return _e(e).getComputedStyle(e);
}
function Ho(e) {
  return ke(e)
    ? { scrollLeft: e.scrollLeft, scrollTop: e.scrollTop }
    : { scrollLeft: e.scrollX, scrollTop: e.scrollY };
}
function At(e) {
  if (nn(e) === "html") return e;
  const t = e.assignedSlot || e.parentNode || (ei(e) && e.host) || It(e);
  return ei(t) ? t.host : t;
}
function Hd(e) {
  const t = At(e);
  return Pt(t) ? (e.ownerDocument ? e.ownerDocument.body : e.body) : Ne(t) && Tn(t) ? t : Hd(t);
}
function qt(e, t, n) {
  var r;
  (t === void 0 && (t = []), n === void 0 && (n = !0));
  const o = Hd(e),
    s = o === ((r = e.ownerDocument) == null ? void 0 : r.body),
    i = _e(o);
  if (s) {
    const a = ti(i);
    return t.concat(i, i.visualViewport || [], Tn(o) ? o : [], a && n ? qt(a) : []);
  }
  return t.concat(o, qt(o, [], n));
}
function ti(e) {
  return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;
}
const Xx = () => {},
  ee = typeof document < "u" ? h.useLayoutEffect : Xx,
  Ud = h.createContext(void 0);
function ta(e = !1) {
  const t = h.useContext(Ud);
  if (t === void 0 && !e) throw new Error(Ke(16));
  return t;
}
function Gx(e) {
  const {
      focusableWhenDisabled: t,
      disabled: n,
      composite: r = !1,
      tabIndex: o = 0,
      isNativeButton: s,
    } = e,
    i = r && t !== !1,
    a = r && t === !1;
  return {
    props: h.useMemo(() => {
      const c = {
        onKeyDown(u) {
          n && t && u.key !== "Tab" && u.preventDefault();
        },
      };
      return (
        r || ((c.tabIndex = o), !s && n && (c.tabIndex = t ? o : -1)),
        ((s && (t || i)) || (!s && n)) && (c["aria-disabled"] = n),
        s && (!t || a) && (c.disabled = n),
        c
      );
    }, [r, n, t, i, a, s, o]),
  };
}
function Uo(e = {}) {
  const { disabled: t = !1, focusableWhenDisabled: n, tabIndex: r = 0, native: o = !0 } = e,
    s = h.useRef(null),
    i = ta(!0) !== void 0,
    a = J(() => {
      const f = s.current;
      return !!((f == null ? void 0 : f.tagName) === "A" && f != null && f.href);
    }),
    { props: l } = Gx({
      focusableWhenDisabled: n,
      disabled: t,
      composite: i,
      tabIndex: r,
      isNativeButton: o,
    }),
    c = h.useCallback(() => {
      const f = s.current;
      Kx(f) && i && t && l.disabled === void 0 && f.disabled && (f.disabled = !1);
    }, [t, l.disabled, i]);
  ee(c, [c]);
  const u = h.useCallback(
      (f = {}) => {
        const { onClick: m, onMouseDown: g, onKeyUp: p, onKeyDown: v, onPointerDown: b, ...y } = f;
        return Hn(
          {
            type: o ? "button" : void 0,
            onClick(R) {
              if (t) {
                R.preventDefault();
                return;
              }
              m == null || m(R);
            },
            onMouseDown(R) {
              t || g == null || g(R);
            },
            onKeyDown(R) {
              if ((t || (Zs(R), v == null || v(R)), R.baseUIHandlerPrevented)) return;
              const x = R.target === R.currentTarget && !o && !a() && !t,
                A = R.key === "Enter",
                I = R.key === " ";
              x && ((I || A) && R.preventDefault(), A && (m == null || m(R)));
            },
            onKeyUp(R) {
              (t || (Zs(R), p == null || p(R)),
                !R.baseUIHandlerPrevented &&
                  R.target === R.currentTarget &&
                  !o &&
                  !t &&
                  R.key === " " &&
                  (m == null || m(R)));
            },
            onPointerDown(R) {
              if (t) {
                R.preventDefault();
                return;
              }
              b == null || b(R);
            },
          },
          o ? void 0 : { role: "button" },
          l,
          y,
        );
      },
      [t, l, o, a],
    ),
    d = J((f) => {
      ((s.current = f), c());
    });
  return { getButtonProps: u, buttonRef: d };
}
function Kx(e) {
  return Ne(e) && e.tagName === "BUTTON";
}
const Qx = { type: "regular-item" };
function Zx(e) {
  const {
      closeOnClick: t,
      disabled: n = !1,
      highlighted: r,
      id: o,
      store: s,
      nativeButton: i,
      itemMetadata: a,
      nodeId: l,
    } = e,
    c = h.useRef(null),
    u = Vo(!0),
    d = u !== void 0,
    { events: f } = s.useState("floatingTreeRoot"),
    { getButtonProps: m, buttonRef: g } = Uo({ disabled: n, focusableWhenDisabled: !0, native: i }),
    p = h.useCallback(
      (b) =>
        Hn(
          {
            id: o,
            role: "menuitem",
            tabIndex: r ? 0 : -1,
            onMouseMove(y) {
              l && f.emit("itemhover", { nodeId: l, target: y.currentTarget });
            },
            onMouseEnter() {
              a.type === "submenu-trigger" && a.setActive();
            },
            onKeyUp(y) {
              y.key === " " && s.context.typingRef.current && y.preventBaseUIHandler();
            },
            onClick(y) {
              t && f.emit("close", { domEvent: y, reason: $d });
            },
            onMouseUp(y) {
              if (u) {
                const w = u.initialCursorPointRef.current;
                if (
                  ((u.initialCursorPointRef.current = null),
                  d && w && Math.abs(y.clientX - w.x) <= 1 && Math.abs(y.clientY - w.y) <= 1)
                )
                  return;
              }
              c.current &&
                s.context.allowMouseUpTriggerRef.current &&
                (!d || y.button === 2) &&
                a.type === "regular-item" &&
                c.current.click();
            },
          },
          b,
          m,
        ),
      [o, r, m, t, f, s, d, u, a, l],
    ),
    v = Jt(c, g);
  return h.useMemo(() => ({ getItemProps: p, itemRef: v }), [p, v]);
}
const _d = h.createContext({
  register: () => {},
  unregister: () => {},
  subscribeMapChange: () => () => {},
  elementsRef: { current: [] },
  nextIndexRef: { current: 0 },
});
function Jx() {
  return h.useContext(_d);
}
let ev = (function (e) {
  return ((e[(e.None = 0)] = "None"), (e[(e.GuessFromOrder = 1)] = "GuessFromOrder"), e);
})({});
function na(e = {}) {
  const { label: t, metadata: n, textRef: r, indexGuessBehavior: o, index: s } = e,
    {
      register: i,
      unregister: a,
      subscribeMapChange: l,
      elementsRef: c,
      labelsRef: u,
      nextIndexRef: d,
    } = Jx(),
    f = h.useRef(-1),
    [m, g] = h.useState(
      s ??
        (o === ev.GuessFromOrder
          ? () => {
              if (f.current === -1) {
                const b = d.current;
                ((d.current += 1), (f.current = b));
              }
              return f.current;
            }
          : -1),
    ),
    p = h.useRef(null),
    v = h.useCallback(
      (b) => {
        var y;
        if (((p.current = b), m !== -1 && b !== null && ((c.current[m] = b), u))) {
          const w = t !== void 0;
          u.current[m] = w
            ? t
            : (((y = r == null ? void 0 : r.current) == null ? void 0 : y.textContent) ??
              b.textContent);
        }
      },
      [m, c, u, t, r],
    );
  return (
    ee(() => {
      if (s != null) return;
      const b = p.current;
      if (b)
        return (
          i(b, n),
          () => {
            a(b);
          }
        );
    }, [s, i, a, n]),
    ee(() => {
      if (s == null)
        return l((b) => {
          var w;
          const y = p.current ? ((w = b.get(p.current)) == null ? void 0 : w.index) : null;
          y != null && g(y);
        });
    }, [s, l, g]),
    h.useMemo(() => ({ ref: v, index: m }), [m, v])
  );
}
const tv = { ...Uc };
let Kl = 0;
function nv(e, t = "mui") {
  const [n, r] = h.useState(e),
    o = e || n;
  return (
    h.useEffect(() => {
      n == null && ((Kl += 1), r(`${t}-${Kl}`));
    }, [n, t]),
    o
  );
}
const Ql = tv.useId;
function Rn(e, t) {
  if (Ql !== void 0) {
    const n = Ql();
    return e ?? (t ? `${t}-${n}` : n);
  }
  return nv(e, t);
}
function rn(e) {
  return Rn(e, "base-ui");
}
function Te(e, t, n, r) {
  let o = !1,
    s = !1;
  const i = r ?? je;
  return {
    reason: e,
    event: t ?? new Event("base-ui"),
    cancel() {
      o = !0;
    },
    allowPropagation() {
      s = !0;
    },
    get isCanceled() {
      return o;
    },
    get isPropagationAllowed() {
      return s;
    },
    trigger: n,
    ...i,
  };
}
const rv = [];
function Yd(e) {
  h.useEffect(e, rv);
}
const zr = null;
class ov {
  constructor() {
    Ae(this, "callbacks", []);
    Ae(this, "callbacksCount", 0);
    Ae(this, "nextId", 1);
    Ae(this, "startId", 1);
    Ae(this, "isScheduled", !1);
    Ae(this, "tick", (t) => {
      var o;
      this.isScheduled = !1;
      const n = this.callbacks,
        r = this.callbacksCount;
      if (((this.callbacks = []), (this.callbacksCount = 0), (this.startId = this.nextId), r > 0))
        for (let s = 0; s < n.length; s += 1) (o = n[s]) == null || o.call(n, t);
    });
  }
  request(t) {
    const n = this.nextId;
    return (
      (this.nextId += 1),
      this.callbacks.push(t),
      (this.callbacksCount += 1),
      (!this.isScheduled || !1) && (requestAnimationFrame(this.tick), (this.isScheduled = !0)),
      n
    );
  }
  cancel(t) {
    const n = t - this.startId;
    n < 0 || n >= this.callbacks.length || ((this.callbacks[n] = null), (this.callbacksCount -= 1));
  }
}
const Hr = new ov();
class Et {
  constructor() {
    Ae(this, "currentId", zr);
    Ae(this, "cancel", () => {
      this.currentId !== zr && (Hr.cancel(this.currentId), (this.currentId = zr));
    });
    Ae(this, "disposeEffect", () => this.cancel);
  }
  static create() {
    return new Et();
  }
  static request(t) {
    return Hr.request(t);
  }
  static cancel(t) {
    return Hr.cancel(t);
  }
  request(t) {
    (this.cancel(),
      (this.currentId = Hr.request(() => {
        ((this.currentId = zr), t());
      })));
  }
}
function _o() {
  const e = ft(Et.create).current;
  return (Yd(e.disposeEffect), e);
}
function sv(e, t = !1, n = !1) {
  const [r, o] = h.useState(e && t ? "idle" : void 0),
    [s, i] = h.useState(e);
  return (
    e && !s && (i(!0), o("starting")),
    !e && s && r !== "ending" && !n && o("ending"),
    !e && !s && r === "ending" && o(void 0),
    ee(() => {
      if (!e && s && r !== "ending" && n) {
        const a = Et.request(() => {
          o("ending");
        });
        return () => {
          Et.cancel(a);
        };
      }
    }, [e, s, r, n]),
    ee(() => {
      if (!e || t) return;
      const a = Et.request(() => {
        o(void 0);
      });
      return () => {
        Et.cancel(a);
      };
    }, [t, e]),
    ee(() => {
      if (!e || !t) return;
      e && s && r !== "idle" && o("starting");
      const a = Et.request(() => {
        o("idle");
      });
      return () => {
        Et.cancel(a);
      };
    }, [t, e, s, o, r]),
    h.useMemo(() => ({ mounted: s, setMounted: i, transitionStatus: r }), [s, r])
  );
}
function Ft(e) {
  return e == null ? e : "current" in e ? e.current : e;
}
function iv(e, t = !1, n = !0) {
  const r = _o();
  return J((o, s = null) => {
    r.cancel();
    function i() {
      Rt.flushSync(o);
    }
    const a = Ft(e);
    if (a == null) return;
    const l = a;
    if (typeof l.getAnimations != "function" || globalThis.BASE_UI_ANIMATIONS_DISABLED) o();
    else {
      let c = function () {
          const d = Er.startingStyle;
          if (!l.hasAttribute(d)) {
            r.request(u);
            return;
          }
          const f = new MutationObserver(() => {
            l.hasAttribute(d) || (f.disconnect(), u());
          });
          (f.observe(l, { attributes: !0, attributeFilter: [d] }),
            s == null || s.addEventListener("abort", () => f.disconnect(), { once: !0 }));
        },
        u = function () {
          Promise.all(l.getAnimations().map((d) => d.finished))
            .then(() => {
              (s != null && s.aborted) || i();
            })
            .catch(() => {
              const d = l.getAnimations();
              if (n) {
                if (s != null && s.aborted) return;
                i();
              } else d.length > 0 && d.some((f) => f.pending || f.playState !== "finished") && u();
            });
        };
      if (t) {
        c();
        return;
      }
      r.request(u);
    }
  });
}
function ra(e) {
  const { enabled: t = !0, open: n, ref: r, onComplete: o } = e,
    s = J(o),
    i = iv(r, n, !1);
  h.useEffect(() => {
    if (!t) return;
    const a = new AbortController();
    return (
      i(s, a.signal),
      () => {
        a.abort();
      }
    );
  }, [t, n, s, i]);
}
const av = h.forwardRef(function (t, n) {
    const {
        render: r,
        className: o,
        id: s,
        label: i,
        nativeButton: a = !1,
        disabled: l = !1,
        closeOnClick: c = !0,
        ...u
      } = t,
      d = na({ label: i }),
      f = Id(!0),
      m = rn(s),
      { store: g } = Sn(),
      p = g.useState("isActive", d.index),
      v = g.useState("itemProps"),
      { getItemProps: b, itemRef: y } = Zx({
        closeOnClick: c,
        disabled: l,
        highlighted: p,
        id: m,
        store: g,
        nativeButton: a,
        nodeId: f == null ? void 0 : f.nodeId,
        itemMetadata: Qx,
      }),
      w = h.useMemo(() => ({ disabled: l, highlighted: p }), [l, p]);
    return We("div", t, { state: w, props: [v, u, b], ref: [y, n, d.ref] });
  }),
  ar = 0;
class en {
  constructor() {
    Ae(this, "currentId", ar);
    Ae(this, "clear", () => {
      this.currentId !== ar && (clearTimeout(this.currentId), (this.currentId = ar));
    });
    Ae(this, "disposeEffect", () => this.clear);
  }
  static create() {
    return new en();
  }
  start(t, n) {
    (this.clear(),
      (this.currentId = setTimeout(() => {
        ((this.currentId = ar), n());
      }, t)));
  }
  isStarted() {
    return this.currentId !== ar;
  }
}
function Ge() {
  const e = ft(en.create).current;
  return (Yd(e.disposeEffect), e);
}
function tt(e) {
  const t = ft(lv, e).current;
  return ((t.next = e), ee(t.effect), t);
}
function lv(e) {
  const t = {
    current: e,
    next: e,
    effect: () => {
      t.current = t.next;
    },
  };
  return t;
}
const Jn = typeof navigator < "u",
  ps = uv(),
  qd = fv(),
  Xd = dv(),
  Gd = typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter:none"),
  Kd =
    ps.platform === "MacIntel" && ps.maxTouchPoints > 1
      ? !0
      : /iP(hone|ad|od)|iOS/.test(ps.platform),
  Qd = Jn && /apple/i.test(navigator.vendor),
  ni = (Jn && /android/i.test(qd)) || /android/i.test(Xd),
  cv = Jn && qd.toLowerCase().startsWith("mac") && !navigator.maxTouchPoints,
  Zd = Xd.includes("jsdom/");
function uv() {
  if (!Jn) return { platform: "", maxTouchPoints: -1 };
  const e = navigator.userAgentData;
  return e != null && e.platform
    ? { platform: e.platform, maxTouchPoints: navigator.maxTouchPoints }
    : { platform: navigator.platform ?? "", maxTouchPoints: navigator.maxTouchPoints ?? -1 };
}
function dv() {
  if (!Jn) return "";
  const e = navigator.userAgentData;
  return e && Array.isArray(e.brands)
    ? e.brands.map(({ brand: t, version: n }) => `${t}/${n}`).join(" ")
    : navigator.userAgent;
}
function fv() {
  if (!Jn) return "";
  const e = navigator.userAgentData;
  return e != null && e.platform ? e.platform : (navigator.platform ?? "");
}
const ri = "data-base-ui-focusable",
  Jd = "active",
  ef = "selected",
  tf =
    "input:not([type='hidden']):not([disabled]),[contenteditable]:not([contenteditable='false']),textarea:not([disabled])",
  Xt = "ArrowLeft",
  Gt = "ArrowRight",
  oa = "ArrowUp",
  Dr = "ArrowDown";
function Tt(e) {
  var n;
  let t = e.activeElement;
  for (; ((n = t == null ? void 0 : t.shadowRoot) == null ? void 0 : n.activeElement) != null; )
    t = t.shadowRoot.activeElement;
  return t;
}
function Se(e, t) {
  var r;
  if (!e || !t) return !1;
  const n = (r = t.getRootNode) == null ? void 0 : r.call(t);
  if (e.contains(t)) return !0;
  if (n && ei(n)) {
    let o = t;
    for (; o; ) {
      if (e === o) return !0;
      o = o.parentNode || o.host;
    }
  }
  return !1;
}
function rt(e) {
  return "composedPath" in e ? e.composedPath()[0] : e.target;
}
function wt(e, t) {
  if (t == null) return !1;
  if ("composedPath" in e) return e.composedPath().includes(t);
  const n = e;
  return n.target != null && t.contains(n.target);
}
function hv(e) {
  return e.matches("html,body");
}
function $e(e) {
  return (e == null ? void 0 : e.ownerDocument) || document;
}
function sa(e) {
  return Ne(e) && e.matches(tf);
}
function oi(e) {
  return e ? e.getAttribute("role") === "combobox" && sa(e) : !1;
}
function mv(e) {
  if (!e || Zd) return !0;
  try {
    return e.matches(":focus-visible");
  } catch {
    return !0;
  }
}
function wo(e) {
  return e ? (e.hasAttribute(ri) ? e : e.querySelector(`[${ri}]`) || e) : null;
}
function yn(e, t, n = !0) {
  return e
    .filter((o) => {
      var s;
      return o.parentId === t && (!n || ((s = o.context) == null ? void 0 : s.open));
    })
    .flatMap((o) => [o, ...yn(e, o.id, n)]);
}
function Zl(e, t) {
  var o;
  let n = [],
    r = (o = e.find((s) => s.id === t)) == null ? void 0 : o.parentId;
  for (; r; ) {
    const s = e.find((i) => i.id === r);
    ((r = s == null ? void 0 : s.parentId), s && (n = n.concat(s)));
  }
  return n;
}
function Je(e) {
  (e.preventDefault(), e.stopPropagation());
}
function pv(e) {
  return "nativeEvent" in e;
}
function nf(e) {
  return e.mozInputSource === 0 && e.isTrusted
    ? !0
    : ni && e.pointerType
      ? e.type === "click" && e.buttons === 1
      : e.detail === 0 && !e.pointerType;
}
function rf(e) {
  return Zd
    ? !1
    : (!ni && e.width === 0 && e.height === 0) ||
        (ni &&
          e.width === 1 &&
          e.height === 1 &&
          e.pressure === 0 &&
          e.detail === 0 &&
          e.pointerType === "mouse") ||
        (e.width < 1 &&
          e.height < 1 &&
          e.pressure === 0 &&
          e.detail === 0 &&
          e.pointerType === "touch");
}
function vn(e, t) {
  const n = ["mouse", "pen"];
  return (t || n.push("", void 0), n.includes(e));
}
function of(e) {
  const t = e.type;
  return t === "click" || t === "mousedown" || t === "keydown" || t === "keyup";
}
const gv = ["top", "right", "bottom", "left"],
  Yn = Math.min,
  ut = Math.max,
  So = Math.round,
  Dn = Math.floor,
  kt = (e) => ({ x: e, y: e }),
  bv = { left: "right", right: "left", bottom: "top", top: "bottom" },
  yv = { start: "end", end: "start" };
function si(e, t, n) {
  return ut(e, Yn(t, n));
}
function Vt(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function lt(e) {
  return e.split("-")[0];
}
function on(e) {
  return e.split("-")[1];
}
function ia(e) {
  return e === "x" ? "y" : "x";
}
function aa(e) {
  return e === "y" ? "height" : "width";
}
const xv = new Set(["top", "bottom"]);
function gt(e) {
  return xv.has(lt(e)) ? "y" : "x";
}
function la(e) {
  return ia(gt(e));
}
function vv(e, t, n) {
  n === void 0 && (n = !1);
  const r = on(e),
    o = la(e),
    s = aa(o);
  let i =
    o === "x" ? (r === (n ? "end" : "start") ? "right" : "left") : r === "start" ? "bottom" : "top";
  return (t.reference[s] > t.floating[s] && (i = To(i)), [i, To(i)]);
}
function wv(e) {
  const t = To(e);
  return [ii(e), t, ii(t)];
}
function ii(e) {
  return e.replace(/start|end/g, (t) => yv[t]);
}
const Jl = ["left", "right"],
  ec = ["right", "left"],
  Sv = ["top", "bottom"],
  Tv = ["bottom", "top"];
function Rv(e, t, n) {
  switch (e) {
    case "top":
    case "bottom":
      return n ? (t ? ec : Jl) : t ? Jl : ec;
    case "left":
    case "right":
      return t ? Sv : Tv;
    default:
      return [];
  }
}
function Ev(e, t, n, r) {
  const o = on(e);
  let s = Rv(lt(e), n === "start", r);
  return (o && ((s = s.map((i) => i + "-" + o)), t && (s = s.concat(s.map(ii)))), s);
}
function To(e) {
  return e.replace(/left|right|bottom|top/g, (t) => bv[t]);
}
function Cv(e) {
  return { top: 0, right: 0, bottom: 0, left: 0, ...e };
}
function sf(e) {
  return typeof e != "number" ? Cv(e) : { top: e, right: e, bottom: e, left: e };
}
function Ro(e) {
  const { x: t, y: n, width: r, height: o } = e;
  return { width: r, height: o, top: n, left: t, right: t + r, bottom: n + o, x: t, y: n };
}
function Ur(e, t, n) {
  return Math.floor(e / t) !== n;
}
function Ln(e, t) {
  return t < 0 || t >= e.current.length;
}
function lo(e, t) {
  return Ze(e, { disabledIndices: t });
}
function ai(e, t) {
  return Ze(e, { decrement: !0, startingIndex: e.current.length, disabledIndices: t });
}
function Ze(
  e,
  { startingIndex: t = -1, decrement: n = !1, disabledIndices: r, amount: o = 1 } = {},
) {
  let s = t;
  do s += n ? -o : o;
  while (s >= 0 && s <= e.current.length - 1 && Kt(e, s, r));
  return s;
}
function af(
  e,
  {
    event: t,
    orientation: n,
    loopFocus: r,
    rtl: o,
    cols: s,
    disabledIndices: i,
    minIndex: a,
    maxIndex: l,
    prevIndex: c,
    stopEvent: u = !1,
  },
) {
  let d = c;
  const f = [],
    m = {};
  let g = !1;
  {
    let b = null,
      y = -1;
    e.current.forEach((w, R) => {
      if (w == null) return;
      const x = w.closest('[role="row"]');
      (x && (g = !0),
        (x !== b || y === -1) && ((b = x), (y += 1), (f[y] = [])),
        f[y].push(R),
        (m[R] = y));
    });
  }
  const p = g && f.length > 0 && f.some((b) => b.length !== s);
  function v(b) {
    if (!p || c === -1) return;
    const y = m[c];
    if (y == null) return;
    const w = f[y].indexOf(c);
    let R = b === "up" ? y - 1 : y + 1;
    r && (R < 0 ? (R = f.length - 1) : R >= f.length && (R = 0));
    const x = new Set();
    for (; R >= 0 && R < f.length && !x.has(R); ) {
      x.add(R);
      const A = f[R];
      if (A.length === 0) {
        R = b === "up" ? R - 1 : R + 1;
        continue;
      }
      const I = Math.min(w, A.length - 1);
      for (let P = I; P >= 0; P -= 1) {
        const D = A[P];
        if (!Kt(e, D, i)) return D;
      }
      ((R = b === "up" ? R - 1 : R + 1),
        r && (R < 0 ? (R = f.length - 1) : R >= f.length && (R = 0)));
    }
  }
  if (t.key === oa) {
    const b = v("up");
    if (b !== void 0) (u && Je(t), (d = b));
    else {
      if ((u && Je(t), c === -1)) d = l;
      else if (
        ((d = Ze(e, { startingIndex: d, amount: s, decrement: !0, disabledIndices: i })),
        r && (c - s < a || d < 0))
      ) {
        const y = c % s,
          w = l % s,
          R = l - (w - y);
        w === y ? (d = l) : (d = w > y ? R : R - s);
      }
      Ln(e, d) && (d = c);
    }
  }
  if (t.key === Dr) {
    const b = v("down");
    b !== void 0
      ? (u && Je(t), (d = b))
      : (u && Je(t),
        c === -1
          ? (d = a)
          : ((d = Ze(e, { startingIndex: c, amount: s, disabledIndices: i })),
            r &&
              c + s > l &&
              (d = Ze(e, { startingIndex: (c % s) - s, amount: s, disabledIndices: i }))),
        Ln(e, d) && (d = c));
  }
  if (n === "both") {
    const b = Dn(c / s);
    (t.key === (o ? Xt : Gt) &&
      (u && Je(t),
      c % s !== s - 1
        ? ((d = Ze(e, { startingIndex: c, disabledIndices: i })),
          r && Ur(d, s, b) && (d = Ze(e, { startingIndex: c - (c % s) - 1, disabledIndices: i })))
        : r && (d = Ze(e, { startingIndex: c - (c % s) - 1, disabledIndices: i })),
      Ur(d, s, b) && (d = c)),
      t.key === (o ? Gt : Xt) &&
        (u && Je(t),
        c % s !== 0
          ? ((d = Ze(e, { startingIndex: c, decrement: !0, disabledIndices: i })),
            r &&
              Ur(d, s, b) &&
              (d = Ze(e, { startingIndex: c + (s - (c % s)), decrement: !0, disabledIndices: i })))
          : r &&
            (d = Ze(e, { startingIndex: c + (s - (c % s)), decrement: !0, disabledIndices: i })),
        Ur(d, s, b) && (d = c)));
    const y = Dn(l / s) === b;
    Ln(e, d) &&
      (r && y
        ? (d =
            t.key === (o ? Gt : Xt)
              ? l
              : Ze(e, { startingIndex: c - (c % s) - 1, disabledIndices: i }))
        : (d = c));
  }
  return d;
}
function lf(e, t, n) {
  const r = [];
  let o = 0;
  return (
    e.forEach(({ width: s, height: i }, a) => {
      let l = !1;
      for (n && (o = 0); !l; ) {
        const c = [];
        for (let u = 0; u < s; u += 1) for (let d = 0; d < i; d += 1) c.push(o + u + d * t);
        (o % t) + s <= t && c.every((u) => r[u] == null)
          ? (c.forEach((u) => {
              r[u] = a;
            }),
            (l = !0))
          : (o += 1);
      }
    }),
    [...r]
  );
}
function cf(e, t, n, r, o) {
  if (e === -1) return -1;
  const s = n.indexOf(e),
    i = t[e];
  switch (o) {
    case "tl":
      return s;
    case "tr":
      return i ? s + i.width - 1 : s;
    case "bl":
      return i ? s + (i.height - 1) * r : s;
    case "br":
      return n.lastIndexOf(e);
    default:
      return -1;
  }
}
function uf(e, t) {
  return t.flatMap((n, r) => (e.includes(n) ? [r] : []));
}
function Kt(e, t, n) {
  if (typeof n == "function") return n(t);
  if (n) return n.includes(t);
  const r = e.current[t];
  return r ? r.hasAttribute("disabled") || r.getAttribute("aria-disabled") === "true" : !1;
}
/*!
 * tabbable 6.4.0
 * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
 */ var Pv = [
    "input:not([inert]):not([inert] *)",
    "select:not([inert]):not([inert] *)",
    "textarea:not([inert]):not([inert] *)",
    "a[href]:not([inert]):not([inert] *)",
    "button:not([inert]):not([inert] *)",
    "[tabindex]:not(slot):not([inert]):not([inert] *)",
    "audio[controls]:not([inert]):not([inert] *)",
    "video[controls]:not([inert]):not([inert] *)",
    '[contenteditable]:not([contenteditable="false"]):not([inert]):not([inert] *)',
    "details>summary:first-of-type:not([inert]):not([inert] *)",
    "details:not([inert]):not([inert] *)",
  ],
  Eo = Pv.join(","),
  df = typeof Element > "u",
  qn = df
    ? function () {}
    : Element.prototype.matches ||
      Element.prototype.msMatchesSelector ||
      Element.prototype.webkitMatchesSelector,
  Co =
    !df && Element.prototype.getRootNode
      ? function (e) {
          var t;
          return e == null || (t = e.getRootNode) === null || t === void 0 ? void 0 : t.call(e);
        }
      : function (e) {
          return e == null ? void 0 : e.ownerDocument;
        },
  Po = function (t, n) {
    var r;
    n === void 0 && (n = !0);
    var o =
        t == null || (r = t.getAttribute) === null || r === void 0 ? void 0 : r.call(t, "inert"),
      s = o === "" || o === "true",
      i =
        s || (n && t && (typeof t.closest == "function" ? t.closest("[inert]") : Po(t.parentNode)));
    return i;
  },
  kv = function (t) {
    var n,
      r =
        t == null || (n = t.getAttribute) === null || n === void 0
          ? void 0
          : n.call(t, "contenteditable");
    return r === "" || r === "true";
  },
  ff = function (t, n, r) {
    if (Po(t)) return [];
    var o = Array.prototype.slice.apply(t.querySelectorAll(Eo));
    return (n && qn.call(t, Eo) && o.unshift(t), (o = o.filter(r)), o);
  },
  ko = function (t, n, r) {
    for (var o = [], s = Array.from(t); s.length; ) {
      var i = s.shift();
      if (!Po(i, !1))
        if (i.tagName === "SLOT") {
          var a = i.assignedElements(),
            l = a.length ? a : i.children,
            c = ko(l, !0, r);
          r.flatten ? o.push.apply(o, c) : o.push({ scopeParent: i, candidates: c });
        } else {
          var u = qn.call(i, Eo);
          u && r.filter(i) && (n || !t.includes(i)) && o.push(i);
          var d = i.shadowRoot || (typeof r.getShadowRoot == "function" && r.getShadowRoot(i)),
            f = !Po(d, !1) && (!r.shadowRootFilter || r.shadowRootFilter(i));
          if (d && f) {
            var m = ko(d === !0 ? i.children : d.children, !0, r);
            r.flatten ? o.push.apply(o, m) : o.push({ scopeParent: i, candidates: m });
          } else s.unshift.apply(s, i.children);
        }
    }
    return o;
  },
  hf = function (t) {
    return !isNaN(parseInt(t.getAttribute("tabindex"), 10));
  },
  mf = function (t) {
    if (!t) throw new Error("No node provided");
    return t.tabIndex < 0 && (/^(AUDIO|VIDEO|DETAILS)$/.test(t.tagName) || kv(t)) && !hf(t)
      ? 0
      : t.tabIndex;
  },
  Mv = function (t, n) {
    var r = mf(t);
    return r < 0 && n && !hf(t) ? 0 : r;
  },
  Av = function (t, n) {
    return t.tabIndex === n.tabIndex ? t.documentOrder - n.documentOrder : t.tabIndex - n.tabIndex;
  },
  pf = function (t) {
    return t.tagName === "INPUT";
  },
  Ov = function (t) {
    return pf(t) && t.type === "hidden";
  },
  Iv = function (t) {
    var n =
      t.tagName === "DETAILS" &&
      Array.prototype.slice.apply(t.children).some(function (r) {
        return r.tagName === "SUMMARY";
      });
    return n;
  },
  Dv = function (t, n) {
    for (var r = 0; r < t.length; r++) if (t[r].checked && t[r].form === n) return t[r];
  },
  Nv = function (t) {
    if (!t.name) return !0;
    var n = t.form || Co(t),
      r = function (a) {
        return n.querySelectorAll('input[type="radio"][name="' + a + '"]');
      },
      o;
    if (typeof window < "u" && typeof window.CSS < "u" && typeof window.CSS.escape == "function")
      o = r(window.CSS.escape(t.name));
    else
      try {
        o = r(t.name);
      } catch (i) {
        return (
          console.error(
            "Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s",
            i.message,
          ),
          !1
        );
      }
    var s = Dv(o, t.form);
    return !s || s === t;
  },
  Fv = function (t) {
    return pf(t) && t.type === "radio";
  },
  Lv = function (t) {
    return Fv(t) && !Nv(t);
  },
  jv = function (t) {
    var n,
      r = t && Co(t),
      o = (n = r) === null || n === void 0 ? void 0 : n.host,
      s = !1;
    if (r && r !== t) {
      var i, a, l;
      for (
        s = !!(
          ((i = o) !== null &&
            i !== void 0 &&
            (a = i.ownerDocument) !== null &&
            a !== void 0 &&
            a.contains(o)) ||
          (t != null && (l = t.ownerDocument) !== null && l !== void 0 && l.contains(t))
        );
        !s && o;
      ) {
        var c, u, d;
        ((r = Co(o)),
          (o = (c = r) === null || c === void 0 ? void 0 : c.host),
          (s = !!(
            (u = o) !== null &&
            u !== void 0 &&
            (d = u.ownerDocument) !== null &&
            d !== void 0 &&
            d.contains(o)
          )));
      }
    }
    return s;
  },
  tc = function (t) {
    var n = t.getBoundingClientRect(),
      r = n.width,
      o = n.height;
    return r === 0 && o === 0;
  },
  Vv = function (t, n) {
    var r = n.displayCheck,
      o = n.getShadowRoot;
    if (r === "full-native" && "checkVisibility" in t) {
      var s = t.checkVisibility({
        checkOpacity: !1,
        opacityProperty: !1,
        contentVisibilityAuto: !0,
        visibilityProperty: !0,
        checkVisibilityCSS: !0,
      });
      return !s;
    }
    if (getComputedStyle(t).visibility === "hidden") return !0;
    var i = qn.call(t, "details>summary:first-of-type"),
      a = i ? t.parentElement : t;
    if (qn.call(a, "details:not([open]) *")) return !0;
    if (!r || r === "full" || r === "full-native" || r === "legacy-full") {
      if (typeof o == "function") {
        for (var l = t; t; ) {
          var c = t.parentElement,
            u = Co(t);
          if (c && !c.shadowRoot && o(c) === !0) return tc(t);
          t.assignedSlot
            ? (t = t.assignedSlot)
            : !c && u !== t.ownerDocument
              ? (t = u.host)
              : (t = c);
        }
        t = l;
      }
      if (jv(t)) return !t.getClientRects().length;
      if (r !== "legacy-full") return !0;
    } else if (r === "non-zero-area") return tc(t);
    return !1;
  },
  Bv = function (t) {
    if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(t.tagName))
      for (var n = t.parentElement; n; ) {
        if (n.tagName === "FIELDSET" && n.disabled) {
          for (var r = 0; r < n.children.length; r++) {
            var o = n.children.item(r);
            if (o.tagName === "LEGEND")
              return qn.call(n, "fieldset[disabled] *") ? !0 : !o.contains(t);
          }
          return !0;
        }
        n = n.parentElement;
      }
    return !1;
  },
  li = function (t, n) {
    return !(n.disabled || Ov(n) || Vv(n, t) || Iv(n) || Bv(n));
  },
  ci = function (t, n) {
    return !(Lv(n) || mf(n) < 0 || !li(t, n));
  },
  $v = function (t) {
    var n = parseInt(t.getAttribute("tabindex"), 10);
    return !!(isNaN(n) || n >= 0);
  },
  gf = function (t) {
    var n = [],
      r = [];
    return (
      t.forEach(function (o, s) {
        var i = !!o.scopeParent,
          a = i ? o.scopeParent : o,
          l = Mv(a, i),
          c = i ? gf(o.candidates) : a;
        l === 0
          ? i
            ? n.push.apply(n, c)
            : n.push(a)
          : r.push({ documentOrder: s, tabIndex: l, item: o, isScope: i, content: c });
      }),
      r
        .sort(Av)
        .reduce(function (o, s) {
          return (s.isScope ? o.push.apply(o, s.content) : o.push(s.content), o);
        }, [])
        .concat(n)
    );
  },
  Nr = function (t, n) {
    n = n || {};
    var r;
    return (
      n.getShadowRoot
        ? (r = ko([t], n.includeContainer, {
            filter: ci.bind(null, n),
            flatten: !1,
            getShadowRoot: n.getShadowRoot,
            shadowRootFilter: $v,
          }))
        : (r = ff(t, n.includeContainer, ci.bind(null, n))),
      gf(r)
    );
  },
  Wv = function (t, n) {
    n = n || {};
    var r;
    return (
      n.getShadowRoot
        ? (r = ko([t], n.includeContainer, {
            filter: li.bind(null, n),
            flatten: !0,
            getShadowRoot: n.getShadowRoot,
          }))
        : (r = ff(t, n.includeContainer, li.bind(null, n))),
      r
    );
  },
  bf = function (t, n) {
    if (((n = n || {}), !t)) throw new Error("No node provided");
    return qn.call(t, Eo) === !1 ? !1 : ci(n, t);
  };
const er = () => ({
  getShadowRoot: !0,
  displayCheck:
    typeof ResizeObserver == "function" && ResizeObserver.toString().includes("[native code]")
      ? "full"
      : "none",
});
function yf(e, t) {
  const n = Nr(e, er()),
    r = n.length;
  if (r === 0) return;
  const o = Tt($e(e)),
    s = n.indexOf(o),
    i = s === -1 ? (t === 1 ? 0 : r - 1) : s + t;
  return n[i];
}
function ca(e) {
  return yf($e(e).body, 1) || e;
}
function xf(e) {
  return yf($e(e).body, -1) || e;
}
function vf(e, t) {
  if (!e) return null;
  const n = Nr($e(e).body, er()),
    r = n.length;
  if (r === 0) return null;
  const o = n.indexOf(e);
  if (o === -1) return null;
  const s = (o + t + r) % r;
  return n[s];
}
function zv(e) {
  return vf(e, 1);
}
function Hv(e) {
  return vf(e, -1);
}
function jn(e, t) {
  const n = t || e.currentTarget,
    r = e.relatedTarget;
  return !r || !Se(n, r);
}
function Uv(e) {
  Nr(e, er()).forEach((n) => {
    ((n.dataset.tabindex = n.getAttribute("tabindex") || ""), n.setAttribute("tabindex", "-1"));
  });
}
function nc(e) {
  e.querySelectorAll("[data-tabindex]").forEach((n) => {
    const r = n.dataset.tabindex;
    (delete n.dataset.tabindex, r ? n.setAttribute("tabindex", r) : n.removeAttribute("tabindex"));
  });
}
function wf() {
  const e = new Map();
  return {
    emit(t, n) {
      var r;
      (r = e.get(t)) == null || r.forEach((o) => o(n));
    },
    on(t, n) {
      (e.has(t) || e.set(t, new Set()), e.get(t).add(n));
    },
    off(t, n) {
      var r;
      (r = e.get(t)) == null || r.delete(n);
    },
  };
}
class ua {
  constructor() {
    Ae(this, "nodesRef", { current: [] });
    Ae(this, "events", wf());
  }
  addNode(t) {
    this.nodesRef.current.push(t);
  }
  removeNode(t) {
    const n = this.nodesRef.current.findIndex((r) => r === t);
    n !== -1 && this.nodesRef.current.splice(n, 1);
  }
}
const Sf = h.createContext(null),
  Tf = h.createContext(null),
  Bt = () => {
    var e;
    return ((e = h.useContext(Sf)) == null ? void 0 : e.id) || null;
  },
  sn = (e) => {
    const t = h.useContext(Tf);
    return e ?? t;
  };
function Rf(e) {
  const t = Rn(),
    n = sn(e),
    r = Bt();
  return (
    ee(() => {
      if (!t) return;
      const o = { id: t, parentId: r };
      return (
        n == null || n.addNode(o),
        () => {
          n == null || n.removeNode(o);
        }
      );
    }, [n, t, r]),
    t
  );
}
function _v(e) {
  const { children: t, id: n } = e,
    r = Bt();
  return T.jsx(Sf.Provider, {
    value: h.useMemo(() => ({ id: n, parentId: r }), [n, r]),
    children: t,
  });
}
function Yv(e) {
  const { children: t, externalTree: n } = e,
    r = ft(() => n ?? new ua()).current;
  return T.jsx(Tf.Provider, { value: r, children: t });
}
function Xn(e) {
  return `data-base-ui-${e}`;
}
function co(e, t, n) {
  if (n && !vn(n)) return 0;
  if (typeof e == "number") return e;
  if (typeof e == "function") {
    const r = e();
    return typeof r == "number" ? r : r == null ? void 0 : r[t];
  }
  return e == null ? void 0 : e[t];
}
const Ef = h.createContext({
  hasProvider: !1,
  timeoutMs: 0,
  delayRef: { current: 0 },
  initialDelayRef: { current: 0 },
  timeout: new en(),
  currentIdRef: { current: null },
  currentContextRef: { current: null },
});
function qv(e) {
  const { children: t, delay: n, timeoutMs: r = 0 } = e,
    o = h.useRef(n),
    s = h.useRef(n),
    i = h.useRef(null),
    a = h.useRef(null),
    l = Ge();
  return T.jsx(Ef.Provider, {
    value: h.useMemo(
      () => ({
        hasProvider: !0,
        delayRef: o,
        initialDelayRef: s,
        currentIdRef: i,
        timeoutMs: r,
        currentContextRef: a,
        timeout: l,
      }),
      [r, l],
    ),
    children: t,
  });
}
function Xv(e, t = { open: !1 }) {
  const n = "rootStore" in e ? e.rootStore : e,
    r = n.useState("floatingId"),
    { enabled: o = !0, open: s } = t,
    i = h.useContext(Ef),
    {
      currentIdRef: a,
      delayRef: l,
      timeoutMs: c,
      initialDelayRef: u,
      currentContextRef: d,
      hasProvider: f,
      timeout: m,
    } = i,
    [g, p] = h.useState(!1);
  return (
    ee(() => {
      function v() {
        var b;
        (p(!1),
          (b = d.current) == null || b.setIsInstantPhase(!1),
          (a.current = null),
          (d.current = null),
          (l.current = u.current));
      }
      if (o && a.current && !s && a.current === r) {
        if ((p(!1), c)) {
          const b = r;
          return (
            m.start(c, () => {
              n.select("open") || (a.current && a.current !== b) || v();
            }),
            () => {
              m.clear();
            }
          );
        }
        v();
      }
    }, [o, s, r, a, l, c, u, d, m, n]),
    ee(() => {
      if (!o || !s) return;
      const v = d.current,
        b = a.current;
      (m.clear(),
        (d.current = { onOpenChange: n.setOpen, setIsInstantPhase: p }),
        (a.current = r),
        (l.current = { open: 0, close: co(u.current, "close") }),
        b !== null && b !== r
          ? (p(!0), v == null || v.setIsInstantPhase(!0), v == null || v.onOpenChange(!1, Te(Un)))
          : (p(!1), v == null || v.setIsInstantPhase(!1)));
    }, [o, s, r, n, a, l, c, u, d, m]),
    ee(
      () => () => {
        d.current = null;
      },
      [d],
    ),
    h.useMemo(() => ({ hasProvider: f, delayRef: l, isInstantPhase: g }), [f, l, g])
  );
}
const Cf = {
    clipPath: "inset(50%)",
    overflow: "hidden",
    whiteSpace: "nowrap",
    border: 0,
    padding: 0,
    width: 1,
    height: 1,
    margin: -1,
  },
  da = { ...Cf, position: "fixed", top: 0, left: 0 },
  Gv = { ...Cf, position: "absolute" };
function xt(e) {
  return (e == null ? void 0 : e.ownerDocument) || document;
}
const Gn = h.forwardRef(function (t, n) {
  const [r, o] = h.useState();
  ee(() => {
    Qd && o("button");
  }, []);
  const s = { tabIndex: 0, role: r };
  return T.jsx("span", {
    ...t,
    ref: n,
    style: da,
    "aria-hidden": r ? void 0 : !0,
    ...s,
    "data-base-ui-focus-guard": "",
  });
});
let rc = 0;
function uo(e, t = {}) {
  const { preventScroll: n = !1, cancelPrevious: r = !0, sync: o = !1 } = t;
  r && cancelAnimationFrame(rc);
  const s = () => (e == null ? void 0 : e.focus({ preventScroll: n }));
  o ? s() : (rc = requestAnimationFrame(s));
}
const Vn = { inert: new WeakMap(), "aria-hidden": new WeakMap(), none: new WeakMap() };
function oc(e) {
  return e === "inert" ? Vn.inert : e === "aria-hidden" ? Vn["aria-hidden"] : Vn.none;
}
let _r = new WeakSet(),
  Yr = {},
  gs = 0;
const Pf = (e) => e && (e.host || Pf(e.parentNode)),
  Kv = (e, t) =>
    t
      .map((n) => {
        if (e.contains(n)) return n;
        const r = Pf(n);
        return e.contains(r) ? r : null;
      })
      .filter((n) => n != null);
function Qv(e, t, n, r) {
  const o = "data-base-ui-inert",
    s = r ? "inert" : n ? "aria-hidden" : null,
    i = Kv(t, e),
    a = new Set(),
    l = new Set(i),
    c = [];
  Yr[o] || (Yr[o] = new WeakMap());
  const u = Yr[o];
  (i.forEach(d), f(t), a.clear());
  function d(m) {
    !m || a.has(m) || (a.add(m), m.parentNode && d(m.parentNode));
  }
  function f(m) {
    !m ||
      l.has(m) ||
      [].forEach.call(m.children, (g) => {
        if (nn(g) !== "script")
          if (a.has(g)) f(g);
          else {
            const p = s ? g.getAttribute(s) : null,
              v = p !== null && p !== "false",
              b = oc(s),
              y = (b.get(g) || 0) + 1,
              w = (u.get(g) || 0) + 1;
            (b.set(g, y),
              u.set(g, w),
              c.push(g),
              y === 1 && v && _r.add(g),
              w === 1 && g.setAttribute(o, ""),
              !v && s && g.setAttribute(s, s === "inert" ? "" : "true"));
          }
      });
  }
  return (
    (gs += 1),
    () => {
      (c.forEach((m) => {
        const g = oc(s),
          v = (g.get(m) || 0) - 1,
          b = (u.get(m) || 0) - 1;
        (g.set(m, v),
          u.set(m, b),
          v || (!_r.has(m) && s && m.removeAttribute(s), _r.delete(m)),
          b || m.removeAttribute(o));
      }),
        (gs -= 1),
        gs ||
          ((Vn.inert = new WeakMap()),
          (Vn["aria-hidden"] = new WeakMap()),
          (Vn.none = new WeakMap()),
          (_r = new WeakSet()),
          (Yr = {})));
    }
  );
}
function Zv(e, t = !1, n = !1) {
  const r = $e(e[0]).body;
  return Qv(e.concat(Array.from(r.querySelectorAll("[aria-live]"))), r, t, n);
}
const kf = h.createContext(null),
  Mf = () => h.useContext(kf),
  Jv = Xn("portal");
function Af(e = {}) {
  const { ref: t, container: n, componentProps: r = je, elementProps: o, elementState: s } = e,
    i = Rn(),
    a = Mf(),
    l = a == null ? void 0 : a.portalNode,
    [c, u] = h.useState(null),
    [d, f] = h.useState(null),
    m = J((b) => {
      b !== null && f(b);
    }),
    g = h.useRef(null);
  ee(() => {
    if (n === null) {
      g.current && ((g.current = null), f(null), u(null));
      return;
    }
    if (i == null) return;
    const b = (n && (Ji(n) ? n : n.current)) ?? l ?? document.body;
    if (b == null) {
      g.current && ((g.current = null), f(null), u(null));
      return;
    }
    g.current !== b && ((g.current = b), f(null), u(b));
  }, [n, l, i]);
  const p = We("div", r, { ref: [t, m], state: s, props: [{ id: i, [Jv]: "" }, o] });
  return { portalNode: d, portalSubtree: c && p ? Rt.createPortal(p, c) : null };
}
const ew = h.forwardRef(function (t, n) {
  const { children: r, container: o, className: s, render: i, renderGuards: a, ...l } = t,
    { portalNode: c, portalSubtree: u } = Af({
      container: o,
      ref: n,
      componentProps: t,
      elementProps: l,
    }),
    d = h.useRef(null),
    f = h.useRef(null),
    m = h.useRef(null),
    g = h.useRef(null),
    [p, v] = h.useState(null),
    b = p == null ? void 0 : p.modal,
    y = p == null ? void 0 : p.open,
    w = typeof a == "boolean" ? a : !!p && !p.modal && p.open && !!c;
  (h.useEffect(() => {
    if (!c || b) return;
    function x(A) {
      c && A.relatedTarget && jn(A) && (A.type === "focusin" ? nc : Uv)(c);
    }
    return (
      c.addEventListener("focusin", x, !0),
      c.addEventListener("focusout", x, !0),
      () => {
        (c.removeEventListener("focusin", x, !0), c.removeEventListener("focusout", x, !0));
      }
    );
  }, [c, b]),
    h.useEffect(() => {
      !c || y || nc(c);
    }, [y, c]));
  const R = h.useMemo(
    () => ({
      beforeOutsideRef: d,
      afterOutsideRef: f,
      beforeInsideRef: m,
      afterInsideRef: g,
      portalNode: c,
      setFocusManagerState: v,
    }),
    [c],
  );
  return T.jsxs(h.Fragment, {
    children: [
      u,
      T.jsxs(kf.Provider, {
        value: R,
        children: [
          w &&
            c &&
            T.jsx(Gn, {
              "data-type": "outside",
              ref: d,
              onFocus: (x) => {
                var A;
                if (jn(x, c)) (A = m.current) == null || A.focus();
                else {
                  const I = p ? p.domReference : null,
                    P = xf(I);
                  P == null || P.focus();
                }
              },
            }),
          w && c && T.jsx("span", { "aria-owns": c.id, style: wx }),
          c && Rt.createPortal(r, c),
          w &&
            c &&
            T.jsx(Gn, {
              "data-type": "outside",
              ref: f,
              onFocus: (x) => {
                var A;
                if (jn(x, c)) (A = g.current) == null || A.focus();
                else {
                  const I = p ? p.domReference : null,
                    P = ca(I);
                  (P == null || P.focus(),
                    p != null &&
                      p.closeOnFocusOut &&
                      (p == null || p.onOpenChange(!1, Te(_n, x.nativeEvent))));
                }
              },
            }),
        ],
      }),
    ],
  });
});
function tw(e, t) {
  const n = _e(e.target);
  return e instanceof n.KeyboardEvent
    ? "keyboard"
    : e instanceof n.FocusEvent
      ? t || "keyboard"
      : "pointerType" in e
        ? e.pointerType || "keyboard"
        : "touches" in e
          ? "touch"
          : e instanceof n.MouseEvent
            ? t || (e.detail === 0 ? "keyboard" : "mouse")
            : "";
}
const sc = 20;
let Ut = [];
function fa() {
  Ut = Ut.filter((e) => e.isConnected);
}
function nw(e) {
  (fa(), e && nn(e) !== "body" && (Ut.push(e), Ut.length > sc && (Ut = Ut.slice(-sc))));
}
function bs() {
  return (fa(), Ut[Ut.length - 1]);
}
function rw(e) {
  if (!e) return null;
  const t = er();
  return bf(e, t) ? e : Nr(e, t)[0] || e;
}
function ow(e) {
  return !e || !e.isConnected
    ? !1
    : typeof e.checkVisibility == "function"
      ? e.checkVisibility()
      : ht(e).display !== "none";
}
function ic(e, t) {
  var i;
  if (
    !t.current.includes("floating") &&
    !((i = e.getAttribute("role")) != null && i.includes("dialog"))
  )
    return;
  const n = er(),
    o = Wv(e, n).filter((a) => {
      const l = a.getAttribute("data-tabindex") || "";
      return bf(a, n) || (a.hasAttribute("data-tabindex") && !l.startsWith("-"));
    }),
    s = e.getAttribute("tabindex");
  t.current.includes("floating") || o.length === 0
    ? s !== "0" && e.setAttribute("tabindex", "0")
    : (s !== "-1" ||
        (e.hasAttribute("data-tabindex") && e.getAttribute("data-tabindex") !== "-1")) &&
      (e.setAttribute("tabindex", "-1"), e.setAttribute("data-tabindex", "-1"));
}
function sw(e) {
  const {
      context: t,
      children: n,
      disabled: r = !1,
      order: o = ["content"],
      initialFocus: s = !0,
      returnFocus: i = !0,
      restoreFocus: a = !1,
      modal: l = !0,
      closeOnFocusOut: c = !0,
      openInteractionType: u = "",
      getInsideElements: d = () => [],
      nextFocusableElement: f,
      previousFocusableElement: m,
      beforeContentFocusGuardRef: g,
      externalTree: p,
    } = e,
    v = "rootStore" in t ? t.rootStore : t,
    b = v.useState("open"),
    y = v.useState("domReferenceElement"),
    w = v.useState("floatingElement"),
    { events: R, dataRef: x } = v.context,
    A = J(() => {
      var z;
      return (z = x.current.floatingContext) == null ? void 0 : z.nodeId;
    }),
    I = J(d),
    P = s === !1,
    D = oi(y) && P,
    V = tt(o),
    B = tt(s),
    M = tt(i),
    C = tt(u),
    L = sn(p),
    k = Mf(),
    F = h.useRef(null),
    E = h.useRef(null),
    S = h.useRef(!1),
    O = h.useRef(!1),
    j = h.useRef(!1),
    _ = h.useRef(-1),
    Q = h.useRef(""),
    $ = h.useRef(""),
    Y = h.useRef(null),
    ne = h.useRef(null),
    te = Jt(Y, g, k == null ? void 0 : k.beforeInsideRef),
    H = Jt(ne, k == null ? void 0 : k.afterInsideRef),
    ue = Ge(),
    le = Ge(),
    ce = _o(),
    pe = k != null,
    N = wo(w),
    X = J((z = N) => (z ? Nr(z, er()) : [])),
    q = J((z) => {
      const W = X(z);
      return V.current
        .map(() => W)
        .filter(Boolean)
        .flat();
    });
  (h.useEffect(() => {
    if (r || !l) return;
    function z(G) {
      G.key === "Tab" && Se(N, Tt($e(N))) && X().length === 0 && !D && Je(G);
    }
    const W = $e(N);
    return (
      W.addEventListener("keydown", z),
      () => {
        W.removeEventListener("keydown", z);
      }
    );
  }, [r, y, N, l, V, D, X, q]),
    h.useEffect(() => {
      if (r || !w) return;
      function z(W) {
        const G = rt(W),
          he = X().indexOf(G);
        he !== -1 && (_.current = he);
      }
      return (
        w.addEventListener("focusin", z),
        () => {
          w.removeEventListener("focusin", z);
        }
      );
    }, [r, w, X]),
    h.useEffect(() => {
      if (r || !b) return;
      const z = $e(N);
      function W() {
        j.current = !1;
      }
      function G(he) {
        const ae = rt(he),
          de = Se(w, ae) || Se(y, ae) || Se(k == null ? void 0 : k.portalNode, ae);
        ((j.current = !de), ($.current = he.pointerType || "keyboard"));
      }
      function ie() {
        $.current = "keyboard";
      }
      return (
        z.addEventListener("pointerdown", G, !0),
        z.addEventListener("pointerup", W, !0),
        z.addEventListener("pointercancel", W, !0),
        z.addEventListener("keydown", ie, !0),
        () => {
          (z.removeEventListener("pointerdown", G, !0),
            z.removeEventListener("pointerup", W, !0),
            z.removeEventListener("pointercancel", W, !0),
            z.removeEventListener("keydown", ie, !0));
        }
      );
    }, [r, w, y, N, b, k]),
    h.useEffect(() => {
      if (r || !c) return;
      function z() {
        ((O.current = !0),
          le.start(0, () => {
            O.current = !1;
          }));
      }
      function W(ae) {
        const de = ae.relatedTarget,
          U = ae.currentTarget,
          Z = rt(ae);
        queueMicrotask(() => {
          const K = A(),
            xe = v.context.triggerElements,
            Re =
              (de == null ? void 0 : de.hasAttribute(Xn("focus-guard"))) &&
              [
                Y.current,
                ne.current,
                k == null ? void 0 : k.beforeInsideRef.current,
                k == null ? void 0 : k.afterInsideRef.current,
                k == null ? void 0 : k.beforeOutsideRef.current,
                k == null ? void 0 : k.afterOutsideRef.current,
                Ft(m),
                Ft(f),
              ].includes(de),
            Ee = !(
              Se(y, de) ||
              Se(w, de) ||
              Se(de, w) ||
              Se(k == null ? void 0 : k.portalNode, de) ||
              (de != null && xe.hasElement(de)) ||
              xe.hasMatchingElement((Ce) => Se(Ce, de)) ||
              Re ||
              (L &&
                (yn(L.nodesRef.current, K).find((Ce) => {
                  var Oe, Ie;
                  return (
                    Se((Oe = Ce.context) == null ? void 0 : Oe.elements.floating, de) ||
                    Se((Ie = Ce.context) == null ? void 0 : Ie.elements.domReference, de)
                  );
                }) ||
                  Zl(L.nodesRef.current, K).find((Ce) => {
                    var Oe, Ie, ze;
                    return (
                      [
                        (Oe = Ce.context) == null ? void 0 : Oe.elements.floating,
                        wo((Ie = Ce.context) == null ? void 0 : Ie.elements.floating),
                      ].includes(de) ||
                      ((ze = Ce.context) == null ? void 0 : ze.elements.domReference) === de
                    );
                  })))
            );
          if ((U === y && N && ic(N, V), a && U !== y && !ow(Z) && Tt($e(N)) === $e(N).body)) {
            if (Ne(N) && (N.focus(), a === "popup")) {
              ce.request(() => {
                N.focus();
              });
              return;
            }
            const Ce = _.current,
              Oe = X(),
              Ie = Oe[Ce] || Oe[Oe.length - 1] || N;
            Ne(Ie) && Ie.focus();
          }
          if (x.current.insideReactTree) {
            x.current.insideReactTree = !1;
            return;
          }
          (D || !l) &&
            de &&
            Ee &&
            !O.current &&
            (D || de !== bs()) &&
            ((S.current = !0), v.setOpen(!1, Te(_n, ae)));
        });
      }
      function G() {
        j.current ||
          ((x.current.insideReactTree = !0),
          ue.start(0, () => {
            x.current.insideReactTree = !1;
          }));
      }
      const ie = Ne(y) ? y : null,
        he = [];
      if (!(!w && !ie))
        return (
          ie &&
            (ie.addEventListener("focusout", W),
            ie.addEventListener("pointerdown", z),
            he.push(() => {
              (ie.removeEventListener("focusout", W), ie.removeEventListener("pointerdown", z));
            })),
          w &&
            (w.addEventListener("focusout", W),
            k &&
              (w.addEventListener("focusout", G, !0),
              he.push(() => {
                w.removeEventListener("focusout", G, !0);
              })),
            he.push(() => {
              w.removeEventListener("focusout", W);
            })),
          () => {
            he.forEach((ae) => {
              ae();
            });
          }
        );
    }, [r, y, w, N, l, L, k, v, c, a, X, D, A, V, x, ue, le, ce, f, m]),
    h.useEffect(() => {
      var ae, de, U;
      if (r || !w || !b) return;
      const z = Array.from(
          ((ae = k == null ? void 0 : k.portalNode) == null
            ? void 0
            : ae.querySelectorAll(`[${Xn("portal")}]`)) || [],
        ),
        G =
          (U =
            (de = (L ? Zl(L.nodesRef.current, A()) : []).find((Z) => {
              var K;
              return oi(((K = Z.context) == null ? void 0 : K.elements.domReference) || null);
            })) == null
              ? void 0
              : de.context) == null
            ? void 0
            : U.elements.domReference,
        ie = [
          w,
          G,
          ...z,
          ...I(),
          F.current,
          E.current,
          Y.current,
          ne.current,
          k == null ? void 0 : k.beforeOutsideRef.current,
          k == null ? void 0 : k.afterOutsideRef.current,
          Ft(m),
          Ft(f),
          D ? y : null,
        ].filter((Z) => Z != null),
        he = Zv(ie, l || D);
      return () => {
        he();
      };
    }, [b, r, y, w, l, V, k, D, L, A, I, f, m]),
    ee(() => {
      if (!b || r || !Ne(N)) return;
      const z = $e(N),
        W = Tt(z);
      queueMicrotask(() => {
        const G = q(N),
          ie = B.current,
          he = typeof ie == "function" ? ie(C.current || "") : ie;
        if (he === void 0 || he === !1) return;
        let ae;
        (he === !0 || he === null ? (ae = G[0] || N) : (ae = Ft(he)),
          (ae = ae || G[0] || N),
          !Se(N, W) && uo(ae, { preventScroll: ae === N }));
      });
    }, [r, b, N, P, q, B, C]),
    ee(() => {
      if (r || !N) return;
      const z = $e(N),
        W = Tt(z);
      nw(W);
      function G(ae) {
        if (
          (ae.open || (Q.current = tw(ae.nativeEvent, $.current)),
          ae.reason === et && ae.nativeEvent.type === "mouseleave" && (S.current = !0),
          ae.reason === Zi)
        )
          if (ae.nested) S.current = !1;
          else if (nf(ae.nativeEvent) || rf(ae.nativeEvent)) S.current = !1;
          else {
            let de = !1;
            (document.createElement("div").focus({
              get preventScroll() {
                return ((de = !0), !1);
              },
            }),
              de ? (S.current = !1) : (S.current = !0));
          }
      }
      R.on("openchange", G);
      const ie = z.createElement("span");
      (ie.setAttribute("tabindex", "-1"),
        ie.setAttribute("aria-hidden", "true"),
        Object.assign(ie.style, da),
        pe && y && y.insertAdjacentElement("afterend", ie));
      function he() {
        const ae = M.current;
        let de = typeof ae == "function" ? ae(Q.current) : ae;
        if (de === void 0 || de === !1) return null;
        if ((de === null && (de = !0), typeof de == "boolean")) {
          const Z = y || bs();
          return Z && Z.isConnected ? Z : ie;
        }
        const U = y || bs() || ie;
        return Ft(de) || U;
      }
      return () => {
        R.off("openchange", G);
        const ae = Tt(z),
          de =
            Se(w, ae) ||
            (L &&
              yn(L.nodesRef.current, A(), !1).some((Z) => {
                var K;
                return Se((K = Z.context) == null ? void 0 : K.elements.floating, ae);
              })),
          U = he();
        queueMicrotask(() => {
          const Z = rw(U),
            K = typeof M.current != "boolean";
          (M.current &&
            !S.current &&
            Ne(Z) &&
            (!(!K && Z !== ae && ae !== z.body) || de) &&
            Z.focus({ preventScroll: !0 }),
            ie.remove());
        });
      };
    }, [r, w, N, M, x, R, L, pe, y, A]),
    h.useEffect(() => {
      queueMicrotask(() => {
        S.current = !1;
      });
    }, [r]),
    h.useEffect(() => {
      if (r || !b) return;
      function z(G) {
        const ie = rt(G);
        ie != null && ie.closest(`[${xx}]`) && (O.current = !0);
      }
      const W = $e(N);
      return (
        W.addEventListener("pointerdown", z, !0),
        () => {
          W.removeEventListener("pointerdown", z, !0);
        }
      );
    }, [r, b, N]),
    ee(() => {
      if (!r && k)
        return (
          k.setFocusManagerState({
            modal: l,
            closeOnFocusOut: c,
            open: b,
            onOpenChange: v.setOpen,
            domReference: y,
          }),
          () => {
            k.setFocusManagerState(null);
          }
        );
    }, [r, k, l, b, v, c, y]),
    ee(() => {
      if (!(r || !N))
        return (
          ic(N, V),
          () => {
            queueMicrotask(fa);
          }
        );
    }, [r, N, V]));
  const we = !r && (l ? !D : !0) && (pe || l);
  return T.jsxs(h.Fragment, {
    children: [
      we &&
        T.jsx(Gn, {
          "data-type": "inside",
          ref: te,
          onFocus: (z) => {
            var W;
            if (l) {
              const G = q();
              uo(G[G.length - 1]);
            } else if (k != null && k.portalNode)
              if (((S.current = !1), jn(z, k.portalNode))) {
                const G = ca(y);
                G == null || G.focus();
              } else (W = Ft(m ?? k.beforeOutsideRef)) == null || W.focus();
          },
        }),
      n,
      we &&
        T.jsx(Gn, {
          "data-type": "inside",
          ref: H,
          onFocus: (z) => {
            var W;
            if (l) uo(q()[0]);
            else if (k != null && k.portalNode)
              if ((c && (S.current = !0), jn(z, k.portalNode))) {
                const G = xf(y);
                G == null || G.focus();
              } else (W = Ft(f ?? k.afterOutsideRef)) == null || W.focus();
          },
        }),
    ],
  });
}
function iw(e, t = {}) {
  const n = "rootStore" in e ? e.rootStore : e,
    r = n.context.dataRef,
    {
      enabled: o = !0,
      event: s = "click",
      toggle: i = !0,
      ignoreMouse: a = !1,
      stickIfOpen: l = !0,
      touchOpenDelay: c = 0,
    } = t,
    u = h.useRef(void 0),
    d = _o(),
    f = Ge(),
    m = h.useMemo(
      () => ({
        onPointerDown(g) {
          u.current = g.pointerType;
        },
        onMouseDown(g) {
          const p = u.current,
            v = g.nativeEvent,
            b = n.select("open");
          if (g.button !== 0 || s === "click" || (vn(p, !0) && a)) return;
          const y = r.current.openEvent,
            w = y == null ? void 0 : y.type,
            R = n.select("domReferenceElement") !== g.currentTarget,
            x = (b && R) || !(b && i && (!(y && l) || w === "click" || w === "mousedown"));
          if (sa(v.target)) {
            const I = Te(Yt, v, v.target);
            x && p === "touch" && c > 0
              ? f.start(c, () => {
                  n.setOpen(!0, I);
                })
              : n.setOpen(x, I);
            return;
          }
          const A = g.currentTarget;
          d.request(() => {
            const I = Te(Yt, v, A);
            x && p === "touch" && c > 0
              ? f.start(c, () => {
                  n.setOpen(!0, I);
                })
              : n.setOpen(x, I);
          });
        },
        onClick(g) {
          if (s === "mousedown-only") return;
          const p = u.current;
          if (s === "mousedown" && p) {
            u.current = void 0;
            return;
          }
          if (vn(p, !0) && a) return;
          const v = n.select("open"),
            b = r.current.openEvent,
            y = n.select("domReferenceElement") !== g.currentTarget,
            w = (v && y) || !(v && i && (!(b && l) || of(b))),
            R = Te(Yt, g.nativeEvent, g.currentTarget);
          w && p === "touch" && c > 0
            ? f.start(c, () => {
                n.setOpen(!0, R);
              })
            : n.setOpen(w, R);
        },
        onKeyDown() {
          u.current = void 0;
        },
      }),
      [r, s, a, n, l, i, d, f, c],
    );
  return h.useMemo(() => (o ? { reference: m } : je), [o, m]);
}
function aw(e, t) {
  let n = null,
    r = null,
    o = !1;
  return {
    contextElement: e || void 0,
    getBoundingClientRect() {
      var m;
      const s = (e == null ? void 0 : e.getBoundingClientRect()) || {
          width: 0,
          height: 0,
          x: 0,
          y: 0,
        },
        i = t.axis === "x" || t.axis === "both",
        a = t.axis === "y" || t.axis === "both",
        l =
          ["mouseenter", "mousemove"].includes(
            ((m = t.dataRef.current.openEvent) == null ? void 0 : m.type) || "",
          ) && t.pointerType !== "touch";
      let c = s.width,
        u = s.height,
        d = s.x,
        f = s.y;
      return (
        n == null && t.x && i && (n = s.x - t.x),
        r == null && t.y && a && (r = s.y - t.y),
        (d -= n || 0),
        (f -= r || 0),
        (c = 0),
        (u = 0),
        !o || l
          ? ((c = t.axis === "y" ? s.width : 0),
            (u = t.axis === "x" ? s.height : 0),
            (d = i && t.x != null ? t.x : d),
            (f = a && t.y != null ? t.y : f))
          : o && !l && ((u = t.axis === "x" ? s.height : u), (c = t.axis === "y" ? s.width : c)),
        (o = !0),
        { width: c, height: u, x: d, y: f, top: f, right: d + c, bottom: f + u, left: d }
      );
    },
  };
}
function ac(e) {
  return e != null && e.clientX != null;
}
function lw(e, t = {}) {
  const n = "rootStore" in e ? e.rootStore : e,
    r = n.useState("open"),
    o = n.useState("floatingElement"),
    s = n.useState("domReferenceElement"),
    i = n.context.dataRef,
    { enabled: a = !0, axis: l = "both", x: c = null, y: u = null } = t,
    d = h.useRef(!1),
    f = h.useRef(null),
    [m, g] = h.useState(),
    [p, v] = h.useState([]),
    b = J((A, I, P) => {
      d.current ||
        (i.current.openEvent && !ac(i.current.openEvent)) ||
        n.set("positionReference", aw(P ?? s, { x: A, y: I, axis: l, dataRef: i, pointerType: m }));
    }),
    y = J((A) => {
      c != null || u != null || (r ? f.current || v([]) : b(A.clientX, A.clientY, A.currentTarget));
    }),
    w = vn(m) ? o : r,
    R = h.useCallback(() => {
      if (!w || !a || c != null || u != null) return;
      const A = _e(o);
      function I(P) {
        const D = rt(P);
        Se(o, D)
          ? (A.removeEventListener("mousemove", I), (f.current = null))
          : b(P.clientX, P.clientY);
      }
      if (!i.current.openEvent || ac(i.current.openEvent)) {
        A.addEventListener("mousemove", I);
        const P = () => {
          (A.removeEventListener("mousemove", I), (f.current = null));
        };
        return ((f.current = P), P);
      }
      n.set("positionReference", s);
    }, [w, a, c, u, o, i, s, n, b]);
  (h.useEffect(() => R(), [R, p]),
    h.useEffect(() => {
      a && !o && (d.current = !1);
    }, [a, o]),
    h.useEffect(() => {
      !a && r && (d.current = !0);
    }, [a, r]),
    ee(() => {
      a && (c != null || u != null) && ((d.current = !1), b(c, u));
    }, [a, c, u, b]));
  const x = h.useMemo(() => {
    function A(I) {
      g(I.pointerType);
    }
    return { onPointerDown: A, onPointerEnter: A, onMouseMove: y, onMouseEnter: y };
  }, [y]);
  return h.useMemo(() => (a ? { reference: x, trigger: x } : {}), [a, x]);
}
function lc(e, t, n) {
  let { reference: r, floating: o } = e;
  const s = gt(t),
    i = la(t),
    a = aa(i),
    l = lt(t),
    c = s === "y",
    u = r.x + r.width / 2 - o.width / 2,
    d = r.y + r.height / 2 - o.height / 2,
    f = r[a] / 2 - o[a] / 2;
  let m;
  switch (l) {
    case "top":
      m = { x: u, y: r.y - o.height };
      break;
    case "bottom":
      m = { x: u, y: r.y + r.height };
      break;
    case "right":
      m = { x: r.x + r.width, y: d };
      break;
    case "left":
      m = { x: r.x - o.width, y: d };
      break;
    default:
      m = { x: r.x, y: r.y };
  }
  switch (on(t)) {
    case "start":
      m[i] -= f * (n && c ? -1 : 1);
      break;
    case "end":
      m[i] += f * (n && c ? -1 : 1);
      break;
  }
  return m;
}
const cw = async (e, t, n) => {
  const { placement: r = "bottom", strategy: o = "absolute", middleware: s = [], platform: i } = n,
    a = s.filter(Boolean),
    l = await (i.isRTL == null ? void 0 : i.isRTL(t));
  let c = await i.getElementRects({ reference: e, floating: t, strategy: o }),
    { x: u, y: d } = lc(c, r, l),
    f = r,
    m = {},
    g = 0;
  for (let p = 0; p < a.length; p++) {
    const { name: v, fn: b } = a[p],
      {
        x: y,
        y: w,
        data: R,
        reset: x,
      } = await b({
        x: u,
        y: d,
        initialPlacement: r,
        placement: f,
        strategy: o,
        middlewareData: m,
        rects: c,
        platform: i,
        elements: { reference: e, floating: t },
      });
    ((u = y ?? u),
      (d = w ?? d),
      (m = { ...m, [v]: { ...m[v], ...R } }),
      x &&
        g <= 50 &&
        (g++,
        typeof x == "object" &&
          (x.placement && (f = x.placement),
          x.rects &&
            (c =
              x.rects === !0
                ? await i.getElementRects({ reference: e, floating: t, strategy: o })
                : x.rects),
          ({ x: u, y: d } = lc(c, f, l))),
        (p = -1)));
  }
  return { x: u, y: d, placement: f, strategy: o, middlewareData: m };
};
async function Cr(e, t) {
  var n;
  t === void 0 && (t = {});
  const { x: r, y: o, platform: s, rects: i, elements: a, strategy: l } = e,
    {
      boundary: c = "clippingAncestors",
      rootBoundary: u = "viewport",
      elementContext: d = "floating",
      altBoundary: f = !1,
      padding: m = 0,
    } = Vt(t, e),
    g = sf(m),
    v = a[f ? (d === "floating" ? "reference" : "floating") : d],
    b = Ro(
      await s.getClippingRect({
        element:
          (n = await (s.isElement == null ? void 0 : s.isElement(v))) == null || n
            ? v
            : v.contextElement ||
              (await (s.getDocumentElement == null ? void 0 : s.getDocumentElement(a.floating))),
        boundary: c,
        rootBoundary: u,
        strategy: l,
      }),
    ),
    y =
      d === "floating"
        ? { x: r, y: o, width: i.floating.width, height: i.floating.height }
        : i.reference,
    w = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(a.floating)),
    R = (await (s.isElement == null ? void 0 : s.isElement(w)))
      ? (await (s.getScale == null ? void 0 : s.getScale(w))) || { x: 1, y: 1 }
      : { x: 1, y: 1 },
    x = Ro(
      s.convertOffsetParentRelativeRectToViewportRelativeRect
        ? await s.convertOffsetParentRelativeRectToViewportRelativeRect({
            elements: a,
            rect: y,
            offsetParent: w,
            strategy: l,
          })
        : y,
    );
  return {
    top: (b.top - x.top + g.top) / R.y,
    bottom: (x.bottom - b.bottom + g.bottom) / R.y,
    left: (b.left - x.left + g.left) / R.x,
    right: (x.right - b.right + g.right) / R.x,
  };
}
const uw = function (e) {
  return (
    e === void 0 && (e = {}),
    {
      name: "flip",
      options: e,
      async fn(t) {
        var n, r;
        const {
            placement: o,
            middlewareData: s,
            rects: i,
            initialPlacement: a,
            platform: l,
            elements: c,
          } = t,
          {
            mainAxis: u = !0,
            crossAxis: d = !0,
            fallbackPlacements: f,
            fallbackStrategy: m = "bestFit",
            fallbackAxisSideDirection: g = "none",
            flipAlignment: p = !0,
            ...v
          } = Vt(e, t);
        if ((n = s.arrow) != null && n.alignmentOffset) return {};
        const b = lt(o),
          y = gt(a),
          w = lt(a) === a,
          R = await (l.isRTL == null ? void 0 : l.isRTL(c.floating)),
          x = f || (w || !p ? [To(a)] : wv(a)),
          A = g !== "none";
        !f && A && x.push(...Ev(a, p, g, R));
        const I = [a, ...x],
          P = await Cr(t, v),
          D = [];
        let V = ((r = s.flip) == null ? void 0 : r.overflows) || [];
        if ((u && D.push(P[b]), d)) {
          const L = vv(o, i, R);
          D.push(P[L[0]], P[L[1]]);
        }
        if (((V = [...V, { placement: o, overflows: D }]), !D.every((L) => L <= 0))) {
          var B, M;
          const L = (((B = s.flip) == null ? void 0 : B.index) || 0) + 1,
            k = I[L];
          if (
            k &&
            (!(d === "alignment" ? y !== gt(k) : !1) ||
              V.every((S) => (gt(S.placement) === y ? S.overflows[0] > 0 : !0)))
          )
            return { data: { index: L, overflows: V }, reset: { placement: k } };
          let F =
            (M = V.filter((E) => E.overflows[0] <= 0).sort(
              (E, S) => E.overflows[1] - S.overflows[1],
            )[0]) == null
              ? void 0
              : M.placement;
          if (!F)
            switch (m) {
              case "bestFit": {
                var C;
                const E =
                  (C = V.filter((S) => {
                    if (A) {
                      const O = gt(S.placement);
                      return O === y || O === "y";
                    }
                    return !0;
                  })
                    .map((S) => [
                      S.placement,
                      S.overflows.filter((O) => O > 0).reduce((O, j) => O + j, 0),
                    ])
                    .sort((S, O) => S[1] - O[1])[0]) == null
                    ? void 0
                    : C[0];
                E && (F = E);
                break;
              }
              case "initialPlacement":
                F = a;
                break;
            }
          if (o !== F) return { reset: { placement: F } };
        }
        return {};
      },
    }
  );
};
function cc(e, t) {
  return {
    top: e.top - t.height,
    right: e.right - t.width,
    bottom: e.bottom - t.height,
    left: e.left - t.width,
  };
}
function uc(e) {
  return gv.some((t) => e[t] >= 0);
}
const dw = function (e) {
    return (
      e === void 0 && (e = {}),
      {
        name: "hide",
        options: e,
        async fn(t) {
          const { rects: n } = t,
            { strategy: r = "referenceHidden", ...o } = Vt(e, t);
          switch (r) {
            case "referenceHidden": {
              const s = await Cr(t, { ...o, elementContext: "reference" }),
                i = cc(s, n.reference);
              return { data: { referenceHiddenOffsets: i, referenceHidden: uc(i) } };
            }
            case "escaped": {
              const s = await Cr(t, { ...o, altBoundary: !0 }),
                i = cc(s, n.floating);
              return { data: { escapedOffsets: i, escaped: uc(i) } };
            }
            default:
              return {};
          }
        },
      }
    );
  },
  Of = new Set(["left", "top"]);
async function fw(e, t) {
  const { placement: n, platform: r, elements: o } = e,
    s = await (r.isRTL == null ? void 0 : r.isRTL(o.floating)),
    i = lt(n),
    a = on(n),
    l = gt(n) === "y",
    c = Of.has(i) ? -1 : 1,
    u = s && l ? -1 : 1,
    d = Vt(t, e);
  let {
    mainAxis: f,
    crossAxis: m,
    alignmentAxis: g,
  } = typeof d == "number"
    ? { mainAxis: d, crossAxis: 0, alignmentAxis: null }
    : { mainAxis: d.mainAxis || 0, crossAxis: d.crossAxis || 0, alignmentAxis: d.alignmentAxis };
  return (
    a && typeof g == "number" && (m = a === "end" ? g * -1 : g),
    l ? { x: m * u, y: f * c } : { x: f * c, y: m * u }
  );
}
const hw = function (e) {
    return (
      e === void 0 && (e = 0),
      {
        name: "offset",
        options: e,
        async fn(t) {
          var n, r;
          const { x: o, y: s, placement: i, middlewareData: a } = t,
            l = await fw(t, e);
          return i === ((n = a.offset) == null ? void 0 : n.placement) &&
            (r = a.arrow) != null &&
            r.alignmentOffset
            ? {}
            : { x: o + l.x, y: s + l.y, data: { ...l, placement: i } };
        },
      }
    );
  },
  mw = function (e) {
    return (
      e === void 0 && (e = {}),
      {
        name: "shift",
        options: e,
        async fn(t) {
          const { x: n, y: r, placement: o } = t,
            {
              mainAxis: s = !0,
              crossAxis: i = !1,
              limiter: a = {
                fn: (v) => {
                  let { x: b, y } = v;
                  return { x: b, y };
                },
              },
              ...l
            } = Vt(e, t),
            c = { x: n, y: r },
            u = await Cr(t, l),
            d = gt(lt(o)),
            f = ia(d);
          let m = c[f],
            g = c[d];
          if (s) {
            const v = f === "y" ? "top" : "left",
              b = f === "y" ? "bottom" : "right",
              y = m + u[v],
              w = m - u[b];
            m = si(y, m, w);
          }
          if (i) {
            const v = d === "y" ? "top" : "left",
              b = d === "y" ? "bottom" : "right",
              y = g + u[v],
              w = g - u[b];
            g = si(y, g, w);
          }
          const p = a.fn({ ...t, [f]: m, [d]: g });
          return { ...p, data: { x: p.x - n, y: p.y - r, enabled: { [f]: s, [d]: i } } };
        },
      }
    );
  },
  pw = function (e) {
    return (
      e === void 0 && (e = {}),
      {
        options: e,
        fn(t) {
          const { x: n, y: r, placement: o, rects: s, middlewareData: i } = t,
            { offset: a = 0, mainAxis: l = !0, crossAxis: c = !0 } = Vt(e, t),
            u = { x: n, y: r },
            d = gt(o),
            f = ia(d);
          let m = u[f],
            g = u[d];
          const p = Vt(a, t),
            v =
              typeof p == "number"
                ? { mainAxis: p, crossAxis: 0 }
                : { mainAxis: 0, crossAxis: 0, ...p };
          if (l) {
            const w = f === "y" ? "height" : "width",
              R = s.reference[f] - s.floating[w] + v.mainAxis,
              x = s.reference[f] + s.reference[w] - v.mainAxis;
            m < R ? (m = R) : m > x && (m = x);
          }
          if (c) {
            var b, y;
            const w = f === "y" ? "width" : "height",
              R = Of.has(lt(o)),
              x =
                s.reference[d] -
                s.floating[w] +
                ((R && ((b = i.offset) == null ? void 0 : b[d])) || 0) +
                (R ? 0 : v.crossAxis),
              A =
                s.reference[d] +
                s.reference[w] +
                (R ? 0 : ((y = i.offset) == null ? void 0 : y[d]) || 0) -
                (R ? v.crossAxis : 0);
            g < x ? (g = x) : g > A && (g = A);
          }
          return { [f]: m, [d]: g };
        },
      }
    );
  },
  gw = function (e) {
    return (
      e === void 0 && (e = {}),
      {
        name: "size",
        options: e,
        async fn(t) {
          var n, r;
          const { placement: o, rects: s, platform: i, elements: a } = t,
            { apply: l = () => {}, ...c } = Vt(e, t),
            u = await Cr(t, c),
            d = lt(o),
            f = on(o),
            m = gt(o) === "y",
            { width: g, height: p } = s.floating;
          let v, b;
          d === "top" || d === "bottom"
            ? ((v = d),
              (b =
                f === ((await (i.isRTL == null ? void 0 : i.isRTL(a.floating))) ? "start" : "end")
                  ? "left"
                  : "right"))
            : ((b = d), (v = f === "end" ? "top" : "bottom"));
          const y = p - u.top - u.bottom,
            w = g - u.left - u.right,
            R = Yn(p - u[v], y),
            x = Yn(g - u[b], w),
            A = !t.middlewareData.shift;
          let I = R,
            P = x;
          if (
            ((n = t.middlewareData.shift) != null && n.enabled.x && (P = w),
            (r = t.middlewareData.shift) != null && r.enabled.y && (I = y),
            A && !f)
          ) {
            const V = ut(u.left, 0),
              B = ut(u.right, 0),
              M = ut(u.top, 0),
              C = ut(u.bottom, 0);
            m
              ? (P = g - 2 * (V !== 0 || B !== 0 ? V + B : ut(u.left, u.right)))
              : (I = p - 2 * (M !== 0 || C !== 0 ? M + C : ut(u.top, u.bottom)));
          }
          await l({ ...t, availableWidth: P, availableHeight: I });
          const D = await i.getDimensions(a.floating);
          return g !== D.width || p !== D.height ? { reset: { rects: !0 } } : {};
        },
      }
    );
  };
function If(e) {
  const t = ht(e);
  let n = parseFloat(t.width) || 0,
    r = parseFloat(t.height) || 0;
  const o = Ne(e),
    s = o ? e.offsetWidth : n,
    i = o ? e.offsetHeight : r,
    a = So(n) !== s || So(r) !== i;
  return (a && ((n = s), (r = i)), { width: n, height: r, $: a });
}
function ha(e) {
  return ke(e) ? e : e.contextElement;
}
function Bn(e) {
  const t = ha(e);
  if (!Ne(t)) return kt(1);
  const n = t.getBoundingClientRect(),
    { width: r, height: o, $: s } = If(t);
  let i = (s ? So(n.width) : n.width) / r,
    a = (s ? So(n.height) : n.height) / o;
  return (
    (!i || !Number.isFinite(i)) && (i = 1), (!a || !Number.isFinite(a)) && (a = 1), { x: i, y: a }
  );
}
const bw = kt(0);
function Df(e) {
  const t = _e(e);
  return !zo() || !t.visualViewport
    ? bw
    : { x: t.visualViewport.offsetLeft, y: t.visualViewport.offsetTop };
}
function yw(e, t, n) {
  return (t === void 0 && (t = !1), !n || (t && n !== _e(e)) ? !1 : t);
}
function wn(e, t, n, r) {
  (t === void 0 && (t = !1), n === void 0 && (n = !1));
  const o = e.getBoundingClientRect(),
    s = ha(e);
  let i = kt(1);
  t && (r ? ke(r) && (i = Bn(r)) : (i = Bn(e)));
  const a = yw(s, n, r) ? Df(s) : kt(0);
  let l = (o.left + a.x) / i.x,
    c = (o.top + a.y) / i.y,
    u = o.width / i.x,
    d = o.height / i.y;
  if (s) {
    const f = _e(s),
      m = r && ke(r) ? _e(r) : r;
    let g = f,
      p = ti(g);
    for (; p && r && m !== g; ) {
      const v = Bn(p),
        b = p.getBoundingClientRect(),
        y = ht(p),
        w = b.left + (p.clientLeft + parseFloat(y.paddingLeft)) * v.x,
        R = b.top + (p.clientTop + parseFloat(y.paddingTop)) * v.y;
      ((l *= v.x),
        (c *= v.y),
        (u *= v.x),
        (d *= v.y),
        (l += w),
        (c += R),
        (g = _e(p)),
        (p = ti(g)));
    }
  }
  return Ro({ width: u, height: d, x: l, y: c });
}
function Yo(e, t) {
  const n = Ho(e).scrollLeft;
  return t ? t.left + n : wn(It(e)).left + n;
}
function Nf(e, t) {
  const n = e.getBoundingClientRect(),
    r = n.left + t.scrollLeft - Yo(e, n),
    o = n.top + t.scrollTop;
  return { x: r, y: o };
}
function xw(e) {
  let { elements: t, rect: n, offsetParent: r, strategy: o } = e;
  const s = o === "fixed",
    i = It(r),
    a = t ? Wo(t.floating) : !1;
  if (r === i || (a && s)) return n;
  let l = { scrollLeft: 0, scrollTop: 0 },
    c = kt(1);
  const u = kt(0),
    d = Ne(r);
  if ((d || (!d && !s)) && ((nn(r) !== "body" || Tn(i)) && (l = Ho(r)), Ne(r))) {
    const m = wn(r);
    ((c = Bn(r)), (u.x = m.x + r.clientLeft), (u.y = m.y + r.clientTop));
  }
  const f = i && !d && !s ? Nf(i, l) : kt(0);
  return {
    width: n.width * c.x,
    height: n.height * c.y,
    x: n.x * c.x - l.scrollLeft * c.x + u.x + f.x,
    y: n.y * c.y - l.scrollTop * c.y + u.y + f.y,
  };
}
function vw(e) {
  return Array.from(e.getClientRects());
}
function ww(e) {
  const t = It(e),
    n = Ho(e),
    r = e.ownerDocument.body,
    o = ut(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth),
    s = ut(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight);
  let i = -n.scrollLeft + Yo(e);
  const a = -n.scrollTop;
  return (
    ht(r).direction === "rtl" && (i += ut(t.clientWidth, r.clientWidth) - o),
    { width: o, height: s, x: i, y: a }
  );
}
const dc = 25;
function Sw(e, t) {
  const n = _e(e),
    r = It(e),
    o = n.visualViewport;
  let s = r.clientWidth,
    i = r.clientHeight,
    a = 0,
    l = 0;
  if (o) {
    ((s = o.width), (i = o.height));
    const u = zo();
    (!u || (u && t === "fixed")) && ((a = o.offsetLeft), (l = o.offsetTop));
  }
  const c = Yo(r);
  if (c <= 0) {
    const u = r.ownerDocument,
      d = u.body,
      f = getComputedStyle(d),
      m =
        (u.compatMode === "CSS1Compat" && parseFloat(f.marginLeft) + parseFloat(f.marginRight)) ||
        0,
      g = Math.abs(r.clientWidth - d.clientWidth - m);
    g <= dc && (s -= g);
  } else c <= dc && (s += c);
  return { width: s, height: i, x: a, y: l };
}
const Tw = new Set(["absolute", "fixed"]);
function Rw(e, t) {
  const n = wn(e, !0, t === "fixed"),
    r = n.top + e.clientTop,
    o = n.left + e.clientLeft,
    s = Ne(e) ? Bn(e) : kt(1),
    i = e.clientWidth * s.x,
    a = e.clientHeight * s.y,
    l = o * s.x,
    c = r * s.y;
  return { width: i, height: a, x: l, y: c };
}
function fc(e, t, n) {
  let r;
  if (t === "viewport") r = Sw(e, n);
  else if (t === "document") r = ww(It(e));
  else if (ke(t)) r = Rw(t, n);
  else {
    const o = Df(e);
    r = { x: t.x - o.x, y: t.y - o.y, width: t.width, height: t.height };
  }
  return Ro(r);
}
function Ff(e, t) {
  const n = At(e);
  return n === t || !ke(n) || Pt(n) ? !1 : ht(n).position === "fixed" || Ff(n, t);
}
function Ew(e, t) {
  const n = t.get(e);
  if (n) return n;
  let r = qt(e, [], !1).filter((a) => ke(a) && nn(a) !== "body"),
    o = null;
  const s = ht(e).position === "fixed";
  let i = s ? At(e) : e;
  for (; ke(i) && !Pt(i); ) {
    const a = ht(i),
      l = ea(i);
    (!l && a.position === "fixed" && (o = null),
      (
        s
          ? !l && !o
          : (!l && a.position === "static" && !!o && Tw.has(o.position)) ||
            (Tn(i) && !l && Ff(e, i))
      )
        ? (r = r.filter((u) => u !== i))
        : (o = a),
      (i = At(i)));
  }
  return (t.set(e, r), r);
}
function Cw(e) {
  let { element: t, boundary: n, rootBoundary: r, strategy: o } = e;
  const i = [...(n === "clippingAncestors" ? (Wo(t) ? [] : Ew(t, this._c)) : [].concat(n)), r],
    a = i[0],
    l = i.reduce(
      (c, u) => {
        const d = fc(t, u, o);
        return (
          (c.top = ut(d.top, c.top)),
          (c.right = Yn(d.right, c.right)),
          (c.bottom = Yn(d.bottom, c.bottom)),
          (c.left = ut(d.left, c.left)),
          c
        );
      },
      fc(t, a, o),
    );
  return { width: l.right - l.left, height: l.bottom - l.top, x: l.left, y: l.top };
}
function Pw(e) {
  const { width: t, height: n } = If(e);
  return { width: t, height: n };
}
function kw(e, t, n) {
  const r = Ne(t),
    o = It(t),
    s = n === "fixed",
    i = wn(e, !0, s, t);
  let a = { scrollLeft: 0, scrollTop: 0 };
  const l = kt(0);
  function c() {
    l.x = Yo(o);
  }
  if (r || (!r && !s))
    if (((nn(t) !== "body" || Tn(o)) && (a = Ho(t)), r)) {
      const m = wn(t, !0, s, t);
      ((l.x = m.x + t.clientLeft), (l.y = m.y + t.clientTop));
    } else o && c();
  s && !r && o && c();
  const u = o && !r && !s ? Nf(o, a) : kt(0),
    d = i.left + a.scrollLeft - l.x - u.x,
    f = i.top + a.scrollTop - l.y - u.y;
  return { x: d, y: f, width: i.width, height: i.height };
}
function ys(e) {
  return ht(e).position === "static";
}
function hc(e, t) {
  if (!Ne(e) || ht(e).position === "fixed") return null;
  if (t) return t(e);
  let n = e.offsetParent;
  return (It(e) === n && (n = n.ownerDocument.body), n);
}
function Lf(e, t) {
  const n = _e(e);
  if (Wo(e)) return n;
  if (!Ne(e)) {
    let o = At(e);
    for (; o && !Pt(o); ) {
      if (ke(o) && !ys(o)) return o;
      o = At(o);
    }
    return n;
  }
  let r = hc(e, t);
  for (; r && Wx(r) && ys(r); ) r = hc(r, t);
  return r && Pt(r) && ys(r) && !ea(r) ? n : r || Yx(e) || n;
}
const Mw = async function (e) {
  const t = this.getOffsetParent || Lf,
    n = this.getDimensions,
    r = await n(e.floating);
  return {
    reference: kw(e.reference, await t(e.floating), e.strategy),
    floating: { x: 0, y: 0, width: r.width, height: r.height },
  };
};
function Aw(e) {
  return ht(e).direction === "rtl";
}
const Ow = {
  convertOffsetParentRelativeRectToViewportRelativeRect: xw,
  getDocumentElement: It,
  getClippingRect: Cw,
  getOffsetParent: Lf,
  getElementRects: Mw,
  getClientRects: vw,
  getDimensions: Pw,
  getScale: Bn,
  isElement: ke,
  isRTL: Aw,
};
function jf(e, t) {
  return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height;
}
function Iw(e, t) {
  let n = null,
    r;
  const o = It(e);
  function s() {
    var a;
    (clearTimeout(r), (a = n) == null || a.disconnect(), (n = null));
  }
  function i(a, l) {
    (a === void 0 && (a = !1), l === void 0 && (l = 1), s());
    const c = e.getBoundingClientRect(),
      { left: u, top: d, width: f, height: m } = c;
    if ((a || t(), !f || !m)) return;
    const g = Dn(d),
      p = Dn(o.clientWidth - (u + f)),
      v = Dn(o.clientHeight - (d + m)),
      b = Dn(u),
      w = {
        rootMargin: -g + "px " + -p + "px " + -v + "px " + -b + "px",
        threshold: ut(0, Yn(1, l)) || 1,
      };
    let R = !0;
    function x(A) {
      const I = A[0].intersectionRatio;
      if (I !== l) {
        if (!R) return i();
        I
          ? i(!1, I)
          : (r = setTimeout(() => {
              i(!1, 1e-7);
            }, 1e3));
      }
      (I === 1 && !jf(c, e.getBoundingClientRect()) && i(), (R = !1));
    }
    try {
      n = new IntersectionObserver(x, { ...w, root: o.ownerDocument });
    } catch {
      n = new IntersectionObserver(x, w);
    }
    n.observe(e);
  }
  return (i(!0), s);
}
function mc(e, t, n, r) {
  r === void 0 && (r = {});
  const {
      ancestorScroll: o = !0,
      ancestorResize: s = !0,
      elementResize: i = typeof ResizeObserver == "function",
      layoutShift: a = typeof IntersectionObserver == "function",
      animationFrame: l = !1,
    } = r,
    c = ha(e),
    u = o || s ? [...(c ? qt(c) : []), ...qt(t)] : [];
  u.forEach((b) => {
    (o && b.addEventListener("scroll", n, { passive: !0 }), s && b.addEventListener("resize", n));
  });
  const d = c && a ? Iw(c, n) : null;
  let f = -1,
    m = null;
  i &&
    ((m = new ResizeObserver((b) => {
      let [y] = b;
      (y &&
        y.target === c &&
        m &&
        (m.unobserve(t),
        cancelAnimationFrame(f),
        (f = requestAnimationFrame(() => {
          var w;
          (w = m) == null || w.observe(t);
        }))),
        n());
    })),
    c && !l && m.observe(c),
    m.observe(t));
  let g,
    p = l ? wn(e) : null;
  l && v();
  function v() {
    const b = wn(e);
    (p && !jf(p, b) && n(), (p = b), (g = requestAnimationFrame(v)));
  }
  return (
    n(),
    () => {
      var b;
      (u.forEach((y) => {
        (o && y.removeEventListener("scroll", n), s && y.removeEventListener("resize", n));
      }),
        d == null || d(),
        (b = m) == null || b.disconnect(),
        (m = null),
        l && cancelAnimationFrame(g));
    }
  );
}
const Dw = hw,
  Nw = mw,
  Fw = uw,
  Lw = gw,
  jw = dw,
  Vw = pw,
  Bw = (e, t, n) => {
    const r = new Map(),
      o = { platform: Ow, ...n },
      s = { ...o.platform, _c: r };
    return cw(e, t, { ...o, platform: s });
  };
var $w = typeof document < "u",
  Ww = function () {},
  fo = $w ? h.useLayoutEffect : Ww;
function Mo(e, t) {
  if (e === t) return !0;
  if (typeof e != typeof t) return !1;
  if (typeof e == "function" && e.toString() === t.toString()) return !0;
  let n, r, o;
  if (e && t && typeof e == "object") {
    if (Array.isArray(e)) {
      if (((n = e.length), n !== t.length)) return !1;
      for (r = n; r-- !== 0; ) if (!Mo(e[r], t[r])) return !1;
      return !0;
    }
    if (((o = Object.keys(e)), (n = o.length), n !== Object.keys(t).length)) return !1;
    for (r = n; r-- !== 0; ) if (!{}.hasOwnProperty.call(t, o[r])) return !1;
    for (r = n; r-- !== 0; ) {
      const s = o[r];
      if (!(s === "_owner" && e.$$typeof) && !Mo(e[s], t[s])) return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
}
function Vf(e) {
  return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function pc(e, t) {
  const n = Vf(e);
  return Math.round(t * n) / n;
}
function xs(e) {
  const t = h.useRef(e);
  return (
    fo(() => {
      t.current = e;
    }),
    t
  );
}
function zw(e) {
  e === void 0 && (e = {});
  const {
      placement: t = "bottom",
      strategy: n = "absolute",
      middleware: r = [],
      platform: o,
      elements: { reference: s, floating: i } = {},
      transform: a = !0,
      whileElementsMounted: l,
      open: c,
    } = e,
    [u, d] = h.useState({
      x: 0,
      y: 0,
      strategy: n,
      placement: t,
      middlewareData: {},
      isPositioned: !1,
    }),
    [f, m] = h.useState(r);
  Mo(f, r) || m(r);
  const [g, p] = h.useState(null),
    [v, b] = h.useState(null),
    y = h.useCallback((S) => {
      S !== A.current && ((A.current = S), p(S));
    }, []),
    w = h.useCallback((S) => {
      S !== I.current && ((I.current = S), b(S));
    }, []),
    R = s || g,
    x = i || v,
    A = h.useRef(null),
    I = h.useRef(null),
    P = h.useRef(u),
    D = l != null,
    V = xs(l),
    B = xs(o),
    M = xs(c),
    C = h.useCallback(() => {
      if (!A.current || !I.current) return;
      const S = { placement: t, strategy: n, middleware: f };
      (B.current && (S.platform = B.current),
        Bw(A.current, I.current, S).then((O) => {
          const j = { ...O, isPositioned: M.current !== !1 };
          L.current &&
            !Mo(P.current, j) &&
            ((P.current = j),
            Rt.flushSync(() => {
              d(j);
            }));
        }));
    }, [f, t, n, B, M]);
  fo(() => {
    c === !1 &&
      P.current.isPositioned &&
      ((P.current.isPositioned = !1), d((S) => ({ ...S, isPositioned: !1 })));
  }, [c]);
  const L = h.useRef(!1);
  (fo(
    () => (
      (L.current = !0),
      () => {
        L.current = !1;
      }
    ),
    [],
  ),
    fo(() => {
      if ((R && (A.current = R), x && (I.current = x), R && x)) {
        if (V.current) return V.current(R, x, C);
        C();
      }
    }, [R, x, C, V, D]));
  const k = h.useMemo(
      () => ({ reference: A, floating: I, setReference: y, setFloating: w }),
      [y, w],
    ),
    F = h.useMemo(() => ({ reference: R, floating: x }), [R, x]),
    E = h.useMemo(() => {
      const S = { position: n, left: 0, top: 0 };
      if (!F.floating) return S;
      const O = pc(F.floating, u.x),
        j = pc(F.floating, u.y);
      return a
        ? {
            ...S,
            transform: "translate(" + O + "px, " + j + "px)",
            ...(Vf(F.floating) >= 1.5 && { willChange: "transform" }),
          }
        : { position: n, left: O, top: j };
    }, [n, a, F.floating, u.x, u.y]);
  return h.useMemo(
    () => ({ ...u, update: C, refs: k, elements: F, floatingStyles: E }),
    [u, C, k, F, E],
  );
}
const Hw = (e, t) => ({ ...Dw(e), options: [e, t] }),
  Uw = (e, t) => ({ ...Nw(e), options: [e, t] }),
  _w = (e, t) => ({ ...Vw(e), options: [e, t] }),
  Yw = (e, t) => ({ ...Fw(e), options: [e, t] }),
  qw = (e, t) => ({ ...Lw(e), options: [e, t] }),
  Xw = (e, t) => ({ ...jw(e), options: [e, t] }),
  Gw = { intentional: "onClick", sloppy: "onPointerDown" };
function Kw(e) {
  return {
    escapeKey: typeof e == "boolean" ? e : ((e == null ? void 0 : e.escapeKey) ?? !1),
    outsidePress: typeof e == "boolean" ? e : ((e == null ? void 0 : e.outsidePress) ?? !0),
  };
}
function Bf(e, t = {}) {
  const n = "rootStore" in e ? e.rootStore : e,
    r = n.useState("open"),
    o = n.useState("floatingElement"),
    s = n.useState("referenceElement"),
    i = n.useState("domReferenceElement"),
    { onOpenChange: a, dataRef: l } = n.context,
    {
      enabled: c = !0,
      escapeKey: u = !0,
      outsidePress: d = !0,
      outsidePressEvent: f = "sloppy",
      referencePress: m = !1,
      referencePressEvent: g = "sloppy",
      ancestorScroll: p = !1,
      bubbles: v,
      externalTree: b,
    } = t,
    y = sn(b),
    w = J(typeof d == "function" ? d : () => !1),
    R = typeof d == "function" ? w : d,
    x = h.useRef(!1),
    { escapeKey: A, outsidePress: I } = Kw(v),
    P = h.useRef(null),
    D = Ge(),
    V = Ge(),
    B = J(() => {
      (V.clear(), (l.current.insideReactTree = !1));
    }),
    M = h.useRef(!1),
    C = h.useRef(""),
    L = J((N) => {
      C.current = N.pointerType;
    }),
    k = J(() => {
      const N = C.current,
        X = N === "pen" || !N ? "mouse" : N,
        q = typeof f == "function" ? f() : f;
      return typeof q == "string" ? q : q[X];
    }),
    F = J((N) => {
      var W;
      if (!r || !c || !u || N.key !== "Escape" || M.current) return;
      const X = (W = l.current.floatingContext) == null ? void 0 : W.nodeId,
        q = y ? yn(y.nodesRef.current, X) : [];
      if (!A && q.length > 0) {
        let G = !0;
        if (
          (q.forEach((ie) => {
            var he;
            (he = ie.context) != null &&
              he.open &&
              !ie.context.dataRef.current.__escapeKeyBubbles &&
              (G = !1);
          }),
          !G)
        )
          return;
      }
      const we = pv(N) ? N.nativeEvent : N,
        z = Te(Bo, we);
      (n.setOpen(!1, z), !A && !z.isPropagationAllowed && N.stopPropagation());
    }),
    E = J((N) => {
      const X = k();
      return (X === "intentional" && N.type !== "click") || (X === "sloppy" && N.type === "click");
    }),
    S = J(() => {
      ((l.current.insideReactTree = !0), V.start(0, B));
    }),
    O = J((N, X = !1) => {
      var de;
      if (E(N)) {
        B();
        return;
      }
      if (l.current.insideReactTree) {
        B();
        return;
      }
      if ((k() === "intentional" && X) || (typeof R == "function" && !R(N))) return;
      const q = rt(N),
        we = `[${Xn("inert")}]`,
        z = $e(n.select("floatingElement")).querySelectorAll(we),
        W = n.context.triggerElements;
      if (q && (W.hasElement(q) || W.hasMatchingElement((U) => Se(U, q)))) return;
      let G = ke(q) ? q : null;
      for (; G && !Pt(G); ) {
        const U = At(G);
        if (Pt(U) || !ke(U)) break;
        G = U;
      }
      if (
        z.length &&
        ke(q) &&
        !hv(q) &&
        !Se(q, n.select("floatingElement")) &&
        Array.from(z).every((U) => !Se(G, U))
      )
        return;
      if (Ne(q) && !("touches" in N)) {
        const U = Pt(q),
          Z = ht(q),
          K = /auto|scroll/,
          xe = U || K.test(Z.overflowX),
          Re = U || K.test(Z.overflowY),
          Ee = xe && q.clientWidth > 0 && q.scrollWidth > q.clientWidth,
          Ce = Re && q.clientHeight > 0 && q.scrollHeight > q.clientHeight,
          Oe = Z.direction === "rtl",
          Ie = Ce && (Oe ? N.offsetX <= q.offsetWidth - q.clientWidth : N.offsetX > q.clientWidth),
          ze = Ee && N.offsetY > q.clientHeight;
        if (Ie || ze) return;
      }
      const ie = (de = l.current.floatingContext) == null ? void 0 : de.nodeId,
        he =
          y &&
          yn(y.nodesRef.current, ie).some((U) => {
            var Z;
            return wt(N, (Z = U.context) == null ? void 0 : Z.elements.floating);
          });
      if (wt(N, n.select("floatingElement")) || wt(N, n.select("domReferenceElement")) || he)
        return;
      const ae = y ? yn(y.nodesRef.current, ie) : [];
      if (ae.length > 0) {
        let U = !0;
        if (
          (ae.forEach((Z) => {
            var K;
            (K = Z.context) != null &&
              K.open &&
              !Z.context.dataRef.current.__outsidePressBubbles &&
              (U = !1);
          }),
          !U)
        )
          return;
      }
      (n.setOpen(!1, Te(Zi, N)), B());
    }),
    j = J((N) => {
      k() !== "sloppy" ||
        N.pointerType === "touch" ||
        !n.select("open") ||
        !c ||
        wt(N, n.select("floatingElement")) ||
        wt(N, n.select("domReferenceElement")) ||
        O(N);
    }),
    _ = J((N) => {
      if (
        k() !== "sloppy" ||
        !n.select("open") ||
        !c ||
        wt(N, n.select("floatingElement")) ||
        wt(N, n.select("domReferenceElement"))
      )
        return;
      const X = N.touches[0];
      X &&
        ((P.current = {
          startTime: Date.now(),
          startX: X.clientX,
          startY: X.clientY,
          dismissOnTouchEnd: !1,
          dismissOnMouseDown: !0,
        }),
        D.start(1e3, () => {
          P.current && ((P.current.dismissOnTouchEnd = !1), (P.current.dismissOnMouseDown = !1));
        }));
    }),
    Q = J((N) => {
      const X = rt(N);
      function q() {
        (_(N), X == null || X.removeEventListener(N.type, q));
      }
      X == null || X.addEventListener(N.type, q);
    }),
    $ = J((N) => {
      const X = x.current;
      if (
        ((x.current = !1),
        D.clear(),
        N.type === "mousedown" && P.current && !P.current.dismissOnMouseDown)
      )
        return;
      const q = rt(N);
      function we() {
        (N.type === "pointerdown" ? j(N) : O(N, X), q == null || q.removeEventListener(N.type, we));
      }
      q == null || q.addEventListener(N.type, we);
    }),
    Y = J((N) => {
      if (
        k() !== "sloppy" ||
        !P.current ||
        wt(N, n.select("floatingElement")) ||
        wt(N, n.select("domReferenceElement"))
      )
        return;
      const X = N.touches[0];
      if (!X) return;
      const q = Math.abs(X.clientX - P.current.startX),
        we = Math.abs(X.clientY - P.current.startY),
        z = Math.sqrt(q * q + we * we);
      (z > 5 && (P.current.dismissOnTouchEnd = !0),
        z > 10 && (O(N), D.clear(), (P.current = null)));
    }),
    ne = J((N) => {
      const X = rt(N);
      function q() {
        (Y(N), X == null || X.removeEventListener(N.type, q));
      }
      X == null || X.addEventListener(N.type, q);
    }),
    te = J((N) => {
      k() !== "sloppy" ||
        !P.current ||
        wt(N, n.select("floatingElement")) ||
        wt(N, n.select("domReferenceElement")) ||
        (P.current.dismissOnTouchEnd && O(N), D.clear(), (P.current = null));
    }),
    H = J((N) => {
      const X = rt(N);
      function q() {
        (te(N), X == null || X.removeEventListener(N.type, q));
      }
      X == null || X.addEventListener(N.type, q);
    });
  (h.useEffect(() => {
    if (!r || !c) return;
    ((l.current.__escapeKeyBubbles = A), (l.current.__outsidePressBubbles = I));
    const N = new en();
    function X(G) {
      n.setOpen(!1, Te(Un, G));
    }
    function q() {
      (N.clear(), (M.current = !0));
    }
    function we() {
      N.start(zo() ? 5 : 0, () => {
        M.current = !1;
      });
    }
    const z = $e(o);
    (z.addEventListener("pointerdown", L, !0),
      u &&
        (z.addEventListener("keydown", F),
        z.addEventListener("compositionstart", q),
        z.addEventListener("compositionend", we)),
      R &&
        (z.addEventListener("click", $, !0),
        z.addEventListener("pointerdown", $, !0),
        z.addEventListener("touchstart", Q, !0),
        z.addEventListener("touchmove", ne, !0),
        z.addEventListener("touchend", H, !0),
        z.addEventListener("mousedown", $, !0)));
    let W = [];
    return (
      p &&
        (ke(i) && (W = qt(i)),
        ke(o) && (W = W.concat(qt(o))),
        !ke(s) && s && s.contextElement && (W = W.concat(qt(s.contextElement)))),
      (W = W.filter((G) => {
        var ie;
        return G !== ((ie = z.defaultView) == null ? void 0 : ie.visualViewport);
      })),
      W.forEach((G) => {
        G.addEventListener("scroll", X, { passive: !0 });
      }),
      () => {
        (z.removeEventListener("pointerdown", L, !0),
          u &&
            (z.removeEventListener("keydown", F),
            z.removeEventListener("compositionstart", q),
            z.removeEventListener("compositionend", we)),
          R &&
            (z.removeEventListener("click", $, !0),
            z.removeEventListener("pointerdown", $, !0),
            z.removeEventListener("touchstart", Q, !0),
            z.removeEventListener("touchmove", ne, !0),
            z.removeEventListener("touchend", H, !0),
            z.removeEventListener("mousedown", $, !0)),
          W.forEach((G) => {
            G.removeEventListener("scroll", X);
          }),
          N.clear(),
          (x.current = !1));
      }
    );
  }, [l, o, s, i, u, R, r, a, p, c, A, I, F, O, $, j, Q, ne, H, L, n]),
    h.useEffect(B, [R, B]));
  const ue = h.useMemo(
      () => ({
        onKeyDown: F,
        ...(m && {
          [Gw[g]]: (N) => {
            n.setOpen(!1, Te(Yt, N.nativeEvent));
          },
          ...(g !== "intentional" && {
            onClick(N) {
              n.setOpen(!1, Te(Yt, N.nativeEvent));
            },
          }),
        }),
      }),
      [F, n, m, g],
    ),
    le = J((N) => {
      const X = rt(N.nativeEvent);
      !Se(n.select("floatingElement"), X) || N.button !== 0 || (x.current = !0);
    }),
    ce = J((N) => {
      !r || !c || N.button !== 0 || (x.current = !0);
    }),
    pe = h.useMemo(
      () => ({
        onKeyDown: F,
        onPointerDown: le,
        onMouseDown: le,
        onMouseUp: le,
        onClickCapture: S,
        onMouseDownCapture(N) {
          (S(), ce(N));
        },
        onPointerDownCapture(N) {
          (S(), ce(N));
        },
        onMouseUpCapture: S,
        onTouchEndCapture: S,
        onTouchMoveCapture: S,
      }),
      [F, le, S, ce],
    );
  return h.useMemo(() => (c ? { reference: ue, floating: pe, trigger: ue } : {}), [c, ue, pe]);
}
var Ao = Symbol("NOT_FOUND");
function Qw(e, t = `expected a function, instead received ${typeof e}`) {
  if (typeof e != "function") throw new TypeError(t);
}
function Zw(e, t = `expected an object, instead received ${typeof e}`) {
  if (typeof e != "object") throw new TypeError(t);
}
function Jw(e, t = "expected all items to be functions, instead received the following types: ") {
  if (!e.every((n) => typeof n == "function")) {
    const n = e
      .map((r) => (typeof r == "function" ? `function ${r.name || "unnamed"}()` : typeof r))
      .join(", ");
    throw new TypeError(`${t}[${n}]`);
  }
}
var gc = (e) => (Array.isArray(e) ? e : [e]);
function e0(e) {
  const t = Array.isArray(e[0]) ? e[0] : e;
  return (
    Jw(
      t,
      "createSelector expects all input-selectors to be functions, but received the following types: ",
    ),
    t
  );
}
function t0(e, t) {
  const n = [],
    { length: r } = e;
  for (let o = 0; o < r; o++) n.push(e[o].apply(null, t));
  return n;
}
function n0(e) {
  let t;
  return {
    get(n) {
      return t && e(t.key, n) ? t.value : Ao;
    },
    put(n, r) {
      t = { key: n, value: r };
    },
    getEntries() {
      return t ? [t] : [];
    },
    clear() {
      t = void 0;
    },
  };
}
function r0(e, t) {
  let n = [];
  function r(a) {
    const l = n.findIndex((c) => t(a, c.key));
    if (l > -1) {
      const c = n[l];
      return (l > 0 && (n.splice(l, 1), n.unshift(c)), c.value);
    }
    return Ao;
  }
  function o(a, l) {
    r(a) === Ao && (n.unshift({ key: a, value: l }), n.length > e && n.pop());
  }
  function s() {
    return n;
  }
  function i() {
    n = [];
  }
  return { get: r, put: o, getEntries: s, clear: i };
}
var o0 = (e, t) => e === t;
function s0(e) {
  return function (n, r) {
    if (n === null || r === null || n.length !== r.length) return !1;
    const { length: o } = n;
    for (let s = 0; s < o; s++) if (!e(n[s], r[s])) return !1;
    return !0;
  };
}
function i0(e, t) {
  const n = typeof t == "object" ? t : { equalityCheck: t },
    { equalityCheck: r = o0, maxSize: o = 1, resultEqualityCheck: s } = n,
    i = s0(r);
  let a = 0;
  const l = o <= 1 ? n0(i) : r0(o, i);
  function c() {
    let u = l.get(arguments);
    if (u === Ao) {
      if (((u = e.apply(null, arguments)), a++, s)) {
        const f = l.getEntries().find((m) => s(m.value, u));
        f && ((u = f.value), a !== 0 && a--);
      }
      l.put(arguments, u);
    }
    return u;
  }
  return (
    (c.clearCache = () => {
      (l.clear(), c.resetResultsCount());
    }),
    (c.resultsCount = () => a),
    (c.resetResultsCount = () => {
      a = 0;
    }),
    c
  );
}
var a0 = class {
    constructor(e) {
      this.value = e;
    }
    deref() {
      return this.value;
    }
  },
  l0 = typeof WeakRef < "u" ? WeakRef : a0,
  c0 = 0,
  bc = 1;
function qr() {
  return { s: c0, v: void 0, o: null, p: null };
}
function $f(e, t = {}) {
  let n = qr();
  const { resultEqualityCheck: r } = t;
  let o,
    s = 0;
  function i() {
    var d;
    let a = n;
    const { length: l } = arguments;
    for (let f = 0, m = l; f < m; f++) {
      const g = arguments[f];
      if (typeof g == "function" || (typeof g == "object" && g !== null)) {
        let p = a.o;
        p === null && (a.o = p = new WeakMap());
        const v = p.get(g);
        v === void 0 ? ((a = qr()), p.set(g, a)) : (a = v);
      } else {
        let p = a.p;
        p === null && (a.p = p = new Map());
        const v = p.get(g);
        v === void 0 ? ((a = qr()), p.set(g, a)) : (a = v);
      }
    }
    const c = a;
    let u;
    if (a.s === bc) u = a.v;
    else if (((u = e.apply(null, arguments)), s++, r)) {
      const f = ((d = o == null ? void 0 : o.deref) == null ? void 0 : d.call(o)) ?? o;
      (f != null && r(f, u) && ((u = f), s !== 0 && s--),
        (o = (typeof u == "object" && u !== null) || typeof u == "function" ? new l0(u) : u));
    }
    return ((c.s = bc), (c.v = u), u);
  }
  return (
    (i.clearCache = () => {
      ((n = qr()), i.resetResultsCount());
    }),
    (i.resultsCount = () => s),
    (i.resetResultsCount = () => {
      s = 0;
    }),
    i
  );
}
function Wf(e, ...t) {
  const n = typeof e == "function" ? { memoize: e, memoizeOptions: t } : e,
    r = (...o) => {
      let s = 0,
        i = 0,
        a,
        l = {},
        c = o.pop();
      (typeof c == "object" && ((l = c), (c = o.pop())),
        Qw(
          c,
          `createSelector expects an output function after the inputs, but received: [${typeof c}]`,
        ));
      const u = { ...n, ...l },
        { memoize: d, memoizeOptions: f = [], argsMemoize: m = $f, argsMemoizeOptions: g = [] } = u,
        p = gc(f),
        v = gc(g),
        b = e0(o),
        y = d(
          function () {
            return (s++, c.apply(null, arguments));
          },
          ...p,
        ),
        w = m(
          function () {
            i++;
            const x = t0(b, arguments);
            return ((a = y.apply(null, x)), a);
          },
          ...v,
        );
      return Object.assign(w, {
        resultFunc: c,
        memoizedResultFunc: y,
        dependencies: b,
        dependencyRecomputations: () => i,
        resetDependencyRecomputations: () => {
          i = 0;
        },
        lastResult: () => a,
        recomputations: () => s,
        resetRecomputations: () => {
          s = 0;
        },
        memoize: d,
        argsMemoize: m,
      });
    };
  return (Object.assign(r, { withTypes: () => r }), r);
}
var u0 = Wf($f),
  d0 = Object.assign(
    (e, t = u0) => {
      Zw(
        e,
        `createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ${typeof e}`,
      );
      const n = Object.keys(e),
        r = n.map((s) => e[s]);
      return t(r, (...s) => s.reduce((i, a, l) => ((i[n[l]] = a), i), {}));
    },
    { withTypes: () => d0 },
  );
Wf({ memoize: i0, memoizeOptions: { maxSize: 1, equalityCheck: Object.is } });
const me = (e, t, n, r, o, s, ...i) => {
  if (i.length > 0) throw new Error(Ke(1));
  let a;
  if (e) a = e;
  else throw new Error("Missing arguments");
  return a;
};
var f0 = em();
const h0 = Ki(19),
  m0 = h0 ? g0 : b0;
function p0(e, t, n, r, o) {
  return m0(e, t, n, r, o);
}
function g0(e, t, n, r, o) {
  const s = h.useCallback(() => t(e.getSnapshot(), n, r, o), [e, t, n, r, o]);
  return f0.useSyncExternalStore(e.subscribe, s, s);
}
function b0(e, t, n, r, o) {
  return tm.useSyncExternalStoreWithSelector(e.subscribe, e.getSnapshot, e.getSnapshot, (s) =>
    t(s, n, r, o),
  );
}
class yr {
  constructor(t) {
    Ae(
      this,
      "subscribe",
      (t) => (
        this.listeners.add(t),
        () => {
          this.listeners.delete(t);
        }
      ),
    );
    Ae(this, "getSnapshot", () => this.state);
    ((this.state = t), (this.listeners = new Set()), (this.updateTick = 0));
  }
  setState(t) {
    if (this.state === t) return;
    ((this.state = t), (this.updateTick += 1));
    const n = this.updateTick;
    for (const r of this.listeners) {
      if (n !== this.updateTick) return;
      r(t);
    }
  }
  update(t) {
    for (const n in t)
      if (!Object.is(this.state[n], t[n])) {
        yr.prototype.setState.call(this, { ...this.state, ...t });
        return;
      }
  }
  set(t, n) {
    Object.is(this.state[t], n) || yr.prototype.setState.call(this, { ...this.state, [t]: n });
  }
  notifyAll() {
    const t = { ...this.state };
    yr.prototype.setState.call(this, t);
  }
}
class ma extends yr {
  constructor(n, r = {}, o) {
    super(n);
    Ae(this, "controlledValues", new Map());
    Ae(this, "select", (n, r, o, s) => {
      const i = this.selectors[n];
      return i(this.state, r, o, s);
    });
    Ae(this, "useState", (n, r, o, s) => {
      h.useDebugValue(n);
      const i = this.selectors[n];
      return p0(this, i, r, o, s);
    });
    ((this.context = r), (this.selectors = o));
  }
  useSyncedValue(n, r) {
    (h.useDebugValue(n),
      ee(() => {
        this.state[n] !== r && this.set(n, r);
      }, [n, r]));
  }
  useSyncedValueWithCleanup(n, r) {
    const o = this;
    ee(
      () => (
        o.state[n] !== r && o.set(n, r),
        () => {
          o.set(n, void 0);
        }
      ),
      [o, n, r],
    );
  }
  useSyncedValues(n) {
    const r = this,
      o = Object.values(n);
    ee(() => {
      r.update(n);
    }, [r, ...o]);
  }
  useControlledProp(n, r, o) {
    h.useDebugValue(n);
    const s = this,
      i = r !== void 0;
    (this.controlledValues.has(n) ||
      (this.controlledValues.set(n, i),
      !i && !Object.is(this.state[n], o) && super.setState({ ...this.state, [n]: o })),
      ee(() => {
        i && !Object.is(s.state[n], r) && super.setState({ ...s.state, [n]: r });
      }, [s, n, r, o, i]));
  }
  set(n, r) {
    this.controlledValues.get(n) !== !0 && super.set(n, r);
  }
  update(n) {
    const r = { ...n };
    for (const o in r)
      if (Object.hasOwn(r, o) && this.controlledValues.get(o) === !0) {
        delete r[o];
        continue;
      }
    super.update(r);
  }
  setState(n) {
    const r = { ...n };
    for (const o in r)
      if (Object.hasOwn(r, o) && this.controlledValues.get(o) === !0) {
        delete r[o];
        continue;
      }
    super.setState({ ...this.state, ...r });
  }
  useContextCallback(n, r) {
    h.useDebugValue(n);
    const o = J(r ?? dt);
    this.context[n] = o;
  }
  useStateSetter(n) {
    const r = h.useRef(void 0);
    return (
      r.current === void 0 &&
        (r.current = (o) => {
          this.set(n, o);
        }),
      r.current
    );
  }
  observe(n, r) {
    let o;
    typeof n == "function" ? (o = n) : (o = this.selectors[n]);
    let s = o(this.state);
    return (
      r(s, s, this),
      this.subscribe((i) => {
        const a = o(i);
        if (!Object.is(s, a)) {
          const l = s;
          ((s = a), r(a, l, this));
        }
      })
    );
  }
}
const y0 = {
  open: me((e) => e.open),
  domReferenceElement: me((e) => e.domReferenceElement),
  referenceElement: me((e) => e.positionReference ?? e.referenceElement),
  floatingElement: me((e) => e.floatingElement),
  floatingId: me((e) => e.floatingId),
};
class pa extends ma {
  constructor(n) {
    const { nested: r, noEmit: o, onOpenChange: s, triggerElements: i, ...a } = n;
    super(
      { ...a, positionReference: a.referenceElement, domReferenceElement: a.referenceElement },
      {
        onOpenChange: s,
        dataRef: { current: {} },
        events: wf(),
        nested: r,
        noEmit: o,
        triggerElements: i,
      },
      y0,
    );
    Ae(this, "setOpen", (n, r) => {
      var o, s;
      if (
        ((!n || !this.state.open || of(r.event)) &&
          (this.context.dataRef.current.openEvent = n ? r.event : void 0),
        !this.context.noEmit)
      ) {
        const i = {
          open: n,
          reason: r.reason,
          nativeEvent: r.event,
          nested: this.context.nested,
          triggerElement: r.trigger,
        };
        this.context.events.emit("openchange", i);
      }
      (s = (o = this.context).onOpenChange) == null || s.call(o, n, r);
    });
  }
}
function x0(e, t) {
  const n = h.useRef(null),
    r = h.useRef(null);
  return h.useCallback(
    (o) => {
      if (e !== void 0) {
        if (n.current !== null) {
          const s = n.current,
            i = r.current,
            a = t.context.triggerElements.getById(s);
          (i && a === i && t.context.triggerElements.delete(s),
            (n.current = null),
            (r.current = null));
        }
        o !== null && ((n.current = e), (r.current = o), t.context.triggerElements.add(e, o));
      }
    },
    [t, e],
  );
}
function zf(e, t, n, r) {
  const o = n.useState("isMountedByTrigger", e),
    s = x0(e, n),
    i = J((a) => {
      if ((s(a), !a || !n.select("open"))) return;
      const l = n.select("activeTriggerId");
      if (l === e) {
        n.update({ activeTriggerElement: a, ...r });
        return;
      }
      l == null && n.update({ activeTriggerId: e, activeTriggerElement: a, ...r });
    });
  return (
    ee(() => {
      o && n.update({ activeTriggerElement: t.current, ...r });
    }, [o, n, t, ...Object.values(r)]),
    { registerTrigger: i, isMountedByThisTrigger: o }
  );
}
function Hf(e) {
  const t = e.useState("open");
  ee(() => {
    if (t && !e.select("activeTriggerId") && e.context.triggerElements.size === 1) {
      const n = e.context.triggerElements.entries().next();
      if (!n.done) {
        const [r, o] = n.value;
        e.update({ activeTriggerId: r, activeTriggerElement: o });
      }
    }
  }, [t, e]);
}
function Uf(e, t, n) {
  const { mounted: r, setMounted: o, transitionStatus: s } = sv(e);
  t.useSyncedValues({ mounted: r, transitionStatus: s });
  const i = J(() => {
      var l, c;
      (o(!1),
        t.update({ activeTriggerId: null, activeTriggerElement: null, mounted: !1 }),
        n == null || n(),
        (c = (l = t.context).onOpenChangeComplete) == null || c.call(l, !1));
    }),
    a = t.useState("preventUnmountingOnClose");
  return (
    ra({
      enabled: !a,
      open: e,
      ref: t.context.popupRef,
      onComplete() {
        e || i();
      },
    }),
    { forceUnmount: i, transitionStatus: s }
  );
}
class qo {
  constructor() {
    ((this.elements = new Set()), (this.idMap = new Map()));
  }
  add(t, n) {
    const r = this.idMap.get(t);
    r !== n &&
      (r !== void 0 && this.elements.delete(r), this.elements.add(n), this.idMap.set(t, n));
  }
  delete(t) {
    const n = this.idMap.get(t);
    n && (this.elements.delete(n), this.idMap.delete(t));
  }
  hasElement(t) {
    return this.elements.has(t);
  }
  hasMatchingElement(t) {
    for (const n of this.elements) if (t(n)) return !0;
    return !1;
  }
  getById(t) {
    return this.idMap.get(t);
  }
  entries() {
    return this.idMap.entries();
  }
  get size() {
    return this.idMap.size;
  }
}
function v0() {
  return new pa({
    open: !1,
    floatingElement: null,
    referenceElement: null,
    triggerElements: new qo(),
    floatingId: "",
    nested: !1,
    noEmit: !1,
    onOpenChange: void 0,
  });
}
function _f() {
  return {
    open: !1,
    mounted: !1,
    transitionStatus: "idle",
    floatingRootContext: v0(),
    preventUnmountingOnClose: !1,
    payload: void 0,
    activeTriggerId: null,
    activeTriggerElement: null,
    popupElement: null,
    positionerElement: null,
    activeTriggerProps: je,
    inactiveTriggerProps: je,
    popupProps: je,
  };
}
const Yf = {
  open: me((e) => e.open),
  mounted: me((e) => e.mounted),
  transitionStatus: me((e) => e.transitionStatus),
  floatingRootContext: me((e) => e.floatingRootContext),
  preventUnmountingOnClose: me((e) => e.preventUnmountingOnClose),
  payload: me((e) => e.payload),
  activeTriggerId: me((e) => e.activeTriggerId),
  activeTriggerElement: me((e) => (e.mounted ? e.activeTriggerElement : null)),
  isTriggerActive: me((e, t) => t !== void 0 && e.activeTriggerId === t),
  isOpenedByTrigger: me((e, t) => t !== void 0 && e.activeTriggerId === t && e.open),
  isMountedByTrigger: me((e, t) => t !== void 0 && e.activeTriggerId === t && e.mounted),
  triggerProps: me((e, t) => (t ? e.activeTriggerProps : e.inactiveTriggerProps)),
  popupProps: me((e) => e.popupProps),
  popupElement: me((e) => e.popupElement),
  positionerElement: me((e) => e.positionerElement),
};
function w0(e) {
  const { open: t = !1, onOpenChange: n, elements: r = {} } = e,
    o = Rn(),
    s = Bt() != null,
    i = ft(
      () =>
        new pa({
          open: t,
          onOpenChange: n,
          referenceElement: r.reference ?? null,
          floatingElement: r.floating ?? null,
          triggerElements: r.triggers ?? new qo(),
          floatingId: o,
          nested: s,
          noEmit: e.noEmit || !1,
        }),
    ).current;
  return (
    ee(() => {
      const a = { open: t, floatingId: o };
      (r.reference !== void 0 &&
        ((a.referenceElement = r.reference),
        (a.domReferenceElement = ke(r.reference) ? r.reference : null)),
        r.floating !== void 0 && (a.floatingElement = r.floating),
        i.update(a));
    }, [t, o, r.reference, r.floating, i]),
    (i.context.onOpenChange = n),
    (i.context.nested = s),
    (i.context.noEmit = e.noEmit || !1),
    i
  );
}
function S0(e = {}) {
  const { nodeId: t, externalTree: n } = e,
    r = w0(e),
    o = e.rootContext || r,
    s = {
      reference: o.useState("referenceElement"),
      floating: o.useState("floatingElement"),
      domReference: o.useState("domReferenceElement"),
    },
    [i, a] = h.useState(null),
    l = h.useRef(null),
    c = sn(n);
  ee(() => {
    s.domReference && (l.current = s.domReference);
  }, [s.domReference]);
  const u = zw({ ...e, elements: { ...s, ...(i && { reference: i }) } }),
    d = h.useCallback(
      (I) => {
        const P = ke(I)
          ? {
              getBoundingClientRect: () => I.getBoundingClientRect(),
              getClientRects: () => I.getClientRects(),
              contextElement: I,
            }
          : I;
        (a(P), u.refs.setReference(P));
      },
      [u.refs],
    ),
    [f, m] = h.useState(null),
    [g, p] = h.useState(null);
  (o.useSyncedValue("referenceElement", f),
    o.useSyncedValue("domReferenceElement", ke(f) ? f : null),
    o.useSyncedValue("floatingElement", g));
  const v = h.useCallback(
      (I) => {
        ((ke(I) || I === null) && ((l.current = I), m(I)),
          (ke(u.refs.reference.current) ||
            u.refs.reference.current === null ||
            (I !== null && !ke(I))) &&
            u.refs.setReference(I));
      },
      [u.refs, m],
    ),
    b = h.useCallback(
      (I) => {
        (p(I), u.refs.setFloating(I));
      },
      [u.refs],
    ),
    y = h.useMemo(
      () => ({
        ...u.refs,
        setReference: v,
        setFloating: b,
        setPositionReference: d,
        domReference: l,
      }),
      [u.refs, v, b, d],
    ),
    w = h.useMemo(
      () => ({ ...u.elements, domReference: s.domReference }),
      [u.elements, s.domReference],
    ),
    R = o.useState("open"),
    x = o.useState("floatingId"),
    A = h.useMemo(
      () => ({
        ...u,
        dataRef: o.context.dataRef,
        open: R,
        onOpenChange: o.setOpen,
        events: o.context.events,
        floatingId: x,
        refs: y,
        elements: w,
        nodeId: t,
        rootStore: o,
      }),
      [u, y, w, t, o, R, x],
    );
  return (
    ee(() => {
      o.context.dataRef.current.floatingContext = A;
      const I = c == null ? void 0 : c.nodesRef.current.find((P) => P.id === t);
      I && (I.context = A);
    }),
    h.useMemo(() => ({ ...u, context: A, refs: y, elements: w, rootStore: o }), [u, y, w, A, o])
  );
}
function qf(e) {
  const { popupStore: t, noEmit: n = !1, treatPopupAsFloatingElement: r = !1, onOpenChange: o } = e,
    s = Rn(),
    i = Bt() != null,
    a = t.useState("open"),
    l = t.useState("activeTriggerElement"),
    c = t.useState(r ? "popupElement" : "positionerElement"),
    u = t.context.triggerElements,
    d = ft(
      () =>
        new pa({
          open: a,
          referenceElement: l,
          floatingElement: c,
          triggerElements: u,
          onOpenChange: o,
          floatingId: s,
          nested: i,
          noEmit: n,
        }),
    ).current;
  return (
    ee(() => {
      const f = { open: a, floatingId: s, referenceElement: l, floatingElement: c };
      (ke(l) && (f.domReferenceElement = l),
        d.state.positionReference === d.state.referenceElement && (f.positionReference = l),
        d.update(f));
    }, [a, s, l, c, d]),
    (d.context.onOpenChange = o),
    (d.context.nested = i),
    (d.context.noEmit = n),
    d
  );
}
const vs = cv && Qd;
function Xf(e, t = {}) {
  const n = "rootStore" in e ? e.rootStore : e,
    { events: r, dataRef: o } = n.context,
    { enabled: s = !0, visibleOnly: i = !0, delay: a } = t,
    l = h.useRef(!1),
    c = h.useRef(null),
    u = Ge(),
    d = h.useRef(!0);
  (h.useEffect(() => {
    const m = n.select("domReferenceElement");
    if (!s) return;
    const g = _e(m);
    function p() {
      const y = n.select("domReferenceElement");
      !n.select("open") && Ne(y) && y === Tt($e(y)) && (l.current = !0);
    }
    function v() {
      d.current = !0;
    }
    function b() {
      d.current = !1;
    }
    return (
      g.addEventListener("blur", p),
      vs && (g.addEventListener("keydown", v, !0), g.addEventListener("pointerdown", b, !0)),
      () => {
        (g.removeEventListener("blur", p),
          vs &&
            (g.removeEventListener("keydown", v, !0), g.removeEventListener("pointerdown", b, !0)));
      }
    );
  }, [n, s]),
    h.useEffect(() => {
      if (!s) return;
      function m(g) {
        if (g.reason === Yt || g.reason === Bo) {
          const p = n.select("domReferenceElement");
          ke(p) && ((c.current = p), (l.current = !0));
        }
      }
      return (
        r.on("openchange", m),
        () => {
          r.off("openchange", m);
        }
      );
    }, [r, s, n]));
  const f = h.useMemo(
    () => ({
      onMouseLeave() {
        ((l.current = !1), (c.current = null));
      },
      onFocus(m) {
        const g = m.currentTarget;
        if (l.current) {
          if (c.current === g) return;
          ((l.current = !1), (c.current = null));
        }
        const p = rt(m.nativeEvent);
        if (i && ke(p)) {
          if (vs && !m.relatedTarget) {
            if (!d.current && !sa(p)) return;
          } else if (!mv(p)) return;
        }
        const v = m.relatedTarget && n.context.triggerElements.hasElement(m.relatedTarget),
          { nativeEvent: b, currentTarget: y } = m,
          w = typeof a == "function" ? a() : a;
        if ((n.select("open") && v) || w === 0 || w === void 0) {
          n.setOpen(!0, Te(Fn, b, y));
          return;
        }
        u.start(w, () => {
          l.current || n.setOpen(!0, Te(Fn, b, y));
        });
      },
      onBlur(m) {
        ((l.current = !1), (c.current = null));
        const g = m.relatedTarget,
          p = m.nativeEvent,
          v =
            ke(g) && g.hasAttribute(Xn("focus-guard")) && g.getAttribute("data-type") === "outside";
        u.start(0, () => {
          var R;
          const b = n.select("domReferenceElement"),
            y = Tt(b ? b.ownerDocument : document);
          if (
            (!g && y === b) ||
            Se((R = o.current.floatingContext) == null ? void 0 : R.refs.floating.current, y) ||
            Se(b, y) ||
            v
          )
            return;
          const w = g ?? y;
          if (ke(w)) {
            const x = n.context.triggerElements;
            if (x.hasElement(w) || x.hasMatchingElement((A) => Se(A, w))) return;
          }
          n.setOpen(!1, Te(Fn, p));
        });
      },
    }),
    [o, n, i, u, a],
  );
  return h.useMemo(() => (s ? { reference: f, trigger: f } : {}), [s, f]);
}
const ui = Xn("safe-polygon"),
  T0 = `button,a,[role="button"],select,[tabindex]:not([tabindex="-1"]),${tf}`;
function R0(e) {
  return e ? !!e.closest(T0) : !1;
}
function Gf(e) {
  const t = h.useRef(void 0),
    n = h.useRef(!1),
    r = h.useRef(void 0),
    o = h.useRef(!0),
    s = h.useRef(!1),
    i = h.useRef(() => {}),
    a = h.useRef(!1),
    l = Ge(),
    c = Ge(),
    u = h.useRef(void 0);
  return h.useMemo(() => {
    const d = e.context.dataRef.current;
    return (
      d.hoverInteractionState ||
        (d.hoverInteractionState = {
          pointerTypeRef: t,
          interactedInsideRef: n,
          handlerRef: r,
          blockMouseMoveRef: o,
          performedPointerEventsMutationRef: s,
          unbindMouseMoveRef: i,
          restTimeoutPendingRef: a,
          openChangeTimeout: l,
          restTimeout: c,
          handleCloseOptionsRef: u,
        }),
      d.hoverInteractionState
    );
  }, [e, t, n, r, o, s, i, a, l, c, u]);
}
const E0 = new Set(["click", "mousedown"]);
function Kf(e, t = {}) {
  const n = "rootStore" in e ? e.rootStore : e,
    r = n.useState("open"),
    o = n.useState("floatingElement"),
    s = n.useState("domReferenceElement"),
    { dataRef: i } = n.context,
    { enabled: a = !0, closeDelay: l = 0, externalTree: c } = t,
    {
      pointerTypeRef: u,
      interactedInsideRef: d,
      handlerRef: f,
      performedPointerEventsMutationRef: m,
      unbindMouseMoveRef: g,
      restTimeoutPendingRef: p,
      openChangeTimeout: v,
      handleCloseOptionsRef: b,
    } = Gf(n),
    y = sn(c),
    w = Bt(),
    R = J(() => (d.current ? !0 : i.current.openEvent ? E0.has(i.current.openEvent.type) : !1)),
    x = J(() => {
      var B;
      const V = (B = i.current.openEvent) == null ? void 0 : B.type;
      return (V == null ? void 0 : V.includes("mouse")) && V !== "mousedown";
    }),
    A = h.useCallback(
      (V, B = !0) => {
        const M = C0(l, u.current);
        M && !f.current
          ? v.start(M, () => n.setOpen(!1, Te(et, V)))
          : B && (v.clear(), n.setOpen(!1, Te(et, V)));
      },
      [l, f, n, u, v],
    ),
    I = J(() => {
      (g.current(), (f.current = void 0));
    }),
    P = J(() => {
      if (m.current) {
        const V = $e(o).body;
        ((V.style.pointerEvents = ""), V.removeAttribute(ui), (m.current = !1));
      }
    }),
    D = J((V) => {
      const B = rt(V);
      if (!R0(B)) {
        d.current = !1;
        return;
      }
      d.current = !0;
    });
  (ee(() => {
    r || ((u.current = void 0), (p.current = !1), (d.current = !1), I(), P());
  }, [r, u, p, d, I, P]),
    h.useEffect(
      () => () => {
        I();
      },
      [I],
    ),
    h.useEffect(() => P, [P]),
    ee(() => {
      var V, B, M;
      if (a && r && (V = b.current) != null && V.blockPointerEvents && x() && ke(s) && o) {
        m.current = !0;
        const C = $e(o).body;
        C.setAttribute(ui, "");
        const L = s,
          k = o,
          F =
            (M =
              (B = y == null ? void 0 : y.nodesRef.current.find((E) => E.id === w)) == null
                ? void 0
                : B.context) == null
              ? void 0
              : M.elements.floating;
        return (
          F && (F.style.pointerEvents = ""),
          (C.style.pointerEvents = "none"),
          (L.style.pointerEvents = "auto"),
          (k.style.pointerEvents = "auto"),
          () => {
            ((C.style.pointerEvents = ""),
              (L.style.pointerEvents = ""),
              (k.style.pointerEvents = ""));
          }
        );
      }
    }, [a, r, s, o, b, x, y, w, m]),
    h.useEffect(() => {
      if (!a) return;
      function V(L) {
        if (R() || !i.current.floatingContext || !n.select("open")) return;
        const k = n.context.triggerElements;
        (L.relatedTarget && k.hasElement(L.relatedTarget)) || (P(), I(), R() || A(L));
      }
      function B(L) {
        var k;
        (v.clear(), P(), (k = f.current) == null || k.call(f, L), I());
      }
      function M(L) {
        R() || A(L, !1);
      }
      const C = o;
      return (
        C &&
          (C.addEventListener("mouseleave", V),
          C.addEventListener("mouseenter", B),
          C.addEventListener("mouseleave", M),
          C.addEventListener("pointerdown", D, !0)),
        () => {
          C &&
            (C.removeEventListener("mouseleave", V),
            C.removeEventListener("mouseenter", B),
            C.removeEventListener("mouseleave", M),
            C.removeEventListener("pointerdown", D, !0));
        }
      );
    }));
}
function C0(e, t) {
  return t && !vn(t) ? 0 : typeof e == "function" ? e() : e;
}
function ws(e) {
  return typeof e == "function" ? e() : e;
}
const P0 = { current: null };
function Qf(e, t = {}) {
  var E;
  const n = "rootStore" in e ? e.rootStore : e,
    { dataRef: r, events: o } = n.context,
    {
      enabled: s = !0,
      delay: i = 0,
      handleClose: a = null,
      mouseOnly: l = !1,
      restMs: c = 0,
      move: u = !0,
      triggerElementRef: d = P0,
      externalTree: f,
      isActiveTrigger: m = !0,
    } = t,
    g = sn(f),
    {
      pointerTypeRef: p,
      interactedInsideRef: v,
      handlerRef: b,
      blockMouseMoveRef: y,
      performedPointerEventsMutationRef: w,
      unbindMouseMoveRef: R,
      restTimeoutPendingRef: x,
      openChangeTimeout: A,
      restTimeout: I,
      handleCloseOptionsRef: P,
    } = Gf(n),
    D = tt(a),
    V = tt(i),
    B = tt(c);
  m && (P.current = (E = D.current) == null ? void 0 : E.__options);
  const M = J(() =>
      v.current
        ? !0
        : r.current.openEvent
          ? ["click", "mousedown"].includes(r.current.openEvent.type)
          : !1,
    ),
    C = h.useCallback(
      (S, O = !0) => {
        const j = co(V.current, "close", p.current);
        j && !b.current
          ? A.start(j, () => n.setOpen(!1, Te(et, S)))
          : O && (A.clear(), n.setOpen(!1, Te(et, S)));
      },
      [V, b, n, p, A],
    ),
    L = J(() => {
      (R.current(), (b.current = void 0));
    }),
    k = J(() => {
      if (w.current) {
        const S = $e(n.select("domReferenceElement")).body;
        ((S.style.pointerEvents = ""), S.removeAttribute(ui), (w.current = !1));
      }
    });
  h.useEffect(() => {
    if (!s) return;
    function S(O) {
      O.open || (A.clear(), I.clear(), (y.current = !0), (x.current = !1));
    }
    return (
      o.on("openchange", S),
      () => {
        o.off("openchange", S);
      }
    );
  }, [s, o, A, I, y, x]);
  const F = J((S) => {
    var _;
    if (M() || !r.current.floatingContext) return;
    const O = n.context.triggerElements;
    if (S.relatedTarget && O.hasElement(S.relatedTarget)) return;
    const j = d.current;
    (_ = D.current) == null ||
      _.call(D, {
        ...r.current.floatingContext,
        tree: g,
        x: S.clientX,
        y: S.clientY,
        onClose() {
          (k(), L(), !M() && j === n.select("domReferenceElement") && C(S));
        },
      })(S);
  });
  return (
    h.useEffect(() => {
      if (!s) return;
      const S = d.current ?? (m ? n.select("domReferenceElement") : null);
      if (!ke(S)) return;
      function O(Q) {
        if (
          (A.clear(),
          (y.current = !1),
          (l && !vn(p.current)) || (ws(B.current) > 0 && !co(V.current, "open")))
        )
          return;
        const $ = co(V.current, "open", p.current),
          Y = n.select("domReferenceElement"),
          ne = n.context.triggerElements,
          te =
            (ne.hasElement(Q.target) || ne.hasMatchingElement((ce) => Se(ce, Q.target))) &&
            (!Y || !Se(Y, Q.target)),
          H = Q.currentTarget ?? null,
          ue = n.select("open"),
          le = !ue || te;
        te && ue
          ? n.setOpen(!0, Te(et, Q, H))
          : $
            ? A.start($, () => {
                le && n.setOpen(!0, Te(et, Q, H));
              })
            : le && n.setOpen(!0, Te(et, Q, H));
      }
      function j(Q) {
        if (M()) {
          k();
          return;
        }
        R.current();
        const $ = n.select("domReferenceElement"),
          Y = $e($);
        (I.clear(), (x.current = !1));
        const ne = n.context.triggerElements;
        if (Q.relatedTarget && ne.hasElement(Q.relatedTarget)) return;
        if (D.current && r.current.floatingContext) {
          n.select("open") || A.clear();
          const H = d.current;
          b.current = D.current({
            ...r.current.floatingContext,
            tree: g,
            x: Q.clientX,
            y: Q.clientY,
            onClose() {
              (k(), L(), !M() && H === n.select("domReferenceElement") && C(Q, !0));
            },
          });
          const ue = b.current;
          (ue(Q),
            Y.addEventListener("mousemove", ue),
            (R.current = () => {
              Y.removeEventListener("mousemove", ue);
            }));
          return;
        }
        (p.current === "touch" ? !Se(n.select("floatingElement"), Q.relatedTarget) : !0) && C(Q);
      }
      function _(Q) {
        F(Q);
      }
      return (
        n.select("open") && S.addEventListener("mouseleave", _),
        u && S.addEventListener("mousemove", O, { once: !0 }),
        S.addEventListener("mouseenter", O),
        S.addEventListener("mouseleave", j),
        () => {
          (S.removeEventListener("mouseleave", _),
            u && S.removeEventListener("mousemove", O),
            S.removeEventListener("mouseenter", O),
            S.removeEventListener("mouseleave", j));
        }
      );
    }, [L, k, y, r, V, C, n, s, D, F, m, M, l, u, p, B, I, x, A, d, g, R, b]),
    h.useMemo(() => {
      function S(O) {
        p.current = O.pointerType;
      }
      return {
        onPointerDown: S,
        onPointerEnter: S,
        onMouseMove(O) {
          const { nativeEvent: j } = O,
            _ = O.currentTarget,
            Q = n.select("domReferenceElement"),
            $ = n.context.triggerElements,
            Y = n.select("open"),
            ne =
              ($.hasElement(O.target) || $.hasMatchingElement((H) => Se(H, O.target))) &&
              (!Q || !Se(Q, O.target));
          if (
            (l && !vn(p.current)) ||
            (Y && !ne) ||
            ws(B.current) === 0 ||
            (!ne && x.current && O.movementX ** 2 + O.movementY ** 2 < 2)
          )
            return;
          I.clear();
          function te() {
            if (((x.current = !1), M())) return;
            const H = n.select("open");
            !y.current && (!H || ne) && n.setOpen(!0, Te(et, j, _));
          }
          p.current === "touch"
            ? Rt.flushSync(() => {
                te();
              })
            : ne && Y
              ? te()
              : ((x.current = !0), I.start(ws(B.current), te));
        },
      };
    }, [y, M, l, n, p, B, I, x])
  );
}
function ga(e = []) {
  const t = e.map((c) => (c == null ? void 0 : c.reference)),
    n = e.map((c) => (c == null ? void 0 : c.floating)),
    r = e.map((c) => (c == null ? void 0 : c.item)),
    o = e.map((c) => (c == null ? void 0 : c.trigger)),
    s = h.useCallback((c) => Xr(c, e, "reference"), t),
    i = h.useCallback((c) => Xr(c, e, "floating"), n),
    a = h.useCallback((c) => Xr(c, e, "item"), r),
    l = h.useCallback((c) => Xr(c, e, "trigger"), o);
  return h.useMemo(
    () => ({ getReferenceProps: s, getFloatingProps: i, getItemProps: a, getTriggerProps: l }),
    [s, i, a, l],
  );
}
function Xr(e, t, n) {
  var i;
  const r = new Map(),
    o = n === "item",
    s = {};
  n === "floating" && ((s.tabIndex = -1), (s[ri] = ""));
  for (const a in e) (o && e && (a === Jd || a === ef)) || (s[a] = e[a]);
  for (let a = 0; a < t.length; a += 1) {
    let l;
    const c = (i = t[a]) == null ? void 0 : i[n];
    (typeof c == "function" ? (l = e ? c(e) : null) : (l = c), l && yc(s, l, o, r));
  }
  return (yc(s, e, o, r), s);
}
function yc(e, t, n, r) {
  var o;
  for (const s in t) {
    const i = t[s];
    (n && (s === Jd || s === ef)) ||
      (s.startsWith("on")
        ? (r.has(s) || r.set(s, []),
          typeof i == "function" &&
            ((o = r.get(s)) == null || o.push(i),
            (e[s] = (...a) => {
              var l;
              return (l = r.get(s)) == null
                ? void 0
                : l.map((c) => c(...a)).find((c) => c !== void 0);
            })))
        : (e[s] = i));
  }
}
const k0 = "Escape";
function Xo(e, t, n) {
  switch (e) {
    case "vertical":
      return t;
    case "horizontal":
      return n;
    default:
      return t || n;
  }
}
function Gr(e, t) {
  return Xo(t, e === oa || e === Dr, e === Xt || e === Gt);
}
function Ss(e, t, n) {
  return Xo(t, e === Dr, n ? e === Xt : e === Gt) || e === "Enter" || e === " " || e === "";
}
function M0(e, t, n) {
  return Xo(t, n ? e === Xt : e === Gt, e === Dr);
}
function A0(e, t, n, r) {
  const o = n ? e === Gt : e === Xt,
    s = e === oa;
  return t === "both" || (t === "horizontal" && r && r > 1) ? e === k0 : Xo(t, o, s);
}
function O0(e, t) {
  const n = "rootStore" in e ? e.rootStore : e,
    r = n.useState("open"),
    o = n.useState("floatingElement"),
    s = n.useState("domReferenceElement"),
    i = n.context.dataRef,
    {
      listRef: a,
      activeIndex: l,
      onNavigate: c = () => {},
      enabled: u = !0,
      selectedIndex: d = null,
      allowEscape: f = !1,
      loopFocus: m = !1,
      nested: g = !1,
      rtl: p = !1,
      virtual: v = !1,
      focusItemOnOpen: b = "auto",
      focusItemOnHover: y = !0,
      openOnArrowKeyDown: w = !0,
      disabledIndices: R = void 0,
      orientation: x = "vertical",
      parentOrientation: A,
      cols: I = 1,
      scrollItemIntoView: P = !0,
      itemSizes: D,
      dense: V = !1,
      id: B,
      resetOnPointerLeave: M = !0,
      externalTree: C,
    } = t,
    L = wo(o),
    k = tt(L),
    F = Bt(),
    E = sn(C);
  ee(() => {
    i.current.orientation = x;
  }, [i, x]);
  const S = oi(s),
    O = h.useRef(b),
    j = h.useRef(d ?? -1),
    _ = h.useRef(null),
    Q = h.useRef(!0),
    $ = J((U) => {
      c(j.current === -1 ? null : j.current, U);
    }),
    Y = h.useRef($),
    ne = h.useRef(!!o),
    te = h.useRef(r),
    H = h.useRef(!1),
    ue = h.useRef(!1),
    le = tt(R),
    ce = tt(r),
    pe = tt(P),
    N = tt(d),
    X = tt(M),
    q = J(() => {
      function U(Re) {
        v
          ? E == null || E.events.emit("virtualfocus", Re)
          : uo(Re, { sync: H.current, preventScroll: !0 });
      }
      const Z = a.current[j.current],
        K = ue.current;
      (Z && U(Z),
        (H.current ? (Re) => Re() : requestAnimationFrame)(() => {
          var Oe;
          const Re = a.current[j.current] || Z;
          if (!Re) return;
          Z || U(Re);
          const Ee = pe.current;
          Ee &&
            z &&
            (K || !Q.current) &&
            ((Oe = Re.scrollIntoView) == null ||
              Oe.call(Re, typeof Ee == "boolean" ? { block: "nearest", inline: "nearest" } : Ee));
        }));
    });
  (ee(() => {
    u &&
      (r && o
        ? ((j.current = d ?? -1), O.current && d != null && ((ue.current = !0), $()))
        : ne.current && ((j.current = -1), Y.current()));
  }, [u, r, o, d, $]),
    ee(() => {
      if (u) {
        if (!r) {
          H.current = !1;
          return;
        }
        if (o)
          if (l == null) {
            if (((H.current = !1), N.current != null)) return;
            if (
              (ne.current && ((j.current = -1), q()),
              (!te.current || !ne.current) &&
                O.current &&
                (_.current != null || (O.current === !0 && _.current == null)))
            ) {
              let U = 0;
              const Z = () => {
                a.current[0] == null
                  ? (U < 2 && (U ? requestAnimationFrame : queueMicrotask)(Z), (U += 1))
                  : ((j.current = _.current == null || Ss(_.current, x, p) || g ? lo(a) : ai(a)),
                    (_.current = null),
                    $());
              };
              Z();
            }
          } else Ln(a, l) || ((j.current = l), q(), (ue.current = !1));
      }
    }, [u, r, o, l, N, g, a, x, p, $, q, le]),
    ee(() => {
      var Re, Ee;
      if (!u || o || !E || v || !ne.current) return;
      const U = E.nodesRef.current,
        Z =
          (Ee = (Re = U.find((Ce) => Ce.id === F)) == null ? void 0 : Re.context) == null
            ? void 0
            : Ee.elements.floating,
        K = Tt($e(o)),
        xe = U.some((Ce) => Ce.context && Se(Ce.context.elements.floating, K));
      Z && !xe && Q.current && Z.focus({ preventScroll: !0 });
    }, [u, o, E, F, v]),
    ee(() => {
      ((Y.current = $), (te.current = r), (ne.current = !!o));
    }),
    ee(() => {
      r || ((_.current = null), (O.current = b));
    }, [r, b]));
  const we = l != null,
    z = h.useMemo(() => {
      function U(K) {
        if (!ce.current) return;
        const xe = a.current.indexOf(K.currentTarget);
        xe !== -1 && j.current !== xe && ((j.current = xe), $(K));
      }
      return {
        onFocus(K) {
          ((H.current = !0), U(K));
        },
        onClick: ({ currentTarget: K }) => K.focus({ preventScroll: !0 }),
        onMouseMove(K) {
          ((H.current = !0), (ue.current = !1), y && U(K));
        },
        onPointerLeave(K) {
          var Re;
          if (!ce.current || !Q.current || K.pointerType === "touch") return;
          H.current = !0;
          const xe = K.relatedTarget;
          !y ||
            a.current.includes(xe) ||
            (X.current &&
              ((j.current = -1),
              $(K),
              v || (Re = k.current) == null || Re.focus({ preventScroll: !0 })));
        },
      };
    }, [ce, k, y, a, $, X, v]),
    W = h.useCallback(() => {
      var U, Z, K;
      return (
        A ??
        ((K =
          (Z =
            (U = E == null ? void 0 : E.nodesRef.current.find((xe) => xe.id === F)) == null
              ? void 0
              : U.context) == null
            ? void 0
            : Z.dataRef) == null
          ? void 0
          : K.current.orientation)
      );
    }, [F, E, A]),
    G = J((U) => {
      if (
        ((Q.current = !1),
        (H.current = !0),
        U.which === 229 || (!ce.current && U.currentTarget === k.current))
      )
        return;
      if (g && A0(U.key, x, p, I)) {
        (Gr(U.key, W()) || Je(U),
          n.setOpen(!1, Te(ao, U.nativeEvent)),
          Ne(s) && (v ? E == null || E.events.emit("virtualfocus", s) : s.focus()));
        return;
      }
      const Z = j.current,
        K = lo(a, R),
        xe = ai(a, R);
      if (
        (S ||
          (U.key === "Home" && (Je(U), (j.current = K), $(U)),
          U.key === "End" && (Je(U), (j.current = xe), $(U))),
        I > 1)
      ) {
        const Re = D || Array.from({ length: a.current.length }, () => ({ width: 1, height: 1 })),
          Ee = lf(Re, I, V),
          Ce = Ee.findIndex((ze) => ze != null && !Kt(a, ze, R)),
          Oe = Ee.reduce((ze, ct, ge) => (ct != null && !Kt(a, ct, R) ? ge : ze), -1),
          Ie =
            Ee[
              af(
                { current: Ee.map((ze) => (ze != null ? a.current[ze] : null)) },
                {
                  event: U,
                  orientation: x,
                  loopFocus: m,
                  rtl: p,
                  cols: I,
                  disabledIndices: uf(
                    [
                      ...((typeof R != "function" ? R : null) ||
                        a.current.map((ze, ct) => (Kt(a, ct, R) ? ct : void 0))),
                      void 0,
                    ],
                    Ee,
                  ),
                  minIndex: Ce,
                  maxIndex: Oe,
                  prevIndex: cf(
                    j.current > xe ? K : j.current,
                    Re,
                    Ee,
                    I,
                    U.key === Dr ? "bl" : U.key === (p ? Xt : Gt) ? "tr" : "tl",
                  ),
                  stopEvent: !0,
                },
              )
            ];
        if ((Ie != null && ((j.current = Ie), $(U)), x === "both")) return;
      }
      if (Gr(U.key, x)) {
        if ((Je(U), r && !v && Tt(U.currentTarget.ownerDocument) === U.currentTarget)) {
          ((j.current = Ss(U.key, x, p) ? K : xe), $(U));
          return;
        }
        (Ss(U.key, x, p)
          ? m
            ? Z >= xe
              ? f && Z !== a.current.length
                ? (j.current = -1)
                : ((H.current = !1), (j.current = K))
              : (j.current = Ze(a, { startingIndex: Z, disabledIndices: R }))
            : (j.current = Math.min(xe, Ze(a, { startingIndex: Z, disabledIndices: R })))
          : m
            ? Z <= K
              ? f && Z !== -1
                ? (j.current = a.current.length)
                : ((H.current = !1), (j.current = xe))
              : (j.current = Ze(a, { startingIndex: Z, decrement: !0, disabledIndices: R }))
            : (j.current = Math.max(
                K,
                Ze(a, { startingIndex: Z, decrement: !0, disabledIndices: R }),
              )),
          Ln(a, j.current) && (j.current = -1),
          $(U));
      }
    }),
    ie = h.useMemo(
      () => v && r && we && { "aria-activedescendant": `${B}-${l}` },
      [v, r, we, B, l],
    ),
    he = h.useMemo(
      () => ({
        "aria-orientation": x === "both" ? void 0 : x,
        ...(S ? {} : ie),
        onKeyDown(U) {
          if (U.key === "Tab" && U.shiftKey && r && !v) {
            const Z = rt(U.nativeEvent);
            if (Z && !Se(k.current, Z)) return;
            (Je(U), n.setOpen(!1, Te(_n, U.nativeEvent)), Ne(s) && s.focus());
            return;
          }
          G(U);
        },
        onPointerMove() {
          Q.current = !0;
        },
      }),
      [ie, G, k, x, S, n, r, v, s],
    ),
    ae = h.useMemo(() => {
      function U(K) {
        b === "auto" && nf(K.nativeEvent) && (O.current = !v);
      }
      function Z(K) {
        ((O.current = b), b === "auto" && rf(K.nativeEvent) && (O.current = !0));
      }
      return {
        onKeyDown(K) {
          const xe = n.select("open");
          Q.current = !1;
          const Re = K.key.startsWith("Arrow"),
            Ee = M0(K.key, W(), p),
            Ce = Gr(K.key, x),
            Oe = (g ? Ee : Ce) || K.key === "Enter" || K.key.trim() === "";
          if (v && xe) return G(K);
          if (!(!xe && !w && Re)) {
            if (Oe) {
              const Ie = Gr(K.key, W());
              _.current = g && Ie ? null : K.key;
            }
            if (g) {
              Ee &&
                (Je(K),
                xe
                  ? ((j.current = lo(a, le.current)), $(K))
                  : n.setOpen(!0, Te(ao, K.nativeEvent, K.currentTarget)));
              return;
            }
            Ce &&
              (N.current != null && (j.current = N.current),
              Je(K),
              !xe && w ? n.setOpen(!0, Te(ao, K.nativeEvent, K.currentTarget)) : G(K),
              xe && $(K));
          }
        },
        onFocus(K) {
          n.select("open") && !v && ((j.current = -1), $(K));
        },
        onPointerDown: Z,
        onPointerEnter: Z,
        onMouseDown: U,
        onClick: U,
      };
    }, [G, le, b, a, g, $, n, w, x, W, p, N, v]),
    de = h.useMemo(() => ({ ...ie, ...ae }), [ie, ae]);
  return h.useMemo(
    () => (u ? { reference: de, floating: he, item: z, trigger: ae } : {}),
    [u, de, he, ae, z],
  );
}
const I0 = new Map([
  ["select", "listbox"],
  ["combobox", "listbox"],
  ["label", !1],
]);
function D0(e, t = {}) {
  const n = "rootStore" in e ? e.rootStore : e,
    r = n.useState("open"),
    o = n.useState("floatingId"),
    s = n.useState("domReferenceElement"),
    i = n.useState("floatingElement"),
    { enabled: a = !0, role: l = "dialog" } = t,
    c = Rn(),
    u = (s == null ? void 0 : s.id) || c,
    d = h.useMemo(() => {
      var w;
      return ((w = wo(i)) == null ? void 0 : w.id) || o;
    }, [i, o]),
    f = I0.get(l) ?? l,
    g = Bt() != null,
    p = h.useMemo(
      () =>
        f === "tooltip" || l === "label"
          ? je
          : {
              "aria-haspopup": f === "alertdialog" ? "dialog" : f,
              "aria-expanded": "false",
              ...(f === "listbox" && { role: "combobox" }),
              ...(f === "menu" && g && { role: "menuitem" }),
              ...(l === "select" && { "aria-autocomplete": "none" }),
              ...(l === "combobox" && { "aria-autocomplete": "list" }),
            },
      [f, g, l],
    ),
    v = h.useMemo(
      () =>
        f === "tooltip" || l === "label"
          ? { [`aria-${l === "label" ? "labelledby" : "describedby"}`]: r ? d : void 0 }
          : {
              ...p,
              "aria-expanded": r ? "true" : "false",
              "aria-controls": r ? d : void 0,
              ...(f === "menu" && { id: u }),
            },
      [f, d, r, u, l, p],
    ),
    b = h.useMemo(() => {
      const w = { id: d, ...(f && { role: f }) };
      return f === "tooltip" || l === "label"
        ? w
        : { ...w, ...(f === "menu" && { "aria-labelledby": u }) };
    }, [f, d, u, l]),
    y = h.useCallback(
      ({ active: w, selected: R }) => {
        const x = { role: "option", ...(w && { id: `${d}-fui-option` }) };
        switch (l) {
          case "select":
          case "combobox":
            return { ...x, "aria-selected": R };
        }
        return {};
      },
      [d, l],
    );
  return h.useMemo(
    () => (a ? { reference: v, floating: b, item: y, trigger: p } : {}),
    [a, v, b, p, y],
  );
}
function N0(e, t) {
  const n = "rootStore" in e ? e.rootStore : e,
    r = n.useState("open"),
    o = n.context.dataRef,
    {
      listRef: s,
      activeIndex: i,
      onMatch: a,
      onTypingChange: l,
      enabled: c = !0,
      findMatch: u = null,
      resetMs: d = 750,
      ignoreKeys: f = xn,
      selectedIndex: m = null,
    } = t,
    g = Ge(),
    p = h.useRef(""),
    v = h.useRef(m ?? i ?? -1),
    b = h.useRef(null);
  (ee(() => {
    r && (g.clear(), (b.current = null), (p.current = ""));
  }, [r, g]),
    ee(() => {
      r && p.current === "" && (v.current = m ?? i ?? -1);
    }, [r, m, i]));
  const y = J((A) => {
      A
        ? o.current.typing || ((o.current.typing = A), l == null || l(A))
        : o.current.typing && ((o.current.typing = A), l == null || l(A));
    }),
    w = J((A) => {
      function I(M, C, L) {
        const k = u
          ? u(C, L)
          : C.find(
              (F) =>
                (F == null ? void 0 : F.toLocaleLowerCase().indexOf(L.toLocaleLowerCase())) === 0,
            );
        return k ? M.indexOf(k) : -1;
      }
      const P = s.current;
      if (
        (p.current.length > 0 &&
          p.current[0] !== " " &&
          (I(P, P, p.current) === -1 ? y(!1) : A.key === " " && Je(A)),
        P == null || f.includes(A.key) || A.key.length !== 1 || A.ctrlKey || A.metaKey || A.altKey)
      )
        return;
      (r && A.key !== " " && (Je(A), y(!0)),
        P.every((M) => {
          var C, L;
          return M
            ? ((C = M[0]) == null ? void 0 : C.toLocaleLowerCase()) !==
                ((L = M[1]) == null ? void 0 : L.toLocaleLowerCase())
            : !0;
        }) &&
          p.current === A.key &&
          ((p.current = ""), (v.current = b.current)),
        (p.current += A.key),
        g.start(d, () => {
          ((p.current = ""), (v.current = b.current), y(!1));
        }));
      const V = v.current,
        B = I(P, [...P.slice((V || 0) + 1), ...P.slice(0, (V || 0) + 1)], p.current);
      B !== -1 ? (a == null || a(B), (b.current = B)) : A.key !== " " && ((p.current = ""), y(!1));
    }),
    R = h.useMemo(() => ({ onKeyDown: w }), [w]),
    x = h.useMemo(
      () => ({
        onKeyDown: w,
        onKeyUp(A) {
          A.key === " " && y(!1);
        },
      }),
      [w, y],
    );
  return h.useMemo(() => (c ? { reference: R, floating: x } : {}), [c, R, x]);
}
function xc(e, t) {
  const [n, r] = e;
  let o = !1;
  const s = t.length;
  for (let i = 0, a = s - 1; i < s; a = i++) {
    const [l, c] = t[i] || [0, 0],
      [u, d] = t[a] || [0, 0];
    c >= r != d >= r && n <= ((u - l) * (r - c)) / (d - c) + l && (o = !o);
  }
  return o;
}
function F0(e, t) {
  return e[0] >= t.x && e[0] <= t.x + t.width && e[1] >= t.y && e[1] <= t.y + t.height;
}
function Zf(e = {}) {
  const { buffer: t = 0.5, blockPointerEvents: n = !1, requireIntent: r = !0 } = e,
    o = new en();
  let s = !1,
    i = null,
    a = null,
    l = typeof performance < "u" ? performance.now() : 0;
  function c(d, f) {
    const m = performance.now(),
      g = m - l;
    if (i === null || a === null || g === 0) return ((i = d), (a = f), (l = m), null);
    const p = d - i,
      v = f - a,
      y = Math.sqrt(p * p + v * v) / g;
    return ((i = d), (a = f), (l = m), y);
  }
  const u = ({ x: d, y: f, placement: m, elements: g, onClose: p, nodeId: v, tree: b }) =>
    function (w) {
      function R() {
        (o.clear(), p());
      }
      if ((o.clear(), !g.domReference || !g.floating || m == null || d == null || f == null))
        return;
      const { clientX: x, clientY: A } = w,
        I = [x, A],
        P = rt(w),
        D = w.type === "mouseleave",
        V = Se(g.floating, P),
        B = Se(g.domReference, P),
        M = g.domReference.getBoundingClientRect(),
        C = g.floating.getBoundingClientRect(),
        L = m.split("-")[0],
        k = d > C.right - C.width / 2,
        F = f > C.bottom - C.height / 2,
        E = F0(I, M),
        S = C.width > M.width,
        O = C.height > M.height,
        j = (S ? M : C).left,
        _ = (S ? M : C).right,
        Q = (O ? M : C).top,
        $ = (O ? M : C).bottom;
      if (V && ((s = !0), !D)) return;
      if ((B && (s = !1), B && !D)) {
        s = !0;
        return;
      }
      if (
        (D && ke(w.relatedTarget) && Se(g.floating, w.relatedTarget)) ||
        (b && yn(b.nodesRef.current, v).some(({ context: te }) => (te == null ? void 0 : te.open)))
      )
        return;
      if (
        (L === "top" && f >= M.bottom - 1) ||
        (L === "bottom" && f <= M.top + 1) ||
        (L === "left" && d >= M.right - 1) ||
        (L === "right" && d <= M.left + 1)
      )
        return R();
      let Y = [];
      switch (L) {
        case "top":
          Y = [
            [j, M.top + 1],
            [j, C.bottom - 1],
            [_, C.bottom - 1],
            [_, M.top + 1],
          ];
          break;
        case "bottom":
          Y = [
            [j, C.top + 1],
            [j, M.bottom - 1],
            [_, M.bottom - 1],
            [_, C.top + 1],
          ];
          break;
        case "left":
          Y = [
            [C.right - 1, $],
            [C.right - 1, Q],
            [M.left + 1, Q],
            [M.left + 1, $],
          ];
          break;
        case "right":
          Y = [
            [M.right - 1, $],
            [M.right - 1, Q],
            [C.left + 1, Q],
            [C.left + 1, $],
          ];
          break;
      }
      function ne([te, H]) {
        switch (L) {
          case "top": {
            const ue = [S ? te + t / 2 : k ? te + t * 4 : te - t * 4, H + t + 1],
              le = [S ? te - t / 2 : k ? te + t * 4 : te - t * 4, H + t + 1],
              ce = [
                [C.left, k || S ? C.bottom - t : C.top],
                [C.right, k ? (S ? C.bottom - t : C.top) : C.bottom - t],
              ];
            return [ue, le, ...ce];
          }
          case "bottom": {
            const ue = [S ? te + t / 2 : k ? te + t * 4 : te - t * 4, H - t],
              le = [S ? te - t / 2 : k ? te + t * 4 : te - t * 4, H - t],
              ce = [
                [C.left, k || S ? C.top + t : C.bottom],
                [C.right, k ? (S ? C.top + t : C.bottom) : C.top + t],
              ];
            return [ue, le, ...ce];
          }
          case "left": {
            const ue = [te + t + 1, O ? H + t / 2 : F ? H + t * 4 : H - t * 4],
              le = [te + t + 1, O ? H - t / 2 : F ? H + t * 4 : H - t * 4];
            return [
              ...[
                [F || O ? C.right - t : C.left, C.top],
                [F ? (O ? C.right - t : C.left) : C.right - t, C.bottom],
              ],
              ue,
              le,
            ];
          }
          case "right": {
            const ue = [te - t, O ? H + t / 2 : F ? H + t * 4 : H - t * 4],
              le = [te - t, O ? H - t / 2 : F ? H + t * 4 : H - t * 4],
              ce = [
                [F || O ? C.left + t : C.right, C.top],
                [F ? (O ? C.left + t : C.right) : C.left + t, C.bottom],
              ];
            return [ue, le, ...ce];
          }
          default:
            return [];
        }
      }
      if (!xc([x, A], Y)) {
        if (s && !E) return R();
        if (!D && r) {
          const te = c(w.clientX, w.clientY);
          if (te !== null && te < 0.1) return R();
        }
        xc([x, A], ne([d, f])) ? !s && r && o.start(40, R) : R();
      }
    };
  return ((u.__options = { blockPointerEvents: n }), u);
}
const L0 = h.createContext(void 0);
function j0(e) {
  return h.useContext(L0);
}
const $n = "ArrowUp",
  gn = "ArrowDown",
  Pr = "ArrowLeft",
  Wn = "ArrowRight",
  Fr = "Home",
  Lr = "End",
  Jf = new Set([Pr, Wn]),
  V0 = new Set([Pr, Wn, Fr, Lr]),
  eh = new Set([$n, gn]),
  B0 = new Set([$n, gn, Fr, Lr]),
  th = new Set([...Jf, ...eh]),
  $0 = new Set([...th, Fr, Lr]),
  W0 = new Set([$n, gn, Pr, Wn, Fr, Lr]),
  z0 = "Shift",
  H0 = "Control",
  U0 = "Alt",
  _0 = "Meta",
  Y0 = new Set([z0, H0, U0, _0]);
function q0(e) {
  return Ne(e) && e.tagName === "INPUT";
}
function vc(e) {
  return !!((q0(e) && e.selectionStart != null) || (Ne(e) && e.tagName === "TEXTAREA"));
}
function wc(e, t, n, r) {
  if (!e || !t || !t.scrollTo) return;
  let o = e.scrollLeft,
    s = e.scrollTop;
  const i = e.clientWidth < e.scrollWidth,
    a = e.clientHeight < e.scrollHeight;
  if (i && r !== "vertical") {
    const l = Sc(e, t, "left"),
      c = Kr(e),
      u = Kr(t);
    (n === "ltr" &&
      (l + t.offsetWidth + u.scrollMarginRight > e.scrollLeft + e.clientWidth - c.scrollPaddingRight
        ? (o = l + t.offsetWidth + u.scrollMarginRight - e.clientWidth + c.scrollPaddingRight)
        : l - u.scrollMarginLeft < e.scrollLeft + c.scrollPaddingLeft &&
          (o = l - u.scrollMarginLeft - c.scrollPaddingLeft)),
      n === "rtl" &&
        (l - u.scrollMarginRight < e.scrollLeft + c.scrollPaddingLeft
          ? (o = l - u.scrollMarginLeft - c.scrollPaddingLeft)
          : l + t.offsetWidth + u.scrollMarginRight >
              e.scrollLeft + e.clientWidth - c.scrollPaddingRight &&
            (o = l + t.offsetWidth + u.scrollMarginRight - e.clientWidth + c.scrollPaddingRight)));
  }
  if (a && r !== "horizontal") {
    const l = Sc(e, t, "top"),
      c = Kr(e),
      u = Kr(t);
    l - u.scrollMarginTop < e.scrollTop + c.scrollPaddingTop
      ? (s = l - u.scrollMarginTop - c.scrollPaddingTop)
      : l + t.offsetHeight + u.scrollMarginBottom >
          e.scrollTop + e.clientHeight - c.scrollPaddingBottom &&
        (s = l + t.offsetHeight + u.scrollMarginBottom - e.clientHeight + c.scrollPaddingBottom);
  }
  e.scrollTo({ left: o, top: s, behavior: "auto" });
}
function Sc(e, t, n) {
  const r = n === "left" ? "offsetLeft" : "offsetTop";
  let o = 0;
  for (; t.offsetParent && ((o += t[r]), t.offsetParent !== e); ) t = t.offsetParent;
  return o;
}
function Kr(e) {
  const t = getComputedStyle(e);
  return {
    scrollMarginTop: parseFloat(t.scrollMarginTop) || 0,
    scrollMarginRight: parseFloat(t.scrollMarginRight) || 0,
    scrollMarginBottom: parseFloat(t.scrollMarginBottom) || 0,
    scrollMarginLeft: parseFloat(t.scrollMarginLeft) || 0,
    scrollPaddingTop: parseFloat(t.scrollPaddingTop) || 0,
    scrollPaddingRight: parseFloat(t.scrollPaddingRight) || 0,
    scrollPaddingBottom: parseFloat(t.scrollPaddingBottom) || 0,
    scrollPaddingLeft: parseFloat(t.scrollPaddingLeft) || 0,
  };
}
function ba(e) {
  return e === "starting" ? yx : je;
}
const X0 = { ...Ir, ...Bd },
  G0 = h.forwardRef(function (t, n) {
    const { render: r, className: o, finalFocus: s, ...i } = t,
      { store: a } = Sn(),
      { side: l, align: c } = Id(),
      u = j0() != null,
      d = a.useState("open"),
      f = a.useState("transitionStatus"),
      m = a.useState("popupProps"),
      g = a.useState("mounted"),
      p = a.useState("instantType"),
      v = a.useState("activeTriggerElement"),
      b = a.useState("parent"),
      y = a.useState("lastOpenChangeReason"),
      w = a.useState("rootId"),
      R = a.useState("floatingRootContext"),
      x = a.useState("floatingTreeRoot"),
      A = a.useState("closeDelay"),
      I = a.useState("activeTriggerElement"),
      P = b.type === "context-menu";
    (ra({
      open: d,
      ref: a.context.popupRef,
      onComplete() {
        var L, k;
        d && ((k = (L = a.context).onOpenChangeComplete) == null || k.call(L, !0));
      },
    }),
      h.useEffect(() => {
        function L(k) {
          a.setOpen(!1, Te(k.reason, k.domEvent));
        }
        return (
          x.events.on("close", L),
          () => {
            x.events.off("close", L);
          }
        );
      }, [x.events, a]));
    const D = a.useState("hoverEnabled"),
      V = a.useState("disabled");
    Kf(R, { enabled: D && !V && !P && b.type !== "menubar", closeDelay: A });
    const B = h.useMemo(
        () => ({
          transitionStatus: f,
          side: l,
          align: c,
          open: d,
          nested: b.type === "menu",
          instant: p,
        }),
        [f, l, c, d, b.type, p],
      ),
      M = We("div", t, {
        state: B,
        ref: [n, a.context.popupRef],
        stateAttributesMapping: X0,
        props: [
          m,
          {
            onKeyDown(L) {
              u && W0.has(L.key) && L.stopPropagation();
            },
          },
          ba(f),
          i,
          { "data-rootownerid": w },
        ],
      });
    let C = b.type === void 0 || P;
    return (
      (v || (b.type === "menubar" && y !== Zi)) && (C = !0),
      T.jsx(sw, {
        context: R,
        modal: P,
        disabled: !g,
        returnFocus: s === void 0 ? C : s,
        initialFocus: b.type !== "menu",
        restoreFocus: !0,
        externalTree: b.type !== "menubar" ? x : void 0,
        previousFocusableElement: I,
        nextFocusableElement: b.type === void 0 ? a.context.triggerFocusTargetRef : void 0,
        beforeContentFocusGuardRef:
          b.type === void 0 ? a.context.beforeContentFocusGuardRef : void 0,
        children: M,
      })
    );
  }),
  nh = h.createContext(void 0);
function K0() {
  const e = h.useContext(nh);
  if (e === void 0) throw new Error(Ke(32));
  return e;
}
const Q0 = h.forwardRef(function (t, n) {
  const { keepMounted: r = !1, ...o } = t,
    { store: s } = Sn();
  return s.useState("mounted") || r
    ? T.jsx(nh.Provider, { value: r, children: T.jsx(ew, { ref: n, ...o }) })
    : null;
});
function Z0(e) {
  return Ki(19) ? e : e ? "true" : void 0;
}
const J0 = h.createContext(void 0);
function tr() {
  const e = h.useContext(J0);
  return (e == null ? void 0 : e.direction) ?? "ltr";
}
const eS = (e) => ({
    name: "arrow",
    options: e,
    async fn(t) {
      var O, j;
      const { x: n, y: r, placement: o, rects: s, platform: i, elements: a, middlewareData: l } = t,
        { element: c, padding: u = 0, offsetParent: d = "real" } = Vt(e, t) || {};
      if (c == null) return {};
      const f = sf(u),
        m = { x: n, y: r },
        g = la(o),
        p = aa(g),
        v = await i.getDimensions(c),
        b = g === "y",
        y = b ? "top" : "left",
        w = b ? "bottom" : "right",
        R = b ? "clientHeight" : "clientWidth",
        x = s.reference[p] + s.reference[g] - m[g] - s.floating[p],
        A = m[g] - s.reference[g],
        I =
          d === "real"
            ? await ((O = i.getOffsetParent) == null ? void 0 : O.call(i, c))
            : a.floating;
      let P = a.floating[R] || s.floating[p];
      (!P || !(await ((j = i.isElement) == null ? void 0 : j.call(i, I)))) &&
        (P = a.floating[R] || s.floating[p]);
      const D = x / 2 - A / 2,
        V = P / 2 - v[p] / 2 - 1,
        B = Math.min(f[y], V),
        M = Math.min(f[w], V),
        C = B,
        L = P - v[p] - M,
        k = P / 2 - v[p] / 2 + D,
        F = si(C, k, L),
        E =
          !l.arrow &&
          on(o) != null &&
          k !== F &&
          s.reference[p] / 2 - (k < C ? B : M) - v[p] / 2 < 0,
        S = E ? (k < C ? k - C : k - L) : 0;
      return {
        [g]: m[g] + S,
        data: { [g]: F, centerOffset: k - F - S, ...(E && { alignmentOffset: S }) },
        reset: E,
      };
    },
  }),
  tS = (e, t) => ({ ...eS(e), options: [e, t] }),
  nS = {
    name: "hide",
    async fn(e) {
      var a;
      const { width: t, height: n, x: r, y: o } = e.rects.reference,
        s = t === 0 && n === 0 && r === 0 && o === 0;
      return {
        data: {
          referenceHidden:
            ((a = (await Xw().fn(e)).data) == null ? void 0 : a.referenceHidden) || s,
        },
      };
    },
  },
  ho = { sideX: "left", sideY: "top" },
  rS = {
    name: "adaptiveOrigin",
    async fn(e) {
      var y, w;
      const {
          x: t,
          y: n,
          rects: { floating: r },
          elements: { floating: o },
          platform: s,
          strategy: i,
          placement: a,
        } = e,
        l = _e(o),
        c = l.getComputedStyle(o);
      if (!(c.transitionDuration !== "0s" && c.transitionDuration !== ""))
        return { x: t, y: n, data: ho };
      const d = await ((y = s.getOffsetParent) == null ? void 0 : y.call(s, o));
      let f = { width: 0, height: 0 };
      if (i === "fixed" && l != null && l.visualViewport)
        f = { width: l.visualViewport.width, height: l.visualViewport.height };
      else if (d === l) {
        const R = xt(o);
        f = { width: R.documentElement.clientWidth, height: R.documentElement.clientHeight };
      } else
        (await ((w = s.isElement) == null ? void 0 : w.call(s, d))) &&
          (f = await s.getDimensions(d));
      const m = lt(a);
      let g = t,
        p = n;
      (m === "left" && (g = f.width - (t + r.width)),
        m === "top" && (p = f.height - (n + r.height)));
      const v = m === "left" ? "right" : ho.sideX,
        b = m === "top" ? "bottom" : ho.sideY;
      return { x: g, y: p, data: { sideX: v, sideY: b } };
    },
  };
function rh(e, t, n) {
  const r = e === "inline-start" || e === "inline-end";
  return {
    top: "top",
    right: r ? (n ? "inline-start" : "inline-end") : "right",
    bottom: "bottom",
    left: r ? (n ? "inline-end" : "inline-start") : "left",
  }[t];
}
function Tc(e, t, n) {
  const { rects: r, placement: o } = e;
  return {
    side: rh(t, lt(o), n),
    align: on(o) || "center",
    anchor: { width: r.reference.width, height: r.reference.height },
    positioner: { width: r.floating.width, height: r.floating.height },
  };
}
function oh(e) {
  var an, it;
  const {
      anchor: t,
      positionMethod: n = "absolute",
      side: r = "bottom",
      sideOffset: o = 0,
      align: s = "center",
      alignOffset: i = 0,
      collisionBoundary: a,
      collisionPadding: l = 5,
      sticky: c = !1,
      arrowPadding: u = 5,
      disableAnchorTracking: d = !1,
      keepMounted: f = !1,
      floatingRootContext: m,
      mounted: g,
      collisionAvoidance: p,
      shiftCrossAxis: v = !1,
      nodeId: b,
      adaptiveOrigin: y,
      lazyFlip: w = !1,
      externalTree: R,
    } = e,
    [x, A] = h.useState(null);
  !g && x !== null && A(null);
  const I = p.side || "flip",
    P = p.align || "flip",
    D = p.fallbackAxisSide || "end",
    V = typeof t == "function" ? t : void 0,
    B = J(V),
    M = V ? B : t,
    C = tt(t),
    k = tr() === "rtl",
    F =
      x ||
      {
        top: "top",
        right: "right",
        bottom: "bottom",
        left: "left",
        "inline-end": k ? "left" : "right",
        "inline-start": k ? "right" : "left",
      }[r],
    E = s === "center" ? F : `${F}-${s}`;
  let S = l;
  const O = 1,
    j = r === "bottom" ? O : 0,
    _ = r === "top" ? O : 0,
    Q = r === "right" ? O : 0,
    $ = r === "left" ? O : 0;
  typeof S == "number"
    ? (S = { top: S + j, right: S + $, bottom: S + _, left: S + Q })
    : S &&
      (S = {
        top: (S.top || 0) + j,
        right: (S.right || 0) + $,
        bottom: (S.bottom || 0) + _,
        left: (S.left || 0) + Q,
      });
  const Y = { boundary: a === "clipping-ancestors" ? "clippingAncestors" : a, padding: S },
    ne = h.useRef(null),
    te = tt(o),
    H = tt(i),
    ce = [
      Hw(
        (Me) => {
          const Be = Tc(Me, r, k),
            Ye = typeof te.current == "function" ? te.current(Be) : te.current,
            be = typeof H.current == "function" ? H.current(Be) : H.current;
          return { mainAxis: Ye, crossAxis: be, alignmentAxis: be };
        },
        [typeof o != "function" ? o : 0, typeof i != "function" ? i : 0, k, r],
      ),
    ],
    pe = P === "none" && I !== "shift",
    N = !pe && (c || v || I === "shift"),
    X =
      I === "none"
        ? null
        : Yw({
            ...Y,
            padding: { top: S.top + O, right: S.right + O, bottom: S.bottom + O, left: S.left + O },
            mainAxis: !v && I === "flip",
            crossAxis: P === "flip" ? "alignment" : !1,
            fallbackAxisSideDirection: D,
          }),
    q = pe
      ? null
      : Uw(
          (Me) => {
            const Be = xt(Me.elements.floating).documentElement;
            return {
              ...Y,
              rootBoundary: v
                ? { x: 0, y: 0, width: Be.clientWidth, height: Be.clientHeight }
                : void 0,
              mainAxis: P !== "none",
              crossAxis: N,
              limiter:
                c || v
                  ? void 0
                  : _w((Ye) => {
                      if (!ne.current) return {};
                      const { width: be, height: He } = ne.current.getBoundingClientRect(),
                        at = gt(lt(Ye.placement)),
                        $t = at === "y" ? be : He,
                        Ko = at === "y" ? S.left + S.right : S.top + S.bottom;
                      return { offset: $t / 2 + Ko / 2 };
                    }),
            };
          },
          [Y, c, v, S, P],
        );
  (I === "shift" || P === "shift" || s === "center" ? ce.push(q, X) : ce.push(X, q),
    ce.push(
      qw({
        ...Y,
        apply({
          elements: { floating: Me },
          rects: { reference: Be },
          availableWidth: Ye,
          availableHeight: be,
        }) {
          Object.entries({
            "--available-width": `${Ye}px`,
            "--available-height": `${be}px`,
            "--anchor-width": `${Be.width}px`,
            "--anchor-height": `${Be.height}px`,
          }).forEach(([He, at]) => {
            Me.style.setProperty(He, at);
          });
        },
      }),
      tS(
        () => ({
          element: ne.current || document.createElement("div"),
          padding: u,
          offsetParent: "floating",
        }),
        [u],
      ),
      {
        name: "transformOrigin",
        fn(Me) {
          var Pa, ka, Ma;
          const { elements: Be, middlewareData: Ye, placement: be, rects: He, y: at } = Me,
            $t = lt(be),
            Ko = gt($t),
            En = ne.current,
            Hh = ((Pa = Ye.arrow) == null ? void 0 : Pa.x) || 0,
            Uh = ((ka = Ye.arrow) == null ? void 0 : ka.y) || 0,
            _h = (En == null ? void 0 : En.clientWidth) || 0,
            Yh = (En == null ? void 0 : En.clientHeight) || 0,
            Qo = Hh + _h / 2,
            Ca = Uh + Yh / 2,
            qh = Math.abs(((Ma = Ye.shift) == null ? void 0 : Ma.y) || 0),
            Xh = He.reference.height / 2,
            or = typeof o == "function" ? o(Tc(Me, r, k)) : o,
            Gh = qh > or,
            Kh = {
              top: `${Qo}px calc(100% + ${or}px)`,
              bottom: `${Qo}px ${-or}px`,
              left: `calc(100% + ${or}px) ${Ca}px`,
              right: `${-or}px ${Ca}px`,
            }[$t],
            Qh = `${Qo}px ${He.reference.y + Xh - at}px`;
          return (
            Be.floating.style.setProperty("--transform-origin", N && Ko === "y" && Gh ? Qh : Kh), {}
          );
        },
      },
      nS,
      y,
    ),
    ee(() => {
      !g &&
        m &&
        m.update({ referenceElement: null, floatingElement: null, domReferenceElement: null });
    }, [g, m]));
  const we = h.useMemo(
      () => ({
        elementResize: !d && typeof ResizeObserver < "u",
        layoutShift: !d && typeof IntersectionObserver < "u",
      }),
      [d],
    ),
    {
      refs: z,
      elements: W,
      x: G,
      y: ie,
      middlewareData: he,
      update: ae,
      placement: de,
      context: U,
      isPositioned: Z,
      floatingStyles: K,
    } = S0({
      rootContext: m,
      placement: E,
      middleware: ce,
      strategy: n,
      whileElementsMounted: f ? void 0 : (...Me) => mc(...Me, we),
      nodeId: b,
      externalTree: R,
    }),
    { sideX: xe, sideY: Re } = he.adaptiveOrigin || ho,
    Ee = Z ? n : "fixed",
    Ce = h.useMemo(
      () => (y ? { position: Ee, [xe]: G, [Re]: ie } : { position: Ee, ...K }),
      [y, Ee, xe, G, Re, ie, K],
    ),
    Oe = h.useRef(null);
  (ee(() => {
    if (!g) return;
    const Me = C.current,
      Be = typeof Me == "function" ? Me() : Me,
      be = (Rc(Be) ? Be.current : Be) || null || null;
    be !== Oe.current && (z.setPositionReference(be), (Oe.current = be));
  }, [g, z, M, C]),
    h.useEffect(() => {
      if (!g) return;
      const Me = C.current;
      typeof Me != "function" &&
        Rc(Me) &&
        Me.current !== Oe.current &&
        (z.setPositionReference(Me.current), (Oe.current = Me.current));
    }, [g, z, M, C]),
    h.useEffect(() => {
      if (f && g && W.domReference && W.floating) return mc(W.domReference, W.floating, ae, we);
    }, [f, g, W, ae, we]));
  const Ie = lt(de),
    ze = rh(r, Ie, k),
    ct = on(de) || "center",
    ge = !!((an = he.hide) != null && an.referenceHidden);
  ee(() => {
    w && g && Z && A(Ie);
  }, [w, g, Z, Ie]);
  const Pe = h.useMemo(() => {
      var Me, Be;
      return {
        position: "absolute",
        top: (Me = he.arrow) == null ? void 0 : Me.y,
        left: (Be = he.arrow) == null ? void 0 : Be.x,
      };
    }, [he.arrow]),
    Ve = ((it = he.arrow) == null ? void 0 : it.centerOffset) !== 0;
  return h.useMemo(
    () => ({
      positionerStyles: Ce,
      arrowStyles: Pe,
      arrowRef: ne,
      arrowUncentered: Ve,
      side: ze,
      align: ct,
      physicalSide: Ie,
      anchorHidden: ge,
      refs: z,
      context: U,
      isPositioned: Z,
      update: ae,
    }),
    [Ce, Pe, ne, Ve, ze, ct, Ie, ge, z, U, Z, ae],
  );
}
function Rc(e) {
  return e != null && "current" in e;
}
function ya(e) {
  const { children: t, elementsRef: n, labelsRef: r, onMapChange: o } = e,
    s = J(o),
    i = h.useRef(0),
    a = ft(sS).current,
    l = ft(oS).current,
    [c, u] = h.useState(0),
    d = h.useRef(c),
    f = J((b, y) => {
      (l.set(b, y ?? null), (d.current += 1), u(d.current));
    }),
    m = J((b) => {
      (l.delete(b), (d.current += 1), u(d.current));
    }),
    g = h.useMemo(() => {
      const b = new Map();
      return (
        Array.from(l.keys())
          .filter((w) => w.isConnected)
          .sort(iS)
          .forEach((w, R) => {
            const x = l.get(w) ?? {};
            b.set(w, { ...x, index: R });
          }),
        b
      );
    }, [l, c]);
  (ee(() => {
    if (typeof MutationObserver != "function" || g.size === 0) return;
    const b = new MutationObserver((y) => {
      const w = new Set(),
        R = (x) => (w.has(x) ? w.delete(x) : w.add(x));
      (y.forEach((x) => {
        (x.removedNodes.forEach(R), x.addedNodes.forEach(R));
      }),
        w.size === 0 && ((d.current += 1), u(d.current)));
    });
    return (
      g.forEach((y, w) => {
        w.parentElement && b.observe(w.parentElement, { childList: !0 });
      }),
      () => {
        b.disconnect();
      }
    );
  }, [g]),
    ee(() => {
      (d.current === c &&
        (n.current.length !== g.size && (n.current.length = g.size),
        r && r.current.length !== g.size && (r.current.length = g.size),
        (i.current = g.size)),
        s(g));
    }, [s, g, n, r, c]),
    ee(
      () => () => {
        n.current = [];
      },
      [n],
    ),
    ee(
      () => () => {
        r && (r.current = []);
      },
      [r],
    ));
  const p = J(
    (b) => (
      a.add(b),
      () => {
        a.delete(b);
      }
    ),
  );
  ee(() => {
    a.forEach((b) => b(g));
  }, [a, g]);
  const v = h.useMemo(
    () => ({
      register: f,
      unregister: m,
      subscribeMapChange: p,
      elementsRef: n,
      labelsRef: r,
      nextIndexRef: i,
    }),
    [f, m, p, n, r, i],
  );
  return T.jsx(_d.Provider, { value: v, children: t });
}
function oS() {
  return new Map();
}
function sS() {
  return new Set();
}
function iS(e, t) {
  const n = e.compareDocumentPosition(t);
  return n & Node.DOCUMENT_POSITION_FOLLOWING || n & Node.DOCUMENT_POSITION_CONTAINED_BY
    ? -1
    : n & Node.DOCUMENT_POSITION_PRECEDING || n & Node.DOCUMENT_POSITION_CONTAINS
      ? 1
      : 0;
}
const aS = h.forwardRef(function (t, n) {
    const { cutout: r, ...o } = t;
    let s;
    if (r) {
      const i = r == null ? void 0 : r.getBoundingClientRect();
      s = `polygon(
      0% 0%,
      100% 0%,
      100% 100%,
      0% 100%,
      0% 0%,
      ${i.left}px ${i.top}px,
      ${i.left}px ${i.bottom}px,
      ${i.right}px ${i.bottom}px,
      ${i.right}px ${i.top}px,
      ${i.left}px ${i.top}px
    )`;
    }
    return T.jsx("div", {
      ref: n,
      role: "presentation",
      "data-base-ui-inert": "",
      ...o,
      style: {
        position: "fixed",
        inset: 0,
        userSelect: "none",
        WebkitUserSelect: "none",
        clipPath: s,
      },
    });
  }),
  lS = h.forwardRef(function (t, n) {
    var ce;
    const {
        anchor: r,
        positionMethod: o = "absolute",
        className: s,
        render: i,
        side: a,
        align: l,
        sideOffset: c = 0,
        alignOffset: u = 0,
        collisionBoundary: d = "clipping-ancestors",
        collisionPadding: f = 5,
        arrowPadding: m = 5,
        sticky: g = !1,
        disableAnchorTracking: p = !1,
        collisionAvoidance: v = vx,
        ...b
      } = t,
      { store: y } = Sn(),
      w = K0(),
      R = Vo(!0),
      x = y.useState("parent"),
      A = y.useState("floatingRootContext"),
      I = y.useState("floatingTreeRoot"),
      P = y.useState("mounted"),
      D = y.useState("open"),
      V = y.useState("modal"),
      B = y.useState("activeTriggerElement"),
      M = y.useState("lastOpenChangeReason"),
      C = y.useState("floatingNodeId"),
      L = y.useState("floatingParentNodeId");
    let k = r,
      F = c,
      E = u,
      S = l,
      O = v;
    x.type === "context-menu" &&
      ((k = r ?? ((ce = x.context) == null ? void 0 : ce.anchor)),
      (S = S ?? "start"),
      !a && S !== "center" && ((E = t.alignOffset ?? 2), (F = t.sideOffset ?? -5)));
    let j = a,
      _ = S;
    x.type === "menu"
      ? ((j = j ?? "inline-end"), (_ = _ ?? "start"), (O = t.collisionAvoidance ?? Vd))
      : x.type === "menubar" && ((j = j ?? "bottom"), (_ = _ ?? "start"));
    const Q = x.type === "context-menu",
      $ = oh({
        anchor: k,
        floatingRootContext: A,
        positionMethod: R ? "fixed" : o,
        mounted: P,
        side: j,
        sideOffset: F,
        align: _,
        alignOffset: E,
        arrowPadding: Q ? 0 : m,
        collisionBoundary: d,
        collisionPadding: f,
        sticky: g,
        nodeId: C,
        keepMounted: w,
        disableAnchorTracking: p,
        collisionAvoidance: O,
        shiftCrossAxis: Q,
        externalTree: I,
      }),
      Y = h.useMemo(() => {
        const pe = {};
        return (
          D || (pe.pointerEvents = "none"),
          { role: "presentation", hidden: !P, style: { ...$.positionerStyles, ...pe } }
        );
      }, [D, P, $.positionerStyles]);
    (h.useEffect(() => {
      function pe(N) {
        N.open
          ? (N.parentNodeId === C && y.set("hoverEnabled", !1),
            N.nodeId !== C &&
              N.parentNodeId === y.select("floatingParentNodeId") &&
              y.setOpen(!1, Te(fr)))
          : N.parentNodeId === C && N.reason !== fr && y.set("hoverEnabled", !0);
      }
      return (
        I.events.on("menuopenchange", pe),
        () => {
          I.events.off("menuopenchange", pe);
        }
      );
    }, [y, I.events, C]),
      h.useEffect(() => {
        if (y.select("floatingParentNodeId") == null) return;
        function pe(N) {
          if (N.open || N.nodeId !== y.select("floatingParentNodeId")) return;
          const X = N.reason ?? fr;
          y.setOpen(!1, Te(X));
        }
        return (
          I.events.on("menuopenchange", pe),
          () => {
            I.events.off("menuopenchange", pe);
          }
        );
      }, [I.events, y]),
      h.useEffect(() => {
        function pe(N) {
          !D ||
            N.nodeId !== y.select("floatingParentNodeId") ||
            (N.target && B && B !== N.target && y.setOpen(!1, Te(fr)));
        }
        return (
          I.events.on("itemhover", pe),
          () => {
            I.events.off("itemhover", pe);
          }
        );
      }, [I.events, D, B, y]),
      h.useEffect(() => {
        const pe = {
          open: D,
          nodeId: C,
          parentNodeId: L,
          reason: y.select("lastOpenChangeReason"),
        };
        I.events.emit("menuopenchange", pe);
      }, [I.events, D, y, C, L]));
    const ne = h.useMemo(
        () => ({
          open: D,
          side: $.side,
          align: $.align,
          anchorHidden: $.anchorHidden,
          nested: x.type === "menu",
        }),
        [D, $.side, $.align, $.anchorHidden, x.type],
      ),
      te = h.useMemo(
        () => ({
          side: $.side,
          align: $.align,
          arrowRef: $.arrowRef,
          arrowUncentered: $.arrowUncentered,
          arrowStyles: $.arrowStyles,
          nodeId: $.context.nodeId,
        }),
        [$.side, $.align, $.arrowRef, $.arrowUncentered, $.arrowStyles, $.context.nodeId],
      ),
      H = We("div", t, {
        state: ne,
        stateAttributesMapping: Ir,
        ref: [n, y.useStateSetter("positionerElement")],
        props: [Y, b],
      }),
      ue =
        P &&
        x.type !== "menu" &&
        ((x.type !== "menubar" && V && M !== et) || (x.type === "menubar" && x.context.modal));
    let le = null;
    return (
      x.type === "menubar" ? (le = x.context.contentElement) : x.type === void 0 && (le = B),
      T.jsxs(Od.Provider, {
        value: te,
        children: [
          ue &&
            T.jsx(aS, {
              ref:
                x.type === "context-menu" || x.type === "nested-context-menu"
                  ? x.context.internalBackdropRef
                  : null,
              inert: Z0(!D),
              cutout: le,
            }),
          T.jsx(_v, {
            id: C,
            children: T.jsx(ya, {
              elementsRef: y.context.itemDomElements,
              labelsRef: y.context.itemLabels,
              children: H,
            }),
          }),
        ],
      })
    );
  });
let Ec = {},
  Cc = {},
  Pc = "";
function cS(e) {
  if (typeof document > "u") return !1;
  const t = xt(e);
  return _e(t).innerWidth - t.documentElement.clientWidth > 0;
}
function uS(e) {
  if (
    !(typeof CSS < "u" && CSS.supports && CSS.supports("scrollbar-gutter", "stable")) ||
    typeof document > "u"
  )
    return !1;
  const r = xt(e).documentElement,
    o = { scrollbarGutter: r.style.scrollbarGutter, overflowY: r.style.overflowY };
  ((r.style.scrollbarGutter = "stable"), (r.style.overflowY = "scroll"));
  const s = r.offsetWidth;
  r.style.overflowY = "hidden";
  const i = r.offsetWidth;
  return (Object.assign(r.style, o), s === i);
}
function dS(e) {
  const t = xt(e),
    n = t.documentElement,
    r = t.body,
    o = Tn(n) ? n : r,
    s = o.style.overflow;
  return (
    (o.style.overflow = "hidden"),
    () => {
      o.style.overflow = s;
    }
  );
}
function fS(e) {
  var f;
  const t = xt(e),
    n = t.documentElement,
    r = t.body,
    o = _e(n);
  let s = 0,
    i = 0,
    a = !1;
  const l = Et.create();
  if (Gd && (((f = o.visualViewport) == null ? void 0 : f.scale) ?? 1) !== 1) return () => {};
  function c() {
    const m = o.getComputedStyle(n),
      g = o.getComputedStyle(r),
      b = (m.scrollbarGutter || "").includes("both-edges") ? "stable both-edges" : "stable";
    ((s = n.scrollTop),
      (i = n.scrollLeft),
      (Ec = {
        scrollbarGutter: n.style.scrollbarGutter,
        overflowY: n.style.overflowY,
        overflowX: n.style.overflowX,
      }),
      (Pc = n.style.scrollBehavior),
      (Cc = {
        position: r.style.position,
        height: r.style.height,
        width: r.style.width,
        boxSizing: r.style.boxSizing,
        overflowY: r.style.overflowY,
        overflowX: r.style.overflowX,
        scrollBehavior: r.style.scrollBehavior,
      }));
    const y = n.scrollHeight > n.clientHeight,
      w = n.scrollWidth > n.clientWidth,
      R = m.overflowY === "scroll" || g.overflowY === "scroll",
      x = m.overflowX === "scroll" || g.overflowX === "scroll",
      A = Math.max(0, o.innerWidth - r.clientWidth),
      I = Math.max(0, o.innerHeight - r.clientHeight),
      P = parseFloat(g.marginTop) + parseFloat(g.marginBottom),
      D = parseFloat(g.marginLeft) + parseFloat(g.marginRight),
      V = Tn(n) ? n : r;
    if (((a = uS(e)), a)) {
      ((n.style.scrollbarGutter = b),
        (V.style.overflowY = "hidden"),
        (V.style.overflowX = "hidden"));
      return;
    }
    (Object.assign(n.style, { scrollbarGutter: b, overflowY: "hidden", overflowX: "hidden" }),
      (y || R) && (n.style.overflowY = "scroll"),
      (w || x) && (n.style.overflowX = "scroll"),
      Object.assign(r.style, {
        position: "relative",
        height: P || I ? `calc(100dvh - ${P + I}px)` : "100dvh",
        width: D || A ? `calc(100vw - ${D + A}px)` : "100vw",
        boxSizing: "border-box",
        overflow: "hidden",
        scrollBehavior: "unset",
      }),
      (r.scrollTop = s),
      (r.scrollLeft = i),
      n.setAttribute("data-base-ui-scroll-locked", ""),
      (n.style.scrollBehavior = "unset"));
  }
  function u() {
    (Object.assign(n.style, Ec),
      Object.assign(r.style, Cc),
      a ||
        ((n.scrollTop = s),
        (n.scrollLeft = i),
        n.removeAttribute("data-base-ui-scroll-locked"),
        (n.style.scrollBehavior = Pc)));
  }
  function d() {
    (u(), l.request(c));
  }
  return (
    c(),
    o.addEventListener("resize", d),
    () => {
      (l.cancel(),
        u(),
        typeof o.removeEventListener == "function" && o.removeEventListener("resize", d));
    }
  );
}
class hS {
  constructor() {
    Ae(this, "lockCount", 0);
    Ae(this, "restore", null);
    Ae(this, "timeoutLock", en.create());
    Ae(this, "timeoutUnlock", en.create());
    Ae(this, "release", () => {
      ((this.lockCount -= 1),
        this.lockCount === 0 && this.restore && this.timeoutUnlock.start(0, this.unlock));
    });
    Ae(this, "unlock", () => {
      var t;
      this.lockCount === 0 &&
        this.restore &&
        ((t = this.restore) == null || t.call(this), (this.restore = null));
    });
  }
  acquire(t) {
    return (
      (this.lockCount += 1),
      this.lockCount === 1 &&
        this.restore === null &&
        this.timeoutLock.start(0, () => this.lock(t)),
      this.release
    );
  }
  lock(t) {
    if (this.lockCount === 0 || this.restore !== null) return;
    const r = xt(t).documentElement,
      o = _e(r).getComputedStyle(r).overflowY;
    if (o === "hidden" || o === "clip") {
      this.restore = dt;
      return;
    }
    const s = Kd || !cS(t);
    this.restore = s ? dS(t) : fS(t);
  }
}
const mS = new hS();
function pS(e = !0, t = null) {
  ee(() => {
    if (e) return mS.acquire(t);
  }, [e, t]);
}
const gS = h.createContext(null);
function sh(e) {
  return h.useContext(gS);
}
function bS(e) {
  const t = h.useRef(""),
    n = h.useCallback(
      (o) => {
        o.defaultPrevented || ((t.current = o.pointerType), e(o, o.pointerType));
      },
      [e],
    );
  return {
    onClick: h.useCallback(
      (o) => {
        if (o.detail === 0) {
          e(o, "keyboard");
          return;
        }
        ("pointerType" in o && e(o, o.pointerType), e(o, t.current), (t.current = ""));
      },
      [e],
    ),
    onPointerDown: n,
  };
}
function yS(e) {
  const [t, n] = h.useState(null),
    r = J((a, l) => {
      e || n(l || (Kd ? "touch" : ""));
    }),
    o = h.useCallback(() => {
      n(null);
    }, []),
    { onClick: s, onPointerDown: i } = bS(r);
  return h.useMemo(
    () => ({ openMethod: t, reset: o, triggerProps: { onClick: s, onPointerDown: i } }),
    [t, o, s, i],
  );
}
const xS = {
  ...Yf,
  disabled: me((e) => (e.parent.type === "menubar" && e.parent.context.disabled) || e.disabled),
  modal: me(
    (e) => (e.parent.type === void 0 || e.parent.type === "context-menu") && (e.modal ?? !0),
  ),
  allowMouseEnter: me((e) =>
    e.parent.type === "menu" ? e.parent.store.select("allowMouseEnter") : e.allowMouseEnter,
  ),
  stickIfOpen: me((e) => e.stickIfOpen),
  parent: me((e) => e.parent),
  rootId: me((e) =>
    e.parent.type === "menu"
      ? e.parent.store.select("rootId")
      : e.parent.type !== void 0
        ? e.parent.context.rootId
        : e.rootId,
  ),
  activeIndex: me((e) => e.activeIndex),
  isActive: me((e, t) => e.activeIndex === t),
  hoverEnabled: me((e) => e.hoverEnabled),
  instantType: me((e) => e.instantType),
  lastOpenChangeReason: me((e) => e.openChangeReason),
  floatingTreeRoot: me((e) =>
    e.parent.type === "menu" ? e.parent.store.select("floatingTreeRoot") : e.floatingTreeRoot,
  ),
  floatingNodeId: me((e) => e.floatingNodeId),
  floatingParentNodeId: me((e) => e.floatingParentNodeId),
  itemProps: me((e) => e.itemProps),
  closeDelay: me((e) => e.closeDelay),
  keyboardEventRelay: me((e) => {
    if (e.keyboardEventRelay) return e.keyboardEventRelay;
    if (e.parent.type === "menu") return e.parent.store.select("keyboardEventRelay");
  }),
};
class xa extends ma {
  constructor(n) {
    super(
      { ...vS(), ...n },
      {
        positionerRef: h.createRef(),
        popupRef: h.createRef(),
        typingRef: { current: !1 },
        itemDomElements: { current: [] },
        itemLabels: { current: [] },
        allowMouseUpTriggerRef: { current: !1 },
        triggerFocusTargetRef: h.createRef(),
        beforeContentFocusGuardRef: h.createRef(),
        onOpenChangeComplete: void 0,
        triggerElements: new qo(),
      },
      xS,
    );
    Ae(this, "unsubscribeParentListener", null);
    (this.observe(
      me((r) => r.allowMouseEnter),
      (r, o) => {
        this.state.parent.type === "menu" &&
          r !== o &&
          this.state.parent.store.set("allowMouseEnter", r);
      },
    ),
      (this.unsubscribeParentListener = this.observe("parent", (r) => {
        var o;
        if (((o = this.unsubscribeParentListener) == null || o.call(this), r.type === "menu")) {
          ((this.unsubscribeParentListener = r.store.subscribe(() => {
            this.notifyAll();
          })),
            (this.context.allowMouseUpTriggerRef = r.store.context.allowMouseUpTriggerRef));
          return;
        }
        (r.type !== void 0 &&
          (this.context.allowMouseUpTriggerRef = r.context.allowMouseUpTriggerRef),
          (this.unsubscribeParentListener = null));
      })));
  }
  setOpen(n, r) {
    this.state.floatingRootContext.context.events.emit("setOpen", { open: n, eventDetails: r });
  }
  static useStore(n, r) {
    const o = ft(() => new xa(r)).current;
    return n ?? o;
  }
}
function vS() {
  return {
    ..._f(),
    disabled: !1,
    modal: !0,
    allowMouseEnter: !0,
    stickIfOpen: !0,
    parent: { type: void 0 },
    rootId: void 0,
    activeIndex: null,
    hoverEnabled: !0,
    instantType: void 0,
    openChangeReason: null,
    floatingTreeRoot: new ua(),
    floatingNodeId: void 0,
    floatingParentNodeId: null,
    itemProps: je,
    keyboardEventRelay: void 0,
    closeDelay: 0,
  };
}
const wS = h.createContext(void 0);
function SS() {
  return h.useContext(wS);
}
function TS(e) {
  const {
      children: t,
      open: n,
      onOpenChange: r,
      onOpenChangeComplete: o,
      defaultOpen: s = !1,
      disabled: i = !1,
      modal: a,
      loopFocus: l = !0,
      orientation: c = "vertical",
      actionsRef: u,
      closeParentOnEsc: d = !1,
      handle: f,
      triggerId: m,
      defaultTriggerId: g = null,
      highlightItemOnHover: p = !0,
    } = e,
    v = Vo(!0),
    b = Sn(!0),
    y = sh(),
    w = SS(),
    R = h.useMemo(
      () =>
        w && b
          ? { type: "menu", store: b.store }
          : y
            ? { type: "menubar", context: y }
            : v && !b
              ? { type: "context-menu", context: v }
              : { type: void 0 },
      [v, b, y, w],
    ),
    x = xa.useStore(f == null ? void 0 : f.store, { parent: R }),
    A = x.useState("floatingTreeRoot"),
    I = Rf(A),
    P = Bt();
  (ee(() => {
    v && !b
      ? x.update({
          parent: { type: "context-menu", context: v },
          floatingNodeId: I,
          floatingParentNodeId: P,
        })
      : b && x.update({ floatingNodeId: I, floatingParentNodeId: P });
  }, [v, b, I, P, x]),
    x.useControlledProp("open", n, s),
    x.useControlledProp("activeTriggerId", m, g),
    x.useContextCallback("onOpenChangeComplete", o));
  const D = x.useState("open"),
    V = x.useState("activeTriggerElement"),
    B = x.useState("positionerElement"),
    M = x.useState("hoverEnabled"),
    C = x.useState("modal"),
    L = x.useState("disabled"),
    k = x.useState("lastOpenChangeReason"),
    F = x.useState("parent"),
    E = x.useState("activeIndex"),
    S = x.useState("payload"),
    O = x.useState("floatingParentNodeId"),
    j = h.useRef(null),
    _ = O != null;
  let Q;
  x.useSyncedValues({ disabled: i, modal: F.type === void 0 ? a : void 0, rootId: Rn() });
  const { openMethod: $, triggerProps: Y, reset: ne } = yS(D);
  Hf(x);
  const { forceUnmount: te } = Uf(D, x, () => {
      (x.update({ allowMouseEnter: !1, stickIfOpen: !0 }), ne());
    }),
    H = h.useRef(F.type !== "context-menu"),
    ue = Ge();
  (h.useEffect(() => {
    if ((D || (j.current = null), F.type === "context-menu")) {
      if (!D) {
        (ue.clear(), (H.current = !1));
        return;
      }
      ue.start(500, () => {
        H.current = !0;
      });
    }
  }, [ue, D, F.type]),
    pS(D && C && k !== et && $ !== "touch", B),
    ee(() => {
      !D && !M && x.set("hoverEnabled", !0);
    }, [D, M, x]));
  const le = h.useRef(!0),
    ce = Ge(),
    pe = J((ge, Pe) => {
      const Ve = Pe.reason;
      if (
        (D === ge && Pe.trigger === V && k === Ve) ||
        ((Pe.preventUnmountOnClose = () => {
          x.set("preventUnmountingOnClose", !0);
        }),
        !ge && Pe.trigger == null && (Pe.trigger = V ?? void 0),
        r == null || r(ge, Pe),
        Pe.isCanceled)
      )
        return;
      const an = { open: ge, nativeEvent: Pe.event, reason: Pe.reason, nested: _ };
      Q == null || Q.emit("openchange", an);
      const it = Pe.event;
      if (
        ge === !1 &&
        (it == null ? void 0 : it.type) === "click" &&
        it.pointerType === "touch" &&
        !le.current
      )
        return;
      if (!ge && E !== null) {
        const be = x.context.itemDomElements.current[E];
        queueMicrotask(() => {
          be == null || be.setAttribute("tabindex", "-1");
        });
      }
      ge && Ve === Fn
        ? ((le.current = !1),
          ce.start(300, () => {
            le.current = !0;
          }))
        : ((le.current = !0), ce.clear());
      const Me =
          (Ve === Yt || Ve === $d) && it.detail === 0 && (it == null ? void 0 : it.isTrusted),
        Be = !ge && (Ve === Bo || Ve == null);
      function Ye() {
        var at;
        const be = { open: ge, openChangeReason: Ve };
        j.current = Pe.event ?? null;
        const He = ((at = Pe.trigger) == null ? void 0 : at.id) ?? null;
        ((He || ge) && ((be.activeTriggerId = He), (be.activeTriggerElement = Pe.trigger ?? null)),
          x.update(be));
      }
      (Ve === et ? Rt.flushSync(Ye) : Ye(),
        F.type === "menubar" && (Ve === Fn || Ve === _n || Ve === et || Ve === ao || Ve === fr)
          ? x.set("instantType", "group")
          : Me || Be
            ? x.set("instantType", Me ? "click" : "dismiss")
            : x.set("instantType", void 0));
    }),
    N = h.useCallback(
      (ge) => {
        const Pe = Te(ge);
        return (
          (Pe.preventUnmountOnClose = () => {
            x.set("preventUnmountingOnClose", !0);
          }),
          Pe
        );
      },
      [x],
    ),
    X = h.useCallback(() => {
      x.setOpen(!1, N(Wd));
    }, [x, N]);
  h.useImperativeHandle(u, () => ({ unmount: te, close: X }), [te, X]);
  let q;
  (F.type === "context-menu" && (q = F.context),
    h.useImperativeHandle(q == null ? void 0 : q.positionerRef, () => B, [B]),
    h.useImperativeHandle(q == null ? void 0 : q.actionsRef, () => ({ setOpen: pe }), [pe]));
  const we = qf({ popupStore: x, onOpenChange: pe });
  ((Q = we.context.events),
    h.useEffect(() => {
      const ge = ({ open: Pe, eventDetails: Ve }) => pe(Pe, Ve);
      return (
        Q.on("setOpen", ge),
        () => {
          Q == null || Q.off("setOpen", ge);
        }
      );
    }, [Q, pe]));
  const z = Bf(we, {
      enabled: !L,
      bubbles: { escapeKey: d && F.type === "menu" },
      outsidePress() {
        var ge;
        return F.type !== "context-menu" ||
          ((ge = j.current) == null ? void 0 : ge.type) === "contextmenu"
          ? !0
          : H.current;
      },
      externalTree: _ ? A : void 0,
    }),
    W = D0(we, { role: "menu" }),
    G = tr(),
    ie = h.useCallback(
      (ge) => {
        x.select("activeIndex") !== ge && x.set("activeIndex", ge);
      },
      [x],
    ),
    he = O0(we, {
      enabled: !L,
      listRef: x.context.itemDomElements,
      activeIndex: E,
      nested: F.type !== void 0,
      loopFocus: l,
      orientation: c,
      parentOrientation: F.type === "menubar" ? F.context.orientation : void 0,
      rtl: G === "rtl",
      disabledIndices: xn,
      onNavigate: ie,
      openOnArrowKeyDown: F.type !== "context-menu",
      externalTree: _ ? A : void 0,
      focusItemOnHover: p,
    }),
    ae = h.useCallback(
      (ge) => {
        x.context.typingRef.current = ge;
      },
      [x],
    ),
    de = N0(we, {
      listRef: x.context.itemLabels,
      activeIndex: E,
      resetMs: gx,
      onMatch: (ge) => {
        D && ge !== E && x.set("activeIndex", ge);
      },
      onTypingChange: ae,
    }),
    {
      getReferenceProps: U,
      getFloatingProps: Z,
      getItemProps: K,
      getTriggerProps: xe,
    } = ga([z, W, he, de]),
    Re = h.useMemo(() => {
      const ge = Hn(
        U(),
        {
          onMouseEnter() {
            x.set("hoverEnabled", !0);
          },
          onMouseMove() {
            x.set("allowMouseEnter", !0);
          },
        },
        Y,
      );
      return (delete ge.role, ge);
    }, [U, x, Y]),
    Ee = h.useMemo(() => {
      const ge = xe();
      if (!ge) return ge;
      const Pe = Hn(ge, Y);
      return (delete Pe.role, delete Pe["aria-controls"], Pe);
    }, [xe, Y]),
    Ce = _o(),
    Oe = h.useMemo(
      () =>
        Z({
          onMouseEnter() {
            F.type === "menu" && Ce.request(() => x.set("hoverEnabled", !1));
          },
          onMouseMove() {
            x.set("allowMouseEnter", !0);
          },
          onClick() {
            x.select("hoverEnabled") && x.set("hoverEnabled", !1);
          },
          onKeyDown(ge) {
            const Pe = x.select("keyboardEventRelay");
            Pe && !ge.isPropagationStopped() && Pe(ge);
          },
        }),
      [Z, F.type, Ce, x],
    ),
    Ie = h.useMemo(() => K(), [K]);
  x.useSyncedValues({
    floatingRootContext: we,
    activeTriggerProps: Re,
    inactiveTriggerProps: Ee,
    popupProps: Oe,
    itemProps: Ie,
  });
  const ze = h.useMemo(() => ({ store: x, parent: R }), [x, R]),
    ct = T.jsx(Dd.Provider, {
      value: ze,
      children: typeof t == "function" ? t({ payload: S }) : t,
    });
  return F.type === void 0 || F.type === "context-menu"
    ? T.jsx(Yv, { externalTree: A, children: ct })
    : ct;
}
function RS(e) {
  const t = e.getBoundingClientRect(),
    n = window.getComputedStyle(e, "::before"),
    r = window.getComputedStyle(e, "::after");
  if (!(n.content !== "none" || r.content !== "none")) return t;
  const s = parseFloat(n.width) || 0,
    i = parseFloat(n.height) || 0,
    a = parseFloat(r.width) || 0,
    l = parseFloat(r.height) || 0,
    c = Math.max(t.width, s, a),
    u = Math.max(t.height, i, l),
    d = c - t.width,
    f = u - t.height;
  return {
    left: t.left - d / 2,
    right: t.right + d / 2,
    top: t.top - f / 2,
    bottom: t.bottom + f / 2,
  };
}
function ih(e = {}) {
  const { highlightItemOnHover: t, highlightedIndex: n, onHighlightedIndexChange: r } = ta(),
    { ref: o, index: s } = na(e),
    i = n === s,
    a = h.useRef(null),
    l = Jt(o, a);
  return {
    compositeProps: h.useMemo(
      () => ({
        tabIndex: i ? 0 : -1,
        onFocus() {
          r(s);
        },
        onMouseMove() {
          const u = a.current;
          if (!t || !u) return;
          const d = u.hasAttribute("disabled") || u.ariaDisabled === "true";
          !i && !d && u.focus();
        },
      }),
      [i, r, s, t],
    ),
    compositeRef: l,
    index: s,
  };
}
function ES(e) {
  const {
      render: t,
      className: n,
      state: r = je,
      props: o = xn,
      refs: s = xn,
      metadata: i,
      stateAttributesMapping: a,
      tag: l = "div",
      ...c
    } = e,
    { compositeProps: u, compositeRef: d } = ih({ metadata: i });
  return We(l, e, { state: r, ref: [...s, d], props: [u, ...o, c], stateAttributesMapping: a });
}
function ah(e) {
  if (Ne(e) && e.hasAttribute("data-rootownerid"))
    return e.getAttribute("data-rootownerid") ?? void 0;
  if (!Pt(e)) return ah(At(e));
}
function CS(e) {
  const { enabled: t = !0, mouseDownAction: n, open: r } = e,
    o = h.useRef(!1);
  return h.useMemo(
    () =>
      t
        ? {
            onMouseDown: (s) => {
              ((n === "open" && !r) || (n === "close" && r)) &&
                ((o.current = !0),
                xt(s.currentTarget).addEventListener(
                  "click",
                  () => {
                    o.current = !1;
                  },
                  { once: !0 },
                ));
            },
            onClick: (s) => {
              o.current && ((o.current = !1), s.preventBaseUIHandler());
            },
          }
        : je,
    [t, n, r],
  );
}
const Qr = 2,
  PS = h.forwardRef(function (t, n) {
    const {
        render: r,
        className: o,
        disabled: s = !1,
        nativeButton: i = !0,
        id: a,
        openOnHover: l,
        delay: c = 100,
        closeDelay: u = 0,
        handle: d,
        payload: f,
        ...m
      } = t,
      g = Sn(!0),
      p = (d == null ? void 0 : d.store) ?? (g == null ? void 0 : g.store);
    if (!p) throw new Error(Ke(85));
    const v = rn(a),
      b = p.useState("isTriggerActive", v),
      y = p.useState("floatingRootContext"),
      w = p.useState("isOpenedByTrigger", v),
      R = h.useRef(null),
      x = MS(),
      A = ta(!0),
      I = sn(),
      P = h.useMemo(() => I ?? new ua(), [I]),
      D = Rf(P),
      V = Bt(),
      { registerTrigger: B, isMountedByThisTrigger: M } = zf(v, R, p, {
        payload: f,
        closeDelay: u,
        parent: x,
        floatingTreeRoot: P,
        floatingNodeId: D,
        floatingParentNodeId: V,
        keyboardEventRelay: A == null ? void 0 : A.relayKeyboardEvent,
      }),
      C = x.type === "menubar",
      L = p.useState("disabled"),
      k = s || L || (C && x.context.disabled),
      { getButtonProps: F, buttonRef: E } = Uo({ disabled: k, native: i });
    h.useEffect(() => {
      !w && x.type === void 0 && (p.context.allowMouseUpTriggerRef.current = !1);
    }, [p, w, x.type]);
    const S = h.useRef(null),
      O = Ge(),
      j = J((W) => {
        if (!S.current) return;
        (O.clear(), (p.context.allowMouseUpTriggerRef.current = !1));
        const G = W.target;
        if (
          Se(S.current, G) ||
          Se(p.select("positionerElement"), G) ||
          G === S.current ||
          (G != null && ah(G) === p.select("rootId"))
        )
          return;
        const ie = RS(S.current);
        (W.clientX >= ie.left - Qr &&
          W.clientX <= ie.right + Qr &&
          W.clientY >= ie.top - Qr &&
          W.clientY <= ie.bottom + Qr) ||
          P.events.emit("close", { domEvent: W, reason: Nx });
      });
    h.useEffect(() => {
      w &&
        p.select("lastOpenChangeReason") === et &&
        xt(S.current).addEventListener("mouseup", j, { once: !0 });
    }, [w, j, p]);
    const _ = C && x.context.hasSubmenuOpen,
      $ = Qf(y, {
        enabled: (l ?? _) && !k && x.type !== "context-menu" && (!C || (_ && !M)),
        handleClose: Zf({ blockPointerEvents: !C }),
        mouseOnly: !0,
        move: !1,
        restMs: x.type === void 0 ? c : void 0,
        delay: { close: u },
        triggerElementRef: R,
        externalTree: P,
        isActiveTrigger: b,
      }),
      Y = kS(w, p.select("lastOpenChangeReason")),
      ne = iw(y, {
        enabled: !k && x.type !== "context-menu",
        event: w && C ? "click" : "mousedown",
        toggle: !0,
        ignoreMouse: !1,
        stickIfOpen: x.type === void 0 ? Y : !1,
      }),
      te = Xf(y, { enabled: !k && _ }),
      H = CS({ open: w, enabled: C, mouseDownAction: "open" }),
      ue = ga([ne, te]),
      le = h.useMemo(() => ({ disabled: k, open: w }), [k, w]),
      ce = p.useState("triggerProps", M),
      pe = [S, n, E, B, R],
      N = [
        ue.getReferenceProps(),
        $ ?? je,
        ce,
        {
          "aria-haspopup": "menu",
          id: v,
          onMouseDown: (W) => {
            if (p.select("open")) return;
            (O.start(200, () => {
              p.context.allowMouseUpTriggerRef.current = !0;
            }),
              xt(W.currentTarget).addEventListener("mouseup", j, { once: !0 }));
          },
        },
        C ? { role: "menuitem" } : {},
        H,
        m,
        F,
      ],
      X = h.useRef(null),
      q = J((W) => {
        Rt.flushSync(() => {
          p.setOpen(!1, Te(_n, W.nativeEvent, W.currentTarget));
        });
        const G = Hv(X.current);
        G == null || G.focus();
      }),
      we = J((W) => {
        var ie;
        const G = p.select("positionerElement");
        if (G && jn(W, G))
          (ie = p.context.beforeContentFocusGuardRef.current) == null || ie.focus();
        else {
          Rt.flushSync(() => {
            p.setOpen(!1, Te(_n, W.nativeEvent, W.currentTarget));
          });
          let he = zv(p.context.triggerFocusTargetRef.current || R.current);
          for (; he !== null && Se(G, he); ) {
            const ae = he;
            if (((he = ca(he)), he === ae)) break;
          }
          he == null || he.focus();
        }
      }),
      z = We("button", t, {
        enabled: !C,
        stateAttributesMapping: Gl,
        state: le,
        ref: pe,
        props: N,
      });
    return C
      ? T.jsx(ES, {
          tag: "button",
          render: r,
          className: o,
          state: le,
          refs: pe,
          props: N,
          stateAttributesMapping: Gl,
        })
      : w
        ? T.jsxs(h.Fragment, {
            children: [
              T.jsx(Gn, { ref: X, onFocus: q }, `${v}-pre-focus-guard`),
              T.jsx(h.Fragment, { children: z }, v),
              T.jsx(
                Gn,
                { ref: p.context.triggerFocusTargetRef, onFocus: we },
                `${v}-post-focus-guard`,
              ),
            ],
          })
        : T.jsx(h.Fragment, { children: z }, v);
  });
function kS(e, t) {
  const n = Ge(),
    [r, o] = h.useState(!1);
  return (
    ee(() => {
      e && t === "trigger-hover"
        ? (o(!0),
          n.start(bx, () => {
            o(!1);
          }))
        : e || (n.clear(), o(!1));
    }, [e, t, n]),
    r
  );
}
function MS() {
  const e = Vo(!0),
    t = Sn(!0),
    n = sh();
  return h.useMemo(
    () =>
      n
        ? { type: "menubar", context: n }
        : e && !t
          ? { type: "context-menu", context: e }
          : { type: void 0 },
    [e, t, n],
  );
}
function lh(e) {
  var t,
    n,
    r = "";
  if (typeof e == "string" || typeof e == "number") r += e;
  else if (typeof e == "object")
    if (Array.isArray(e)) {
      var o = e.length;
      for (t = 0; t < o; t++) e[t] && (n = lh(e[t])) && (r && (r += " "), (r += n));
    } else for (n in e) e[n] && (r && (r += " "), (r += n));
  return r;
}
function ch() {
  for (var e, t, n = 0, r = "", o = arguments.length; n < o; n++)
    (e = arguments[n]) && (t = lh(e)) && (r && (r += " "), (r += t));
  return r;
}
const AS = (e, t) => {
    const n = new Array(e.length + t.length);
    for (let r = 0; r < e.length; r++) n[r] = e[r];
    for (let r = 0; r < t.length; r++) n[e.length + r] = t[r];
    return n;
  },
  OS = (e, t) => ({ classGroupId: e, validator: t }),
  uh = (e = new Map(), t = null, n) => ({ nextPart: e, validators: t, classGroupId: n }),
  Oo = "-",
  kc = [],
  IS = "arbitrary..",
  DS = (e) => {
    const t = FS(e),
      { conflictingClassGroups: n, conflictingClassGroupModifiers: r } = e;
    return {
      getClassGroupId: (i) => {
        if (i.startsWith("[") && i.endsWith("]")) return NS(i);
        const a = i.split(Oo),
          l = a[0] === "" && a.length > 1 ? 1 : 0;
        return dh(a, l, t);
      },
      getConflictingClassGroupIds: (i, a) => {
        if (a) {
          const l = r[i],
            c = n[i];
          return l ? (c ? AS(c, l) : l) : c || kc;
        }
        return n[i] || kc;
      },
    };
  },
  dh = (e, t, n) => {
    if (e.length - t === 0) return n.classGroupId;
    const o = e[t],
      s = n.nextPart.get(o);
    if (s) {
      const c = dh(e, t + 1, s);
      if (c) return c;
    }
    const i = n.validators;
    if (i === null) return;
    const a = t === 0 ? e.join(Oo) : e.slice(t).join(Oo),
      l = i.length;
    for (let c = 0; c < l; c++) {
      const u = i[c];
      if (u.validator(a)) return u.classGroupId;
    }
  },
  NS = (e) =>
    e.slice(1, -1).indexOf(":") === -1
      ? void 0
      : (() => {
          const t = e.slice(1, -1),
            n = t.indexOf(":"),
            r = t.slice(0, n);
          return r ? IS + r : void 0;
        })(),
  FS = (e) => {
    const { theme: t, classGroups: n } = e;
    return LS(n, t);
  },
  LS = (e, t) => {
    const n = uh();
    for (const r in e) {
      const o = e[r];
      va(o, n, r, t);
    }
    return n;
  },
  va = (e, t, n, r) => {
    const o = e.length;
    for (let s = 0; s < o; s++) {
      const i = e[s];
      jS(i, t, n, r);
    }
  },
  jS = (e, t, n, r) => {
    if (typeof e == "string") {
      VS(e, t, n);
      return;
    }
    if (typeof e == "function") {
      BS(e, t, n, r);
      return;
    }
    $S(e, t, n, r);
  },
  VS = (e, t, n) => {
    const r = e === "" ? t : fh(t, e);
    r.classGroupId = n;
  },
  BS = (e, t, n, r) => {
    if (WS(e)) {
      va(e(r), t, n, r);
      return;
    }
    (t.validators === null && (t.validators = []), t.validators.push(OS(n, e)));
  },
  $S = (e, t, n, r) => {
    const o = Object.entries(e),
      s = o.length;
    for (let i = 0; i < s; i++) {
      const [a, l] = o[i];
      va(l, fh(t, a), n, r);
    }
  },
  fh = (e, t) => {
    let n = e;
    const r = t.split(Oo),
      o = r.length;
    for (let s = 0; s < o; s++) {
      const i = r[s];
      let a = n.nextPart.get(i);
      (a || ((a = uh()), n.nextPart.set(i, a)), (n = a));
    }
    return n;
  },
  WS = (e) => "isThemeGetter" in e && e.isThemeGetter === !0,
  zS = (e) => {
    if (e < 1) return { get: () => {}, set: () => {} };
    let t = 0,
      n = Object.create(null),
      r = Object.create(null);
    const o = (s, i) => {
      ((n[s] = i), t++, t > e && ((t = 0), (r = n), (n = Object.create(null))));
    };
    return {
      get(s) {
        let i = n[s];
        if (i !== void 0) return i;
        if ((i = r[s]) !== void 0) return (o(s, i), i);
      },
      set(s, i) {
        s in n ? (n[s] = i) : o(s, i);
      },
    };
  },
  di = "!",
  Mc = ":",
  HS = [],
  Ac = (e, t, n, r, o) => ({
    modifiers: e,
    hasImportantModifier: t,
    baseClassName: n,
    maybePostfixModifierPosition: r,
    isExternal: o,
  }),
  US = (e) => {
    const { prefix: t, experimentalParseClassName: n } = e;
    let r = (o) => {
      const s = [];
      let i = 0,
        a = 0,
        l = 0,
        c;
      const u = o.length;
      for (let p = 0; p < u; p++) {
        const v = o[p];
        if (i === 0 && a === 0) {
          if (v === Mc) {
            (s.push(o.slice(l, p)), (l = p + 1));
            continue;
          }
          if (v === "/") {
            c = p;
            continue;
          }
        }
        v === "[" ? i++ : v === "]" ? i-- : v === "(" ? a++ : v === ")" && a--;
      }
      const d = s.length === 0 ? o : o.slice(l);
      let f = d,
        m = !1;
      d.endsWith(di)
        ? ((f = d.slice(0, -1)), (m = !0))
        : d.startsWith(di) && ((f = d.slice(1)), (m = !0));
      const g = c && c > l ? c - l : void 0;
      return Ac(s, m, f, g);
    };
    if (t) {
      const o = t + Mc,
        s = r;
      r = (i) => (i.startsWith(o) ? s(i.slice(o.length)) : Ac(HS, !1, i, void 0, !0));
    }
    if (n) {
      const o = r;
      r = (s) => n({ className: s, parseClassName: o });
    }
    return r;
  },
  _S = (e) => {
    const t = new Map();
    return (
      e.orderSensitiveModifiers.forEach((n, r) => {
        t.set(n, 1e6 + r);
      }),
      (n) => {
        const r = [];
        let o = [];
        for (let s = 0; s < n.length; s++) {
          const i = n[s],
            a = i[0] === "[",
            l = t.has(i);
          a || l ? (o.length > 0 && (o.sort(), r.push(...o), (o = [])), r.push(i)) : o.push(i);
        }
        return (o.length > 0 && (o.sort(), r.push(...o)), r);
      }
    );
  },
  YS = (e) => ({ cache: zS(e.cacheSize), parseClassName: US(e), sortModifiers: _S(e), ...DS(e) }),
  qS = /\s+/,
  XS = (e, t) => {
    const {
        parseClassName: n,
        getClassGroupId: r,
        getConflictingClassGroupIds: o,
        sortModifiers: s,
      } = t,
      i = [],
      a = e.trim().split(qS);
    let l = "";
    for (let c = a.length - 1; c >= 0; c -= 1) {
      const u = a[c],
        {
          isExternal: d,
          modifiers: f,
          hasImportantModifier: m,
          baseClassName: g,
          maybePostfixModifierPosition: p,
        } = n(u);
      if (d) {
        l = u + (l.length > 0 ? " " + l : l);
        continue;
      }
      let v = !!p,
        b = r(v ? g.substring(0, p) : g);
      if (!b) {
        if (!v) {
          l = u + (l.length > 0 ? " " + l : l);
          continue;
        }
        if (((b = r(g)), !b)) {
          l = u + (l.length > 0 ? " " + l : l);
          continue;
        }
        v = !1;
      }
      const y = f.length === 0 ? "" : f.length === 1 ? f[0] : s(f).join(":"),
        w = m ? y + di : y,
        R = w + b;
      if (i.indexOf(R) > -1) continue;
      i.push(R);
      const x = o(b, v);
      for (let A = 0; A < x.length; ++A) {
        const I = x[A];
        i.push(w + I);
      }
      l = u + (l.length > 0 ? " " + l : l);
    }
    return l;
  },
  GS = (...e) => {
    let t = 0,
      n,
      r,
      o = "";
    for (; t < e.length; ) (n = e[t++]) && (r = hh(n)) && (o && (o += " "), (o += r));
    return o;
  },
  hh = (e) => {
    if (typeof e == "string") return e;
    let t,
      n = "";
    for (let r = 0; r < e.length; r++) e[r] && (t = hh(e[r])) && (n && (n += " "), (n += t));
    return n;
  },
  KS = (e, ...t) => {
    let n, r, o, s;
    const i = (l) => {
        const c = t.reduce((u, d) => d(u), e());
        return ((n = YS(c)), (r = n.cache.get), (o = n.cache.set), (s = a), a(l));
      },
      a = (l) => {
        const c = r(l);
        if (c) return c;
        const u = XS(l, n);
        return (o(l, u), u);
      };
    return ((s = i), (...l) => s(GS(...l)));
  },
  QS = [],
  qe = (e) => {
    const t = (n) => n[e] || QS;
    return ((t.isThemeGetter = !0), t);
  },
  mh = /^\[(?:(\w[\w-]*):)?(.+)\]$/i,
  ph = /^\((?:(\w[\w-]*):)?(.+)\)$/i,
  ZS = /^\d+\/\d+$/,
  JS = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/,
  eT =
    /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/,
  tT = /^(rgba?|hsla?|hwb|(ok)?(lab|lch)|color-mix)\(.+\)$/,
  nT = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/,
  rT =
    /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/,
  Pn = (e) => ZS.test(e),
  ve = (e) => !!e && !Number.isNaN(Number(e)),
  Wt = (e) => !!e && Number.isInteger(Number(e)),
  Ts = (e) => e.endsWith("%") && ve(e.slice(0, -1)),
  Dt = (e) => JS.test(e),
  oT = () => !0,
  sT = (e) => eT.test(e) && !tT.test(e),
  gh = () => !1,
  iT = (e) => nT.test(e),
  aT = (e) => rT.test(e),
  lT = (e) => !re(e) && !oe(e),
  cT = (e) => nr(e, xh, gh),
  re = (e) => mh.test(e),
  dn = (e) => nr(e, vh, sT),
  Rs = (e) => nr(e, mT, ve),
  Oc = (e) => nr(e, bh, gh),
  uT = (e) => nr(e, yh, aT),
  Zr = (e) => nr(e, wh, iT),
  oe = (e) => ph.test(e),
  lr = (e) => rr(e, vh),
  dT = (e) => rr(e, pT),
  Ic = (e) => rr(e, bh),
  fT = (e) => rr(e, xh),
  hT = (e) => rr(e, yh),
  Jr = (e) => rr(e, wh, !0),
  nr = (e, t, n) => {
    const r = mh.exec(e);
    return r ? (r[1] ? t(r[1]) : n(r[2])) : !1;
  },
  rr = (e, t, n = !1) => {
    const r = ph.exec(e);
    return r ? (r[1] ? t(r[1]) : n) : !1;
  },
  bh = (e) => e === "position" || e === "percentage",
  yh = (e) => e === "image" || e === "url",
  xh = (e) => e === "length" || e === "size" || e === "bg-size",
  vh = (e) => e === "length",
  mT = (e) => e === "number",
  pT = (e) => e === "family-name",
  wh = (e) => e === "shadow",
  gT = () => {
    const e = qe("color"),
      t = qe("font"),
      n = qe("text"),
      r = qe("font-weight"),
      o = qe("tracking"),
      s = qe("leading"),
      i = qe("breakpoint"),
      a = qe("container"),
      l = qe("spacing"),
      c = qe("radius"),
      u = qe("shadow"),
      d = qe("inset-shadow"),
      f = qe("text-shadow"),
      m = qe("drop-shadow"),
      g = qe("blur"),
      p = qe("perspective"),
      v = qe("aspect"),
      b = qe("ease"),
      y = qe("animate"),
      w = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"],
      R = () => [
        "center",
        "top",
        "bottom",
        "left",
        "right",
        "top-left",
        "left-top",
        "top-right",
        "right-top",
        "bottom-right",
        "right-bottom",
        "bottom-left",
        "left-bottom",
      ],
      x = () => [...R(), oe, re],
      A = () => ["auto", "hidden", "clip", "visible", "scroll"],
      I = () => ["auto", "contain", "none"],
      P = () => [oe, re, l],
      D = () => [Pn, "full", "auto", ...P()],
      V = () => [Wt, "none", "subgrid", oe, re],
      B = () => ["auto", { span: ["full", Wt, oe, re] }, Wt, oe, re],
      M = () => [Wt, "auto", oe, re],
      C = () => ["auto", "min", "max", "fr", oe, re],
      L = () => [
        "start",
        "end",
        "center",
        "between",
        "around",
        "evenly",
        "stretch",
        "baseline",
        "center-safe",
        "end-safe",
      ],
      k = () => ["start", "end", "center", "stretch", "center-safe", "end-safe"],
      F = () => ["auto", ...P()],
      E = () => [
        Pn,
        "auto",
        "full",
        "dvw",
        "dvh",
        "lvw",
        "lvh",
        "svw",
        "svh",
        "min",
        "max",
        "fit",
        ...P(),
      ],
      S = () => [e, oe, re],
      O = () => [...R(), Ic, Oc, { position: [oe, re] }],
      j = () => ["no-repeat", { repeat: ["", "x", "y", "space", "round"] }],
      _ = () => ["auto", "cover", "contain", fT, cT, { size: [oe, re] }],
      Q = () => [Ts, lr, dn],
      $ = () => ["", "none", "full", c, oe, re],
      Y = () => ["", ve, lr, dn],
      ne = () => ["solid", "dashed", "dotted", "double"],
      te = () => [
        "normal",
        "multiply",
        "screen",
        "overlay",
        "darken",
        "lighten",
        "color-dodge",
        "color-burn",
        "hard-light",
        "soft-light",
        "difference",
        "exclusion",
        "hue",
        "saturation",
        "color",
        "luminosity",
      ],
      H = () => [ve, Ts, Ic, Oc],
      ue = () => ["", "none", g, oe, re],
      le = () => ["none", ve, oe, re],
      ce = () => ["none", ve, oe, re],
      pe = () => [ve, oe, re],
      N = () => [Pn, "full", ...P()];
    return {
      cacheSize: 500,
      theme: {
        animate: ["spin", "ping", "pulse", "bounce"],
        aspect: ["video"],
        blur: [Dt],
        breakpoint: [Dt],
        color: [oT],
        container: [Dt],
        "drop-shadow": [Dt],
        ease: ["in", "out", "in-out"],
        font: [lT],
        "font-weight": [
          "thin",
          "extralight",
          "light",
          "normal",
          "medium",
          "semibold",
          "bold",
          "extrabold",
          "black",
        ],
        "inset-shadow": [Dt],
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose"],
        perspective: ["dramatic", "near", "normal", "midrange", "distant", "none"],
        radius: [Dt],
        shadow: [Dt],
        spacing: ["px", ve],
        text: [Dt],
        "text-shadow": [Dt],
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest"],
      },
      classGroups: {
        aspect: [{ aspect: ["auto", "square", Pn, re, oe, v] }],
        container: ["container"],
        columns: [{ columns: [ve, re, oe, a] }],
        "break-after": [{ "break-after": w() }],
        "break-before": [{ "break-before": w() }],
        "break-inside": [{ "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"] }],
        "box-decoration": [{ "box-decoration": ["slice", "clone"] }],
        box: [{ box: ["border", "content"] }],
        display: [
          "block",
          "inline-block",
          "inline",
          "flex",
          "inline-flex",
          "table",
          "inline-table",
          "table-caption",
          "table-cell",
          "table-column",
          "table-column-group",
          "table-footer-group",
          "table-header-group",
          "table-row-group",
          "table-row",
          "flow-root",
          "grid",
          "inline-grid",
          "contents",
          "list-item",
          "hidden",
        ],
        sr: ["sr-only", "not-sr-only"],
        float: [{ float: ["right", "left", "none", "start", "end"] }],
        clear: [{ clear: ["left", "right", "both", "none", "start", "end"] }],
        isolation: ["isolate", "isolation-auto"],
        "object-fit": [{ object: ["contain", "cover", "fill", "none", "scale-down"] }],
        "object-position": [{ object: x() }],
        overflow: [{ overflow: A() }],
        "overflow-x": [{ "overflow-x": A() }],
        "overflow-y": [{ "overflow-y": A() }],
        overscroll: [{ overscroll: I() }],
        "overscroll-x": [{ "overscroll-x": I() }],
        "overscroll-y": [{ "overscroll-y": I() }],
        position: ["static", "fixed", "absolute", "relative", "sticky"],
        inset: [{ inset: D() }],
        "inset-x": [{ "inset-x": D() }],
        "inset-y": [{ "inset-y": D() }],
        start: [{ start: D() }],
        end: [{ end: D() }],
        top: [{ top: D() }],
        right: [{ right: D() }],
        bottom: [{ bottom: D() }],
        left: [{ left: D() }],
        visibility: ["visible", "invisible", "collapse"],
        z: [{ z: [Wt, "auto", oe, re] }],
        basis: [{ basis: [Pn, "full", "auto", a, ...P()] }],
        "flex-direction": [{ flex: ["row", "row-reverse", "col", "col-reverse"] }],
        "flex-wrap": [{ flex: ["nowrap", "wrap", "wrap-reverse"] }],
        flex: [{ flex: [ve, Pn, "auto", "initial", "none", re] }],
        grow: [{ grow: ["", ve, oe, re] }],
        shrink: [{ shrink: ["", ve, oe, re] }],
        order: [{ order: [Wt, "first", "last", "none", oe, re] }],
        "grid-cols": [{ "grid-cols": V() }],
        "col-start-end": [{ col: B() }],
        "col-start": [{ "col-start": M() }],
        "col-end": [{ "col-end": M() }],
        "grid-rows": [{ "grid-rows": V() }],
        "row-start-end": [{ row: B() }],
        "row-start": [{ "row-start": M() }],
        "row-end": [{ "row-end": M() }],
        "grid-flow": [{ "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"] }],
        "auto-cols": [{ "auto-cols": C() }],
        "auto-rows": [{ "auto-rows": C() }],
        gap: [{ gap: P() }],
        "gap-x": [{ "gap-x": P() }],
        "gap-y": [{ "gap-y": P() }],
        "justify-content": [{ justify: [...L(), "normal"] }],
        "justify-items": [{ "justify-items": [...k(), "normal"] }],
        "justify-self": [{ "justify-self": ["auto", ...k()] }],
        "align-content": [{ content: ["normal", ...L()] }],
        "align-items": [{ items: [...k(), { baseline: ["", "last"] }] }],
        "align-self": [{ self: ["auto", ...k(), { baseline: ["", "last"] }] }],
        "place-content": [{ "place-content": L() }],
        "place-items": [{ "place-items": [...k(), "baseline"] }],
        "place-self": [{ "place-self": ["auto", ...k()] }],
        p: [{ p: P() }],
        px: [{ px: P() }],
        py: [{ py: P() }],
        ps: [{ ps: P() }],
        pe: [{ pe: P() }],
        pt: [{ pt: P() }],
        pr: [{ pr: P() }],
        pb: [{ pb: P() }],
        pl: [{ pl: P() }],
        m: [{ m: F() }],
        mx: [{ mx: F() }],
        my: [{ my: F() }],
        ms: [{ ms: F() }],
        me: [{ me: F() }],
        mt: [{ mt: F() }],
        mr: [{ mr: F() }],
        mb: [{ mb: F() }],
        ml: [{ ml: F() }],
        "space-x": [{ "space-x": P() }],
        "space-x-reverse": ["space-x-reverse"],
        "space-y": [{ "space-y": P() }],
        "space-y-reverse": ["space-y-reverse"],
        size: [{ size: E() }],
        w: [{ w: [a, "screen", ...E()] }],
        "min-w": [{ "min-w": [a, "screen", "none", ...E()] }],
        "max-w": [{ "max-w": [a, "screen", "none", "prose", { screen: [i] }, ...E()] }],
        h: [{ h: ["screen", "lh", ...E()] }],
        "min-h": [{ "min-h": ["screen", "lh", "none", ...E()] }],
        "max-h": [{ "max-h": ["screen", "lh", ...E()] }],
        "font-size": [{ text: ["base", n, lr, dn] }],
        "font-smoothing": ["antialiased", "subpixel-antialiased"],
        "font-style": ["italic", "not-italic"],
        "font-weight": [{ font: [r, oe, Rs] }],
        "font-stretch": [
          {
            "font-stretch": [
              "ultra-condensed",
              "extra-condensed",
              "condensed",
              "semi-condensed",
              "normal",
              "semi-expanded",
              "expanded",
              "extra-expanded",
              "ultra-expanded",
              Ts,
              re,
            ],
          },
        ],
        "font-family": [{ font: [dT, re, t] }],
        "fvn-normal": ["normal-nums"],
        "fvn-ordinal": ["ordinal"],
        "fvn-slashed-zero": ["slashed-zero"],
        "fvn-figure": ["lining-nums", "oldstyle-nums"],
        "fvn-spacing": ["proportional-nums", "tabular-nums"],
        "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
        tracking: [{ tracking: [o, oe, re] }],
        "line-clamp": [{ "line-clamp": [ve, "none", oe, Rs] }],
        leading: [{ leading: [s, ...P()] }],
        "list-image": [{ "list-image": ["none", oe, re] }],
        "list-style-position": [{ list: ["inside", "outside"] }],
        "list-style-type": [{ list: ["disc", "decimal", "none", oe, re] }],
        "text-alignment": [{ text: ["left", "center", "right", "justify", "start", "end"] }],
        "placeholder-color": [{ placeholder: S() }],
        "text-color": [{ text: S() }],
        "text-decoration": ["underline", "overline", "line-through", "no-underline"],
        "text-decoration-style": [{ decoration: [...ne(), "wavy"] }],
        "text-decoration-thickness": [{ decoration: [ve, "from-font", "auto", oe, dn] }],
        "text-decoration-color": [{ decoration: S() }],
        "underline-offset": [{ "underline-offset": [ve, "auto", oe, re] }],
        "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
        "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
        "text-wrap": [{ text: ["wrap", "nowrap", "balance", "pretty"] }],
        indent: [{ indent: P() }],
        "vertical-align": [
          {
            align: [
              "baseline",
              "top",
              "middle",
              "bottom",
              "text-top",
              "text-bottom",
              "sub",
              "super",
              oe,
              re,
            ],
          },
        ],
        whitespace: [
          { whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"] },
        ],
        break: [{ break: ["normal", "words", "all", "keep"] }],
        wrap: [{ wrap: ["break-word", "anywhere", "normal"] }],
        hyphens: [{ hyphens: ["none", "manual", "auto"] }],
        content: [{ content: ["none", oe, re] }],
        "bg-attachment": [{ bg: ["fixed", "local", "scroll"] }],
        "bg-clip": [{ "bg-clip": ["border", "padding", "content", "text"] }],
        "bg-origin": [{ "bg-origin": ["border", "padding", "content"] }],
        "bg-position": [{ bg: O() }],
        "bg-repeat": [{ bg: j() }],
        "bg-size": [{ bg: _() }],
        "bg-image": [
          {
            bg: [
              "none",
              {
                linear: [{ to: ["t", "tr", "r", "br", "b", "bl", "l", "tl"] }, Wt, oe, re],
                radial: ["", oe, re],
                conic: [Wt, oe, re],
              },
              hT,
              uT,
            ],
          },
        ],
        "bg-color": [{ bg: S() }],
        "gradient-from-pos": [{ from: Q() }],
        "gradient-via-pos": [{ via: Q() }],
        "gradient-to-pos": [{ to: Q() }],
        "gradient-from": [{ from: S() }],
        "gradient-via": [{ via: S() }],
        "gradient-to": [{ to: S() }],
        rounded: [{ rounded: $() }],
        "rounded-s": [{ "rounded-s": $() }],
        "rounded-e": [{ "rounded-e": $() }],
        "rounded-t": [{ "rounded-t": $() }],
        "rounded-r": [{ "rounded-r": $() }],
        "rounded-b": [{ "rounded-b": $() }],
        "rounded-l": [{ "rounded-l": $() }],
        "rounded-ss": [{ "rounded-ss": $() }],
        "rounded-se": [{ "rounded-se": $() }],
        "rounded-ee": [{ "rounded-ee": $() }],
        "rounded-es": [{ "rounded-es": $() }],
        "rounded-tl": [{ "rounded-tl": $() }],
        "rounded-tr": [{ "rounded-tr": $() }],
        "rounded-br": [{ "rounded-br": $() }],
        "rounded-bl": [{ "rounded-bl": $() }],
        "border-w": [{ border: Y() }],
        "border-w-x": [{ "border-x": Y() }],
        "border-w-y": [{ "border-y": Y() }],
        "border-w-s": [{ "border-s": Y() }],
        "border-w-e": [{ "border-e": Y() }],
        "border-w-t": [{ "border-t": Y() }],
        "border-w-r": [{ "border-r": Y() }],
        "border-w-b": [{ "border-b": Y() }],
        "border-w-l": [{ "border-l": Y() }],
        "divide-x": [{ "divide-x": Y() }],
        "divide-x-reverse": ["divide-x-reverse"],
        "divide-y": [{ "divide-y": Y() }],
        "divide-y-reverse": ["divide-y-reverse"],
        "border-style": [{ border: [...ne(), "hidden", "none"] }],
        "divide-style": [{ divide: [...ne(), "hidden", "none"] }],
        "border-color": [{ border: S() }],
        "border-color-x": [{ "border-x": S() }],
        "border-color-y": [{ "border-y": S() }],
        "border-color-s": [{ "border-s": S() }],
        "border-color-e": [{ "border-e": S() }],
        "border-color-t": [{ "border-t": S() }],
        "border-color-r": [{ "border-r": S() }],
        "border-color-b": [{ "border-b": S() }],
        "border-color-l": [{ "border-l": S() }],
        "divide-color": [{ divide: S() }],
        "outline-style": [{ outline: [...ne(), "none", "hidden"] }],
        "outline-offset": [{ "outline-offset": [ve, oe, re] }],
        "outline-w": [{ outline: ["", ve, lr, dn] }],
        "outline-color": [{ outline: S() }],
        shadow: [{ shadow: ["", "none", u, Jr, Zr] }],
        "shadow-color": [{ shadow: S() }],
        "inset-shadow": [{ "inset-shadow": ["none", d, Jr, Zr] }],
        "inset-shadow-color": [{ "inset-shadow": S() }],
        "ring-w": [{ ring: Y() }],
        "ring-w-inset": ["ring-inset"],
        "ring-color": [{ ring: S() }],
        "ring-offset-w": [{ "ring-offset": [ve, dn] }],
        "ring-offset-color": [{ "ring-offset": S() }],
        "inset-ring-w": [{ "inset-ring": Y() }],
        "inset-ring-color": [{ "inset-ring": S() }],
        "text-shadow": [{ "text-shadow": ["none", f, Jr, Zr] }],
        "text-shadow-color": [{ "text-shadow": S() }],
        opacity: [{ opacity: [ve, oe, re] }],
        "mix-blend": [{ "mix-blend": [...te(), "plus-darker", "plus-lighter"] }],
        "bg-blend": [{ "bg-blend": te() }],
        "mask-clip": [
          { "mask-clip": ["border", "padding", "content", "fill", "stroke", "view"] },
          "mask-no-clip",
        ],
        "mask-composite": [{ mask: ["add", "subtract", "intersect", "exclude"] }],
        "mask-image-linear-pos": [{ "mask-linear": [ve] }],
        "mask-image-linear-from-pos": [{ "mask-linear-from": H() }],
        "mask-image-linear-to-pos": [{ "mask-linear-to": H() }],
        "mask-image-linear-from-color": [{ "mask-linear-from": S() }],
        "mask-image-linear-to-color": [{ "mask-linear-to": S() }],
        "mask-image-t-from-pos": [{ "mask-t-from": H() }],
        "mask-image-t-to-pos": [{ "mask-t-to": H() }],
        "mask-image-t-from-color": [{ "mask-t-from": S() }],
        "mask-image-t-to-color": [{ "mask-t-to": S() }],
        "mask-image-r-from-pos": [{ "mask-r-from": H() }],
        "mask-image-r-to-pos": [{ "mask-r-to": H() }],
        "mask-image-r-from-color": [{ "mask-r-from": S() }],
        "mask-image-r-to-color": [{ "mask-r-to": S() }],
        "mask-image-b-from-pos": [{ "mask-b-from": H() }],
        "mask-image-b-to-pos": [{ "mask-b-to": H() }],
        "mask-image-b-from-color": [{ "mask-b-from": S() }],
        "mask-image-b-to-color": [{ "mask-b-to": S() }],
        "mask-image-l-from-pos": [{ "mask-l-from": H() }],
        "mask-image-l-to-pos": [{ "mask-l-to": H() }],
        "mask-image-l-from-color": [{ "mask-l-from": S() }],
        "mask-image-l-to-color": [{ "mask-l-to": S() }],
        "mask-image-x-from-pos": [{ "mask-x-from": H() }],
        "mask-image-x-to-pos": [{ "mask-x-to": H() }],
        "mask-image-x-from-color": [{ "mask-x-from": S() }],
        "mask-image-x-to-color": [{ "mask-x-to": S() }],
        "mask-image-y-from-pos": [{ "mask-y-from": H() }],
        "mask-image-y-to-pos": [{ "mask-y-to": H() }],
        "mask-image-y-from-color": [{ "mask-y-from": S() }],
        "mask-image-y-to-color": [{ "mask-y-to": S() }],
        "mask-image-radial": [{ "mask-radial": [oe, re] }],
        "mask-image-radial-from-pos": [{ "mask-radial-from": H() }],
        "mask-image-radial-to-pos": [{ "mask-radial-to": H() }],
        "mask-image-radial-from-color": [{ "mask-radial-from": S() }],
        "mask-image-radial-to-color": [{ "mask-radial-to": S() }],
        "mask-image-radial-shape": [{ "mask-radial": ["circle", "ellipse"] }],
        "mask-image-radial-size": [
          { "mask-radial": [{ closest: ["side", "corner"], farthest: ["side", "corner"] }] },
        ],
        "mask-image-radial-pos": [{ "mask-radial-at": R() }],
        "mask-image-conic-pos": [{ "mask-conic": [ve] }],
        "mask-image-conic-from-pos": [{ "mask-conic-from": H() }],
        "mask-image-conic-to-pos": [{ "mask-conic-to": H() }],
        "mask-image-conic-from-color": [{ "mask-conic-from": S() }],
        "mask-image-conic-to-color": [{ "mask-conic-to": S() }],
        "mask-mode": [{ mask: ["alpha", "luminance", "match"] }],
        "mask-origin": [
          { "mask-origin": ["border", "padding", "content", "fill", "stroke", "view"] },
        ],
        "mask-position": [{ mask: O() }],
        "mask-repeat": [{ mask: j() }],
        "mask-size": [{ mask: _() }],
        "mask-type": [{ "mask-type": ["alpha", "luminance"] }],
        "mask-image": [{ mask: ["none", oe, re] }],
        filter: [{ filter: ["", "none", oe, re] }],
        blur: [{ blur: ue() }],
        brightness: [{ brightness: [ve, oe, re] }],
        contrast: [{ contrast: [ve, oe, re] }],
        "drop-shadow": [{ "drop-shadow": ["", "none", m, Jr, Zr] }],
        "drop-shadow-color": [{ "drop-shadow": S() }],
        grayscale: [{ grayscale: ["", ve, oe, re] }],
        "hue-rotate": [{ "hue-rotate": [ve, oe, re] }],
        invert: [{ invert: ["", ve, oe, re] }],
        saturate: [{ saturate: [ve, oe, re] }],
        sepia: [{ sepia: ["", ve, oe, re] }],
        "backdrop-filter": [{ "backdrop-filter": ["", "none", oe, re] }],
        "backdrop-blur": [{ "backdrop-blur": ue() }],
        "backdrop-brightness": [{ "backdrop-brightness": [ve, oe, re] }],
        "backdrop-contrast": [{ "backdrop-contrast": [ve, oe, re] }],
        "backdrop-grayscale": [{ "backdrop-grayscale": ["", ve, oe, re] }],
        "backdrop-hue-rotate": [{ "backdrop-hue-rotate": [ve, oe, re] }],
        "backdrop-invert": [{ "backdrop-invert": ["", ve, oe, re] }],
        "backdrop-opacity": [{ "backdrop-opacity": [ve, oe, re] }],
        "backdrop-saturate": [{ "backdrop-saturate": [ve, oe, re] }],
        "backdrop-sepia": [{ "backdrop-sepia": ["", ve, oe, re] }],
        "border-collapse": [{ border: ["collapse", "separate"] }],
        "border-spacing": [{ "border-spacing": P() }],
        "border-spacing-x": [{ "border-spacing-x": P() }],
        "border-spacing-y": [{ "border-spacing-y": P() }],
        "table-layout": [{ table: ["auto", "fixed"] }],
        caption: [{ caption: ["top", "bottom"] }],
        transition: [
          { transition: ["", "all", "colors", "opacity", "shadow", "transform", "none", oe, re] },
        ],
        "transition-behavior": [{ transition: ["normal", "discrete"] }],
        duration: [{ duration: [ve, "initial", oe, re] }],
        ease: [{ ease: ["linear", "initial", b, oe, re] }],
        delay: [{ delay: [ve, oe, re] }],
        animate: [{ animate: ["none", y, oe, re] }],
        backface: [{ backface: ["hidden", "visible"] }],
        perspective: [{ perspective: [p, oe, re] }],
        "perspective-origin": [{ "perspective-origin": x() }],
        rotate: [{ rotate: le() }],
        "rotate-x": [{ "rotate-x": le() }],
        "rotate-y": [{ "rotate-y": le() }],
        "rotate-z": [{ "rotate-z": le() }],
        scale: [{ scale: ce() }],
        "scale-x": [{ "scale-x": ce() }],
        "scale-y": [{ "scale-y": ce() }],
        "scale-z": [{ "scale-z": ce() }],
        "scale-3d": ["scale-3d"],
        skew: [{ skew: pe() }],
        "skew-x": [{ "skew-x": pe() }],
        "skew-y": [{ "skew-y": pe() }],
        transform: [{ transform: [oe, re, "", "none", "gpu", "cpu"] }],
        "transform-origin": [{ origin: x() }],
        "transform-style": [{ transform: ["3d", "flat"] }],
        translate: [{ translate: N() }],
        "translate-x": [{ "translate-x": N() }],
        "translate-y": [{ "translate-y": N() }],
        "translate-z": [{ "translate-z": N() }],
        "translate-none": ["translate-none"],
        accent: [{ accent: S() }],
        appearance: [{ appearance: ["none", "auto"] }],
        "caret-color": [{ caret: S() }],
        "color-scheme": [
          { scheme: ["normal", "dark", "light", "light-dark", "only-dark", "only-light"] },
        ],
        cursor: [
          {
            cursor: [
              "auto",
              "default",
              "pointer",
              "wait",
              "text",
              "move",
              "help",
              "not-allowed",
              "none",
              "context-menu",
              "progress",
              "cell",
              "crosshair",
              "vertical-text",
              "alias",
              "copy",
              "no-drop",
              "grab",
              "grabbing",
              "all-scroll",
              "col-resize",
              "row-resize",
              "n-resize",
              "e-resize",
              "s-resize",
              "w-resize",
              "ne-resize",
              "nw-resize",
              "se-resize",
              "sw-resize",
              "ew-resize",
              "ns-resize",
              "nesw-resize",
              "nwse-resize",
              "zoom-in",
              "zoom-out",
              oe,
              re,
            ],
          },
        ],
        "field-sizing": [{ "field-sizing": ["fixed", "content"] }],
        "pointer-events": [{ "pointer-events": ["auto", "none"] }],
        resize: [{ resize: ["none", "", "y", "x"] }],
        "scroll-behavior": [{ scroll: ["auto", "smooth"] }],
        "scroll-m": [{ "scroll-m": P() }],
        "scroll-mx": [{ "scroll-mx": P() }],
        "scroll-my": [{ "scroll-my": P() }],
        "scroll-ms": [{ "scroll-ms": P() }],
        "scroll-me": [{ "scroll-me": P() }],
        "scroll-mt": [{ "scroll-mt": P() }],
        "scroll-mr": [{ "scroll-mr": P() }],
        "scroll-mb": [{ "scroll-mb": P() }],
        "scroll-ml": [{ "scroll-ml": P() }],
        "scroll-p": [{ "scroll-p": P() }],
        "scroll-px": [{ "scroll-px": P() }],
        "scroll-py": [{ "scroll-py": P() }],
        "scroll-ps": [{ "scroll-ps": P() }],
        "scroll-pe": [{ "scroll-pe": P() }],
        "scroll-pt": [{ "scroll-pt": P() }],
        "scroll-pr": [{ "scroll-pr": P() }],
        "scroll-pb": [{ "scroll-pb": P() }],
        "scroll-pl": [{ "scroll-pl": P() }],
        "snap-align": [{ snap: ["start", "end", "center", "align-none"] }],
        "snap-stop": [{ snap: ["normal", "always"] }],
        "snap-type": [{ snap: ["none", "x", "y", "both"] }],
        "snap-strictness": [{ snap: ["mandatory", "proximity"] }],
        touch: [{ touch: ["auto", "none", "manipulation"] }],
        "touch-x": [{ "touch-pan": ["x", "left", "right"] }],
        "touch-y": [{ "touch-pan": ["y", "up", "down"] }],
        "touch-pz": ["touch-pinch-zoom"],
        select: [{ select: ["none", "text", "all", "auto"] }],
        "will-change": [{ "will-change": ["auto", "scroll", "contents", "transform", oe, re] }],
        fill: [{ fill: ["none", ...S()] }],
        "stroke-w": [{ stroke: [ve, lr, dn, Rs] }],
        stroke: [{ stroke: ["none", ...S()] }],
        "forced-color-adjust": [{ "forced-color-adjust": ["auto", "none"] }],
      },
      conflictingClassGroups: {
        overflow: ["overflow-x", "overflow-y"],
        overscroll: ["overscroll-x", "overscroll-y"],
        inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
        "inset-x": ["right", "left"],
        "inset-y": ["top", "bottom"],
        flex: ["basis", "grow", "shrink"],
        gap: ["gap-x", "gap-y"],
        p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
        px: ["pr", "pl"],
        py: ["pt", "pb"],
        m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
        mx: ["mr", "ml"],
        my: ["mt", "mb"],
        size: ["w", "h"],
        "font-size": ["leading"],
        "fvn-normal": [
          "fvn-ordinal",
          "fvn-slashed-zero",
          "fvn-figure",
          "fvn-spacing",
          "fvn-fraction",
        ],
        "fvn-ordinal": ["fvn-normal"],
        "fvn-slashed-zero": ["fvn-normal"],
        "fvn-figure": ["fvn-normal"],
        "fvn-spacing": ["fvn-normal"],
        "fvn-fraction": ["fvn-normal"],
        "line-clamp": ["display", "overflow"],
        rounded: [
          "rounded-s",
          "rounded-e",
          "rounded-t",
          "rounded-r",
          "rounded-b",
          "rounded-l",
          "rounded-ss",
          "rounded-se",
          "rounded-ee",
          "rounded-es",
          "rounded-tl",
          "rounded-tr",
          "rounded-br",
          "rounded-bl",
        ],
        "rounded-s": ["rounded-ss", "rounded-es"],
        "rounded-e": ["rounded-se", "rounded-ee"],
        "rounded-t": ["rounded-tl", "rounded-tr"],
        "rounded-r": ["rounded-tr", "rounded-br"],
        "rounded-b": ["rounded-br", "rounded-bl"],
        "rounded-l": ["rounded-tl", "rounded-bl"],
        "border-spacing": ["border-spacing-x", "border-spacing-y"],
        "border-w": [
          "border-w-x",
          "border-w-y",
          "border-w-s",
          "border-w-e",
          "border-w-t",
          "border-w-r",
          "border-w-b",
          "border-w-l",
        ],
        "border-w-x": ["border-w-r", "border-w-l"],
        "border-w-y": ["border-w-t", "border-w-b"],
        "border-color": [
          "border-color-x",
          "border-color-y",
          "border-color-s",
          "border-color-e",
          "border-color-t",
          "border-color-r",
          "border-color-b",
          "border-color-l",
        ],
        "border-color-x": ["border-color-r", "border-color-l"],
        "border-color-y": ["border-color-t", "border-color-b"],
        translate: ["translate-x", "translate-y", "translate-none"],
        "translate-none": ["translate", "translate-x", "translate-y", "translate-z"],
        "scroll-m": [
          "scroll-mx",
          "scroll-my",
          "scroll-ms",
          "scroll-me",
          "scroll-mt",
          "scroll-mr",
          "scroll-mb",
          "scroll-ml",
        ],
        "scroll-mx": ["scroll-mr", "scroll-ml"],
        "scroll-my": ["scroll-mt", "scroll-mb"],
        "scroll-p": [
          "scroll-px",
          "scroll-py",
          "scroll-ps",
          "scroll-pe",
          "scroll-pt",
          "scroll-pr",
          "scroll-pb",
          "scroll-pl",
        ],
        "scroll-px": ["scroll-pr", "scroll-pl"],
        "scroll-py": ["scroll-pt", "scroll-pb"],
        touch: ["touch-x", "touch-y", "touch-pz"],
        "touch-x": ["touch"],
        "touch-y": ["touch"],
        "touch-pz": ["touch"],
      },
      conflictingClassGroupModifiers: { "font-size": ["leading"] },
      orderSensitiveModifiers: [
        "*",
        "**",
        "after",
        "backdrop",
        "before",
        "details-content",
        "file",
        "first-letter",
        "first-line",
        "marker",
        "placeholder",
        "selection",
      ],
    };
  },
  bT = KS(gT);
function ye(...e) {
  return bT(ch(e));
}
function Sh({ ...e }) {
  return T.jsx(TS, { "data-slot": "dropdown-menu", ...e });
}
function Th({ ...e }) {
  return T.jsx(PS, { "data-slot": "dropdown-menu-trigger", ...e });
}
function Rh({
  align: e = "start",
  alignOffset: t = 0,
  side: n = "bottom",
  sideOffset: r = 4,
  className: o,
  ...s
}) {
  return T.jsx(Q0, {
    children: T.jsx(lS, {
      className: "isolate z-50 outline-none",
      align: e,
      alignOffset: t,
      side: n,
      sideOffset: r,
      children: T.jsx(G0, {
        "data-slot": "dropdown-menu-content",
        className: ye(
          "data-open:animate-in data-closed:animate-out data-closed:fade-out-0 data-open:fade-in-0 data-closed:zoom-out-95 data-open:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 ring-foreground/10 bg-popover text-popover-foreground min-w-32 rounded-none shadow-md ring-1 duration-100 z-50 max-h-(--available-height) w-(--anchor-width) origin-(--transform-origin) overflow-x-hidden overflow-y-auto outline-none data-closed:overflow-hidden",
          o,
        ),
        ...s,
      }),
    }),
  });
}
function yT({ className: e, inset: t, variant: n = "default", ...r }) {
  return T.jsx(av, {
    "data-slot": "dropdown-menu-item",
    "data-inset": t,
    "data-variant": n,
    className: ye(
      "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:text-destructive not-data-[variant=destructive]:focus:**:text-accent-foreground gap-2 rounded-none px-2 py-2 text-xs [&_svg:not([class*='size-'])]:size-4 group/dropdown-menu-item relative flex cursor-default items-center outline-hidden select-none data-disabled:pointer-events-none data-disabled:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0",
      e,
    ),
    ...r,
  });
}
const Eh = h.createContext(void 0);
function Go() {
  const e = h.useContext(Eh);
  if (e === void 0) throw new Error(Ke(53));
  return e;
}
let Io = (function (e) {
  return (
    (e.scrollAreaCornerHeight = "--scroll-area-corner-height"),
    (e.scrollAreaCornerWidth = "--scroll-area-corner-width"),
    e
  );
})({});
const eo = 500,
  Dc = 16;
function bt(e, t, n) {
  if (!e) return 0;
  const r = getComputedStyle(e),
    o = n === "x" ? "Inline" : "Block";
  return n === "x" && t === "margin"
    ? parseFloat(r[`${t}InlineStart`]) * 2
    : parseFloat(r[`${t}${o}Start`]) + parseFloat(r[`${t}${o}End`]);
}
let xT = (function (e) {
  return (
    (e.orientation = "data-orientation"),
    (e.hovering = "data-hovering"),
    (e.scrolling = "data-scrolling"),
    (e.hasOverflowX = "data-has-overflow-x"),
    (e.hasOverflowY = "data-has-overflow-y"),
    (e.overflowXStart = "data-overflow-x-start"),
    (e.overflowXEnd = "data-overflow-x-end"),
    (e.overflowYStart = "data-overflow-y-start"),
    (e.overflowYEnd = "data-overflow-y-end"),
    e
  );
})({});
const to = "base-ui-disable-scrollbar",
  Ch = {
    className: to,
    getElement(e) {
      return T.jsx("style", {
        nonce: e,
        href: to,
        precedence: "base-ui:low",
        children: `.${to}{scrollbar-width:none}.${to}::-webkit-scrollbar{display:none}`,
      });
    },
  };
let kn = (function (e) {
  return (
    (e.hasOverflowX = "data-has-overflow-x"),
    (e.hasOverflowY = "data-has-overflow-y"),
    (e.overflowXStart = "data-overflow-x-start"),
    (e.overflowXEnd = "data-overflow-x-end"),
    (e.overflowYStart = "data-overflow-y-start"),
    (e.overflowYEnd = "data-overflow-y-end"),
    e
  );
})({});
const wa = {
    hasOverflowX: (e) => (e ? { [kn.hasOverflowX]: "" } : null),
    hasOverflowY: (e) => (e ? { [kn.hasOverflowY]: "" } : null),
    overflowXStart: (e) => (e ? { [kn.overflowXStart]: "" } : null),
    overflowXEnd: (e) => (e ? { [kn.overflowXEnd]: "" } : null),
    overflowYStart: (e) => (e ? { [kn.overflowYStart]: "" } : null),
    overflowYEnd: (e) => (e ? { [kn.overflowYEnd]: "" } : null),
    cornerHidden: () => null,
  },
  vT = h.createContext(void 0),
  wT = { disableStyleElements: !1 };
function ST() {
  return h.useContext(vT) ?? wT;
}
const TT = { x: 0, y: 0 },
  Nc = { width: 0, height: 0 },
  RT = { xStart: !1, xEnd: !1, yStart: !1, yEnd: !1 },
  ET = { x: !1, y: !1, corner: !1 },
  CT = h.forwardRef(function (t, n) {
    const { render: r, className: o, overflowEdgeThreshold: s, ...i } = t,
      a = PT(s),
      l = rn(),
      c = Ge(),
      u = Ge(),
      { nonce: d, disableStyleElements: f } = ST(),
      [m, g] = h.useState(!1),
      [p, v] = h.useState(!1),
      [b, y] = h.useState(!1),
      [w, R] = h.useState(!1),
      [x, A] = h.useState(Nc),
      [I, P] = h.useState(Nc),
      [D, V] = h.useState(RT),
      [B, M] = h.useState(ET),
      C = h.useRef(null),
      L = h.useRef(null),
      k = h.useRef(null),
      F = h.useRef(null),
      E = h.useRef(null),
      S = h.useRef(null),
      O = h.useRef(null),
      j = h.useRef(!1),
      _ = h.useRef(0),
      Q = h.useRef(0),
      $ = h.useRef(0),
      Y = h.useRef(0),
      ne = h.useRef("vertical"),
      te = h.useRef(TT),
      H = J((W) => {
        const G = W.x - te.current.x,
          ie = W.y - te.current.y;
        ((te.current = W),
          ie !== 0 &&
            (y(!0),
            c.start(eo, () => {
              y(!1);
            })),
          G !== 0 &&
            (v(!0),
            u.start(eo, () => {
              v(!1);
            })));
      }),
      ue = J((W) => {
        W.button === 0 &&
          ((j.current = !0),
          (_.current = W.clientY),
          (Q.current = W.clientX),
          (ne.current = W.currentTarget.getAttribute(xT.orientation)),
          L.current && (($.current = L.current.scrollTop), (Y.current = L.current.scrollLeft)),
          E.current && ne.current === "vertical" && E.current.setPointerCapture(W.pointerId),
          S.current && ne.current === "horizontal" && S.current.setPointerCapture(W.pointerId));
      }),
      le = J((W) => {
        if (!j.current) return;
        const G = W.clientY - _.current,
          ie = W.clientX - Q.current;
        if (L.current) {
          const he = L.current.scrollHeight,
            ae = L.current.clientHeight,
            de = L.current.scrollWidth,
            U = L.current.clientWidth;
          if (E.current && k.current && ne.current === "vertical") {
            const Z = bt(k.current, "padding", "y"),
              K = bt(E.current, "margin", "y"),
              xe = E.current.offsetHeight,
              Re = k.current.offsetHeight - xe - Z - K,
              Ee = G / Re;
            ((L.current.scrollTop = $.current + Ee * (he - ae)),
              W.preventDefault(),
              y(!0),
              c.start(eo, () => {
                y(!1);
              }));
          }
          if (S.current && F.current && ne.current === "horizontal") {
            const Z = bt(F.current, "padding", "x"),
              K = bt(S.current, "margin", "x"),
              xe = S.current.offsetWidth,
              Re = F.current.offsetWidth - xe - Z - K,
              Ee = ie / Re;
            ((L.current.scrollLeft = Y.current + Ee * (de - U)),
              W.preventDefault(),
              v(!0),
              u.start(eo, () => {
                v(!1);
              }));
          }
        }
      }),
      ce = J((W) => {
        ((j.current = !1),
          E.current && ne.current === "vertical" && E.current.releasePointerCapture(W.pointerId),
          S.current && ne.current === "horizontal" && S.current.releasePointerCapture(W.pointerId));
      });
    function pe(W) {
      R(W.pointerType === "touch");
    }
    function N(W) {
      if ((pe(W), W.pointerType !== "touch")) {
        const G = Se(C.current, W.target);
        g(G);
      }
    }
    const X = h.useMemo(
        () => ({
          hasOverflowX: !B.x,
          hasOverflowY: !B.y,
          overflowXStart: D.xStart,
          overflowXEnd: D.xEnd,
          overflowYStart: D.yStart,
          overflowYEnd: D.yEnd,
          cornerHidden: B.corner,
        }),
        [B.x, B.y, B.corner, D],
      ),
      q = {
        role: "presentation",
        onPointerEnter: N,
        onPointerMove: N,
        onPointerDown: pe,
        onPointerLeave() {
          g(!1);
        },
        style: {
          position: "relative",
          [Io.scrollAreaCornerHeight]: `${x.height}px`,
          [Io.scrollAreaCornerWidth]: `${x.width}px`,
        },
      },
      we = We("div", t, { state: X, ref: [n, C], props: [q, i], stateAttributesMapping: wa }),
      z = h.useMemo(
        () => ({
          handlePointerDown: ue,
          handlePointerMove: le,
          handlePointerUp: ce,
          handleScroll: H,
          cornerSize: x,
          setCornerSize: A,
          thumbSize: I,
          setThumbSize: P,
          touchModality: w,
          cornerRef: O,
          scrollingX: p,
          setScrollingX: v,
          scrollingY: b,
          setScrollingY: y,
          hovering: m,
          setHovering: g,
          viewportRef: L,
          rootRef: C,
          scrollbarYRef: k,
          scrollbarXRef: F,
          thumbYRef: E,
          thumbXRef: S,
          rootId: l,
          hiddenState: B,
          setHiddenState: M,
          overflowEdges: D,
          setOverflowEdges: V,
          viewportState: X,
          overflowEdgeThreshold: a,
        }),
        [ue, le, ce, H, x, I, w, p, v, b, y, m, g, l, B, D, X, a],
      );
    return T.jsxs(Eh.Provider, { value: z, children: [!f && Ch.getElement(d), we] });
  });
function PT(e) {
  if (typeof e == "number") {
    const t = Math.max(0, e);
    return { xStart: t, xEnd: t, yStart: t, yEnd: t };
  }
  return {
    xStart: Math.max(0, (e == null ? void 0 : e.xStart) || 0),
    xEnd: Math.max(0, (e == null ? void 0 : e.xEnd) || 0),
    yStart: Math.max(0, (e == null ? void 0 : e.yStart) || 0),
    yEnd: Math.max(0, (e == null ? void 0 : e.yEnd) || 0),
  };
}
const kT = h.createContext(void 0);
function Nt(e, t = Number.MIN_SAFE_INTEGER, n = Number.MAX_SAFE_INTEGER) {
  return Math.max(t, Math.min(e, n));
}
function MT(e, t) {
  if (typeof IntersectionObserver > "u") return () => {};
  const n = new IntersectionObserver((r) => {
    r.forEach((o) => {
      o.intersectionRatio > 0 && (t(), n.disconnect());
    });
  });
  return (
    n.observe(e),
    () => {
      n.disconnect();
    }
  );
}
let _t = (function (e) {
    return (
      (e.scrollAreaOverflowXStart = "--scroll-area-overflow-x-start"),
      (e.scrollAreaOverflowXEnd = "--scroll-area-overflow-x-end"),
      (e.scrollAreaOverflowYStart = "--scroll-area-overflow-y-start"),
      (e.scrollAreaOverflowYEnd = "--scroll-area-overflow-y-end"),
      e
    );
  })({}),
  Fc = !1;
function AT() {
  Fc ||
    Gd ||
    (typeof CSS < "u" &&
      "registerProperty" in CSS &&
      [
        _t.scrollAreaOverflowXStart,
        _t.scrollAreaOverflowXEnd,
        _t.scrollAreaOverflowYStart,
        _t.scrollAreaOverflowYEnd,
      ].forEach((e) => {
        try {
          CSS.registerProperty({ name: e, syntax: "<length>", inherits: !1, initialValue: "0px" });
        } catch {}
      }),
    (Fc = !0));
}
const OT = h.forwardRef(function (t, n) {
    const { render: r, className: o, ...s } = t,
      {
        viewportRef: i,
        scrollbarYRef: a,
        scrollbarXRef: l,
        thumbYRef: c,
        thumbXRef: u,
        cornerRef: d,
        cornerSize: f,
        setCornerSize: m,
        setThumbSize: g,
        rootId: p,
        setHiddenState: v,
        hiddenState: b,
        handleScroll: y,
        setHovering: w,
        setOverflowEdges: R,
        overflowEdges: x,
        overflowEdgeThreshold: A,
      } = Go(),
      I = tr(),
      P = h.useRef(!0),
      D = Ge(),
      V = Ge(),
      B = J(() => {
        const E = i.current,
          S = a.current,
          O = l.current,
          j = c.current,
          _ = u.current,
          Q = d.current;
        if (!E) return;
        const $ = E.scrollHeight,
          Y = E.scrollWidth,
          ne = E.clientHeight,
          te = E.clientWidth,
          H = E.scrollTop,
          ue = E.scrollLeft;
        if ($ === 0 || Y === 0) return;
        const le = ne >= $,
          ce = te >= Y,
          pe = te / Y,
          N = ne / $,
          X = Math.max(0, Y - te),
          q = Math.max(0, $ - ne);
        let we = 0,
          z = 0;
        ce || (I === "rtl" ? (we = Nt(-ue, 0, X)) : (we = Nt(ue, 0, X)), (z = X - we));
        const W = le ? 0 : Nt(H, 0, q),
          G = le ? 0 : q - W,
          ie = ce ? 0 : te,
          he = le ? 0 : ne;
        let ae = 0,
          de = 0;
        !ce &&
          !le &&
          ((ae = (S == null ? void 0 : S.offsetWidth) || 0),
          (de = (O == null ? void 0 : O.offsetHeight) || 0));
        const U = f.width === 0 && f.height === 0,
          Z = U ? ae : 0,
          K = U ? de : 0,
          xe = bt(O, "padding", "x"),
          Re = bt(S, "padding", "y"),
          Ee = bt(_, "margin", "x"),
          Ce = bt(j, "margin", "y"),
          Oe = ie - xe - Ee,
          Ie = he - Re - Ce,
          ze = O ? Math.min(O.offsetWidth - Z, Oe) : Oe,
          ct = S ? Math.min(S.offsetHeight - K, Ie) : Ie,
          ge = Math.max(Dc, ze * pe),
          Pe = Math.max(Dc, ct * N);
        if (
          (g((be) => (be.height === Pe && be.width === ge ? be : { width: ge, height: Pe })),
          S && j)
        ) {
          const be = S.offsetHeight - Pe - Re - Ce,
            He = $ - ne,
            at = He === 0 ? 0 : H / He,
            $t = Math.min(be, Math.max(0, at * be));
          j.style.transform = `translate3d(0,${$t}px,0)`;
        }
        if (O && _) {
          const be = O.offsetWidth - ge - xe - Ee,
            He = Y - te,
            at = He === 0 ? 0 : ue / He,
            $t = I === "rtl" ? Nt(at * be, -be, 0) : Nt(at * be, 0, be);
          _.style.transform = `translate3d(${$t}px,0,0)`;
        }
        const Ve = Nt(we, 0, X),
          an = Nt(z, 0, X),
          it = Nt(W, 0, q),
          Me = Nt(G, 0, q),
          Be = [
            [_t.scrollAreaOverflowXStart, Ve],
            [_t.scrollAreaOverflowXEnd, an],
            [_t.scrollAreaOverflowYStart, it],
            [_t.scrollAreaOverflowYEnd, Me],
          ];
        for (const [be, He] of Be) E.style.setProperty(be, `${He}px`);
        (Q && (ce || le ? m({ width: 0, height: 0 }) : !ce && !le && m({ width: ae, height: de })),
          v((be) => {
            const He = le || ce;
            return be.y === le && be.x === ce && be.corner === He
              ? be
              : { y: le, x: ce, corner: He };
          }));
        const Ye = {
          xStart: !ce && Ve > A.xStart,
          xEnd: !ce && an > A.xEnd,
          yStart: !le && it > A.yStart,
          yEnd: !le && Me > A.yEnd,
        };
        R((be) =>
          be.xStart === Ye.xStart &&
          be.xEnd === Ye.xEnd &&
          be.yStart === Ye.yStart &&
          be.yEnd === Ye.yEnd
            ? be
            : Ye,
        );
      });
    (ee(() => {
      if (!i.current) return;
      AT();
      let E = !1;
      return MT(i.current, () => {
        if (!E) {
          E = !0;
          return;
        }
        B();
      });
    }, [B, i]),
      ee(() => {
        queueMicrotask(B);
      }, [B, b, I]),
      ee(() => {
        var E;
        (E = i.current) != null && E.matches(":hover") && w(!0);
      }, [i, w]),
      h.useEffect(() => {
        const E = i.current;
        if (typeof ResizeObserver > "u" || !E) return;
        let S = !1;
        const O = new ResizeObserver(() => {
          if (!S) {
            S = !0;
            return;
          }
          B();
        });
        return (
          O.observe(E),
          V.start(0, () => {
            const j = E.getAnimations({ subtree: !0 });
            j.length !== 0 &&
              Promise.all(j.map((_) => _.finished))
                .then(B)
                .catch(() => {});
          }),
          () => {
            (O.disconnect(), V.clear());
          }
        );
      }, [B, i, V]));
    function M() {
      P.current = !1;
    }
    const C = {
        role: "presentation",
        ...(p && { "data-id": `${p}-viewport` }),
        ...((!b.x || !b.y) && { tabIndex: 0 }),
        className: Ch.className,
        style: { overflow: "scroll" },
        onScroll() {
          i.current &&
            (B(),
            P.current || y({ x: i.current.scrollLeft, y: i.current.scrollTop }),
            D.start(100, () => {
              P.current = !0;
            }));
        },
        onWheel: M,
        onTouchMove: M,
        onPointerMove: M,
        onPointerEnter: M,
        onKeyDown: M,
      },
      L = h.useMemo(
        () => ({
          hasOverflowX: !b.x,
          hasOverflowY: !b.y,
          overflowXStart: x.xStart,
          overflowXEnd: x.xEnd,
          overflowYStart: x.yStart,
          overflowYEnd: x.yEnd,
          cornerHidden: b.corner,
        }),
        [b.x, b.y, b.corner, x],
      ),
      k = We("div", t, { ref: [n, i], state: L, props: [C, s], stateAttributesMapping: wa }),
      F = h.useMemo(() => ({ computeThumbPosition: B }), [B]);
    return T.jsx(kT.Provider, { value: F, children: k });
  }),
  Ph = h.createContext(void 0);
function IT() {
  const e = h.useContext(Ph);
  if (e === void 0) throw new Error(Ke(54));
  return e;
}
let Do = (function (e) {
  return (
    (e.scrollAreaThumbHeight = "--scroll-area-thumb-height"),
    (e.scrollAreaThumbWidth = "--scroll-area-thumb-width"),
    e
  );
})({});
const DT = h.forwardRef(function (t, n) {
    const { render: r, className: o, orientation: s = "vertical", keepMounted: i = !1, ...a } = t,
      {
        hovering: l,
        scrollingX: c,
        scrollingY: u,
        hiddenState: d,
        overflowEdges: f,
        scrollbarYRef: m,
        scrollbarXRef: g,
        viewportRef: p,
        thumbYRef: v,
        thumbXRef: b,
        handlePointerDown: y,
        handlePointerUp: w,
        rootId: R,
        thumbSize: x,
      } = Go(),
      A = h.useMemo(
        () => ({
          hovering: l,
          scrolling: { horizontal: c, vertical: u }[s],
          orientation: s,
          hasOverflowX: !d.x,
          hasOverflowY: !d.y,
          overflowXStart: f.xStart,
          overflowXEnd: f.xEnd,
          overflowYStart: f.yStart,
          overflowYEnd: f.yEnd,
          cornerHidden: d.corner,
        }),
        [l, c, u, s, d, f],
      ),
      I = tr();
    h.useEffect(() => {
      const C = p.current,
        L = s === "vertical" ? m.current : g.current;
      if (!L) return;
      function k(F) {
        if (!(!C || !L || F.ctrlKey)) {
          if ((F.preventDefault(), s === "vertical")) {
            if (C.scrollTop === 0 && F.deltaY < 0) return;
          } else if (C.scrollLeft === 0 && F.deltaX < 0) return;
          if (s === "vertical") {
            if (C.scrollTop === C.scrollHeight - C.clientHeight && F.deltaY > 0) return;
          } else if (C.scrollLeft === C.scrollWidth - C.clientWidth && F.deltaX > 0) return;
          s === "vertical" ? (C.scrollTop += F.deltaY) : (C.scrollLeft += F.deltaX);
        }
      }
      return (
        L.addEventListener("wheel", k, { passive: !1 }),
        () => {
          L.removeEventListener("wheel", k);
        }
      );
    }, [s, g, m, p]);
    const P = {
        ...(R && { "data-id": `${R}-scrollbar` }),
        onPointerDown(C) {
          if (C.button === 0 && C.currentTarget === C.target && p.current) {
            if (v.current && m.current && s === "vertical") {
              const L = bt(v.current, "margin", "y"),
                k = bt(m.current, "padding", "y"),
                F = v.current.offsetHeight,
                E = m.current.getBoundingClientRect(),
                S = C.clientY - E.top - F / 2 - k + L / 2,
                O = p.current.scrollHeight,
                j = p.current.clientHeight,
                _ = m.current.offsetHeight - F - k - L,
                $ = (S / _) * (O - j);
              p.current.scrollTop = $;
            }
            if (b.current && g.current && s === "horizontal") {
              const L = bt(b.current, "margin", "x"),
                k = bt(g.current, "padding", "x"),
                F = b.current.offsetWidth,
                E = g.current.getBoundingClientRect(),
                S = C.clientX - E.left - F / 2 - k + L / 2,
                O = p.current.scrollWidth,
                j = p.current.clientWidth,
                _ = g.current.offsetWidth - F - k - L,
                Q = S / _;
              let $;
              (I === "rtl"
                ? (($ = (1 - Q) * (O - j)), p.current.scrollLeft <= 0 && ($ = -$))
                : ($ = Q * (O - j)),
                (p.current.scrollLeft = $));
            }
            y(C);
          }
        },
        onPointerUp: w,
        style: {
          position: "absolute",
          touchAction: "none",
          WebkitUserSelect: "none",
          userSelect: "none",
          ...(s === "vertical" && {
            top: 0,
            bottom: `var(${Io.scrollAreaCornerHeight})`,
            insetInlineEnd: 0,
            [Do.scrollAreaThumbHeight]: `${x.height}px`,
          }),
          ...(s === "horizontal" && {
            insetInlineStart: 0,
            insetInlineEnd: `var(${Io.scrollAreaCornerWidth})`,
            bottom: 0,
            [Do.scrollAreaThumbWidth]: `${x.width}px`,
          }),
        },
      },
      D = We("div", t, {
        ref: [n, s === "vertical" ? m : g],
        state: A,
        props: [P, a],
        stateAttributesMapping: wa,
      }),
      V = h.useMemo(() => ({ orientation: s }), [s]),
      B = s === "vertical" ? d.y : d.x;
    return i || !B ? T.jsx(Ph.Provider, { value: V, children: D }) : null;
  }),
  NT = h.forwardRef(function (t, n) {
    const { render: r, className: o, ...s } = t,
      {
        thumbYRef: i,
        thumbXRef: a,
        handlePointerDown: l,
        handlePointerMove: c,
        handlePointerUp: u,
        setScrollingX: d,
        setScrollingY: f,
      } = Go(),
      { orientation: m } = IT(),
      g = h.useMemo(() => ({ orientation: m }), [m]);
    return We("div", t, {
      ref: [n, m === "vertical" ? i : a],
      state: g,
      props: [
        {
          onPointerDown: l,
          onPointerMove: c,
          onPointerUp(v) {
            (m === "vertical" && f(!1), m === "horizontal" && d(!1), u(v));
          },
          style: {
            ...(m === "vertical" && { height: `var(${Do.scrollAreaThumbHeight})` }),
            ...(m === "horizontal" && { width: `var(${Do.scrollAreaThumbWidth})` }),
          },
        },
        s,
      ],
    });
  }),
  FT = h.forwardRef(function (t, n) {
    const { render: r, className: o, ...s } = t,
      { cornerRef: i, cornerSize: a, hiddenState: l } = Go(),
      c = We("div", t, {
        ref: [n, i],
        props: [
          {
            style: {
              position: "absolute",
              bottom: 0,
              insetInlineEnd: 0,
              width: a.width,
              height: a.height,
            },
          },
          s,
        ],
      });
    return l.corner ? null : c;
  });
function Es({ className: e, children: t, ...n }) {
  return T.jsxs(CT, {
    "data-slot": "scroll-area",
    className: ye("relative", e),
    ...n,
    children: [
      T.jsx(OT, {
        "data-slot": "scroll-area-viewport",
        className:
          "focus-visible:ring-ring/50 size-full rounded-[inherit] transition-[color,box-shadow] outline-none focus-visible:ring-[3px] focus-visible:outline-1",
        children: t,
      }),
      T.jsx(Lc, {}),
      T.jsx(Lc, { orientation: "horizontal" }),
      T.jsx(FT, {}),
    ],
  });
}
function Lc({ className: e, orientation: t = "vertical", ...n }) {
  return T.jsx(DT, {
    "data-slot": "scroll-area-scrollbar",
    "data-orientation": t,
    orientation: t,
    className: ye(
      "data-horizontal:h-2.5 data-horizontal:flex-col data-horizontal:border-t data-horizontal:border-t-transparent data-vertical:h-full data-vertical:w-2.5 data-vertical:border-l data-vertical:border-l-transparent flex touch-none p-px transition-colors select-none",
      e,
    ),
    ...n,
    children: T.jsx(NT, {
      "data-slot": "scroll-area-thumb",
      className: "rounded-none bg-border relative flex-1",
    }),
  });
}
const kh = h.createContext(void 0);
function Sa() {
  const e = h.useContext(kh);
  if (e === void 0) throw new Error(Ke(64));
  return e;
}
let LT = (function (e) {
  return (
    (e.activationDirection = "data-activation-direction"), (e.orientation = "data-orientation"), e
  );
})({});
const Ta = { tabActivationDirection: (e) => ({ [LT.activationDirection]: e }) },
  jT = h.forwardRef(function (t, n) {
    const {
        className: r,
        defaultValue: o = 0,
        onValueChange: s,
        orientation: i = "horizontal",
        render: a,
        value: l,
        ...c
      } = t,
      u = tr(),
      d = Object.hasOwn(t, "defaultValue"),
      f = h.useRef([]),
      [m, g] = h.useState(() => new Map()),
      [p, v] = zd({ controlled: l, default: o, name: "Tabs", state: "value" }),
      b = l !== void 0,
      [y, w] = h.useState(() => new Map()),
      [R, x] = h.useState("none"),
      A = J((E, S) => {
        (s == null || s(E, S), !S.isCanceled && (v(E), x(S.activationDirection)));
      }),
      I = J((E, S) => {
        g((O) => {
          if (O.get(E) === S) return O;
          const j = new Map(O);
          return (j.set(E, S), j);
        });
      }),
      P = J((E, S) => {
        g((O) => {
          if (!O.has(E) || O.get(E) !== S) return O;
          const j = new Map(O);
          return (j.delete(E), j);
        });
      }),
      D = h.useCallback((E) => m.get(E), [m]),
      V = h.useCallback(
        (E) => {
          for (const S of y.values())
            if (E === (S == null ? void 0 : S.value)) return S == null ? void 0 : S.id;
        },
        [y],
      ),
      B = h.useCallback(
        (E) => {
          if (E === void 0) return null;
          for (const [S, O] of y.entries()) if (O != null && E === (O.value ?? O.index)) return S;
          return null;
        },
        [y],
      ),
      M = h.useMemo(
        () => ({
          direction: u,
          getTabElementBySelectedValue: B,
          getTabIdByPanelValue: V,
          getTabPanelIdByValue: D,
          onValueChange: A,
          orientation: i,
          registerMountedTabPanel: I,
          setTabMap: w,
          unregisterMountedTabPanel: P,
          tabActivationDirection: R,
          value: p,
        }),
        [u, B, V, D, A, i, I, w, P, R, p],
      ),
      C = h.useMemo(() => {
        for (const E of y.values()) if (E != null && E.value === p) return E;
      }, [y, p]),
      L = h.useMemo(() => {
        for (const E of y.values()) if (E != null && !E.disabled) return E.value;
      }, [y]);
    ee(() => {
      if (b || y.size === 0) return;
      const E = C == null ? void 0 : C.disabled,
        S = C == null && p !== null;
      if ((d && E && p === o) || (!E && !S)) return;
      const j = L ?? null;
      p !== j && (v(j), x("none"));
    }, [o, L, d, b, C, x, v, y, p]);
    const F = We("div", t, {
      state: { orientation: i, tabActivationDirection: R },
      ref: n,
      props: c,
      stateAttributesMapping: Ta,
    });
    return T.jsx(kh.Provider, { value: M, children: T.jsx(ya, { elementsRef: f, children: F }) });
  }),
  Mh = "data-composite-item-active",
  Ah = h.createContext(void 0);
function VT() {
  const e = h.useContext(Ah);
  if (e === void 0) throw new Error(Ke(65));
  return e;
}
const BT = h.forwardRef(function (t, n) {
  const {
      className: r,
      disabled: o = !1,
      render: s,
      value: i,
      id: a,
      nativeButton: l = !0,
      ...c
    } = t,
    { value: u, getTabPanelIdByValue: d, orientation: f } = Sa(),
    {
      activateOnFocus: m,
      highlightedTabIndex: g,
      onTabActivation: p,
      setHighlightedTabIndex: v,
      tabsListElement: b,
    } = VT(),
    y = rn(a),
    w = h.useMemo(() => ({ disabled: o, id: y, value: i }), [o, y, i]),
    { compositeProps: R, compositeRef: x, index: A } = ih({ metadata: w }),
    I = i === u,
    P = h.useRef(!1);
  ee(() => {
    if (P.current) {
      P.current = !1;
      return;
    }
    if (!(I && A > -1 && g !== A)) return;
    const O = b;
    if (O != null) {
      const j = Tt(xt(O));
      if (j && Se(O, j)) return;
    }
    o || v(A);
  }, [I, A, g, v, o, b]);
  const { getButtonProps: D, buttonRef: V } = Uo({
      disabled: o,
      native: l,
      focusableWhenDisabled: !0,
    }),
    B = d(i),
    M = h.useRef(!1),
    C = h.useRef(!1);
  function L(O) {
    I || o || p(i, Te(Un, O.nativeEvent, void 0, { activationDirection: "none" }));
  }
  function k(O) {
    I ||
      (A > -1 && !o && v(A),
      !o &&
        m &&
        (!M.current || (M.current && C.current)) &&
        p(i, Te(Un, O.nativeEvent, void 0, { activationDirection: "none" })));
  }
  function F(O) {
    if (I || o) return;
    M.current = !0;
    function j() {
      ((M.current = !1), (C.current = !1));
    }
    (!O.button || O.button === 0) &&
      ((C.current = !0), xt(O.currentTarget).addEventListener("pointerup", j, { once: !0 }));
  }
  const E = h.useMemo(() => ({ disabled: o, active: I, orientation: f }), [o, I, f]);
  return We("button", t, {
    state: E,
    ref: [n, V, x],
    props: [
      R,
      {
        role: "tab",
        "aria-controls": B,
        "aria-selected": I,
        id: y,
        onClick: L,
        onFocus: k,
        onPointerDown: F,
        [Mh]: I ? "" : void 0,
        onKeyDownCapture() {
          P.current = !0;
        },
      },
      c,
      D,
    ],
  });
});
let $T = (function (e) {
  return (
    (e.index = "data-index"),
    (e.activationDirection = "data-activation-direction"),
    (e.orientation = "data-orientation"),
    (e.hidden = "data-hidden"),
    e
  );
})({});
const WT = h.forwardRef(function (t, n) {
  const { className: r, value: o, render: s, keepMounted: i = !1, ...a } = t,
    {
      value: l,
      getTabIdByPanelValue: c,
      orientation: u,
      tabActivationDirection: d,
      registerMountedTabPanel: f,
      unregisterMountedTabPanel: m,
    } = Sa(),
    g = rn(),
    p = h.useMemo(() => ({ id: g, value: o }), [g, o]),
    { ref: v, index: b } = na({ metadata: p }),
    y = o !== l,
    w = c(o),
    R = h.useMemo(() => ({ hidden: y, orientation: u, tabActivationDirection: d }), [y, u, d]),
    x = We("div", t, {
      state: R,
      ref: [n, v],
      props: [
        {
          "aria-labelledby": w,
          hidden: y,
          id: g ?? void 0,
          role: "tabpanel",
          tabIndex: y ? -1 : 0,
          [$T.index]: b,
        },
        a,
      ],
      stateAttributesMapping: Ta,
    });
  return (
    ee(() => {
      if (!(y && !i) && g != null)
        return (
          f(o, g),
          () => {
            m(o, g);
          }
        );
    }, [y, i, o, g, f, m]),
    !y || i ? x : null
  );
});
function zT(e) {
  return e == null || e.hasAttribute("disabled") || e.getAttribute("aria-disabled") === "true";
}
const HT = [];
function UT(e) {
  const {
      itemSizes: t,
      cols: n = 1,
      loopFocus: r = !0,
      dense: o = !1,
      orientation: s = "both",
      direction: i,
      highlightedIndex: a,
      onHighlightedIndexChange: l,
      rootRef: c,
      enableHomeAndEndKeys: u = !1,
      stopEventPropagation: d = !1,
      disabledIndices: f,
      modifierKeys: m = HT,
    } = e,
    [g, p] = h.useState(0),
    v = n > 1,
    b = h.useRef(null),
    y = Jt(b, c),
    w = h.useRef([]),
    R = h.useRef(!1),
    x = a ?? g,
    A = J((D, V = !1) => {
      if (((l ?? p)(D), V)) {
        const B = w.current[D];
        wc(b.current, B, i, s);
      }
    }),
    I = J((D) => {
      if (D.size === 0 || R.current) return;
      R.current = !0;
      const V = Array.from(D.keys()),
        B = V.find((C) => (C == null ? void 0 : C.hasAttribute(Mh))) ?? null,
        M = B ? V.indexOf(B) : -1;
      (M !== -1 && A(M), wc(b.current, B, i, s));
    }),
    P = h.useMemo(
      () => ({
        "aria-orientation": s === "both" ? void 0 : s,
        ref: y,
        onFocus(D) {
          !b.current || !vc(D.target) || D.target.setSelectionRange(0, D.target.value.length ?? 0);
        },
        onKeyDown(D) {
          const V = u ? $0 : th;
          if (!V.has(D.key) || _T(D, m) || !b.current) return;
          const M = i === "rtl",
            C = M ? Pr : Wn,
            L = { horizontal: C, vertical: gn, both: C }[s],
            k = M ? Wn : Pr,
            F = { horizontal: k, vertical: $n, both: k }[s];
          if (vc(D.target) && !zT(D.target)) {
            const $ = D.target.selectionStart,
              Y = D.target.selectionEnd,
              ne = D.target.value ?? "";
            if (
              $ == null ||
              D.shiftKey ||
              $ !== Y ||
              (D.key !== F && $ < ne.length) ||
              (D.key !== L && $ > 0)
            )
              return;
          }
          let E = x;
          const S = lo(w, f),
            O = ai(w, f);
          if (v) {
            const $ =
                t || Array.from({ length: w.current.length }, () => ({ width: 1, height: 1 })),
              Y = lf($, n, o),
              ne = Y.findIndex((H) => H != null && !Kt(w, H, f)),
              te = Y.reduce((H, ue, le) => (ue != null && !Kt(w, ue, f) ? le : H), -1);
            E =
              Y[
                af(
                  { current: Y.map((H) => (H ? w.current[H] : null)) },
                  {
                    event: D,
                    orientation: s,
                    loopFocus: r,
                    cols: n,
                    disabledIndices: uf(
                      [...(f || w.current.map((H, ue) => (Kt(w, ue) ? ue : void 0))), void 0],
                      Y,
                    ),
                    minIndex: ne,
                    maxIndex: te,
                    prevIndex: cf(
                      x > O ? S : x,
                      $,
                      Y,
                      n,
                      D.key === gn ? "bl" : D.key === Wn ? "tr" : "tl",
                    ),
                    rtl: M,
                  },
                )
              ];
          }
          const j = { horizontal: [C], vertical: [gn], both: [C, gn] }[s],
            _ = { horizontal: [k], vertical: [$n], both: [k, $n] }[s],
            Q = v ? V : { horizontal: u ? V0 : Jf, vertical: u ? B0 : eh, both: V }[s];
          (u && (D.key === Fr ? (E = S) : D.key === Lr && (E = O)),
            E === x &&
              (j.includes(D.key) || _.includes(D.key)) &&
              (r && E === O && j.includes(D.key)
                ? (E = S)
                : r && E === S && _.includes(D.key)
                  ? (E = O)
                  : (E = Ze(w, {
                      startingIndex: E,
                      decrement: _.includes(D.key),
                      disabledIndices: f,
                    }))),
            E !== x &&
              !Ln(w, E) &&
              (d && D.stopPropagation(),
              Q.has(D.key) && D.preventDefault(),
              A(E, !0),
              queueMicrotask(() => {
                var $;
                ($ = w.current[E]) == null || $.focus();
              })));
        },
      }),
      [n, o, i, f, w, u, x, v, t, r, y, m, A, s, d],
    );
  return h.useMemo(
    () => ({
      props: P,
      highlightedIndex: x,
      onHighlightedIndexChange: A,
      elementsRef: w,
      disabledIndices: f,
      onMapChange: I,
      relayKeyboardEvent: P.onKeyDown,
    }),
    [P, x, A, w, f, I],
  );
}
function _T(e, t) {
  for (const n of Y0.values()) if (!t.includes(n) && e.getModifierState(n)) return !0;
  return !1;
}
function YT(e) {
  const {
      render: t,
      className: n,
      refs: r = xn,
      props: o = xn,
      state: s = je,
      stateAttributesMapping: i,
      highlightedIndex: a,
      onHighlightedIndexChange: l,
      orientation: c,
      dense: u,
      itemSizes: d,
      loopFocus: f,
      cols: m,
      enableHomeAndEndKeys: g,
      onMapChange: p,
      stopEventPropagation: v = !0,
      rootRef: b,
      disabledIndices: y,
      modifierKeys: w,
      highlightItemOnHover: R = !1,
      tag: x = "div",
      ...A
    } = e,
    I = tr(),
    {
      props: P,
      highlightedIndex: D,
      onHighlightedIndexChange: V,
      elementsRef: B,
      onMapChange: M,
      relayKeyboardEvent: C,
    } = UT({
      itemSizes: d,
      cols: m,
      loopFocus: f,
      dense: u,
      orientation: c,
      highlightedIndex: a,
      onHighlightedIndexChange: l,
      rootRef: b,
      stopEventPropagation: v,
      enableHomeAndEndKeys: g,
      direction: I,
      disabledIndices: y,
      modifierKeys: w,
    }),
    L = We(x, e, { state: s, ref: r, props: [P, ...o, A], stateAttributesMapping: i }),
    k = h.useMemo(
      () => ({
        highlightedIndex: D,
        onHighlightedIndexChange: V,
        highlightItemOnHover: R,
        relayKeyboardEvent: C,
      }),
      [D, V, R, C],
    );
  return T.jsx(Ud.Provider, {
    value: k,
    children: T.jsx(ya, {
      elementsRef: B,
      onMapChange: (F) => {
        (p == null || p(F), M(F));
      },
      children: L,
    }),
  });
}
const qT = h.forwardRef(function (t, n) {
  const { activateOnFocus: r = !1, className: o, loopFocus: s = !0, render: i, ...a } = t,
    {
      getTabElementBySelectedValue: l,
      onValueChange: c,
      orientation: u,
      value: d,
      setTabMap: f,
      tabActivationDirection: m,
    } = Sa(),
    [g, p] = h.useState(0),
    [v, b] = h.useState(null),
    y = XT(d, u, v, l),
    w = J((I, P) => {
      if (I !== d) {
        const D = y(I);
        ((P.activationDirection = D), c(I, P));
      }
    }),
    R = h.useMemo(() => ({ orientation: u, tabActivationDirection: m }), [u, m]),
    x = { "aria-orientation": u === "vertical" ? "vertical" : void 0, role: "tablist" },
    A = h.useMemo(
      () => ({
        activateOnFocus: r,
        highlightedTabIndex: g,
        onTabActivation: w,
        setHighlightedTabIndex: p,
        tabsListElement: v,
        value: d,
      }),
      [r, g, w, p, v, d],
    );
  return T.jsx(Ah.Provider, {
    value: A,
    children: T.jsx(YT, {
      render: i,
      className: o,
      state: R,
      refs: [n, b],
      props: [x, a],
      stateAttributesMapping: Ta,
      highlightedIndex: g,
      enableHomeAndEndKeys: !0,
      loopFocus: s,
      orientation: u,
      onHighlightedIndexChange: p,
      onMapChange: f,
      disabledIndices: xn,
    }),
  });
});
function jc(e, t) {
  const { left: n, top: r } = e.getBoundingClientRect(),
    { left: o, top: s } = t.getBoundingClientRect(),
    i = n - o,
    a = r - s;
  return { left: i, top: a };
}
function XT(e, t, n, r) {
  const [o, s] = h.useState(null);
  return (
    ee(() => {
      if (e == null || n == null) {
        s(null);
        return;
      }
      const i = r(e);
      if (i == null) {
        s(null);
        return;
      }
      const { left: a, top: l } = jc(i, n);
      s(t === "horizontal" ? a : l);
    }, [t, r, n, e]),
    h.useCallback(
      (i) => {
        if (i === e) return "none";
        if (i == null) return (s(null), "none");
        if (i != null && n != null) {
          const a = r(i);
          if (a != null) {
            const { left: l, top: c } = jc(a, n);
            if (o == null) return (s(t === "horizontal" ? l : c), "none");
            if (t === "horizontal") {
              if (l < o) return (s(l), "left");
              if (l > o) return (s(l), "right");
            } else {
              if (c < o) return (s(c), "up");
              if (c > o) return (s(c), "down");
            }
          }
        }
        return "none";
      },
      [r, t, o, n, e],
    )
  );
}
const Vc = (e) => (typeof e == "boolean" ? `${e}` : e === 0 ? "0" : e),
  Bc = ch,
  GT = (e, t) => (n) => {
    var r;
    if ((t == null ? void 0 : t.variants) == null)
      return Bc(e, n == null ? void 0 : n.class, n == null ? void 0 : n.className);
    const { variants: o, defaultVariants: s } = t,
      i = Object.keys(o).map((c) => {
        const u = n == null ? void 0 : n[c],
          d = s == null ? void 0 : s[c];
        if (u === null) return null;
        const f = Vc(u) || Vc(d);
        return o[c][f];
      }),
      a =
        n &&
        Object.entries(n).reduce((c, u) => {
          let [d, f] = u;
          return (f === void 0 || (c[d] = f), c);
        }, {}),
      l =
        t == null || (r = t.compoundVariants) === null || r === void 0
          ? void 0
          : r.reduce((c, u) => {
              let { class: d, className: f, ...m } = u;
              return Object.entries(m).every((g) => {
                let [p, v] = g;
                return Array.isArray(v) ? v.includes({ ...s, ...a }[p]) : { ...s, ...a }[p] === v;
              })
                ? [...c, d, f]
                : c;
            }, []);
    return Bc(e, i, l, n == null ? void 0 : n.class, n == null ? void 0 : n.className);
  };
function KT({ className: e, orientation: t = "horizontal", ...n }) {
  return T.jsx(jT, {
    "data-slot": "tabs",
    "data-orientation": t,
    className: ye("gap-2 group/tabs flex data-[orientation=horizontal]:flex-col", e),
    ...n,
  });
}
const QT = GT(
  "rounded-none p-[3px] group-data-horizontal/tabs:h-8 data-[variant=line]:rounded-none group/tabs-list text-muted-foreground inline-flex w-fit items-center justify-center group-data-[orientation=vertical]/tabs:h-fit group-data-[orientation=vertical]/tabs:flex-col",
  {
    variants: { variant: { default: "bg-muted", line: "gap-1 bg-transparent" } },
    defaultVariants: { variant: "default" },
  },
);
function ZT({ className: e, variant: t = "default", ...n }) {
  return T.jsx(qT, {
    "data-slot": "tabs-list",
    "data-variant": t,
    className: ye(QT({ variant: t }), e),
    ...n,
  });
}
function JT({ className: e, ...t }) {
  return T.jsx(BT, {
    "data-slot": "tabs-trigger",
    className: ye(
      "gap-1.5 rounded-none border border-transparent px-1.5 py-0.5 text-xs font-medium group-data-vertical/tabs:py-[calc(--spacing(1.25))] [&_svg:not([class*='size-'])]:size-4 focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring text-foreground/60 hover:text-foreground dark:text-muted-foreground dark:hover:text-foreground relative inline-flex h-[calc(100%-1px)] flex-1 items-center justify-center whitespace-nowrap transition-all group-data-[orientation=vertical]/tabs:w-full group-data-[orientation=vertical]/tabs:justify-start focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0",
      "group-data-[variant=line]/tabs-list:bg-transparent group-data-[variant=line]/tabs-list:data-active:bg-transparent dark:group-data-[variant=line]/tabs-list:data-active:border-transparent dark:group-data-[variant=line]/tabs-list:data-active:bg-transparent",
      "data-active:bg-background dark:data-active:text-foreground dark:data-active:border-input dark:data-active:bg-input/30 data-active:text-foreground",
      "after:bg-foreground after:absolute after:opacity-0 after:transition-opacity group-data-[orientation=horizontal]/tabs:after:inset-x-0 group-data-[orientation=horizontal]/tabs:after:bottom-[-5px] group-data-[orientation=horizontal]/tabs:after:h-0.5 group-data-[orientation=vertical]/tabs:after:inset-y-0 group-data-[orientation=vertical]/tabs:after:-right-1 group-data-[orientation=vertical]/tabs:after:w-0.5 group-data-[variant=line]/tabs-list:data-active:after:opacity-100",
      e,
    ),
    ...t,
  });
}
function eR({ className: e, ...t }) {
  return T.jsx(WT, {
    "data-slot": "tabs-content",
    className: ye("text-xs/relaxed flex-1 outline-none", e),
    ...t,
  });
}
const Oh = h.createContext(void 0);
function jr(e) {
  const t = h.useContext(Oh);
  if (t === void 0 && !e) throw new Error(Ke(72));
  return t;
}
const tR = {
  ...Yf,
  disabled: me((e) => e.disabled),
  instantType: me((e) => e.instantType),
  isInstantPhase: me((e) => e.isInstantPhase),
  trackCursorAxis: me((e) => e.trackCursorAxis),
  disableHoverablePopup: me((e) => e.disableHoverablePopup),
  lastOpenChangeReason: me((e) => e.openChangeReason),
  closeDelay: me((e) => e.closeDelay),
  hasViewport: me((e) => e.hasViewport),
};
class Ra extends ma {
  constructor(n) {
    super(
      { ...nR(), ...n },
      {
        popupRef: h.createRef(),
        onOpenChange: void 0,
        onOpenChangeComplete: void 0,
        triggerElements: new qo(),
      },
      tR,
    );
    Ae(this, "setOpen", (n, r) => {
      var c, u;
      const o = r.reason,
        s = o === et,
        i = n && o === Fn,
        a = !n && (o === Yt || o === Bo);
      if (
        ((r.preventUnmountOnClose = () => {
          this.set("preventUnmountingOnClose", !0);
        }),
        (u = (c = this.context).onOpenChange) == null || u.call(c, n, r),
        r.isCanceled)
      )
        return;
      const l = () => {
        var m;
        const d = { open: n, openChangeReason: o };
        i
          ? (d.instantType = "focus")
          : a
            ? (d.instantType = "dismiss")
            : o === et && (d.instantType = void 0);
        const f = ((m = r.trigger) == null ? void 0 : m.id) ?? null;
        ((f || n) && ((d.activeTriggerId = f), (d.activeTriggerElement = r.trigger ?? null)),
          this.update(d));
      };
      s ? Rt.flushSync(l) : l();
    });
  }
  static useStore(n, r) {
    const o = ft(() => new Ra(r)).current,
      s = n ?? o,
      i = qf({ popupStore: s, onOpenChange: s.setOpen });
    return ((s.state.floatingRootContext = i), s);
  }
}
function nR() {
  return {
    ..._f(),
    disabled: !1,
    instantType: void 0,
    isInstantPhase: !1,
    trackCursorAxis: "none",
    disableHoverablePopup: !1,
    openChangeReason: null,
    closeDelay: 0,
    hasViewport: !1,
  };
}
function rR(e) {
  const {
      disabled: t = !1,
      defaultOpen: n = !1,
      open: r,
      disableHoverablePopup: o = !1,
      trackCursorAxis: s = "none",
      actionsRef: i,
      onOpenChange: a,
      onOpenChangeComplete: l,
      handle: c,
      triggerId: u,
      defaultTriggerId: d = null,
      children: f,
    } = e,
    m = Ra.useStore(c == null ? void 0 : c.store, {
      open: r ?? n,
      activeTriggerId: u !== void 0 ? u : d,
    });
  (m.useControlledProp("open", r, n),
    m.useControlledProp("activeTriggerId", u, d),
    m.useContextCallback("onOpenChange", a),
    m.useContextCallback("onOpenChangeComplete", l));
  const g = m.useState("open"),
    p = !t && g,
    v = m.useState("activeTriggerId"),
    b = m.useState("payload");
  (m.useSyncedValues({ trackCursorAxis: s, disableHoverablePopup: o }),
    ee(() => {
      g && t && m.setOpen(!1, Te(Fx));
    }, [g, t, m]),
    m.useSyncedValue("disabled", t),
    Hf(m));
  const { forceUnmount: y, transitionStatus: w } = Uf(p, m),
    R = m.useState("isInstantPhase"),
    x = m.useState("instantType"),
    A = m.useState("lastOpenChangeReason"),
    I = h.useRef(null);
  (ee(() => {
    (w === "ending" && A === Un) || (w !== "ending" && R)
      ? (x !== "delay" && (I.current = x), m.set("instantType", "delay"))
      : I.current !== null && (m.set("instantType", I.current), (I.current = null));
  }, [w, R, A, x, m]),
    ee(() => {
      p && v == null && m.set("payload", void 0);
    }, [m, v, p]));
  const P = h.useCallback(() => {
    m.setOpen(!1, oR(m, Wd));
  }, [m]);
  h.useImperativeHandle(i, () => ({ unmount: y, close: P }), [y, P]);
  const D = m.useState("floatingRootContext"),
    V = Xf(D, { enabled: !t }),
    B = Bf(D, { enabled: !t, referencePress: !0 }),
    M = lw(D, { enabled: !t && s !== "none", axis: s === "none" ? void 0 : s }),
    { getReferenceProps: C, getFloatingProps: L, getTriggerProps: k } = ga([V, B, M]),
    F = h.useMemo(() => C(), [C]),
    E = h.useMemo(() => k(), [k]),
    S = h.useMemo(() => L(), [L]);
  return (
    m.useSyncedValues({ activeTriggerProps: F, inactiveTriggerProps: E, popupProps: S }),
    T.jsx(Oh.Provider, { value: m, children: typeof f == "function" ? f({ payload: b }) : f })
  );
}
function oR(e, t) {
  const n = Te(t);
  return (
    (n.preventUnmountOnClose = () => {
      e.set("preventUnmountingOnClose", !0);
    }),
    n
  );
}
const Ih = h.createContext(void 0);
function sR() {
  return h.useContext(Ih);
}
const iR = 600,
  aR = h.forwardRef(function (t, n) {
    const {
        className: r,
        render: o,
        handle: s,
        payload: i,
        disabled: a,
        delay: l,
        closeDelay: c,
        id: u,
        ...d
      } = t,
      f = jr(!0),
      m = (s == null ? void 0 : s.store) ?? f;
    if (!m) throw new Error(Ke(82));
    const g = rn(u),
      p = m.useState("isTriggerActive", g),
      v = m.useState("isOpenedByTrigger", g),
      b = m.useState("floatingRootContext"),
      y = h.useRef(null),
      w = l ?? iR,
      R = c ?? 0,
      { registerTrigger: x, isMountedByThisTrigger: A } = zf(g, y, m, {
        payload: i,
        closeDelay: R,
      }),
      I = sR(),
      { delayRef: P, isInstantPhase: D, hasProvider: V } = Xv(b, { open: v });
    m.useSyncedValue("isInstantPhase", D);
    const B = m.useState("disabled"),
      M = a ?? B,
      C = m.useState("trackCursorAxis"),
      L = m.useState("disableHoverablePopup"),
      k = Qf(b, {
        enabled: !M,
        mouseOnly: !0,
        move: !1,
        handleClose: !L && C !== "both" ? Zf() : null,
        restMs() {
          const O = I == null ? void 0 : I.delay,
            j = typeof P.current == "object" ? P.current.open : void 0;
          let _ = w;
          return (V && (j !== 0 ? (_ = l ?? O ?? w) : (_ = 0)), _);
        },
        delay() {
          const O = typeof P.current == "object" ? P.current.close : void 0;
          let j = R;
          return (c == null && V && (j = O), { close: j });
        },
        triggerElementRef: y,
        isActiveTrigger: p,
      }),
      F = h.useMemo(() => ({ open: v }), [v]),
      E = m.useState("triggerProps", A);
    return We("button", t, {
      state: F,
      ref: [n, x, y],
      props: [k, E, { id: g }, d],
      stateAttributesMapping: Ix,
    });
  }),
  Dh = h.createContext(void 0);
function lR() {
  const e = h.useContext(Dh);
  if (e === void 0) throw new Error(Ke(70));
  return e;
}
const cR = h.forwardRef(function (t, n) {
    const { children: r, container: o, className: s, render: i, ...a } = t,
      { portalNode: l, portalSubtree: c } = Af({
        container: o,
        ref: n,
        componentProps: t,
        elementProps: a,
      });
    return !c && !l ? null : T.jsxs(h.Fragment, { children: [c, l && Rt.createPortal(r, l)] });
  }),
  uR = h.forwardRef(function (t, n) {
    const { keepMounted: r = !1, ...o } = t;
    return jr().useState("mounted") || r
      ? T.jsx(Dh.Provider, { value: r, children: T.jsx(cR, { ref: n, ...o }) })
      : null;
  }),
  Nh = h.createContext(void 0);
function Fh() {
  const e = h.useContext(Nh);
  if (e === void 0) throw new Error(Ke(71));
  return e;
}
const dR = h.forwardRef(function (t, n) {
    const {
        render: r,
        className: o,
        anchor: s,
        positionMethod: i = "absolute",
        side: a = "top",
        align: l = "center",
        sideOffset: c = 0,
        alignOffset: u = 0,
        collisionBoundary: d = "clipping-ancestors",
        collisionPadding: f = 5,
        arrowPadding: m = 5,
        sticky: g = !1,
        disableAnchorTracking: p = !1,
        collisionAvoidance: v = Vd,
        ...b
      } = t,
      y = jr(),
      w = lR(),
      R = y.useState("open"),
      x = y.useState("mounted"),
      A = y.useState("trackCursorAxis"),
      I = y.useState("disableHoverablePopup"),
      P = y.useState("floatingRootContext"),
      D = y.useState("instantType"),
      V = y.useState("transitionStatus"),
      B = y.useState("hasViewport"),
      M = oh({
        anchor: s,
        positionMethod: i,
        floatingRootContext: P,
        mounted: x,
        side: a,
        sideOffset: c,
        align: l,
        alignOffset: u,
        collisionBoundary: d,
        collisionPadding: f,
        sticky: g,
        arrowPadding: m,
        disableAnchorTracking: p,
        keepMounted: w,
        collisionAvoidance: v,
        adaptiveOrigin: B ? rS : void 0,
      }),
      C = h.useMemo(() => {
        const E = {};
        return (
          (!R || A === "both" || I) && (E.pointerEvents = "none"),
          { role: "presentation", hidden: !x, style: { ...M.positionerStyles, ...E } }
        );
      }, [R, A, I, x, M.positionerStyles]),
      L = h.useMemo(
        () => ({
          open: R,
          side: M.side,
          align: M.align,
          anchorHidden: M.anchorHidden,
          instant: A !== "none" ? "tracking-cursor" : D,
        }),
        [R, M.side, M.align, M.anchorHidden, A, D],
      ),
      k = h.useMemo(
        () => ({
          ...L,
          arrowRef: M.arrowRef,
          arrowStyles: M.arrowStyles,
          arrowUncentered: M.arrowUncentered,
        }),
        [L, M.arrowRef, M.arrowStyles, M.arrowUncentered],
      ),
      F = We("div", t, {
        state: L,
        props: [C, ba(V), b],
        ref: [n, y.useStateSetter("positionerElement")],
        stateAttributesMapping: Ir,
      });
    return T.jsx(Nh.Provider, { value: k, children: F });
  }),
  fR = { ...Ir, ...Bd },
  hR = h.forwardRef(function (t, n) {
    const { className: r, render: o, ...s } = t,
      i = jr(),
      { side: a, align: l } = Fh(),
      c = i.useState("open"),
      u = i.useState("instantType"),
      d = i.useState("transitionStatus"),
      f = i.useState("popupProps"),
      m = i.useState("floatingRootContext");
    ra({
      open: c,
      ref: i.context.popupRef,
      onComplete() {
        var y, w;
        c && ((w = (y = i.context).onOpenChangeComplete) == null || w.call(y, !0));
      },
    });
    const g = i.useState("disabled"),
      p = i.useState("closeDelay");
    Kf(m, { enabled: !g, closeDelay: p });
    const v = h.useMemo(
      () => ({ open: c, side: a, align: l, instant: u, transitionStatus: d }),
      [c, a, l, u, d],
    );
    return We("div", t, {
      state: v,
      ref: [n, i.context.popupRef, i.useStateSetter("popupElement")],
      props: [f, ba(d), s],
      stateAttributesMapping: fR,
    });
  }),
  mR = h.forwardRef(function (t, n) {
    const { className: r, render: o, ...s } = t,
      a = jr().useState("instantType"),
      { open: l, arrowRef: c, side: u, align: d, arrowUncentered: f, arrowStyles: m } = Fh(),
      g = h.useMemo(
        () => ({ open: l, side: u, align: d, uncentered: f, instant: a }),
        [l, u, d, f, a],
      );
    return We("div", t, {
      state: g,
      ref: [n, c],
      props: [{ style: m, "aria-hidden": !0 }, s],
      stateAttributesMapping: Ir,
    });
  }),
  pR = function (t) {
    const { delay: n, closeDelay: r, timeout: o = 400 } = t,
      s = h.useMemo(() => ({ delay: n, closeDelay: r }), [n, r]),
      i = h.useMemo(() => ({ open: n, close: r }), [n, r]);
    return T.jsx(Ih.Provider, {
      value: s,
      children: T.jsx(qv, { delay: i, timeoutMs: o, children: t.children }),
    });
  };
function Lh({ delay: e = 0, ...t }) {
  return T.jsx(pR, { "data-slot": "tooltip-provider", delay: e, ...t });
}
function fi({ delay: e, ...t }) {
  return T.jsx(Lh, { delay: e, children: T.jsx(rR, { "data-slot": "tooltip", ...t }) });
}
function hi({ ...e }) {
  return T.jsx(aR, { "data-slot": "tooltip-trigger", ...e });
}
function mi({
  className: e,
  side: t = "top",
  sideOffset: n = 4,
  align: r = "center",
  alignOffset: o = 0,
  children: s,
  ...i
}) {
  return T.jsx(uR, {
    children: T.jsx(dR, {
      align: r,
      alignOffset: o,
      side: t,
      sideOffset: n,
      className: "isolate z-50",
      children: T.jsxs(hR, {
        "data-slot": "tooltip-content",
        className: ye(
          "data-open:animate-in data-open:fade-in-0 data-open:zoom-in-95 data-[state=delayed-open]:animate-in data-[state=delayed-open]:fade-in-0 data-[state=delayed-open]:zoom-in-95 data-closed:animate-out data-closed:fade-out-0 data-closed:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 rounded-none px-3 py-1.5 text-xs bg-foreground text-background z-50 w-fit max-w-xs origin-(--transform-origin)",
          e,
        ),
        ...i,
        children: [
          s,
          T.jsx(mR, {
            className:
              "size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-none bg-foreground fill-foreground z-50 data-[side=bottom]:top-1 data-[side=left]:top-1/2! data-[side=left]:-right-1 data-[side=left]:-translate-y-1/2 data-[side=right]:top-1/2! data-[side=right]:-left-1 data-[side=right]:-translate-y-1/2 data-[side=top]:-bottom-2.5",
          }),
        ],
      }),
    }),
  });
}
function gR(e) {
  return e
    ? {
        ecosystem: e.eco ?? fe.ecosystem,
        projectName: e.name ?? fe.projectName,
        webFrontend: e["fe-w"] ?? fe.webFrontend,
        nativeFrontend: e["fe-n"] ?? fe.nativeFrontend,
        astroIntegration: e.ai ?? fe.astroIntegration,
        cssFramework: e.css ?? fe.cssFramework,
        uiLibrary: e.ui ?? fe.uiLibrary,
        runtime: e.rt ?? fe.runtime,
        backend: e.be ?? fe.backend,
        api: e.api ?? fe.api,
        database: e.db ?? fe.database,
        orm: e.orm ?? fe.orm,
        dbSetup: e.dbs ?? fe.dbSetup,
        auth: e.au ?? fe.auth,
        payments: e.pay ?? fe.payments,
        email: e.em ?? fe.email,
        fileUpload: e.fu ?? fe.fileUpload,
        logging: e.log ?? fe.logging,
        observability: e.obs ?? fe.observability,
        backendLibraries: e.bl ?? fe.backendLibraries,
        stateManagement: e.sm ?? fe.stateManagement,
        validation: e.val ?? fe.validation,
        testing: e.tst ?? fe.testing,
        realtime: e.rt2 ?? fe.realtime,
        jobQueue: e.jq ?? fe.jobQueue,
        caching: e.cache ?? fe.caching,
        animation: e.anim ?? fe.animation,
        cms: e.cms ?? fe.cms,
        codeQuality: e.cq ?? fe.codeQuality,
        documentation: e.doc ?? fe.documentation,
        appPlatforms: e.ap ?? fe.appPlatforms,
        packageManager: e.pm ?? fe.packageManager,
        examples: e.ex ?? fe.examples,
        aiSdk: e.aisdk ?? fe.aiSdk,
        git: e.git ?? fe.git,
        install: e.i ?? fe.install,
        webDeploy: e.wd ?? fe.webDeploy,
        serverDeploy: e.sd ?? fe.serverDeploy,
        yolo: e.yolo ?? fe.yolo,
        rustWebFramework: e.rwf ?? fe.rustWebFramework,
        rustFrontend: e.rfe ?? fe.rustFrontend,
        rustOrm: e.rorm ?? fe.rustOrm,
        rustApi: e.rapi ?? fe.rustApi,
        rustCli: e.rcli ?? fe.rustCli,
        rustLibraries: e.rlib ?? fe.rustLibraries,
      }
    : fe;
}
function bR() {
  const [e, t] = h.useState(fe),
    [n, r] = h.useState("command"),
    [o, s] = h.useState(""),
    i = h.useRef(!1),
    a = nm({ from: "/new", strict: !1 });
  h.useEffect(() => {
    if (!i.current && a) {
      i.current = !0;
      const d = gR(a);
      (t(d), r(a.view || "command"), s(a.file || ""));
    }
  }, [a]);
  const l = h.useCallback((d) => {
      (console.log("[useStackState] updateStack called with:", d),
        t((f) => {
          const m = typeof d == "function" ? d(f) : d;
          console.log("[useStackState] newUpdates:", m);
          const g = { ...f, ...m };
          return (console.log("[useStackState] merged result:", g), g);
        }));
    }, []),
    c = h.useCallback((d) => {
      r(d);
    }, []),
    u = h.useCallback((d) => {
      s(d || "");
    }, []);
  return [e, l, n, c, o, u];
}
const yR = {
    ecosystem: "eco",
    projectName: "name",
    webFrontend: "fe-w",
    nativeFrontend: "fe-n",
    astroIntegration: "ai",
    cssFramework: "css",
    uiLibrary: "ui",
    runtime: "rt",
    backend: "be",
    api: "api",
    database: "db",
    orm: "orm",
    dbSetup: "dbs",
    auth: "au",
    payments: "pay",
    email: "em",
    fileUpload: "fu",
    logging: "log",
    observability: "obs",
    backendLibraries: "bl",
    stateManagement: "sm",
    validation: "val",
    testing: "tst",
    realtime: "rt2",
    jobQueue: "jq",
    caching: "cache",
    animation: "anim",
    cms: "cms",
    codeQuality: "cq",
    documentation: "doc",
    appPlatforms: "ap",
    packageManager: "pm",
    examples: "ex",
    aiSdk: "aisdk",
    git: "git",
    install: "i",
    webDeploy: "wd",
    serverDeploy: "sd",
    yolo: "yolo",
    rustWebFramework: "rwf",
    rustFrontend: "rfe",
    rustOrm: "rorm",
    rustApi: "rapi",
    rustCli: "rcli",
    rustLibraries: "rlib",
  },
  pi = [
    "webFrontend",
    "nativeFrontend",
    "astroIntegration",
    "cssFramework",
    "uiLibrary",
    "backend",
    "backendLibraries",
    "runtime",
    "api",
    "database",
    "orm",
    "dbSetup",
    "webDeploy",
    "serverDeploy",
    "auth",
    "payments",
    "email",
    "fileUpload",
    "logging",
    "observability",
    "cms",
    "codeQuality",
    "documentation",
    "appPlatforms",
    "packageManager",
    "examples",
    "git",
    "install",
  ],
  $c = [
    "rustWebFramework",
    "rustFrontend",
    "rustOrm",
    "rustApi",
    "rustCli",
    "rustLibraries",
    "git",
    "install",
  ],
  gi = [
    ...pi,
    "rustWebFramework",
    "rustFrontend",
    "rustOrm",
    "rustApi",
    "rustCli",
    "rustLibraries",
  ];
function xR(e) {
  const t = e.projectName || "my-better-t-app";
  if (e.ecosystem === "rust") return vR(e, t);
  const n = {
      npm: "npx create-better-t-stack@latest",
      pnpm: "pnpm create better-t-stack@latest",
      default: "bun create better-t-stack@latest",
    },
    r = n[e.packageManager] || n.default;
  if (Object.entries(fe).every(([a]) => a === "projectName" || rm(e, a, e[a])))
    return `${r} ${t} --yes`;
  const s = (a) =>
      a === "self-next" || a === "self-tanstack-start" || a === "self-astro" ? "self" : a,
    i = [
      `--frontend ${[...e.webFrontend, ...e.nativeFrontend].filter((a, l, c) => a !== "none" || c.length === 1).join(" ") || "none"}`,
      ...(e.webFrontend.includes("astro") && e.astroIntegration !== "none"
        ? [`--astro-integration ${e.astroIntegration}`]
        : []),
      `--css-framework ${e.cssFramework}`,
      `--ui-library ${e.uiLibrary}`,
      `--backend ${s(e.backend)}`,
      `--runtime ${e.runtime}`,
      `--api ${e.api}`,
      `--auth ${e.auth}`,
      `--payments ${e.payments}`,
      `--email ${e.email}`,
      `--file-upload ${e.fileUpload}`,
      `--logging ${e.logging}`,
      `--observability ${e.observability}`,
      `--job-queue ${e.jobQueue}`,
      `--cms ${e.cms}`,
      `--effect ${e.backendLibraries}`,
      `--database ${e.database}`,
      `--orm ${e.orm}`,
      `--db-setup ${e.dbSetup}`,
      `--package-manager ${e.packageManager}`,
      e.git === "false" ? "--no-git" : "--git",
      `--web-deploy ${e.webDeploy}`,
      `--server-deploy ${e.serverDeploy}`,
      e.install === "false" ? "--no-install" : "--install",
      `--addons ${([...e.codeQuality, ...e.documentation, ...e.appPlatforms].length > 0 && [...e.codeQuality, ...e.documentation, ...e.appPlatforms].filter((a) => ["pwa", "tauri", "starlight", "biome", "lefthook", "husky", "turborepo", "ultracite", "fumadocs", "oxlint", "ruler", "opentui", "wxt"].includes(a)).join(" ")) || "none"}`,
      `--examples ${e.examples.join(" ") || "none"}`,
    ];
  return (e.yolo === "true" && i.push("--yolo"), `${r} ${t} ${i.join(" ")}`);
}
function vR(e, t) {
  const n = [];
  (e.rustWebFramework !== "none" && n.push(`--web-framework ${e.rustWebFramework}`),
    e.rustFrontend !== "none" && n.push(`--frontend ${e.rustFrontend}`),
    e.rustOrm !== "none" && n.push(`--orm ${e.rustOrm}`),
    e.rustApi !== "none" && n.push(`--api ${e.rustApi}`),
    e.rustCli !== "none" && n.push(`--cli ${e.rustCli}`),
    e.rustLibraries !== "none" &&
      e.rustLibraries !== "serde" &&
      n.push(`--libraries ${e.rustLibraries}`),
    e.git === "false" && n.push("--no-git"));
  const r = "cargo new",
    o = n.length > 0 ? ` # Options: ${n.join(" ")}` : "";
  return `${r} ${t}${o}`;
}
function wR(e, t) {
  const n = "https://better-t-stack.dev",
    r = new URLSearchParams();
  Object.entries(yR).forEach(([s, i]) => {
    const a = e[s];
    a !== void 0 && r.set(i, Array.isArray(a) ? a.join(",") : String(a));
  });
  const o = r.toString();
  return `${n}/stack${o ? `?${o}` : ""}`;
}
function SR({ onReset: e, onRandom: t, onSave: n, onLoad: r, hasSavedStack: o }) {
  return T.jsxs("div", {
    className: "flex gap-1",
    children: [
      T.jsxs("button", {
        type: "button",
        onClick: e,
        className:
          "flex flex-1 items-center justify-center gap-1.5 rounded-md border border-border bg-fd-background px-2 py-1.5 font-medium text-muted-foreground text-xs transition-all hover:border-muted-foreground/30 hover:bg-muted hover:text-foreground",
        title: "Reset to defaults",
        children: [T.jsx(fm, { className: "h-3 w-3" }), "Reset"],
      }),
      T.jsxs("button", {
        type: "button",
        onClick: t,
        className:
          "flex flex-1 items-center justify-center gap-1.5 rounded-md border border-border bg-fd-background px-2 py-1.5 font-medium text-muted-foreground text-xs transition-all hover:border-muted-foreground/30 hover:bg-muted hover:text-foreground",
        title: "Generate a random stack",
        children: [T.jsx(bm, { className: "h-3 w-3" }), "Random"],
      }),
      T.jsxs("button", {
        type: "button",
        onClick: n,
        className:
          "flex flex-1 items-center justify-center gap-1.5 rounded-md border border-border bg-fd-background px-2 py-1.5 font-medium text-muted-foreground text-xs transition-all hover:border-muted-foreground/30 hover:bg-muted hover:text-foreground",
        title: "Save current preferences",
        children: [T.jsx(xm, { className: "h-3 w-3" }), "Save"],
      }),
      o &&
        T.jsxs("button", {
          type: "button",
          onClick: r,
          className:
            "flex flex-1 items-center justify-center gap-1.5 rounded-md border border-border bg-fd-background px-2 py-1.5 font-medium text-muted-foreground text-xs transition-all hover:border-muted-foreground/30 hover:bg-muted hover:text-foreground",
          title: "Load saved preferences",
          children: [T.jsx(Xc, { className: "h-3 w-3" }), "Load"],
        }),
    ],
  });
}
const Wc = (e) => {
  switch (e) {
    case "webFrontend":
    case "nativeFrontend":
      return "border-primary/30 bg-primary/10 text-primary";
    case "runtime":
      return "border-accent/30 bg-accent/10 text-accent";
    case "backend":
      return "border-primary/40 bg-primary/15 text-primary";
    case "api":
      return "border-primary/50 bg-primary/20 text-primary";
    case "database":
      return "border-accent/40 bg-accent/15 text-accent";
    case "orm":
      return "border-primary/35 bg-primary/12 text-primary";
    case "auth":
      return "border-accent/35 bg-accent/12 text-accent";
    case "payments":
      return "border-purple-500/30 bg-purple-500/10 text-purple-600 dark:text-purple-400";
    case "email":
      return "border-gray-500/30 bg-gray-500/10 text-gray-600 dark:text-gray-400";
    case "dbSetup":
      return "border-primary/30 bg-primary/10 text-primary";
    case "cssFramework":
      return "border-cyan-500/30 bg-cyan-500/10 text-cyan-600 dark:text-cyan-400";
    case "uiLibrary":
      return "border-violet-500/30 bg-violet-500/10 text-violet-600 dark:text-violet-400";
    case "backendLibraries":
      return "border-indigo-500/30 bg-indigo-500/10 text-indigo-600 dark:text-indigo-400";
    case "codeQuality":
      return "border-emerald-500/30 bg-emerald-500/10 text-emerald-600 dark:text-emerald-400";
    case "documentation":
      return "border-amber-500/30 bg-amber-500/10 text-amber-600 dark:text-amber-400";
    case "appPlatforms":
      return "border-accent/50 bg-accent/20 text-accent";
    case "examples":
      return "border-primary/40 bg-primary/15 text-primary";
    case "packageManager":
      return "border-muted-foreground/30 bg-muted text-muted-foreground";
    case "git":
    case "webDeploy":
    case "serverDeploy":
    case "install":
      return "border-muted-foreground/30 bg-muted text-muted-foreground";
    default:
      return "border-muted-foreground/30 bg-muted text-muted-foreground";
  }
};
function TR({ onApplyPreset: e }) {
  return T.jsxs(Sh, {
    children: [
      T.jsxs(Th, {
        render: T.jsx("button", {
          type: "button",
          className:
            "flex flex-1 items-center justify-center gap-1.5 rounded-md border border-border bg-fd-background px-2 py-1.5 font-medium text-muted-foreground text-xs transition-all hover:border-muted-foreground/30 hover:bg-muted hover:text-foreground",
        }),
        children: [
          T.jsx(Sm, { className: "h-3 w-3" }),
          "Presets",
          T.jsx(qc, { className: "ml-auto h-3 w-3" }),
        ],
      }),
      T.jsx(Rh, {
        align: "end",
        className: "w-64 bg-fd-background",
        children: _c.map((t) =>
          T.jsxs(
            yT,
            {
              onClick: () => e(t.id),
              className: "flex flex-col items-start gap-1 p-3",
              children: [
                T.jsx("div", { className: "font-medium text-sm", children: t.name }),
                T.jsx("div", { className: "text-xs", children: t.description }),
              ],
            },
            t.id,
          ),
        ),
      }),
    ],
  });
}
function RR({ stackUrl: e }) {
  const [t, n] = h.useState(!1),
    r = async () => {
      try {
        (await navigator.clipboard.writeText(e), n(!0), setTimeout(() => n(!1), 2e3));
      } catch (o) {
        console.error("Failed to copy:", o);
      }
    };
  return T.jsx("button", {
    type: "button",
    onClick: r,
    className:
      "flex flex-1 items-center justify-center gap-1.5 rounded-md border border-border bg-fd-background px-2 py-1.5 font-medium text-muted-foreground text-xs transition-all hover:border-muted-foreground/30 hover:bg-muted hover:text-foreground",
    title: t ? "Copied!" : "Copy share link",
    children: t
      ? T.jsxs(T.Fragment, {
          children: [T.jsx(Yc, { className: "h-3 w-3 text-green-500" }), "Copied"],
        })
      : T.jsxs(T.Fragment, { children: [T.jsx(pm, { className: "h-3 w-3" }), "Share"] }),
  });
}
function fn({ icon: e, name: t, className: n }) {
  return e
    ? e.startsWith("https://") || e.startsWith("/")
      ? T.jsx("img", {
          src: e,
          alt: `${t} icon`,
          width: 20,
          height: 20,
          className: ye("inline-block", n),
        })
      : T.jsx("span", { className: ye("inline-flex items-center text-lg", n), children: e })
    : null;
}
function ER(e) {
  const t = ["<", ">", ":", '"', "|", "?", "*"];
  if (e !== ".") {
    if (!e) return "Project name cannot be empty";
    if (e.length > 255) return "Project name must be less than 255 characters";
    if (t.some((r) => e.includes(r))) return "Project name contains invalid characters";
    if (e.startsWith(".") || e.startsWith("-"))
      return "Project name cannot start with a dot or dash";
    if (e.toLowerCase() === "node_modules" || e.toLowerCase() === "favicon.ico")
      return "Project name is reserved";
  }
}
const jh = (e) =>
    e.some((t) => ["tanstack-router", "react-router", "solid", "next", "astro"].includes(t)),
  Vh = (e) =>
    e.some((t) =>
      ["tanstack-router", "react-router", "nuxt", "svelte", "solid", "next", "astro"].includes(t),
    ),
  xr = (e) => {
    const t = {
      rustWebFramework: "Rust Web Framework",
      rustFrontend: "Rust Frontend (WASM)",
      rustOrm: "Rust ORM / Database",
      rustApi: "Rust API Layer",
      rustCli: "Rust CLI Tools",
      rustLibraries: "Rust Core Libraries",
    };
    if (t[e]) return t[e];
    const n = e.replace(/([A-Z])/g, " $1");
    return n.charAt(0).toUpperCase() + n.slice(1);
  },
  CR = (e) => {
    if (e.yolo === "true") return { adjustedStack: null, notes: {}, changes: [] };
    const t = { ...e };
    let n = !1;
    const r = {},
      o = [];
    for (const u of gi) r[u] = { notes: [], hasIssue: !1 };
    if (t.backend === "convex") {
      const u = {
        runtime: "none",
        database: "none",
        orm: "none",
        api: "none",
        dbSetup: "none",
        serverDeploy: "none",
      };
      for (const [d, f] of Object.entries(u)) {
        const m = d;
        t[m] !== f &&
          ((t[m] = f),
          (n = !0),
          o.push({
            category: "backend",
            message: `${xr(m)} set to '${f}' (Convex provides this)`,
          }));
      }
      (t.webFrontend.includes("solid") &&
        ((t.webFrontend = t.webFrontend.filter((d) => d !== "solid")),
        t.webFrontend.length === 0 && (t.webFrontend = ["none"]),
        (n = !0),
        o.push({ category: "backend", message: "Removed Solid (incompatible with Convex)" })),
        t.webFrontend.includes("astro") &&
          ((t.webFrontend = t.webFrontend.filter((d) => d !== "astro")),
          t.webFrontend.length === 0 && (t.webFrontend = ["none"]),
          (t.astroIntegration = "none"),
          (n = !0),
          o.push({ category: "backend", message: "Removed Astro (incompatible with Convex)" })),
        t.examples.includes("ai") &&
          t.webFrontend.some((f) => ["solid", "svelte", "nuxt"].includes(f)) &&
          ((t.examples = t.examples.filter((f) => f !== "ai")),
          t.examples.length === 0 && (t.examples = ["none"]),
          (n = !0),
          o.push({
            category: "examples",
            message: "AI example removed (Convex AI only supports React-based frontends)",
          })),
        t.auth === "clerk" &&
          (t.webFrontend.some((f) =>
            ["tanstack-router", "react-router", "tanstack-start", "next"].includes(f),
          ) ||
            t.nativeFrontend.some((f) =>
              ["native-bare", "native-uniwind", "native-unistyles"].includes(f),
            ) ||
            ((t.auth = "none"),
            (n = !0),
            o.push({
              category: "auth",
              message: "Auth set to 'None' (Clerk requires compatible frontend)",
            }))),
        t.auth === "better-auth" &&
          (t.webFrontend.some((f) => ["tanstack-router", "tanstack-start", "next"].includes(f)) ||
            t.nativeFrontend.some((f) =>
              ["native-bare", "native-uniwind", "native-unistyles"].includes(f),
            ) ||
            ((t.auth = "none"),
            (n = !0),
            o.push({
              category: "auth",
              message: "Auth set to 'None' (Better-Auth with Convex requires compatible frontend)",
            }))));
    }
    if (t.backend === "none") {
      const u = {
        runtime: "none",
        database: "none",
        orm: "none",
        api: "none",
        auth: "none",
        dbSetup: "none",
        serverDeploy: "none",
        payments: "none",
      };
      for (const [d, f] of Object.entries(u)) {
        const m = d;
        t[m] !== f &&
          ((t[m] = f),
          (n = !0),
          o.push({ category: "backend", message: `${xr(m)} set to '${f}' (no backend)` }));
      }
      t.examples.length > 0 &&
        !(t.examples.length === 1 && t.examples[0] === "none") &&
        ((t.examples = ["none"]),
        (n = !0),
        o.push({ category: "backend", message: "Examples cleared (no backend)" }));
    }
    ((t.backend === "self-next" ||
      t.backend === "self-tanstack-start" ||
      t.backend === "self-astro") &&
      (t.runtime !== "none" &&
        ((t.runtime = "none"),
        (n = !0),
        o.push({
          category: "backend",
          message: "Runtime set to 'None' (fullstack uses frontend's API routes)",
        })),
      t.serverDeploy !== "none" &&
        ((t.serverDeploy = "none"),
        (n = !0),
        o.push({
          category: "backend",
          message: "Server deploy set to 'None' (fullstack uses frontend deployment)",
        })),
      t.backend === "self-next" &&
        !t.webFrontend.includes("next") &&
        ((t.webFrontend = ["next"]),
        (n = !0),
        o.push({
          category: "backend",
          message: "Frontend set to 'Next.js' (required for Next.js fullstack)",
        })),
      t.backend === "self-tanstack-start" &&
        !t.webFrontend.includes("tanstack-start") &&
        ((t.webFrontend = ["tanstack-start"]),
        (n = !0),
        o.push({
          category: "backend",
          message: "Frontend set to 'TanStack Start' (required for TanStack Start fullstack)",
        })),
      t.backend === "self-astro" &&
        !t.webFrontend.includes("astro") &&
        ((t.webFrontend = ["astro"]),
        t.astroIntegration === "none" && (t.astroIntegration = "react"),
        (n = !0),
        o.push({
          category: "backend",
          message: "Frontend set to 'Astro' (required for Astro fullstack)",
        }))),
      t.runtime === "workers" &&
        t.backend !== "hono" &&
        ((t.backend = "hono"),
        (n = !0),
        o.push({ category: "runtime", message: "Backend set to 'Hono' (required for Workers)" })),
      t.runtime === "workers" &&
        t.serverDeploy === "none" &&
        ((t.serverDeploy = "cloudflare"),
        (n = !0),
        o.push({
          category: "runtime",
          message: "Server deploy set to 'Cloudflare' (required for Workers)",
        })),
      t.runtime === "workers" &&
        t.database === "mongodb" &&
        ((t.database = "sqlite"),
        (t.orm = "drizzle"),
        (t.dbSetup = "d1"),
        (n = !0),
        o.push({
          category: "runtime",
          message: "Database changed to SQLite with D1 (MongoDB incompatible with Workers)",
        })),
      t.runtime === "none" &&
        t.backend !== "convex" &&
        t.backend !== "none" &&
        t.backend !== "self-next" &&
        t.backend !== "self-tanstack-start" &&
        t.backend !== "self-astro" &&
        ((t.runtime = fe.runtime),
        (n = !0),
        o.push({
          category: "runtime",
          message: `Runtime set to '${fe.runtime}' (required for this backend)`,
        })),
      t.backend !== "convex" &&
        t.backend !== "none" &&
        (t.database === "none" &&
          (t.orm !== "none" &&
            ((t.orm = "none"),
            (n = !0),
            o.push({ category: "database", message: "ORM set to 'None' (no database selected)" })),
          t.dbSetup !== "none" &&
            ((t.dbSetup = "none"),
            (n = !0),
            o.push({
              category: "database",
              message: "DB Setup set to 'None' (no database selected)",
            }))),
        t.database === "mongodb" &&
          (t.orm !== "prisma" &&
            t.orm !== "mongoose" &&
            ((t.orm = "prisma"),
            (n = !0),
            o.push({
              category: "database",
              message: "ORM set to 'Prisma' (required for MongoDB)",
            })),
          t.dbSetup !== "mongodb-atlas" &&
            t.dbSetup !== "none" &&
            t.dbSetup !== "docker" &&
            ((t.dbSetup = "none"),
            (n = !0),
            o.push({
              category: "database",
              message: "DB Setup set to 'None' (incompatible with MongoDB)",
            }))),
        ["sqlite", "postgres", "mysql"].includes(t.database) &&
          (t.orm === "none" &&
            ((t.orm = "drizzle"),
            (n = !0),
            o.push({
              category: "database",
              message: "ORM set to 'Drizzle' (required for database)",
            })),
          t.orm === "mongoose" &&
            ((t.orm = "drizzle"),
            (n = !0),
            o.push({
              category: "database",
              message: "ORM set to 'Drizzle' (Mongoose only works with MongoDB)",
            }))),
        t.orm !== "none" &&
          t.database === "none" &&
          (t.orm === "mongoose"
            ? ((t.database = "mongodb"),
              (n = !0),
              o.push({
                category: "orm",
                message: "Database set to 'MongoDB' (required for Mongoose)",
              }))
            : ((t.database = "sqlite"),
              (n = !0),
              o.push({ category: "orm", message: "Database set to 'SQLite' (required for ORM)" }))),
        t.dbSetup === "turso" &&
          t.database !== "sqlite" &&
          ((t.database = "sqlite"),
          (n = !0),
          o.push({
            category: "dbSetup",
            message: "Database set to 'SQLite' (required for Turso)",
          })),
        t.dbSetup === "d1" &&
          (t.database !== "sqlite" &&
            ((t.database = "sqlite"),
            (n = !0),
            o.push({ category: "dbSetup", message: "Database set to 'SQLite' (required for D1)" })),
          t.runtime !== "workers" &&
            ((t.runtime = "workers"),
            (t.backend = "hono"),
            (n = !0),
            o.push({
              category: "dbSetup",
              message: "Runtime set to 'Workers' with 'Hono' (required for D1)",
            }))),
        t.dbSetup === "neon" &&
          t.database !== "postgres" &&
          ((t.database = "postgres"),
          (n = !0),
          o.push({
            category: "dbSetup",
            message: "Database set to 'PostgreSQL' (required for Neon)",
          })),
        t.dbSetup === "supabase" &&
          t.database !== "postgres" &&
          ((t.database = "postgres"),
          (n = !0),
          o.push({
            category: "dbSetup",
            message: "Database set to 'PostgreSQL' (required for Supabase)",
          })),
        t.dbSetup === "prisma-postgres" &&
          t.database !== "postgres" &&
          ((t.database = "postgres"),
          (n = !0),
          o.push({
            category: "dbSetup",
            message: "Database set to 'PostgreSQL' (required for Prisma Postgres)",
          })),
        t.dbSetup === "mongodb-atlas" &&
          t.database !== "mongodb" &&
          ((t.database = "mongodb"),
          t.orm !== "prisma" && t.orm !== "mongoose" && (t.orm = "prisma"),
          (n = !0),
          o.push({
            category: "dbSetup",
            message: "Database set to 'MongoDB' (required for MongoDB Atlas)",
          })),
        t.dbSetup === "planetscale" &&
          t.database !== "postgres" &&
          t.database !== "mysql" &&
          ((t.database = "postgres"),
          (n = !0),
          o.push({
            category: "dbSetup",
            message: "Database set to 'PostgreSQL' (required for PlanetScale)",
          })),
        t.dbSetup === "docker" &&
          (t.database === "sqlite" &&
            ((t.dbSetup = "none"),
            (n = !0),
            o.push({
              category: "dbSetup",
              message: "DB Setup set to 'None' (SQLite doesn't need Docker)",
            })),
          t.runtime === "workers" &&
            ((t.dbSetup = "d1"),
            (n = !0),
            o.push({
              category: "dbSetup",
              message: "DB Setup set to 'D1' (Docker incompatible with Workers)",
            })))),
      t.backend !== "convex" &&
        t.backend !== "none" &&
        (t.webFrontend.some((d) => ["nuxt", "svelte", "solid"].includes(d)) &&
          t.api === "trpc" &&
          ((t.api = "orpc"),
          (n = !0),
          o.push({ category: "api", message: "API set to 'oRPC' (required for this frontend)" })),
        t.webFrontend.includes("astro") &&
          t.astroIntegration !== "react" &&
          t.api === "trpc" &&
          ((t.api = "orpc"),
          (n = !0),
          o.push({
            category: "api",
            message: "API set to 'oRPC' (tRPC requires React integration with Astro)",
          }))),
      !t.webFrontend.includes("astro") &&
        t.astroIntegration !== "none" &&
        ((t.astroIntegration = "none"),
        (n = !0),
        o.push({
          category: "astroIntegration",
          message: "Astro integration reset (Astro not selected)",
        })),
      t.webFrontend.includes("astro") &&
        t.astroIntegration === "none" &&
        t.api === "trpc" &&
        ((t.astroIntegration = "react"),
        (n = !0),
        o.push({
          category: "astroIntegration",
          message: "Astro integration set to 'React' (required for tRPC)",
        })),
      t.auth === "clerk" &&
        t.backend !== "convex" &&
        ((t.auth = "none"),
        (n = !0),
        o.push({ category: "auth", message: "Auth set to 'None' (Clerk only works with Convex)" })),
      t.payments === "polar" &&
        (t.auth !== "better-auth" &&
          ((t.payments = "none"),
          (n = !0),
          o.push({
            category: "payments",
            message: "Payments set to 'None' (Polar requires Better Auth)",
          })),
        t.backend === "convex" &&
          ((t.payments = "none"),
          (n = !0),
          o.push({
            category: "payments",
            message: "Payments set to 'None' (Polar incompatible with Convex)",
          })),
        t.webFrontend.some((d) => d !== "none") ||
          ((t.payments = "none"),
          (n = !0),
          o.push({
            category: "payments",
            message: "Payments set to 'None' (Polar requires web frontend)",
          }))),
      t.email !== "none" &&
        (t.backend === "convex" &&
          ((t.email = "none"),
          (n = !0),
          o.push({ category: "email", message: "Email set to 'None' (incompatible with Convex)" })),
        t.backend === "none" &&
          ((t.email = "none"),
          (n = !0),
          o.push({ category: "email", message: "Email set to 'None' (requires backend)" }))),
      t.webFrontend.some((u) => u !== "none") ||
        (t.cssFramework !== "none" &&
          ((t.cssFramework = "none"),
          (n = !0),
          o.push({
            category: "cssFramework",
            message: "CSS framework set to 'None' (no web frontend)",
          })),
        t.uiLibrary !== "none" &&
          ((t.uiLibrary = "none"),
          (n = !0),
          o.push({
            category: "uiLibrary",
            message: "UI library set to 'None' (no web frontend)",
          }))),
      ["shadcn-ui", "daisyui", "nextui"].includes(t.uiLibrary) &&
        t.cssFramework !== "tailwind" &&
        ((t.cssFramework = "tailwind"),
        (n = !0),
        o.push({
          category: "cssFramework",
          message: `CSS framework set to 'Tailwind' (required by ${t.uiLibrary})`,
        })));
    const i = ["shadcn-ui", "radix-ui", "chakra-ui", "nextui"],
      a = ["tanstack-router", "react-router", "tanstack-start", "next"];
    if (i.includes(t.uiLibrary)) {
      const u = t.webFrontend.some((f) => a.includes(f)),
        d = t.webFrontend.includes("astro") && t.astroIntegration === "react";
      !u &&
        !d &&
        t.webFrontend.some((f) => f !== "none") &&
        ((t.uiLibrary = "daisyui"),
        (n = !0),
        o.push({
          category: "uiLibrary",
          message:
            "UI library changed to 'daisyUI' (React-only library incompatible with this frontend)",
        }));
    }
    if (t.uiLibrary === "headless-ui") {
      const u = t.webFrontend.some((m) => a.includes(m)),
        d = t.webFrontend.includes("nuxt"),
        f = t.webFrontend.includes("astro") && ["react", "vue"].includes(t.astroIntegration);
      !u &&
        !d &&
        !f &&
        ((t.uiLibrary = "daisyui"),
        (n = !0),
        o.push({
          category: "uiLibrary",
          message: "UI library changed to 'daisyUI' (Headless UI requires React or Vue)",
        }));
    }
    if (t.uiLibrary === "park-ui") {
      const u = t.webFrontend.some((g) => a.includes(g)),
        d = t.webFrontend.includes("nuxt"),
        f = t.webFrontend.includes("solid"),
        m =
          t.webFrontend.includes("astro") && ["react", "vue", "solid"].includes(t.astroIntegration);
      !u &&
        !d &&
        !f &&
        !m &&
        t.webFrontend.some((g) => g !== "none") &&
        ((t.uiLibrary = "daisyui"),
        (n = !0),
        o.push({
          category: "uiLibrary",
          message: "UI library changed to 'daisyUI' (Park UI requires React, Vue, or Solid)",
        }));
    }
    const l = jh(t.webFrontend),
      c = Vh(t.webFrontend);
    if (
      (!l &&
        t.appPlatforms.includes("pwa") &&
        ((t.appPlatforms = t.appPlatforms.filter((u) => u !== "pwa")),
        (n = !0),
        o.push({
          category: "appPlatforms",
          message: "PWA removed (requires compatible frontend)",
        })),
      !c &&
        t.appPlatforms.includes("tauri") &&
        ((t.appPlatforms = t.appPlatforms.filter((u) => u !== "tauri")),
        (n = !0),
        o.push({
          category: "appPlatforms",
          message: "Tauri removed (requires compatible frontend)",
        })),
      t.examples.includes("todo") &&
        t.backend !== "convex" &&
        (t.database === "none" || t.api === "none"))
    ) {
      const d = t.database === "none" ? "requires database" : "requires API layer";
      ((t.examples = t.examples.filter((f) => f !== "todo")),
        t.examples.length === 0 && (t.examples = ["none"]),
        (n = !0),
        o.push({ category: "examples", message: `Todo removed (${d})` }));
    }
    return (
      t.examples.includes("ai") &&
        (t.webFrontend.includes("solid") &&
          ((t.examples = t.examples.filter((u) => u !== "ai")),
          t.examples.length === 0 && (t.examples = ["none"]),
          (n = !0),
          o.push({
            category: "examples",
            message: "AI removed (not compatible with Solid frontend)",
          })),
        t.backend === "convex" &&
          t.webFrontend.some((d) => ["svelte", "nuxt"].includes(d)) &&
          ((t.examples = t.examples.filter((d) => d !== "ai")),
          t.examples.length === 0 && (t.examples = ["none"]),
          (n = !0),
          o.push({
            category: "examples",
            message: "AI removed (Convex AI only supports React-based frontends)",
          }))),
      t.webDeploy !== "none" &&
        !t.webFrontend.some((u) => u !== "none") &&
        ((t.webDeploy = "none"),
        (n = !0),
        o.push({ category: "webDeploy", message: "Web deploy set to 'None' (no web frontend)" })),
      t.serverDeploy === "cloudflare" &&
        (t.runtime !== "workers" || t.backend !== "hono") &&
        ((t.serverDeploy = "none"),
        (n = !0),
        o.push({
          category: "serverDeploy",
          message: "Server deploy set to 'None' (Cloudflare requires Workers + Hono)",
        })),
      t.serverDeploy !== "none" &&
        ["none", "convex", "self-next", "self-tanstack-start", "self-astro"].includes(t.backend) &&
        ((t.serverDeploy = "none"),
        (n = !0),
        o.push({
          category: "serverDeploy",
          message: "Server deploy set to 'None' (not needed for this backend)",
        })),
      { adjustedStack: n ? t : null, notes: r, changes: o }
    );
  },
  bi = (e, t, n) => {
    if (e.backend === "convex") {
      if (t === "runtime" && n !== "none") return "Convex provides its own runtime";
      if (t === "database" && n !== "none") return "Convex provides its own database";
      if (t === "orm" && n !== "none") return "Convex has built-in data access";
      if (t === "api" && n !== "none") return "Convex provides its own API layer";
      if (t === "dbSetup" && n !== "none") return "Convex handles database setup";
      if (t === "serverDeploy" && n !== "none") return "Convex has its own deployment";
      if (
        t === "auth" &&
        n === "better-auth" &&
        !(
          e.webFrontend.some((o) => ["tanstack-router", "tanstack-start", "next"].includes(o)) ||
          e.nativeFrontend.some((o) =>
            ["native-bare", "native-uniwind", "native-unistyles"].includes(o),
          )
        )
      )
        return "Better-Auth with Convex requires TanStack Router, TanStack Start, Next.js, or React Native";
      if (t === "webFrontend" && n === "solid") return "Solid is not compatible with Convex";
      if (t === "webFrontend" && n === "astro") return "Astro is not compatible with Convex";
      if (
        t === "examples" &&
        n === "ai" &&
        e.webFrontend.some((o) => ["solid", "svelte", "nuxt"].includes(o))
      )
        return `Convex AI example only supports React-based frontends (not ${e.webFrontend.find((s) => ["solid", "svelte", "nuxt"].includes(s))})`;
      if (t === "payments" && n === "polar") return "Polar is not compatible with Convex";
    }
    if (
      e.backend === "none" &&
      ((t === "runtime" && n !== "none") ||
        (t === "database" && n !== "none") ||
        (t === "orm" && n !== "none") ||
        (t === "api" && n !== "none") ||
        (t === "auth" && n !== "none") ||
        (t === "dbSetup" && n !== "none") ||
        (t === "serverDeploy" && n !== "none") ||
        (t === "payments" && n !== "none") ||
        (t === "examples" && n !== "none"))
    )
      return "No backend selected";
    if (e.backend === "self-next") {
      if (t === "runtime" && n !== "none") return "Next.js fullstack uses built-in API routes";
      if (t === "webFrontend" && n !== "next" && n !== "none")
        return "Next.js fullstack requires Next.js frontend";
      if (t === "serverDeploy" && n !== "none") return "Fullstack uses frontend deployment";
    }
    if (e.backend === "self-tanstack-start") {
      if (t === "runtime" && n !== "none")
        return "TanStack Start fullstack uses built-in API routes";
      if (t === "webFrontend" && n !== "tanstack-start" && n !== "none")
        return "TanStack Start fullstack requires TanStack Start frontend";
      if (t === "serverDeploy" && n !== "none") return "Fullstack uses frontend deployment";
    }
    if (e.backend === "self-astro") {
      if (t === "runtime" && n !== "none") return "Astro fullstack uses built-in API routes";
      if (t === "webFrontend" && n !== "astro" && n !== "none")
        return "Astro fullstack requires Astro frontend";
      if (t === "serverDeploy" && n !== "none") return "Fullstack uses frontend deployment";
    }
    if (t === "backend") {
      if (n === "self-next" && !e.webFrontend.includes("next")) return "Requires Next.js frontend";
      if (n === "self-tanstack-start" && !e.webFrontend.includes("tanstack-start"))
        return "Requires TanStack Start frontend";
      if (n === "self-astro" && !e.webFrontend.includes("astro")) return "Requires Astro frontend";
      if (n === "convex" && e.webFrontend.includes("solid"))
        return "Convex is not compatible with Solid";
      if (n === "convex" && e.webFrontend.includes("astro"))
        return "Convex is not compatible with Astro";
      if (e.runtime === "workers" && n !== "hono" && n !== "none")
        return "Workers runtime only works with Hono";
    }
    if (t === "runtime") {
      if (n === "workers" && e.backend !== "hono") return "Workers requires Hono backend";
      if (
        n === "none" &&
        !["convex", "none", "self-next", "self-tanstack-start", "self-astro"].includes(e.backend)
      )
        return "Runtime 'None' only for Convex or fullstack backends";
    }
    if (t === "database" && n === "mongodb" && e.runtime === "workers")
      return "MongoDB is not compatible with Workers runtime";
    if (t === "orm") {
      if (n === "mongoose") {
        if (e.runtime === "workers")
          return "Mongoose requires MongoDB, which is incompatible with Workers";
        if (e.database !== "none" && e.database !== "mongodb")
          return "Mongoose only works with MongoDB";
      }
      if (n === "drizzle" && e.database === "mongodb") return "Drizzle does not support MongoDB";
      if (n === "none" && e.database !== "none") return "Database requires an ORM";
    }
    if (t === "dbSetup" && n !== "none") {
      if (e.database === "none") return "Select a database first";
      if (n === "turso" && e.database !== "sqlite") return "Turso requires SQLite";
      if (n === "d1") {
        if (e.database !== "sqlite") return "D1 requires SQLite";
        if (e.runtime !== "workers") return "D1 requires Workers runtime";
      }
      if (n === "neon" && e.database !== "postgres") return "Neon requires PostgreSQL";
      if (n === "supabase" && e.database !== "postgres") return "Supabase requires PostgreSQL";
      if (n === "prisma-postgres" && e.database !== "postgres")
        return "Prisma Postgres requires PostgreSQL";
      if (n === "mongodb-atlas" && e.database !== "mongodb")
        return "MongoDB Atlas requires MongoDB";
      if (n === "planetscale" && e.database !== "postgres" && e.database !== "mysql")
        return "PlanetScale requires PostgreSQL or MySQL";
      if (n === "docker") {
        if (e.database === "sqlite") return "SQLite doesn't need Docker";
        if (e.runtime === "workers") return "Docker is incompatible with Workers";
      }
    }
    if (t === "api" && n === "trpc") {
      if (e.webFrontend.some((o) => ["nuxt", "svelte", "solid"].includes(o)))
        return `${e.webFrontend.find((s) => ["nuxt", "svelte", "solid"].includes(s))} requires oRPC, not tRPC`;
      if (
        e.webFrontend.includes("astro") &&
        e.astroIntegration !== "react" &&
        e.astroIntegration !== "none"
      )
        return `Astro with ${e.astroIntegration} integration requires oRPC, not tRPC`;
    }
    if (t === "astroIntegration") {
      if (!e.webFrontend.includes("astro") && n !== "none")
        return "Astro integration requires Astro frontend";
      if (e.api === "trpc" && n !== "react" && n !== "none")
        return "tRPC requires React integration with Astro";
    }
    if (t === "auth" && n === "clerk") {
      if (e.backend !== "convex") return "Clerk only works with Convex backend";
      if (
        !(
          e.webFrontend.some((o) =>
            ["react-router", "tanstack-router", "tanstack-start", "next"].includes(o),
          ) ||
          e.nativeFrontend.some((o) =>
            ["native-bare", "native-uniwind", "native-unistyles"].includes(o),
          )
        )
      )
        return "Clerk with Convex requires React Router, TanStack Router, TanStack Start, Next.js, or React Native";
    }
    if (t === "payments" && n === "polar") {
      if (e.auth !== "better-auth") return "Polar requires Better Auth";
      if (!e.webFrontend.some((r) => r !== "none")) return "Polar requires a web frontend";
    }
    if (t === "email" && n !== "none") {
      if (e.backend === "convex") return "Email integration is not available with Convex backend";
      if (e.backend === "none") return "Email integration requires a backend";
    }
    if (t === "appPlatforms") {
      if (n === "pwa" && !jh(e.webFrontend))
        return "PWA requires TanStack Router, React Router, Solid, Next.js, or Astro";
      if (n === "tauri" && !Vh(e.webFrontend))
        return "Tauri requires TanStack Router, React Router, Nuxt, Svelte, Solid, Next.js, or Astro";
    }
    if (t === "examples") {
      if (n === "todo" && e.backend !== "convex") {
        if (e.database === "none") return "Todo example requires a database";
        if (e.api === "none") return "Todo example requires an API layer (tRPC or oRPC)";
      }
      if (n === "ai") {
        if (e.webFrontend.includes("solid")) return "AI example not compatible with Solid frontend";
        if (e.backend === "convex" && e.webFrontend.some((o) => ["svelte", "nuxt"].includes(o)))
          return `Convex AI example only supports React-based frontends (not ${e.webFrontend.find((s) => ["svelte", "nuxt"].includes(s))})`;
      }
    }
    if (t === "cssFramework") {
      if (!e.webFrontend.some((o) => o !== "none") && n !== "none")
        return "CSS framework requires a web frontend";
      if (["shadcn-ui", "daisyui", "nextui"].includes(e.uiLibrary) && n !== "tailwind")
        return `${e.uiLibrary === "shadcn-ui" ? "shadcn/ui" : e.uiLibrary === "daisyui" ? "daisyUI" : "NextUI"} requires Tailwind CSS`;
    }
    if (t === "uiLibrary") {
      if (!e.webFrontend.some((s) => s !== "none") && n !== "none")
        return "UI library requires a web frontend";
      const r = ["shadcn-ui", "radix-ui", "chakra-ui", "nextui"],
        o = ["tanstack-router", "react-router", "tanstack-start", "next"];
      if (r.includes(n)) {
        const s = e.webFrontend.some((a) => o.includes(a)),
          i = e.webFrontend.includes("astro") && e.astroIntegration === "react";
        if (!s && !i)
          return `${n === "shadcn-ui" ? "shadcn/ui" : n === "radix-ui" ? "Radix UI" : n === "chakra-ui" ? "Chakra UI" : "NextUI"} requires a React-based frontend`;
      }
      if (n === "headless-ui") {
        const s = e.webFrontend.some((l) => o.includes(l)),
          i = e.webFrontend.includes("nuxt"),
          a = e.webFrontend.includes("astro") && ["react", "vue"].includes(e.astroIntegration);
        if (!s && !i && !a) return "Headless UI requires React or Vue frontend";
      }
      if (n === "park-ui") {
        const s = e.webFrontend.some((c) => o.includes(c)),
          i = e.webFrontend.includes("nuxt"),
          a = e.webFrontend.includes("solid"),
          l =
            e.webFrontend.includes("astro") &&
            ["react", "vue", "solid"].includes(e.astroIntegration);
        if (!s && !i && !a && !l) return "Park UI requires React, Vue, or Solid frontend";
        if (e.cssFramework === "none") return "Park UI requires a CSS framework";
      }
      if (["shadcn-ui", "daisyui", "nextui"].includes(n) && e.cssFramework !== "tailwind")
        return `${n === "shadcn-ui" ? "shadcn/ui" : n === "daisyui" ? "daisyUI" : "NextUI"} requires Tailwind CSS`;
    }
    if (t === "webDeploy" && n !== "none" && !e.webFrontend.some((r) => r !== "none"))
      return "Web deployment requires a web frontend";
    if (t === "serverDeploy") {
      if (n === "cloudflare") {
        if (e.runtime !== "workers") return "Cloudflare requires Workers runtime";
        if (e.backend !== "hono") return "Cloudflare requires Hono backend";
      }
      if (
        n !== "none" &&
        ["none", "convex", "self-next", "self-tanstack-start", "self-astro"].includes(e.backend)
      )
        return "Server deployment not needed for this backend";
      if (n === "none" && e.runtime === "workers") return "Workers requires server deployment";
    }
    return null;
  },
  cr = (e, t, n) => (e.yolo === "true" ? !0 : bi(e, t, n) === null),
  Bh = h.createContext(void 0);
function PR() {
  const e = h.useContext(Bh);
  if (e === void 0) throw new Error(Ke(63));
  return e;
}
let zc = (function (e) {
  return (
    (e.disabled = "data-disabled"),
    (e.valid = "data-valid"),
    (e.invalid = "data-invalid"),
    (e.touched = "data-touched"),
    (e.dirty = "data-dirty"),
    (e.filled = "data-filled"),
    (e.focused = "data-focused"),
    e
  );
})({});
const kR = {
    badInput: !1,
    customError: !1,
    patternMismatch: !1,
    rangeOverflow: !1,
    rangeUnderflow: !1,
    stepMismatch: !1,
    tooLong: !1,
    tooShort: !1,
    typeMismatch: !1,
    valid: null,
    valueMissing: !1,
  },
  MR = {
    valid(e) {
      return e === null ? null : e ? { [zc.valid]: "" } : { [zc.invalid]: "" };
    },
  };
let Hc = (function (e) {
  return (
    (e.checked = "data-checked"),
    (e.unchecked = "data-unchecked"),
    (e.disabled = "data-disabled"),
    (e.readonly = "data-readonly"),
    (e.required = "data-required"),
    (e.valid = "data-valid"),
    (e.invalid = "data-invalid"),
    (e.touched = "data-touched"),
    (e.dirty = "data-dirty"),
    (e.filled = "data-filled"),
    (e.focused = "data-focused"),
    e
  );
})({});
const $h = {
  ...MR,
  checked(e) {
    return e ? { [Hc.checked]: "" } : { [Hc.unchecked]: "" };
  },
};
function AR(e, t) {
  return { ...e, state: { ...e.state, valid: !t && e.state.valid } };
}
const OR = h.createContext({
  formRef: { current: { fields: new Map() } },
  errors: {},
  clearErrors: dt,
  validationMode: "onSubmit",
  submitAttemptedRef: { current: !1 },
});
function Wh() {
  return h.useContext(OR);
}
const IR = h.createContext({
  invalid: void 0,
  name: void 0,
  validityData: { state: kR, errors: [], error: "", value: "", initialValue: null },
  setValidityData: dt,
  disabled: void 0,
  touched: !1,
  setTouched: dt,
  dirty: !1,
  setDirty: dt,
  filled: !1,
  setFilled: dt,
  focused: !1,
  setFocused: dt,
  validate: () => null,
  validationMode: "onSubmit",
  validationDebounceTime: 0,
  shouldValidateOnChange: () => !1,
  state: { disabled: !1, valid: null, touched: !1, dirty: !1, filled: !1, focused: !1 },
  markedDirtyRef: { current: !1 },
  validation: {
    getValidationProps: (e = je) => e,
    getInputValidationProps: (e = je) => e,
    inputRef: { current: null },
    commit: async () => {},
  },
});
function Ea(e = !0) {
  const t = h.useContext(IR);
  if (t.setValidityData === dt && !e) throw new Error(Ke(28));
  return t;
}
function DR(e) {
  const { enabled: t = !0, value: n, id: r, name: o, controlRef: s, commit: i } = e,
    { formRef: a } = Wh(),
    { invalid: l, markedDirtyRef: c, validityData: u, setValidityData: d } = Ea(),
    f = J(e.getValue);
  (ee(() => {
    if (!t) return;
    let m = n;
    (m === void 0 && (m = f()),
      u.initialValue === null && m !== null && d((g) => ({ ...g, initialValue: m })));
  }, [t, d, n, u.initialValue, f]),
    ee(() => {
      !t ||
        !r ||
        a.current.fields.set(r, {
          getValue: f,
          name: o,
          controlRef: s,
          validityData: AR(u, l),
          validate(m = !0) {
            let g = n;
            (g === void 0 && (g = f()), (c.current = !0), m ? Rt.flushSync(() => i(g)) : i(g));
          },
        });
    }, [i, s, t, a, f, r, l, c, o, u, n]),
    ee(() => {
      const m = a.current.fields;
      return () => {
        r && m.delete(r);
      };
    }, [a, r]));
}
const NR = h.createContext({
  controlId: void 0,
  setControlId: dt,
  labelId: void 0,
  setLabelId: dt,
  messageIds: [],
  setMessageIds: dt,
  getDescriptionProps: (e) => e,
});
function zh() {
  return h.useContext(NR);
}
function FR(e = {}) {
  const { id: t, implicit: n = !1, controlRef: r } = e,
    { controlId: o, setControlId: s } = zh(),
    i = rn(t);
  return (
    ee(() => {
      if (!((!n && !t) || s === dt)) {
        if (n) {
          const a = r == null ? void 0 : r.current;
          ke(a) && a.closest("label") != null ? s(t ?? null) : s(o ?? i);
        } else t && s(t);
        return () => {
          t && s(void 0);
        };
      }
    }, [t, r, o, s, n, i]),
    o ?? i
  );
}
function LR(e, t) {
  const n = h.useRef(e),
    r = J(t);
  (ee(() => {
    n.current !== e && r(n.current);
  }, [e, r]),
    ee(() => {
      n.current = e;
    }, [e]));
}
const jR = h.forwardRef(function (t, n) {
    const {
        checked: r,
        className: o,
        defaultChecked: s,
        id: i,
        inputRef: a,
        name: l,
        nativeButton: c = !1,
        onCheckedChange: u,
        readOnly: d = !1,
        required: f = !1,
        disabled: m = !1,
        render: g,
        uncheckedValue: p,
        value: v,
        ...b
      } = t,
      { clearErrors: y } = Wh(),
      {
        state: w,
        setTouched: R,
        setDirty: x,
        validityData: A,
        setFilled: I,
        setFocused: P,
        shouldValidateOnChange: D,
        validationMode: V,
        disabled: B,
        name: M,
        validation: C,
      } = Ea(),
      { labelId: L } = zh(),
      k = B || m,
      F = M ?? l,
      E = J(u),
      S = h.useRef(null),
      O = Jt(S, a, C.inputRef),
      j = h.useRef(null),
      _ = rn(),
      Q = FR({ id: i, implicit: !1, controlRef: j }),
      $ = c ? void 0 : Q,
      [Y, ne] = zd({ controlled: r, default: !!s, name: "Switch", state: "checked" });
    (DR({ id: _, commit: C.commit, value: Y, controlRef: j, name: F, getValue: () => Y }),
      ee(() => {
        S.current && I(S.current.checked);
      }, [S, I]),
      LR(Y, () => {
        (y(F), x(Y !== A.initialValue), I(Y), D() ? C.commit(Y) : C.commit(Y, !0));
      }));
    const { getButtonProps: te, buttonRef: H } = Uo({ disabled: k, native: c }),
      ue = {
        id: c ? Q : _,
        role: "switch",
        "aria-checked": Y,
        "aria-readonly": d || void 0,
        "aria-required": f || void 0,
        "aria-labelledby": L,
        onFocus() {
          k || P(!0);
        },
        onBlur() {
          const N = S.current;
          !N || k || (R(!0), P(!1), V === "onBlur" && C.commit(N.checked));
        },
        onClick(N) {
          var X;
          d || k || (N.preventDefault(), (X = S == null ? void 0 : S.current) == null || X.click());
        },
      },
      le = h.useMemo(
        () =>
          Hn(
            {
              checked: Y,
              disabled: k,
              id: $,
              name: F,
              required: f,
              style: F ? Gv : da,
              tabIndex: -1,
              type: "checkbox",
              "aria-hidden": !0,
              ref: O,
              onChange(N) {
                if (N.nativeEvent.defaultPrevented) return;
                const X = N.target.checked,
                  q = Te(Un, N.nativeEvent);
                (E == null || E(X, q), !q.isCanceled && ne(X));
              },
              onFocus() {
                var N;
                (N = j.current) == null || N.focus();
              },
            },
            C.getInputValidationProps,
            v !== void 0 ? { value: v } : je,
          ),
        [Y, k, O, $, F, E, f, ne, C, v],
      ),
      ce = h.useMemo(
        () => ({ ...w, checked: Y, disabled: k, readOnly: d, required: f }),
        [w, Y, k, d, f],
      ),
      pe = We("span", t, {
        state: ce,
        ref: [n, j, H],
        props: [ue, C.getValidationProps, b, te],
        stateAttributesMapping: $h,
      });
    return T.jsxs(Bh.Provider, {
      value: ce,
      children: [
        pe,
        !Y && F && p !== void 0 && T.jsx("input", { type: "hidden", name: F, value: p }),
        T.jsx("input", { ...le }),
      ],
    });
  }),
  VR = h.forwardRef(function (t, n) {
    const { render: r, className: o, ...s } = t,
      { state: i } = Ea(),
      a = PR(),
      l = { ...i, ...a };
    return We("span", t, { state: l, ref: n, stateAttributesMapping: $h, props: s });
  });
function BR({ className: e, size: t = "default", ...n }) {
  return T.jsx(jR, {
    "data-slot": "switch",
    "data-size": t,
    className: ye(
      "data-checked:bg-primary data-unchecked:bg-input focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:aria-invalid:border-destructive/50 dark:data-unchecked:bg-input/80 shrink-0 rounded-full border border-transparent focus-visible:ring-1 aria-invalid:ring-1 data-[size=default]:h-[18.4px] data-[size=default]:w-[32px] data-[size=sm]:h-[14px] data-[size=sm]:w-[24px] peer group/switch relative inline-flex items-center transition-all outline-none after:absolute after:-inset-x-3 after:-inset-y-2 data-disabled:cursor-not-allowed data-disabled:opacity-50",
      e,
    ),
    ...n,
    children: T.jsx(VR, {
      "data-slot": "switch-thumb",
      className:
        "bg-background dark:data-unchecked:bg-foreground dark:data-checked:bg-primary-foreground rounded-full group-data-[size=default]/switch:size-4 group-data-[size=sm]/switch:size-3 group-data-[size=default]/switch:data-checked:translate-x-[calc(100%-2px)] group-data-[size=sm]/switch:data-checked:translate-x-[calc(100%-2px)] group-data-[size=default]/switch:data-unchecked:translate-x-0 group-data-[size=sm]/switch:data-unchecked:translate-x-0 pointer-events-none block ring-0 transition-transform",
    }),
  });
}
function $R({ stack: e, onToggle: t }) {
  const n = e.yolo === "true";
  return T.jsxs(fi, {
    delay: 100,
    children: [
      T.jsxs(hi, {
        render: T.jsx("div", { className: "flex w-full items-center gap-3 p-3" }),
        children: [
          T.jsx(om, { className: "h-4 w-4 shrink-0" }),
          T.jsxs("div", {
            className: "flex flex-1 flex-col items-start",
            children: [
              T.jsx("div", { className: "font-medium text-sm", children: "YOLO Mode" }),
              T.jsx("div", {
                className: "text-muted-foreground text-xs",
                children: n ? "Enabled" : "Disabled",
              }),
            ],
          }),
          T.jsx(BR, {
            checked: n,
            onCheckedChange: (r) => t(r ? "true" : "false"),
            className: ye(n && "data-[state=checked]:bg-destructive"),
          }),
        ],
      }),
      T.jsx(mi, {
        side: "top",
        align: "start",
        className: "max-w-xs",
        children: T.jsx("p", {
          className: "text-xs",
          children:
            "Disables all validation and adds --yolo flag to the command. Use at your own risk!",
        }),
      }),
    ],
  });
}
function Cs(e) {
  return e.replace(/\s+/g, "-");
}
const _R = () => {
  const [e, t, n, r] = bR();
  h.useEffect(() => {
    console.log("[StackBuilder] Stack state:", e);
  }, [e]);
  const [o, s] = h.useState(""),
    [i, a] = h.useState(!1),
    [l, c] = h.useState(null),
    [, u] = h.useState([]),
    d = h.useRef({}),
    f = h.useRef(null),
    m = h.useRef(null),
    g = h.useRef("");
  h.useEffect(() => {
    if (m.current) {
      const M = m.current.querySelector('[data-slot="scroll-area-viewport"]');
      M && (f.current = M);
    }
  }, [n]);
  const p = CR(e),
    v = ER(e.projectName || ""),
    b = () => {
      const M = p.adjustedStack || e,
        C = M.projectName || "my-better-t-app",
        L = Cs(C),
        k = { ...M, projectName: L };
      return wR(k);
    },
    y = () => {
      var C;
      const M = {};
      for (const L of gi) {
        const k = Cn[L] || [];
        if (k.length === 0) continue;
        const F = L;
        if (
          F === "webFrontend" ||
          F === "nativeFrontend" ||
          F === "codeQuality" ||
          F === "documentation" ||
          F === "appPlatforms" ||
          F === "examples"
        )
          if (F === "webFrontend" || F === "nativeFrontend") {
            const E = Math.floor(Math.random() * k.length),
              S = k[E].id;
            M[F] = [S];
          } else {
            const E = Math.floor(Math.random() * Math.min(k.length, 4));
            if (E === 0) M[F] = [];
            else {
              const S = [...k]
                .filter((O) => O.id !== "none")
                .sort(() => 0.5 - Math.random())
                .slice(0, E);
              M[F] = S.map((O) => O.id);
            }
          }
        else {
          const E = Math.floor(Math.random() * k.length);
          M[F] = k[E].id;
        }
      }
      (h.startTransition(() => {
        t({ ...M, projectName: e.projectName || "my-better-t-app" });
      }),
        (C = f.current) == null || C.scrollTo(0, 0));
    },
    w = (() => {
      const M = [],
        C = e.ecosystem === "rust" ? $c : pi;
      for (const L of C) {
        const k = L,
          F = Cn[L],
          E = e[k],
          S = xr(L);
        if (F)
          if (Array.isArray(E)) {
            if (E.length === 0 || (E.length === 1 && E[0] === "none")) continue;
            for (const O of E) {
              if (O === "none") continue;
              const j = F.find((_) => _.id === O);
              j &&
                M.push(
                  T.jsxs(
                    "div",
                    {
                      className: ye(
                        "flex items-center gap-3 rounded-lg border p-2.5 transition-colors",
                        Wc(L),
                      ),
                      children: [
                        j.icon !== "" &&
                          T.jsx("div", {
                            className:
                              "flex h-8 w-8 shrink-0 items-center justify-center rounded-md bg-muted/50",
                            children: T.jsx(fn, {
                              icon: j.icon,
                              name: j.name,
                              className: ye("h-5 w-5", j.className),
                            }),
                          }),
                        T.jsxs("div", {
                          className: "min-w-0 flex-1",
                          children: [
                            T.jsx("p", {
                              className:
                                "mb-0.5 truncate text-[10px] font-medium uppercase tracking-wider text-muted-foreground/70",
                              children: S,
                            }),
                            T.jsx("p", {
                              className: "truncate font-medium text-foreground text-sm",
                              children: j.name,
                            }),
                          ],
                        }),
                      ],
                    },
                    `${L}-${j.id}`,
                  ),
                );
            }
          } else {
            const O = F.find((j) => j.id === E);
            if (
              !O ||
              O.id === "none" ||
              O.id === "false" ||
              ((L === "git" || L === "install" || L === "auth") && O.id === "true")
            )
              continue;
            M.push(
              T.jsxs(
                "div",
                {
                  className: ye(
                    "flex items-center gap-3 rounded-lg border p-2.5 transition-colors",
                    Wc(L),
                  ),
                  children: [
                    O.icon !== "" &&
                      T.jsx("div", {
                        className:
                          "flex h-8 w-8 shrink-0 items-center justify-center rounded-md bg-muted/50",
                        children: T.jsx(fn, {
                          icon: O.icon,
                          name: O.name,
                          className: ye("h-5 w-5", O.className),
                        }),
                      }),
                    T.jsxs("div", {
                      className: "min-w-0 flex-1",
                      children: [
                        T.jsx("p", {
                          className:
                            "mb-0.5 truncate text-[10px] font-medium uppercase tracking-wider text-muted-foreground/70",
                          children: S,
                        }),
                        T.jsx("p", {
                          className: "truncate font-medium text-foreground text-sm",
                          children: O.name,
                        }),
                      ],
                    }),
                  ],
                },
                `${L}-${O.id}`,
              ),
            );
          }
      }
      return M;
    })();
  (h.useEffect(() => {
    const M = localStorage.getItem("betterTStackPreference");
    if (M)
      try {
        const C = JSON.parse(M);
        c(C);
      } catch (C) {
        (console.error("Failed to parse saved stack", C),
          localStorage.removeItem("betterTStackPreference"));
      }
  }, []),
    h.useEffect(() => {
      if (p.adjustedStack) {
        const M = JSON.stringify(p.adjustedStack);
        g.current !== M &&
          h.startTransition(() => {
            if (p.changes.length > 0) {
              if (p.changes.length === 1) sr.info(p.changes[0].message, { duration: 4e3 });
              else if (p.changes.length > 1) {
                const C = `${p.changes.length} compatibility adjustments made:
${p.changes.map((L) => ` ${L.message}`).join(`
`)}`;
                sr.info(C, { duration: 5e3 });
              }
            }
            (u(p.changes), p.adjustedStack && t(p.adjustedStack), (g.current = M));
          });
      }
    }, [p.adjustedStack, p.changes, t]),
    h.useEffect(() => {
      const M = p.adjustedStack || e,
        C = M.projectName || "my-better-t-app",
        L = Cs(C),
        k = { ...M, projectName: L },
        F = xR(k);
      s(F);
    }, [e, p.adjustedStack]));
  const R = (M, C) => {
      if (
        (console.log("[StackBuilder] handleTechSelect called:", {
          category: M,
          techId: C,
          stack: e,
        }),
        !cr(e, M, C))
      ) {
        console.log("[StackBuilder] Option not compatible, returning early");
        return;
      }
      (console.log("[StackBuilder] Option is compatible, updating state"),
        h.startTransition(() => {
          t((L) => {
            const k = M,
              F = {},
              E = L[k];
            if (
              k === "webFrontend" ||
              k === "nativeFrontend" ||
              k === "codeQuality" ||
              k === "documentation" ||
              k === "appPlatforms" ||
              k === "examples"
            ) {
              const S = Array.isArray(E) ? [...E] : [];
              let O = [...S];
              const j = S.includes(C);
              k === "webFrontend"
                ? C === "none"
                  ? (O = ["none"])
                  : j
                    ? S.length > 1
                      ? (O = O.filter(($) => $ !== C))
                      : (O = ["none"])
                    : (O = [C])
                : k === "nativeFrontend"
                  ? C === "none"
                    ? (O = ["none"])
                    : j
                      ? (O = ["none"])
                      : (O = [C])
                  : (j ? (O = O.filter(($) => $ !== C)) : O.push(C),
                    O.length > 1 && (O = O.filter(($) => $ !== "none")),
                    (O.length === 0 &&
                      (k === "codeQuality" ||
                        k === "documentation" ||
                        k === "appPlatforms" ||
                        k === "examples")) ||
                      (O.length === 0 && (O = ["none"])));
              const _ = [...new Set(O)].sort(),
                Q = [...new Set(S)].sort();
              JSON.stringify(_) !== JSON.stringify(Q) && (F[k] = _);
            } else
              E !== C
                ? (F[k] = C)
                : (M === "git" || M === "install") && C === "false"
                  ? (F[k] = "true")
                  : (M === "git" || M === "install") && C === "true" && (F[k] = "false");
            return Object.keys(F).length > 0 ? F : {};
          });
        }));
    },
    x = () => {
      (navigator.clipboard.writeText(o), a(!0), setTimeout(() => a(!1), 2e3));
    },
    A = () => {
      var M;
      (h.startTransition(() => {
        t(fe);
      }),
        (M = f.current) == null || M.scrollTo(0, 0));
    },
    I = () => {
      const M = p.adjustedStack || e,
        C = M.projectName || "my-better-t-app",
        L = Cs(C),
        k = { ...M, projectName: L };
      (localStorage.setItem("betterTStackPreference", JSON.stringify(k)),
        c(k),
        sr.success("Your stack configuration has been saved"));
    },
    P = () => {
      var M;
      l &&
        (h.startTransition(() => {
          t(l);
        }),
        (M = f.current) == null || M.scrollTo(0, 0),
        sr.success("Saved configuration loaded"));
    },
    D = (M) => {
      var L;
      const C = _c.find((k) => k.id === M);
      C &&
        (h.startTransition(() => {
          t({ ...fe, ...C.stack });
        }),
        (L = f.current) == null || L.scrollTo(0, 0),
        sr.success(`Applied preset: ${C.name}`));
    },
    [V, B] = h.useState("configure");
  return T.jsx(Lh, {
    children: T.jsxs("div", {
      className:
        "flex flex-col h-full w-full overflow-hidden border-border text-foreground sm:grid sm:grid-cols-[auto_1fr]",
      children: [
        T.jsxs("div", {
          className: "flex border-b border-border bg-fd-background pl-2 sm:hidden",
          children: [
            T.jsxs("button", {
              type: "button",
              onClick: () => B("summary"),
              className: ye(
                "flex flex-1 items-center justify-center gap-2 border-b-2 px-1 py-3 text-xs font-medium transition-all hover:bg-muted/50",
                V === "summary"
                  ? "border-primary text-primary"
                  : "border-transparent text-muted-foreground hover:text-foreground",
              ),
              children: [
                T.jsx(um, { className: "h-4 w-4" }),
                T.jsx("span", { children: "Summary" }),
              ],
            }),
            T.jsxs("button", {
              type: "button",
              onClick: () => B("configure"),
              className: ye(
                "flex flex-1 items-center justify-center gap-2 border-b-2 px-1 py-3 text-xs font-medium transition-all hover:bg-muted/50",
                V === "configure"
                  ? "border-primary text-primary"
                  : "border-transparent text-muted-foreground hover:text-foreground",
              ),
              children: [
                T.jsx(ln, { className: "h-4 w-4" }),
                T.jsx("span", { children: "Configure" }),
              ],
            }),
          ],
        }),
        T.jsx("div", {
          className: ye(
            "flex w-full flex-col border-border sm:border-r sm:max-w-3xs md:max-w-xs lg:max-w-sm",
            V === "summary" ? "flex" : "hidden sm:flex",
          ),
          children: T.jsx(Es, {
            className: "flex-1",
            children: T.jsxs("div", {
              className: "flex h-full flex-col gap-3 p-3 sm:p-4 md:h-[calc(100vh-64px)]",
              children: [
                T.jsxs("div", {
                  className: "flex flex-1 flex-col gap-3 overflow-hidden",
                  children: [
                    T.jsxs("label", {
                      className: "flex shrink-0 flex-col",
                      children: [
                        T.jsx("span", {
                          className: "mb-1 text-muted-foreground text-xs",
                          children: "Project Name:",
                        }),
                        T.jsx("input", {
                          type: "text",
                          value: e.projectName || "",
                          onChange: (M) => {
                            t({ projectName: M.target.value });
                          },
                          className: ye(
                            "w-full rounded border px-2 py-1 text-sm focus:outline-none",
                            v
                              ? "border-destructive bg-destructive/10 text-destructive-foreground"
                              : "border-border focus:border-primary",
                          ),
                          placeholder: "my-better-t-app",
                        }),
                        v &&
                          T.jsx("p", { className: "mt-1 text-destructive text-xs", children: v }),
                        (e.projectName || "my-better-t-app").includes(" ") &&
                          T.jsxs("p", {
                            className: "mt-1 text-muted-foreground text-xs",
                            children: [
                              "Will be saved as:",
                              " ",
                              T.jsx("code", {
                                className: "rounded bg-muted px-1 py-0.5 text-xs",
                                children: (e.projectName || "my-better-t-app").replace(/\s+/g, "-"),
                              }),
                            ],
                          }),
                      ],
                    }),
                    T.jsxs("div", {
                      className: "shrink-0 rounded border border-border p-2",
                      children: [
                        T.jsxs("div", {
                          className: "flex",
                          children: [
                            T.jsx("span", {
                              className: "mr-2 select-none text-chart-4",
                              children: "$",
                            }),
                            T.jsx("code", {
                              className: "block break-all text-muted-foreground text-xs sm:text-sm",
                              children: o,
                            }),
                          ],
                        }),
                        T.jsx("div", {
                          className: "mt-2 flex justify-end",
                          children: T.jsx("button", {
                            type: "button",
                            onClick: x,
                            className: ye(
                              "flex items-center gap-1 rounded px-2 py-1 text-xs transition-colors",
                              i
                                ? "bg-muted text-chart-4"
                                : "text-muted-foreground hover:bg-muted hover:text-foreground",
                            ),
                            title: i ? "Copied!" : "Copy command",
                            children: i
                              ? T.jsxs(T.Fragment, {
                                  children: [
                                    T.jsx(Yc, { className: "h-3 w-3 shrink-0" }),
                                    T.jsx("span", { className: "", children: "Copied" }),
                                  ],
                                })
                              : T.jsxs(T.Fragment, {
                                  children: [
                                    T.jsx(lm, { className: "h-3 w-3 shrink-0" }),
                                    T.jsx("span", { className: "", children: "Copy" }),
                                  ],
                                }),
                          }),
                        }),
                      ],
                    }),
                    T.jsxs("div", {
                      className: "flex flex-1 flex-col overflow-hidden",
                      children: [
                        T.jsxs("h3", {
                          className: "mb-2 font-medium text-foreground text-sm",
                          children: ["Selected Stack (", w.length, ")"],
                        }),
                        T.jsx("div", {
                          className: "flex-1 overflow-y-auto pr-1",
                          children: T.jsx("div", {
                            className: "flex flex-col gap-2 pb-2",
                            children: w,
                          }),
                        }),
                      ],
                    }),
                  ],
                }),
                T.jsx("div", {
                  className: "mt-auto border-border border-t pt-4",
                  children: T.jsxs("div", {
                    className: "space-y-3",
                    children: [
                      T.jsx(SR, {
                        onReset: A,
                        onRandom: y,
                        onSave: I,
                        onLoad: P,
                        hasSavedStack: !!l,
                      }),
                      T.jsxs("div", {
                        className: "flex gap-1",
                        children: [
                          T.jsx(RR, { stackUrl: b() }),
                          T.jsx(TR, { onApplyPreset: D }),
                          T.jsxs(Sh, {
                            children: [
                              T.jsxs(Th, {
                                render: T.jsx("button", {
                                  type: "button",
                                  className:
                                    "flex flex-1 items-center justify-center gap-1.5 rounded-md border border-border bg-fd-background px-2 py-1.5 font-medium text-muted-foreground text-xs transition-all hover:border-muted-foreground/30 hover:bg-muted hover:text-foreground",
                                }),
                                children: [
                                  T.jsx(Xc, { className: "h-3 w-3" }),
                                  "Settings",
                                  T.jsx(qc, { className: "ml-auto h-3 w-3" }),
                                ],
                              }),
                              T.jsx(Rh, {
                                align: "end",
                                className: "w-64 bg-fd-background",
                                children: T.jsx($R, { stack: e, onToggle: (M) => t({ yolo: M }) }),
                              }),
                            ],
                          }),
                        ],
                      }),
                    ],
                  }),
                }),
              ],
            }),
          }),
        }),
        T.jsxs("div", {
          className: ye(
            "flex flex-1 flex-col overflow-hidden",
            V === "summary" ? "hidden sm:flex" : "flex",
          ),
          children: [
            T.jsxs(KT, {
              value: n,
              onValueChange: (M) => {
                h.startTransition(() => {
                  r(M);
                });
              },
              className: "hidden sm:flex sm:flex-col sm:flex-1 sm:overflow-hidden",
              children: [
                T.jsx("div", {
                  className: "flex items-center border-b border-border bg-fd-background sm:px-2",
                  children: T.jsx(ZT, {
                    variant: "line",
                    className: "h-auto w-full justify-start gap-4 rounded-none bg-transparent p-0",
                    children: T.jsxs(JT, {
                      value: "command",
                      className:
                        "relative gap-2 rounded-none border-b-2 border-transparent bg-transparent px-2 py-3 text-xs font-medium text-muted-foreground transition-none data-active:border-primary data-active:bg-transparent data-active:text-foreground data-active:shadow-none hover:text-foreground",
                      children: [T.jsx(ln, { className: "h-3.5 w-3.5" }), "Configure"],
                    }),
                  }),
                }),
                T.jsx(eR, {
                  value: "command",
                  className: "flex-1 min-h-0 overflow-hidden",
                  children: T.jsx("div", {
                    ref: m,
                    className: "h-full",
                    children: T.jsx(Es, {
                      className: "h-full overflow-hidden scroll-smooth",
                      children: T.jsxs("main", {
                        className: "p-3 sm:p-4",
                        children: [
                          T.jsxs("div", {
                            className: "mb-6 sm:mb-8",
                            children: [
                              T.jsxs("div", {
                                className:
                                  "mb-3 flex items-center border-border border-b pb-2 text-muted-foreground",
                                children: [
                                  T.jsx(ln, { className: "mr-2 h-4 w-4 shrink-0 sm:h-5 sm:w-5" }),
                                  T.jsx("h2", {
                                    className:
                                      "font-semibold font-mono text-foreground text-sm sm:text-base",
                                    children: "Ecosystem",
                                  }),
                                ],
                              }),
                              T.jsx("div", {
                                className: "flex gap-3",
                                children: sm.map((M) => {
                                  const C = e.ecosystem === M.id;
                                  return T.jsxs(
                                    un.button,
                                    {
                                      type: "button",
                                      className: ye(
                                        "group relative flex flex-1 cursor-pointer items-center gap-3 rounded-xl border-2 px-4 py-4 transition-all",
                                        C
                                          ? "border-primary bg-primary/5 ring-2 ring-primary/20"
                                          : "border-border bg-fd-background hover:border-primary/30 hover:bg-muted/5",
                                      ),
                                      whileHover: { scale: 1.01 },
                                      whileTap: { scale: 0.99 },
                                      onClick: () => {
                                        h.startTransition(() => {
                                          t({ ecosystem: M.id });
                                        });
                                      },
                                      children: [
                                        T.jsx("div", {
                                          className: ye(
                                            "flex h-12 w-12 shrink-0 items-center justify-center rounded-lg transition-colors",
                                            C
                                              ? "bg-primary/10"
                                              : "bg-muted/50 group-hover:bg-muted",
                                          ),
                                          children: T.jsx(fn, {
                                            icon: M.icon,
                                            name: M.name,
                                            className: ye(
                                              "h-6 w-6",
                                              M.id === "rust" && "invert-0 dark:invert",
                                            ),
                                          }),
                                        }),
                                        T.jsxs("div", {
                                          className: "text-left",
                                          children: [
                                            T.jsx("span", {
                                              className: ye(
                                                "block font-semibold text-base",
                                                C ? "text-primary" : "text-foreground",
                                              ),
                                              children: M.name,
                                            }),
                                            T.jsx("p", {
                                              className: "text-muted-foreground text-xs",
                                              children: M.description,
                                            }),
                                          ],
                                        }),
                                      ],
                                    },
                                    M.id,
                                  );
                                }),
                              }),
                            ],
                          }),
                          (e.ecosystem === "rust" ? $c : pi).map((M) => {
                            var F;
                            if (M === "astroIntegration") return null;
                            const C = Cn[M] || [],
                              L = xr(M),
                              k = C;
                            return k.length === 0
                              ? null
                              : T.jsxs(
                                  "div",
                                  {
                                    children: [
                                      T.jsxs("section", {
                                        ref: (E) => {
                                          d.current[M] = E;
                                        },
                                        id: `section-${M}`,
                                        className: "mb-6 scroll-mt-4 sm:mb-8",
                                        children: [
                                          T.jsxs("div", {
                                            className:
                                              "mb-3 flex items-center border-border border-b pb-2 text-muted-foreground",
                                            children: [
                                              T.jsx(ln, {
                                                className: "mr-2 h-4 w-4 shrink-0 sm:h-5 sm:w-5",
                                              }),
                                              T.jsx("h2", {
                                                className:
                                                  "font-semibold font-mono text-foreground text-sm sm:text-base",
                                                children: L,
                                              }),
                                              ((F = p.notes[M]) == null ? void 0 : F.hasIssue) &&
                                                T.jsxs(fi, {
                                                  delay: 100,
                                                  children: [
                                                    T.jsx(hi, {
                                                      render: T.jsx(Aa, {
                                                        className:
                                                          "ml-2 h-4 w-4 shrink-0 cursor-help text-muted-foreground",
                                                      }),
                                                    }),
                                                    T.jsx(mi, {
                                                      side: "top",
                                                      align: "start",
                                                      children: T.jsx("ul", {
                                                        className:
                                                          "list-disc space-y-1 pl-4 text-xs",
                                                        children: p.notes[M].notes.map((E) =>
                                                          T.jsx("li", { children: E }, E),
                                                        ),
                                                      }),
                                                    }),
                                                  ],
                                                }),
                                            ],
                                          }),
                                          T.jsx("div", {
                                            className:
                                              "grid grid-cols-1 gap-2 sm:grid-cols-2 sm:gap-3 lg:grid-cols-3 2xl:grid-cols-4",
                                            children: k.map((E) => {
                                              let S = !1;
                                              const O = M,
                                                j = e[O];
                                              O === "codeQuality" ||
                                              O === "documentation" ||
                                              O === "appPlatforms" ||
                                              O === "examples" ||
                                              O === "webFrontend" ||
                                              O === "nativeFrontend"
                                                ? (S = (j || []).includes(E.id))
                                                : (S = j === E.id);
                                              const _ = !cr(e, M, E.id),
                                                Q = _ ? bi(e, M, E.id) : null;
                                              return T.jsxs(
                                                un.div,
                                                {
                                                  className: ye(
                                                    "group relative cursor-pointer rounded-lg border p-3 transition-all sm:p-4",
                                                    S
                                                      ? "border-primary bg-primary/5 ring-1 ring-primary/20"
                                                      : _
                                                        ? "border-destructive/30 bg-destructive/5 opacity-50 hover:opacity-75"
                                                        : "border-border bg-fd-background hover:border-primary/30 hover:bg-muted/5",
                                                  ),
                                                  whileHover: { scale: 1.01 },
                                                  whileTap: { scale: 0.99 },
                                                  onClick: ($) => {
                                                    ($.stopPropagation(), R(M, E.id));
                                                  },
                                                  title: Q || void 0,
                                                  children: [
                                                    E.default &&
                                                      !S &&
                                                      T.jsx("span", {
                                                        className:
                                                          "absolute top-2 right-2 rounded-full bg-muted px-2 py-0.5 font-medium text-[10px] text-muted-foreground",
                                                        children: "Default",
                                                      }),
                                                    T.jsxs("div", {
                                                      className: "flex items-start gap-3",
                                                      children: [
                                                        E.icon !== "" &&
                                                          T.jsx("div", {
                                                            className: ye(
                                                              "flex h-10 w-10 shrink-0 items-center justify-center rounded-lg transition-colors",
                                                              S
                                                                ? "bg-primary/10"
                                                                : "bg-muted/50 group-hover:bg-muted",
                                                            ),
                                                            children: T.jsx(fn, {
                                                              icon: E.icon,
                                                              name: E.name,
                                                              className: ye("h-5 w-5", E.className),
                                                            }),
                                                          }),
                                                        T.jsxs("div", {
                                                          className: "min-w-0 flex-1 pt-0.5",
                                                          children: [
                                                            T.jsx("span", {
                                                              className: ye(
                                                                "block font-semibold text-sm",
                                                                S
                                                                  ? "text-primary"
                                                                  : "text-foreground",
                                                              ),
                                                              children: E.name,
                                                            }),
                                                            T.jsx("p", {
                                                              className:
                                                                "mt-0.5 line-clamp-2 text-muted-foreground text-xs leading-relaxed",
                                                              children: E.description,
                                                            }),
                                                          ],
                                                        }),
                                                      ],
                                                    }),
                                                  ],
                                                },
                                                E.id,
                                              );
                                            }),
                                          }),
                                        ],
                                      }),
                                      M === "webFrontend" &&
                                        T.jsx(Dl, {
                                          children:
                                            e.webFrontend.includes("astro") &&
                                            T.jsxs(un.section, {
                                              initial: { opacity: 0, height: 0 },
                                              animate: { opacity: 1, height: "auto" },
                                              exit: { opacity: 0, height: 0 },
                                              transition: { duration: 0.3, ease: "easeInOut" },
                                              className: "mb-6 scroll-mt-4 sm:mb-8 overflow-hidden",
                                              children: [
                                                T.jsxs("div", {
                                                  className:
                                                    "mb-3 flex items-center border-border border-b pb-2 text-muted-foreground",
                                                  children: [
                                                    T.jsx(ln, {
                                                      className:
                                                        "mr-2 h-4 w-4 shrink-0 sm:h-5 sm:w-5",
                                                    }),
                                                    T.jsx("h2", {
                                                      className:
                                                        "font-semibold font-mono text-foreground text-sm sm:text-base",
                                                      children: "Astro Integration",
                                                    }),
                                                  ],
                                                }),
                                                T.jsx("div", {
                                                  className:
                                                    "grid grid-cols-1 gap-2 sm:grid-cols-2 sm:gap-3 lg:grid-cols-3 2xl:grid-cols-4",
                                                  children: (Cn.astroIntegration || []).map((E) => {
                                                    const S = e.astroIntegration === E.id,
                                                      O = !cr(e, "astroIntegration", E.id),
                                                      j = O
                                                        ? bi(e, "astroIntegration", E.id)
                                                        : null;
                                                    return T.jsxs(
                                                      un.div,
                                                      {
                                                        className: ye(
                                                          "group relative cursor-pointer rounded-lg border p-3 transition-all sm:p-4",
                                                          S
                                                            ? "border-primary bg-primary/5 ring-1 ring-primary/20"
                                                            : O
                                                              ? "border-destructive/30 bg-destructive/5 opacity-50 hover:opacity-75"
                                                              : "border-border bg-fd-background hover:border-primary/30 hover:bg-muted/5",
                                                        ),
                                                        whileHover: { scale: 1.01 },
                                                        whileTap: { scale: 0.99 },
                                                        onClick: (_) => {
                                                          (_.stopPropagation(),
                                                            R("astroIntegration", E.id));
                                                        },
                                                        title: j || void 0,
                                                        children: [
                                                          E.default &&
                                                            !S &&
                                                            T.jsx("span", {
                                                              className:
                                                                "absolute top-2 right-2 rounded-full bg-muted px-2 py-0.5 font-medium text-[10px] text-muted-foreground",
                                                              children: "Default",
                                                            }),
                                                          T.jsxs("div", {
                                                            className: "flex items-start gap-3",
                                                            children: [
                                                              E.icon !== "" &&
                                                                T.jsx("div", {
                                                                  className: ye(
                                                                    "flex h-10 w-10 shrink-0 items-center justify-center rounded-lg transition-colors",
                                                                    S
                                                                      ? "bg-primary/10"
                                                                      : "bg-muted/50 group-hover:bg-muted",
                                                                  ),
                                                                  children: T.jsx(fn, {
                                                                    icon: E.icon,
                                                                    name: E.name,
                                                                    className: ye(
                                                                      "h-5 w-5",
                                                                      E.className,
                                                                    ),
                                                                  }),
                                                                }),
                                                              T.jsxs("div", {
                                                                className: "min-w-0 flex-1 pt-0.5",
                                                                children: [
                                                                  T.jsx("span", {
                                                                    className: ye(
                                                                      "block font-semibold text-sm",
                                                                      S
                                                                        ? "text-primary"
                                                                        : "text-foreground",
                                                                    ),
                                                                    children: E.name,
                                                                  }),
                                                                  T.jsx("p", {
                                                                    className:
                                                                      "mt-0.5 line-clamp-2 text-muted-foreground text-xs leading-relaxed",
                                                                    children: E.description,
                                                                  }),
                                                                ],
                                                              }),
                                                            ],
                                                          }),
                                                        ],
                                                      },
                                                      E.id,
                                                    );
                                                  }),
                                                }),
                                              ],
                                            }),
                                        }),
                                    ],
                                  },
                                  M,
                                );
                          }),
                          T.jsx("div", { className: "h-10" }),
                        ],
                      }),
                    }),
                  }),
                }),
              ],
            }),
            T.jsx("div", {
              className: "flex flex-1 flex-col overflow-hidden sm:hidden",
              children:
                V === "configure" &&
                T.jsx(Es, {
                  className: "h-full overflow-hidden scroll-smooth",
                  children: T.jsxs("main", {
                    className: "p-3",
                    children: [
                      gi.map((M) => {
                        var F;
                        if (M === "astroIntegration") return null;
                        const C = Cn[M] || [],
                          L = xr(M),
                          k = C;
                        return k.length === 0
                          ? null
                          : T.jsxs(
                              "div",
                              {
                                children: [
                                  T.jsxs("section", {
                                    id: `section-mobile-${M}`,
                                    className: "mb-6 scroll-mt-4",
                                    children: [
                                      T.jsxs("div", {
                                        className:
                                          "mb-3 flex items-center border-border border-b pb-2 text-muted-foreground",
                                        children: [
                                          T.jsx(ln, { className: "mr-2 h-4 w-4 shrink-0" }),
                                          T.jsx("h2", {
                                            className:
                                              "font-semibold font-mono text-foreground text-sm",
                                            children: L,
                                          }),
                                          ((F = p.notes[M]) == null ? void 0 : F.hasIssue) &&
                                            T.jsxs(fi, {
                                              delay: 100,
                                              children: [
                                                T.jsx(hi, {
                                                  render: T.jsx(Aa, {
                                                    className:
                                                      "ml-2 h-4 w-4 shrink-0 cursor-help text-muted-foreground",
                                                  }),
                                                }),
                                                T.jsx(mi, {
                                                  side: "top",
                                                  align: "start",
                                                  children: T.jsx("ul", {
                                                    className: "list-disc space-y-1 pl-4 text-xs",
                                                    children: p.notes[M].notes.map((E) =>
                                                      T.jsx("li", { children: E }, E),
                                                    ),
                                                  }),
                                                }),
                                              ],
                                            }),
                                        ],
                                      }),
                                      T.jsx("div", {
                                        className: "grid grid-cols-1 gap-2",
                                        children: k.map((E) => {
                                          let S = !1;
                                          const O = M,
                                            j = e[O];
                                          O === "codeQuality" ||
                                          O === "documentation" ||
                                          O === "appPlatforms" ||
                                          O === "examples" ||
                                          O === "webFrontend" ||
                                          O === "nativeFrontend"
                                            ? (S = (j || []).includes(E.id))
                                            : (S = j === E.id);
                                          const _ = !cr(e, M, E.id);
                                          return T.jsxs(
                                            un.div,
                                            {
                                              className: ye(
                                                "group relative cursor-pointer rounded-lg border p-3 transition-all",
                                                S
                                                  ? "border-primary bg-primary/5 ring-1 ring-primary/20"
                                                  : _
                                                    ? "border-destructive/30 bg-destructive/5 opacity-50"
                                                    : "border-border bg-fd-background hover:border-primary/30 hover:bg-muted/5",
                                              ),
                                              whileTap: { scale: 0.98 },
                                              onClick: () => R(M, E.id),
                                              children: [
                                                E.default &&
                                                  !S &&
                                                  T.jsx("span", {
                                                    className:
                                                      "absolute top-2 right-2 rounded-full bg-muted px-2 py-0.5 font-medium text-[10px] text-muted-foreground",
                                                    children: "Default",
                                                  }),
                                                T.jsxs("div", {
                                                  className: "flex items-start gap-3",
                                                  children: [
                                                    E.icon !== "" &&
                                                      T.jsx("div", {
                                                        className: ye(
                                                          "flex h-10 w-10 shrink-0 items-center justify-center rounded-lg transition-colors",
                                                          S ? "bg-primary/10" : "bg-muted/50",
                                                        ),
                                                        children: T.jsx(fn, {
                                                          icon: E.icon,
                                                          name: E.name,
                                                          className: ye("h-5 w-5", E.className),
                                                        }),
                                                      }),
                                                    T.jsxs("div", {
                                                      className: "min-w-0 flex-1 pt-0.5",
                                                      children: [
                                                        T.jsx("span", {
                                                          className: ye(
                                                            "block font-semibold text-sm",
                                                            S ? "text-primary" : "text-foreground",
                                                          ),
                                                          children: E.name,
                                                        }),
                                                        T.jsx("p", {
                                                          className:
                                                            "mt-0.5 line-clamp-2 text-muted-foreground text-xs leading-relaxed",
                                                          children: E.description,
                                                        }),
                                                      ],
                                                    }),
                                                  ],
                                                }),
                                              ],
                                            },
                                            E.id,
                                          );
                                        }),
                                      }),
                                    ],
                                  }),
                                  M === "webFrontend" &&
                                    T.jsx(Dl, {
                                      children:
                                        e.webFrontend.includes("astro") &&
                                        T.jsxs(un.section, {
                                          initial: { opacity: 0, height: 0 },
                                          animate: { opacity: 1, height: "auto" },
                                          exit: { opacity: 0, height: 0 },
                                          transition: { duration: 0.3, ease: "easeInOut" },
                                          className: "mb-6 scroll-mt-4 overflow-hidden",
                                          children: [
                                            T.jsxs("div", {
                                              className:
                                                "mb-3 flex items-center border-border border-b pb-2 text-muted-foreground",
                                              children: [
                                                T.jsx(ln, { className: "mr-2 h-4 w-4 shrink-0" }),
                                                T.jsx("h2", {
                                                  className:
                                                    "font-semibold font-mono text-foreground text-sm",
                                                  children: "Astro Integration",
                                                }),
                                              ],
                                            }),
                                            T.jsx("div", {
                                              className: "grid grid-cols-1 gap-2",
                                              children: (Cn.astroIntegration || []).map((E) => {
                                                const S = e.astroIntegration === E.id,
                                                  O = !cr(e, "astroIntegration", E.id);
                                                return T.jsxs(
                                                  un.div,
                                                  {
                                                    className: ye(
                                                      "group relative cursor-pointer rounded-lg border p-3 transition-all",
                                                      S
                                                        ? "border-primary bg-primary/5 ring-1 ring-primary/20"
                                                        : O
                                                          ? "border-destructive/30 bg-destructive/5 opacity-50"
                                                          : "border-border bg-fd-background hover:border-primary/30 hover:bg-muted/5",
                                                    ),
                                                    whileTap: { scale: 0.98 },
                                                    onClick: () => R("astroIntegration", E.id),
                                                    children: [
                                                      E.default &&
                                                        !S &&
                                                        T.jsx("span", {
                                                          className:
                                                            "absolute top-2 right-2 rounded-full bg-muted px-2 py-0.5 font-medium text-[10px] text-muted-foreground",
                                                          children: "Default",
                                                        }),
                                                      T.jsxs("div", {
                                                        className: "flex items-start gap-3",
                                                        children: [
                                                          E.icon !== "" &&
                                                            T.jsx("div", {
                                                              className: ye(
                                                                "flex h-10 w-10 shrink-0 items-center justify-center rounded-lg transition-colors",
                                                                S ? "bg-primary/10" : "bg-muted/50",
                                                              ),
                                                              children: T.jsx(fn, {
                                                                icon: E.icon,
                                                                name: E.name,
                                                                className: ye(
                                                                  "h-5 w-5",
                                                                  E.className,
                                                                ),
                                                              }),
                                                            }),
                                                          T.jsxs("div", {
                                                            className: "min-w-0 flex-1 pt-0.5",
                                                            children: [
                                                              T.jsx("span", {
                                                                className: ye(
                                                                  "block font-semibold text-sm",
                                                                  S
                                                                    ? "text-primary"
                                                                    : "text-foreground",
                                                                ),
                                                                children: E.name,
                                                              }),
                                                              T.jsx("p", {
                                                                className:
                                                                  "mt-0.5 line-clamp-2 text-muted-foreground text-xs leading-relaxed",
                                                                children: E.description,
                                                              }),
                                                            ],
                                                          }),
                                                        ],
                                                      }),
                                                    ],
                                                  },
                                                  E.id,
                                                );
                                              }),
                                            }),
                                          ],
                                        }),
                                    }),
                                ],
                              },
                              M,
                            );
                      }),
                      T.jsx("div", { className: "h-10" }),
                    ],
                  }),
                }),
            }),
          ],
        }),
      ],
    }),
  });
};
export { _R as default };
