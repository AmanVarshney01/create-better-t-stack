var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) =>
  key in obj
    ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value })
    : (obj[key] = value);
var __publicField = (obj, key, value) =>
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var _a;
import {
  c as reactExports,
  s as jsxRuntimeExports,
  C as React,
  D as requireShim,
  E as withSelectorExports,
} from "../server.js";
import { C as Check } from "./check-yuJciO15.js";
import {
  c as createLucideIcon,
  r as reactDomExports,
  D as DEFAULT_STACK,
  u as useSearch,
  i as isStackDefault,
  P as PRESET_TEMPLATES,
  T as TriangleAlert,
  a as TECH_OPTIONS,
  t as toast,
  E as ECOSYSTEMS,
  I as Info,
} from "./router-Bw3MqbPS.js";

import "node:async_hooks";
import "node:stream";
import "util";
import "crypto";
import "async_hooks";
import "stream";
import "node:stream/web";
/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$9 = [["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }]];
const ChevronDown = createLucideIcon("chevron-down", __iconNode$9);
/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$8 = [
  ["rect", { width: "8", height: "4", x: "8", y: "2", rx: "1", ry: "1", key: "tgr4d6" }],
  ["path", { d: "M8 4H6a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-2", key: "4jdomd" }],
  ["path", { d: "M16 4h2a2 2 0 0 1 2 2v4", key: "3hqy98" }],
  ["path", { d: "M21 14H11", key: "1bme5i" }],
  ["path", { d: "m15 10-4 4 4 4", key: "5dvupr" }],
];
const ClipboardCopy = createLucideIcon("clipboard-copy", __iconNode$8);
/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$7 = [
  ["path", { d: "M3 5h.01", key: "18ugdj" }],
  ["path", { d: "M3 12h.01", key: "nlz23k" }],
  ["path", { d: "M3 19h.01", key: "noohij" }],
  ["path", { d: "M8 5h13", key: "1pao27" }],
  ["path", { d: "M8 12h13", key: "1za7za" }],
  ["path", { d: "M8 19h13", key: "m83p4d" }],
];
const List = createLucideIcon("list", __iconNode$7);
/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$6 = [
  ["path", { d: "M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8", key: "v9h5vc" }],
  ["path", { d: "M21 3v5h-5", key: "1q7to0" }],
  ["path", { d: "M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16", key: "3uifl3" }],
  ["path", { d: "M8 16H3v5", key: "1cv678" }],
];
const RefreshCw = createLucideIcon("refresh-cw", __iconNode$6);
/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$5 = [
  [
    "path",
    {
      d: "M9.671 4.136a2.34 2.34 0 0 1 4.659 0 2.34 2.34 0 0 0 3.319 1.915 2.34 2.34 0 0 1 2.33 4.033 2.34 2.34 0 0 0 0 3.831 2.34 2.34 0 0 1-2.33 4.033 2.34 2.34 0 0 0-3.319 1.915 2.34 2.34 0 0 1-4.659 0 2.34 2.34 0 0 0-3.32-1.915 2.34 2.34 0 0 1-2.33-4.033 2.34 2.34 0 0 0 0-3.831A2.34 2.34 0 0 1 6.35 6.051a2.34 2.34 0 0 0 3.319-1.915",
      key: "1i5ecw",
    },
  ],
  ["circle", { cx: "12", cy: "12", r: "3", key: "1v7zrd" }],
];
const Settings = createLucideIcon("settings", __iconNode$5);
/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$4 = [
  ["circle", { cx: "18", cy: "5", r: "3", key: "gq8acd" }],
  ["circle", { cx: "6", cy: "12", r: "3", key: "w7nqdw" }],
  ["circle", { cx: "18", cy: "19", r: "3", key: "1xt0gg" }],
  ["line", { x1: "8.59", x2: "15.42", y1: "13.51", y2: "17.49", key: "47mynk" }],
  ["line", { x1: "15.41", x2: "8.59", y1: "6.51", y2: "10.49", key: "1n3mei" }],
];
const Share2 = createLucideIcon("share-2", __iconNode$4);
/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$3 = [
  ["path", { d: "m18 14 4 4-4 4", key: "10pe0f" }],
  ["path", { d: "m18 2 4 4-4 4", key: "pucp1d" }],
  ["path", { d: "M2 18h1.973a4 4 0 0 0 3.3-1.7l5.454-8.6a4 4 0 0 1 3.3-1.7H22", key: "1ailkh" }],
  ["path", { d: "M2 6h1.972a4 4 0 0 1 3.6 2.2", key: "km57vx" }],
  ["path", { d: "M22 18h-6.041a4 4 0 0 1-3.3-1.8l-.359-.45", key: "os18l9" }],
];
const Shuffle = createLucideIcon("shuffle", __iconNode$3);
/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$2 = [
  [
    "path",
    {
      d: "M11.525 2.295a.53.53 0 0 1 .95 0l2.31 4.679a2.123 2.123 0 0 0 1.595 1.16l5.166.756a.53.53 0 0 1 .294.904l-3.736 3.638a2.123 2.123 0 0 0-.611 1.878l.882 5.14a.53.53 0 0 1-.771.56l-4.618-2.428a2.122 2.122 0 0 0-1.973 0L6.396 21.01a.53.53 0 0 1-.77-.56l.881-5.139a2.122 2.122 0 0 0-.611-1.879L2.16 9.795a.53.53 0 0 1 .294-.906l5.165-.755a2.122 2.122 0 0 0 1.597-1.16z",
      key: "r04s7s",
    },
  ],
];
const Star = createLucideIcon("star", __iconNode$2);
/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$1 = [
  ["path", { d: "M12 19h8", key: "baeox8" }],
  ["path", { d: "m4 17 6-6-6-6", key: "1yngyt" }],
];
const Terminal = createLucideIcon("terminal", __iconNode$1);
/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode = [
  [
    "path",
    {
      d: "M4 14a1 1 0 0 1-.78-1.63l9.9-10.2a.5.5 0 0 1 .86.46l-1.92 6.02A1 1 0 0 0 13 10h7a1 1 0 0 1 .78 1.63l-9.9 10.2a.5.5 0 0 1-.86-.46l1.92-6.02A1 1 0 0 0 11 14z",
      key: "1xq2db",
    },
  ],
];
const Zap = createLucideIcon("zap", __iconNode);
const LayoutGroupContext = reactExports.createContext({});
function useConstant(init) {
  const ref = reactExports.useRef(null);
  if (ref.current === null) {
    ref.current = init();
  }
  return ref.current;
}
const isBrowser$1 = typeof window !== "undefined";
const useIsomorphicLayoutEffect = isBrowser$1
  ? reactExports.useLayoutEffect
  : reactExports.useEffect;
const PresenceContext = /* @__PURE__ */ reactExports.createContext(null);
function addUniqueItem(arr, item) {
  if (arr.indexOf(item) === -1) arr.push(item);
}
function removeItem(arr, item) {
  const index2 = arr.indexOf(item);
  if (index2 > -1) arr.splice(index2, 1);
}
const clamp$2 = (min2, max2, v) => {
  if (v > max2) return max2;
  if (v < min2) return min2;
  return v;
};
function formatErrorMessage$1(message, errorCode) {
  return errorCode
    ? `${message}. For more information and steps for solving, visit https://motion.dev/troubleshooting/${errorCode}`
    : message;
}
let warning = () => {};
let invariant = () => {};
if (
  typeof process !== "undefined" &&
  ((_a = process.env) == null ? void 0 : _a.NODE_ENV) !== "production"
) {
  warning = (check, message, errorCode) => {
    if (!check && typeof console !== "undefined") {
      console.warn(formatErrorMessage$1(message, errorCode));
    }
  };
  invariant = (check, message, errorCode) => {
    if (!check) {
      throw new Error(formatErrorMessage$1(message, errorCode));
    }
  };
}
const MotionGlobalConfig = {};
const isNumericalString = (v) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(v);
function isObject(value) {
  return typeof value === "object" && value !== null;
}
const isZeroValueString = (v) => /^0[^.\s]+$/u.test(v);
// @__NO_SIDE_EFFECTS__
function memo(callback) {
  let result;
  return () => {
    if (result === void 0) result = callback();
    return result;
  };
}
const noop$2 = /* @__NO_SIDE_EFFECTS__ */ (any) => any;
const combineFunctions = (a, b) => (v) => b(a(v));
const pipe = (...transformers) => transformers.reduce(combineFunctions);
const progress = /* @__NO_SIDE_EFFECTS__ */ (from, to, value) => {
  const toFromDifference = to - from;
  return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;
};
class SubscriptionManager {
  constructor() {
    this.subscriptions = [];
  }
  add(handler) {
    addUniqueItem(this.subscriptions, handler);
    return () => removeItem(this.subscriptions, handler);
  }
  notify(a, b, c) {
    const numSubscriptions = this.subscriptions.length;
    if (!numSubscriptions) return;
    if (numSubscriptions === 1) {
      this.subscriptions[0](a, b, c);
    } else {
      for (let i = 0; i < numSubscriptions; i++) {
        const handler = this.subscriptions[i];
        handler && handler(a, b, c);
      }
    }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
const secondsToMilliseconds = /* @__NO_SIDE_EFFECTS__ */ (seconds) => seconds * 1e3;
const millisecondsToSeconds = /* @__NO_SIDE_EFFECTS__ */ (milliseconds) => milliseconds / 1e3;
function velocityPerSecond(velocity, frameDuration) {
  return frameDuration ? velocity * (1e3 / frameDuration) : 0;
}
const calcBezier = (t, a1, a2) =>
  (((1 - 3 * a2 + 3 * a1) * t + (3 * a2 - 6 * a1)) * t + 3 * a1) * t;
const subdivisionPrecision = 1e-7;
const subdivisionMaxIterations = 12;
function binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {
  let currentX;
  let currentT;
  let i = 0;
  do {
    currentT = lowerBound + (upperBound - lowerBound) / 2;
    currentX = calcBezier(currentT, mX1, mX2) - x;
    if (currentX > 0) {
      upperBound = currentT;
    } else {
      lowerBound = currentT;
    }
  } while (Math.abs(currentX) > subdivisionPrecision && ++i < subdivisionMaxIterations);
  return currentT;
}
function cubicBezier(mX1, mY1, mX2, mY2) {
  if (mX1 === mY1 && mX2 === mY2) return noop$2;
  const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);
  return (t) => (t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2));
}
const mirrorEasing = (easing) => (p) =>
  p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;
const reverseEasing = (easing) => (p) => 1 - easing(1 - p);
const backOut = /* @__PURE__ */ cubicBezier(0.33, 1.53, 0.69, 0.99);
const backIn = /* @__PURE__ */ reverseEasing(backOut);
const backInOut = /* @__PURE__ */ mirrorEasing(backIn);
const anticipate = (p) => ((p *= 2) < 1 ? 0.5 * backIn(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1))));
const circIn = (p) => 1 - Math.sin(Math.acos(p));
const circOut = reverseEasing(circIn);
const circInOut = mirrorEasing(circIn);
const easeIn = /* @__PURE__ */ cubicBezier(0.42, 0, 1, 1);
const easeOut = /* @__PURE__ */ cubicBezier(0, 0, 0.58, 1);
const easeInOut = /* @__PURE__ */ cubicBezier(0.42, 0, 0.58, 1);
const isEasingArray = (ease2) => {
  return Array.isArray(ease2) && typeof ease2[0] !== "number";
};
const isBezierDefinition = (easing) => Array.isArray(easing) && typeof easing[0] === "number";
const easingLookup = {
  linear: noop$2,
  easeIn,
  easeInOut,
  easeOut,
  circIn,
  circInOut,
  circOut,
  backIn,
  backInOut,
  backOut,
  anticipate,
};
const isValidEasing = (easing) => {
  return typeof easing === "string";
};
const easingDefinitionToFunction = (definition) => {
  if (isBezierDefinition(definition)) {
    invariant(
      definition.length === 4,
      `Cubic bezier arrays must contain four numerical values.`,
      "cubic-bezier-length",
    );
    const [x1, y1, x2, y2] = definition;
    return cubicBezier(x1, y1, x2, y2);
  } else if (isValidEasing(definition)) {
    invariant(
      easingLookup[definition] !== void 0,
      `Invalid easing type '${definition}'`,
      "invalid-easing-type",
    );
    return easingLookup[definition];
  }
  return definition;
};
const stepsOrder = [
  "setup",
  // Compute
  "read",
  // Read
  "resolveKeyframes",
  // Write/Read/Write/Read
  "preUpdate",
  // Compute
  "update",
  // Compute
  "preRender",
  // Compute
  "render",
  // Write
  "postRender",
  // Compute
];
function createRenderStep(runNextFrame, stepName) {
  let thisFrame = /* @__PURE__ */ new Set();
  let nextFrame = /* @__PURE__ */ new Set();
  let isProcessing = false;
  let flushNextFrame = false;
  const toKeepAlive = /* @__PURE__ */ new WeakSet();
  let latestFrameData = {
    delta: 0,
    timestamp: 0,
    isProcessing: false,
  };
  function triggerCallback(callback) {
    if (toKeepAlive.has(callback)) {
      step.schedule(callback);
      runNextFrame();
    }
    callback(latestFrameData);
  }
  const step = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: (callback, keepAlive = false, immediate = false) => {
      const addToCurrentFrame = immediate && isProcessing;
      const queue = addToCurrentFrame ? thisFrame : nextFrame;
      if (keepAlive) toKeepAlive.add(callback);
      if (!queue.has(callback)) queue.add(callback);
      return callback;
    },
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: (callback) => {
      nextFrame.delete(callback);
      toKeepAlive.delete(callback);
    },
    /**
     * Execute all schedule callbacks.
     */
    process: (frameData2) => {
      latestFrameData = frameData2;
      if (isProcessing) {
        flushNextFrame = true;
        return;
      }
      isProcessing = true;
      [thisFrame, nextFrame] = [nextFrame, thisFrame];
      thisFrame.forEach(triggerCallback);
      thisFrame.clear();
      isProcessing = false;
      if (flushNextFrame) {
        flushNextFrame = false;
        step.process(frameData2);
      }
    },
  };
  return step;
}
const maxElapsed = 40;
function createRenderBatcher(scheduleNextBatch, allowKeepAlive) {
  let runNextFrame = false;
  let useDefaultElapsed = true;
  const state = {
    delta: 0,
    timestamp: 0,
    isProcessing: false,
  };
  const flagRunNextFrame = () => (runNextFrame = true);
  const steps = stepsOrder.reduce((acc, key) => {
    acc[key] = createRenderStep(flagRunNextFrame);
    return acc;
  }, {});
  const {
    setup,
    read,
    resolveKeyframes,
    preUpdate,
    update: update2,
    preRender,
    render,
    postRender,
  } = steps;
  const processBatch = () => {
    const timestamp = MotionGlobalConfig.useManualTiming ? state.timestamp : performance.now();
    runNextFrame = false;
    if (!MotionGlobalConfig.useManualTiming) {
      state.delta = useDefaultElapsed
        ? 1e3 / 60
        : Math.max(Math.min(timestamp - state.timestamp, maxElapsed), 1);
    }
    state.timestamp = timestamp;
    state.isProcessing = true;
    setup.process(state);
    read.process(state);
    resolveKeyframes.process(state);
    preUpdate.process(state);
    update2.process(state);
    preRender.process(state);
    render.process(state);
    postRender.process(state);
    state.isProcessing = false;
    if (runNextFrame && allowKeepAlive) {
      useDefaultElapsed = false;
      scheduleNextBatch(processBatch);
    }
  };
  const wake = () => {
    runNextFrame = true;
    useDefaultElapsed = true;
    if (!state.isProcessing) {
      scheduleNextBatch(processBatch);
    }
  };
  const schedule = stepsOrder.reduce((acc, key) => {
    const step = steps[key];
    acc[key] = (process2, keepAlive = false, immediate = false) => {
      if (!runNextFrame) wake();
      return step.schedule(process2, keepAlive, immediate);
    };
    return acc;
  }, {});
  const cancel = (process2) => {
    for (let i = 0; i < stepsOrder.length; i++) {
      steps[stepsOrder[i]].cancel(process2);
    }
  };
  return { schedule, cancel, state, steps };
}
const {
  schedule: frame,
  cancel: cancelFrame,
  state: frameData,
  steps: frameSteps,
} = /* @__PURE__ */ createRenderBatcher(
  typeof requestAnimationFrame !== "undefined" ? requestAnimationFrame : noop$2,
  true,
);
let now;
function clearTime() {
  now = void 0;
}
const time = {
  now: () => {
    if (now === void 0) {
      time.set(
        frameData.isProcessing || MotionGlobalConfig.useManualTiming
          ? frameData.timestamp
          : performance.now(),
      );
    }
    return now;
  },
  set: (newTime) => {
    now = newTime;
    queueMicrotask(clearTime);
  },
};
const checkStringStartsWith = (token) => (key) => typeof key === "string" && key.startsWith(token);
const isCSSVariableName = /* @__PURE__ */ checkStringStartsWith("--");
const startsAsVariableToken = /* @__PURE__ */ checkStringStartsWith("var(--");
const isCSSVariableToken = (value) => {
  const startsWithToken = startsAsVariableToken(value);
  if (!startsWithToken) return false;
  return singleCssVariableRegex.test(value.split("/*")[0].trim());
};
const singleCssVariableRegex =
  /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu;
function containsCSSVariable(value) {
  if (typeof value !== "string") return false;
  return value.split("/*")[0].includes("var(--");
}
const number = {
  test: (v) => typeof v === "number",
  parse: parseFloat,
  transform: (v) => v,
};
const alpha = {
  ...number,
  transform: (v) => clamp$2(0, 1, v),
};
const scale = {
  ...number,
  default: 1,
};
const sanitize = (v) => Math.round(v * 1e5) / 1e5;
const floatRegex = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
function isNullish(v) {
  return v == null;
}
const singleColorRegex =
  /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu;
const isColorString = (type, testProp) => (v) => {
  return Boolean(
    (typeof v === "string" && singleColorRegex.test(v) && v.startsWith(type)) ||
    (testProp && !isNullish(v) && Object.prototype.hasOwnProperty.call(v, testProp)),
  );
};
const splitColor = (aName, bName, cName) => (v) => {
  if (typeof v !== "string") return v;
  const [a, b, c, alpha2] = v.match(floatRegex);
  return {
    [aName]: parseFloat(a),
    [bName]: parseFloat(b),
    [cName]: parseFloat(c),
    alpha: alpha2 !== void 0 ? parseFloat(alpha2) : 1,
  };
};
const clampRgbUnit = (v) => clamp$2(0, 255, v);
const rgbUnit = {
  ...number,
  transform: (v) => Math.round(clampRgbUnit(v)),
};
const rgba = {
  test: /* @__PURE__ */ isColorString("rgb", "red"),
  parse: /* @__PURE__ */ splitColor("red", "green", "blue"),
  transform: ({ red, green, blue, alpha: alpha$1 = 1 }) =>
    "rgba(" +
    rgbUnit.transform(red) +
    ", " +
    rgbUnit.transform(green) +
    ", " +
    rgbUnit.transform(blue) +
    ", " +
    sanitize(alpha.transform(alpha$1)) +
    ")",
};
function parseHex(v) {
  let r2 = "";
  let g = "";
  let b = "";
  let a = "";
  if (v.length > 5) {
    r2 = v.substring(1, 3);
    g = v.substring(3, 5);
    b = v.substring(5, 7);
    a = v.substring(7, 9);
  } else {
    r2 = v.substring(1, 2);
    g = v.substring(2, 3);
    b = v.substring(3, 4);
    a = v.substring(4, 5);
    r2 += r2;
    g += g;
    b += b;
    a += a;
  }
  return {
    red: parseInt(r2, 16),
    green: parseInt(g, 16),
    blue: parseInt(b, 16),
    alpha: a ? parseInt(a, 16) / 255 : 1,
  };
}
const hex = {
  test: /* @__PURE__ */ isColorString("#"),
  parse: parseHex,
  transform: rgba.transform,
};
const createUnitType = /* @__NO_SIDE_EFFECTS__ */ (unit) => ({
  test: (v) => typeof v === "string" && v.endsWith(unit) && v.split(" ").length === 1,
  parse: parseFloat,
  transform: (v) => `${v}${unit}`,
});
const degrees = /* @__PURE__ */ createUnitType("deg");
const percent = /* @__PURE__ */ createUnitType("%");
const px = /* @__PURE__ */ createUnitType("px");
const vh = /* @__PURE__ */ createUnitType("vh");
const vw = /* @__PURE__ */ createUnitType("vw");
const progressPercentage = /* @__PURE__ */ (() => ({
  ...percent,
  parse: (v) => percent.parse(v) / 100,
  transform: (v) => percent.transform(v * 100),
}))();
const hsla = {
  test: /* @__PURE__ */ isColorString("hsl", "hue"),
  parse: /* @__PURE__ */ splitColor("hue", "saturation", "lightness"),
  transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => {
    return (
      "hsla(" +
      Math.round(hue) +
      ", " +
      percent.transform(sanitize(saturation)) +
      ", " +
      percent.transform(sanitize(lightness)) +
      ", " +
      sanitize(alpha.transform(alpha$1)) +
      ")"
    );
  },
};
const color = {
  test: (v) => rgba.test(v) || hex.test(v) || hsla.test(v),
  parse: (v) => {
    if (rgba.test(v)) {
      return rgba.parse(v);
    } else if (hsla.test(v)) {
      return hsla.parse(v);
    } else {
      return hex.parse(v);
    }
  },
  transform: (v) => {
    return typeof v === "string"
      ? v
      : v.hasOwnProperty("red")
        ? rgba.transform(v)
        : hsla.transform(v);
  },
  getAnimatableNone: (v) => {
    const parsed = color.parse(v);
    parsed.alpha = 0;
    return color.transform(parsed);
  },
};
const colorRegex =
  /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
function test(v) {
  var _a2, _b;
  return (
    isNaN(v) &&
    typeof v === "string" &&
    (((_a2 = v.match(floatRegex)) == null ? void 0 : _a2.length) || 0) +
      (((_b = v.match(colorRegex)) == null ? void 0 : _b.length) || 0) >
      0
  );
}
const NUMBER_TOKEN = "number";
const COLOR_TOKEN = "color";
const VAR_TOKEN = "var";
const VAR_FUNCTION_TOKEN = "var(";
const SPLIT_TOKEN = "${}";
const complexRegex =
  /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function analyseComplexValue(value) {
  const originalValue = value.toString();
  const values = [];
  const indexes = {
    color: [],
    number: [],
    var: [],
  };
  const types = [];
  let i = 0;
  const tokenised = originalValue.replace(complexRegex, (parsedValue) => {
    if (color.test(parsedValue)) {
      indexes.color.push(i);
      types.push(COLOR_TOKEN);
      values.push(color.parse(parsedValue));
    } else if (parsedValue.startsWith(VAR_FUNCTION_TOKEN)) {
      indexes.var.push(i);
      types.push(VAR_TOKEN);
      values.push(parsedValue);
    } else {
      indexes.number.push(i);
      types.push(NUMBER_TOKEN);
      values.push(parseFloat(parsedValue));
    }
    ++i;
    return SPLIT_TOKEN;
  });
  const split = tokenised.split(SPLIT_TOKEN);
  return { values, split, indexes, types };
}
function parseComplexValue(v) {
  return analyseComplexValue(v).values;
}
function createTransformer(source) {
  const { split, types } = analyseComplexValue(source);
  const numSections = split.length;
  return (v) => {
    let output = "";
    for (let i = 0; i < numSections; i++) {
      output += split[i];
      if (v[i] !== void 0) {
        const type = types[i];
        if (type === NUMBER_TOKEN) {
          output += sanitize(v[i]);
        } else if (type === COLOR_TOKEN) {
          output += color.transform(v[i]);
        } else {
          output += v[i];
        }
      }
    }
    return output;
  };
}
const convertNumbersToZero = (v) =>
  typeof v === "number" ? 0 : color.test(v) ? color.getAnimatableNone(v) : v;
function getAnimatableNone$1(v) {
  const parsed = parseComplexValue(v);
  const transformer = createTransformer(v);
  return transformer(parsed.map(convertNumbersToZero));
}
const complex = {
  test,
  parse: parseComplexValue,
  createTransformer,
  getAnimatableNone: getAnimatableNone$1,
};
function hueToRgb(p, q, t) {
  if (t < 0) t += 1;
  if (t > 1) t -= 1;
  if (t < 1 / 6) return p + (q - p) * 6 * t;
  if (t < 1 / 2) return q;
  if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
  return p;
}
function hslaToRgba({ hue, saturation, lightness, alpha: alpha2 }) {
  hue /= 360;
  saturation /= 100;
  lightness /= 100;
  let red = 0;
  let green = 0;
  let blue = 0;
  if (!saturation) {
    red = green = blue = lightness;
  } else {
    const q =
      lightness < 0.5
        ? lightness * (1 + saturation)
        : lightness + saturation - lightness * saturation;
    const p = 2 * lightness - q;
    red = hueToRgb(p, q, hue + 1 / 3);
    green = hueToRgb(p, q, hue);
    blue = hueToRgb(p, q, hue - 1 / 3);
  }
  return {
    red: Math.round(red * 255),
    green: Math.round(green * 255),
    blue: Math.round(blue * 255),
    alpha: alpha2,
  };
}
function mixImmediate(a, b) {
  return (p) => (p > 0 ? b : a);
}
const mixNumber$1 = (from, to, progress2) => {
  return from + (to - from) * progress2;
};
const mixLinearColor = (from, to, v) => {
  const fromExpo = from * from;
  const expo = v * (to * to - fromExpo) + fromExpo;
  return expo < 0 ? 0 : Math.sqrt(expo);
};
const colorTypes = [hex, rgba, hsla];
const getColorType = (v) => colorTypes.find((type) => type.test(v));
function asRGBA(color2) {
  const type = getColorType(color2);
  warning(
    Boolean(type),
    `'${color2}' is not an animatable color. Use the equivalent color code instead.`,
    "color-not-animatable",
  );
  if (!Boolean(type)) return false;
  let model = type.parse(color2);
  if (type === hsla) {
    model = hslaToRgba(model);
  }
  return model;
}
const mixColor = (from, to) => {
  const fromRGBA = asRGBA(from);
  const toRGBA = asRGBA(to);
  if (!fromRGBA || !toRGBA) {
    return mixImmediate(from, to);
  }
  const blended = { ...fromRGBA };
  return (v) => {
    blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v);
    blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v);
    blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v);
    blended.alpha = mixNumber$1(fromRGBA.alpha, toRGBA.alpha, v);
    return rgba.transform(blended);
  };
};
const invisibleValues = /* @__PURE__ */ new Set(["none", "hidden"]);
function mixVisibility(origin, target) {
  if (invisibleValues.has(origin)) {
    return (p) => (p <= 0 ? origin : target);
  } else {
    return (p) => (p >= 1 ? target : origin);
  }
}
function mixNumber(a, b) {
  return (p) => mixNumber$1(a, b, p);
}
function getMixer(a) {
  if (typeof a === "number") {
    return mixNumber;
  } else if (typeof a === "string") {
    return isCSSVariableToken(a) ? mixImmediate : color.test(a) ? mixColor : mixComplex;
  } else if (Array.isArray(a)) {
    return mixArray;
  } else if (typeof a === "object") {
    return color.test(a) ? mixColor : mixObject;
  }
  return mixImmediate;
}
function mixArray(a, b) {
  const output = [...a];
  const numValues = output.length;
  const blendValue = a.map((v, i) => getMixer(v)(v, b[i]));
  return (p) => {
    for (let i = 0; i < numValues; i++) {
      output[i] = blendValue[i](p);
    }
    return output;
  };
}
function mixObject(a, b) {
  const output = { ...a, ...b };
  const blendValue = {};
  for (const key in output) {
    if (a[key] !== void 0 && b[key] !== void 0) {
      blendValue[key] = getMixer(a[key])(a[key], b[key]);
    }
  }
  return (v) => {
    for (const key in blendValue) {
      output[key] = blendValue[key](v);
    }
    return output;
  };
}
function matchOrder(origin, target) {
  const orderedOrigin = [];
  const pointers = { color: 0, var: 0, number: 0 };
  for (let i = 0; i < target.values.length; i++) {
    const type = target.types[i];
    const originIndex = origin.indexes[type][pointers[type]];
    const originValue = origin.values[originIndex] ?? 0;
    orderedOrigin[i] = originValue;
    pointers[type]++;
  }
  return orderedOrigin;
}
const mixComplex = (origin, target) => {
  const template = complex.createTransformer(target);
  const originStats = analyseComplexValue(origin);
  const targetStats = analyseComplexValue(target);
  const canInterpolate =
    originStats.indexes.var.length === targetStats.indexes.var.length &&
    originStats.indexes.color.length === targetStats.indexes.color.length &&
    originStats.indexes.number.length >= targetStats.indexes.number.length;
  if (canInterpolate) {
    if (
      (invisibleValues.has(origin) && !targetStats.values.length) ||
      (invisibleValues.has(target) && !originStats.values.length)
    ) {
      return mixVisibility(origin, target);
    }
    return pipe(mixArray(matchOrder(originStats, targetStats), targetStats.values), template);
  } else {
    warning(
      true,
      `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`,
      "complex-values-different",
    );
    return mixImmediate(origin, target);
  }
};
function mix(from, to, p) {
  if (typeof from === "number" && typeof to === "number" && typeof p === "number") {
    return mixNumber$1(from, to, p);
  }
  const mixer = getMixer(from);
  return mixer(from, to);
}
const frameloopDriver = (update2) => {
  const passTimestamp = ({ timestamp }) => update2(timestamp);
  return {
    start: (keepAlive = true) => frame.update(passTimestamp, keepAlive),
    stop: () => cancelFrame(passTimestamp),
    /**
     * If we're processing this frame we can use the
     * framelocked timestamp to keep things in sync.
     */
    now: () => (frameData.isProcessing ? frameData.timestamp : time.now()),
  };
};
const generateLinearEasing = (easing, duration, resolution = 10) => {
  let points = "";
  const numPoints = Math.max(Math.round(duration / resolution), 2);
  for (let i = 0; i < numPoints; i++) {
    points += Math.round(easing(i / (numPoints - 1)) * 1e4) / 1e4 + ", ";
  }
  return `linear(${points.substring(0, points.length - 2)})`;
};
const maxGeneratorDuration = 2e4;
function calcGeneratorDuration(generator) {
  let duration = 0;
  const timeStep = 50;
  let state = generator.next(duration);
  while (!state.done && duration < maxGeneratorDuration) {
    duration += timeStep;
    state = generator.next(duration);
  }
  return duration >= maxGeneratorDuration ? Infinity : duration;
}
function createGeneratorEasing(options, scale2 = 100, createGenerator) {
  const generator = createGenerator({ ...options, keyframes: [0, scale2] });
  const duration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);
  return {
    type: "keyframes",
    ease: (progress2) => {
      return generator.next(duration * progress2).value / scale2;
    },
    duration: /* @__PURE__ */ millisecondsToSeconds(duration),
  };
}
const velocitySampleDuration = 5;
function calcGeneratorVelocity(resolveValue, t, current) {
  const prevT = Math.max(t - velocitySampleDuration, 0);
  return velocityPerSecond(current - resolveValue(prevT), t - prevT);
}
const springDefaults = {
  // Default spring physics
  stiffness: 100,
  damping: 10,
  mass: 1,
  velocity: 0,
  // Default duration/bounce-based options
  duration: 800,
  // in ms
  bounce: 0.3,
  visualDuration: 0.3,
  // in seconds
  // Rest thresholds
  restSpeed: {
    granular: 0.01,
    default: 2,
  },
  restDelta: {
    granular: 5e-3,
    default: 0.5,
  },
  // Limits
  minDuration: 0.01,
  // in seconds
  maxDuration: 10,
  // in seconds
  minDamping: 0.05,
  maxDamping: 1,
};
const safeMin = 1e-3;
function findSpring({
  duration = springDefaults.duration,
  bounce = springDefaults.bounce,
  velocity = springDefaults.velocity,
  mass = springDefaults.mass,
}) {
  let envelope;
  let derivative;
  warning(
    duration <= /* @__PURE__ */ secondsToMilliseconds(springDefaults.maxDuration),
    "Spring duration must be 10 seconds or less",
    "spring-duration-limit",
  );
  let dampingRatio = 1 - bounce;
  dampingRatio = clamp$2(springDefaults.minDamping, springDefaults.maxDamping, dampingRatio);
  duration = clamp$2(
    springDefaults.minDuration,
    springDefaults.maxDuration,
    /* @__PURE__ */ millisecondsToSeconds(duration),
  );
  if (dampingRatio < 1) {
    envelope = (undampedFreq2) => {
      const exponentialDecay = undampedFreq2 * dampingRatio;
      const delta = exponentialDecay * duration;
      const a = exponentialDecay - velocity;
      const b = calcAngularFreq(undampedFreq2, dampingRatio);
      const c = Math.exp(-delta);
      return safeMin - (a / b) * c;
    };
    derivative = (undampedFreq2) => {
      const exponentialDecay = undampedFreq2 * dampingRatio;
      const delta = exponentialDecay * duration;
      const d = delta * velocity + velocity;
      const e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq2, 2) * duration;
      const f = Math.exp(-delta);
      const g = calcAngularFreq(Math.pow(undampedFreq2, 2), dampingRatio);
      const factor = -envelope(undampedFreq2) + safeMin > 0 ? -1 : 1;
      return (factor * ((d - e) * f)) / g;
    };
  } else {
    envelope = (undampedFreq2) => {
      const a = Math.exp(-undampedFreq2 * duration);
      const b = (undampedFreq2 - velocity) * duration + 1;
      return -safeMin + a * b;
    };
    derivative = (undampedFreq2) => {
      const a = Math.exp(-undampedFreq2 * duration);
      const b = (velocity - undampedFreq2) * (duration * duration);
      return a * b;
    };
  }
  const initialGuess = 5 / duration;
  const undampedFreq = approximateRoot(envelope, derivative, initialGuess);
  duration = /* @__PURE__ */ secondsToMilliseconds(duration);
  if (isNaN(undampedFreq)) {
    return {
      stiffness: springDefaults.stiffness,
      damping: springDefaults.damping,
      duration,
    };
  } else {
    const stiffness = Math.pow(undampedFreq, 2) * mass;
    return {
      stiffness,
      damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),
      duration,
    };
  }
}
const rootIterations = 12;
function approximateRoot(envelope, derivative, initialGuess) {
  let result = initialGuess;
  for (let i = 1; i < rootIterations; i++) {
    result = result - envelope(result) / derivative(result);
  }
  return result;
}
function calcAngularFreq(undampedFreq, dampingRatio) {
  return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
}
const durationKeys = ["duration", "bounce"];
const physicsKeys = ["stiffness", "damping", "mass"];
function isSpringType(options, keys) {
  return keys.some((key) => options[key] !== void 0);
}
function getSpringOptions(options) {
  let springOptions = {
    velocity: springDefaults.velocity,
    stiffness: springDefaults.stiffness,
    damping: springDefaults.damping,
    mass: springDefaults.mass,
    isResolvedFromDuration: false,
    ...options,
  };
  if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {
    if (options.visualDuration) {
      const visualDuration = options.visualDuration;
      const root = (2 * Math.PI) / (visualDuration * 1.2);
      const stiffness = root * root;
      const damping = 2 * clamp$2(0.05, 1, 1 - (options.bounce || 0)) * Math.sqrt(stiffness);
      springOptions = {
        ...springOptions,
        mass: springDefaults.mass,
        stiffness,
        damping,
      };
    } else {
      const derived = findSpring(options);
      springOptions = {
        ...springOptions,
        ...derived,
        mass: springDefaults.mass,
      };
      springOptions.isResolvedFromDuration = true;
    }
  }
  return springOptions;
}
function spring(
  optionsOrVisualDuration = springDefaults.visualDuration,
  bounce = springDefaults.bounce,
) {
  const options =
    typeof optionsOrVisualDuration !== "object"
      ? {
          visualDuration: optionsOrVisualDuration,
          keyframes: [0, 1],
          bounce,
        }
      : optionsOrVisualDuration;
  let { restSpeed, restDelta } = options;
  const origin = options.keyframes[0];
  const target = options.keyframes[options.keyframes.length - 1];
  const state = { done: false, value: origin };
  const { stiffness, damping, mass, duration, velocity, isResolvedFromDuration } = getSpringOptions(
    {
      ...options,
      velocity: -(/* @__PURE__ */ millisecondsToSeconds(options.velocity || 0)),
    },
  );
  const initialVelocity = velocity || 0;
  const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));
  const initialDelta = target - origin;
  const undampedAngularFreq = /* @__PURE__ */ millisecondsToSeconds(Math.sqrt(stiffness / mass));
  const isGranularScale = Math.abs(initialDelta) < 5;
  restSpeed ||
    (restSpeed = isGranularScale
      ? springDefaults.restSpeed.granular
      : springDefaults.restSpeed.default);
  restDelta ||
    (restDelta = isGranularScale
      ? springDefaults.restDelta.granular
      : springDefaults.restDelta.default);
  let resolveSpring;
  if (dampingRatio < 1) {
    const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);
    resolveSpring = (t) => {
      const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);
      return (
        target -
        envelope *
          (((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq) *
            Math.sin(angularFreq * t) +
            initialDelta * Math.cos(angularFreq * t))
      );
    };
  } else if (dampingRatio === 1) {
    resolveSpring = (t) =>
      target -
      Math.exp(-undampedAngularFreq * t) *
        (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t);
  } else {
    const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);
    resolveSpring = (t) => {
      const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);
      const freqForT = Math.min(dampedAngularFreq * t, 300);
      return (
        target -
        (envelope *
          ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) *
            Math.sinh(freqForT) +
            dampedAngularFreq * initialDelta * Math.cosh(freqForT))) /
          dampedAngularFreq
      );
    };
  }
  const generator = {
    calculatedDuration: isResolvedFromDuration ? duration || null : null,
    next: (t) => {
      const current = resolveSpring(t);
      if (!isResolvedFromDuration) {
        let currentVelocity = t === 0 ? initialVelocity : 0;
        if (dampingRatio < 1) {
          currentVelocity =
            t === 0
              ? /* @__PURE__ */ secondsToMilliseconds(initialVelocity)
              : calcGeneratorVelocity(resolveSpring, t, current);
        }
        const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;
        const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;
        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
      } else {
        state.done = t >= duration;
      }
      state.value = state.done ? target : current;
      return state;
    },
    toString: () => {
      const calculatedDuration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);
      const easing = generateLinearEasing(
        (progress2) => generator.next(calculatedDuration * progress2).value,
        calculatedDuration,
        30,
      );
      return calculatedDuration + "ms " + easing;
    },
    toTransition: () => {},
  };
  return generator;
}
spring.applyToOptions = (options) => {
  const generatorOptions = createGeneratorEasing(options, 100, spring);
  options.ease = generatorOptions.ease;
  options.duration = /* @__PURE__ */ secondsToMilliseconds(generatorOptions.duration);
  options.type = "keyframes";
  return options;
};
function inertia({
  keyframes: keyframes2,
  velocity = 0,
  power = 0.8,
  timeConstant = 325,
  bounceDamping = 10,
  bounceStiffness = 500,
  modifyTarget,
  min: min2,
  max: max2,
  restDelta = 0.5,
  restSpeed,
}) {
  const origin = keyframes2[0];
  const state = {
    done: false,
    value: origin,
  };
  const isOutOfBounds = (v) => (min2 !== void 0 && v < min2) || (max2 !== void 0 && v > max2);
  const nearestBoundary = (v) => {
    if (min2 === void 0) return max2;
    if (max2 === void 0) return min2;
    return Math.abs(min2 - v) < Math.abs(max2 - v) ? min2 : max2;
  };
  let amplitude = power * velocity;
  const ideal = origin + amplitude;
  const target = modifyTarget === void 0 ? ideal : modifyTarget(ideal);
  if (target !== ideal) amplitude = target - origin;
  const calcDelta = (t) => -amplitude * Math.exp(-t / timeConstant);
  const calcLatest = (t) => target + calcDelta(t);
  const applyFriction = (t) => {
    const delta = calcDelta(t);
    const latest = calcLatest(t);
    state.done = Math.abs(delta) <= restDelta;
    state.value = state.done ? target : latest;
  };
  let timeReachedBoundary;
  let spring$1;
  const checkCatchBoundary = (t) => {
    if (!isOutOfBounds(state.value)) return;
    timeReachedBoundary = t;
    spring$1 = spring({
      keyframes: [state.value, nearestBoundary(state.value)],
      velocity: calcGeneratorVelocity(calcLatest, t, state.value),
      // TODO: This should be passing * 1000
      damping: bounceDamping,
      stiffness: bounceStiffness,
      restDelta,
      restSpeed,
    });
  };
  checkCatchBoundary(0);
  return {
    calculatedDuration: null,
    next: (t) => {
      let hasUpdatedFrame = false;
      if (!spring$1 && timeReachedBoundary === void 0) {
        hasUpdatedFrame = true;
        applyFriction(t);
        checkCatchBoundary(t);
      }
      if (timeReachedBoundary !== void 0 && t >= timeReachedBoundary) {
        return spring$1.next(t - timeReachedBoundary);
      } else {
        !hasUpdatedFrame && applyFriction(t);
        return state;
      }
    },
  };
}
function createMixers(output, ease2, customMixer) {
  const mixers = [];
  const mixerFactory = customMixer || MotionGlobalConfig.mix || mix;
  const numMixers = output.length - 1;
  for (let i = 0; i < numMixers; i++) {
    let mixer = mixerFactory(output[i], output[i + 1]);
    if (ease2) {
      const easingFunction = Array.isArray(ease2) ? ease2[i] || noop$2 : ease2;
      mixer = pipe(easingFunction, mixer);
    }
    mixers.push(mixer);
  }
  return mixers;
}
function interpolate(input, output, { clamp: isClamp = true, ease: ease2, mixer } = {}) {
  const inputLength = input.length;
  invariant(
    inputLength === output.length,
    "Both input and output ranges must be the same length",
    "range-length",
  );
  if (inputLength === 1) return () => output[0];
  if (inputLength === 2 && output[0] === output[1]) return () => output[1];
  const isZeroDeltaRange = input[0] === input[1];
  if (input[0] > input[inputLength - 1]) {
    input = [...input].reverse();
    output = [...output].reverse();
  }
  const mixers = createMixers(output, ease2, mixer);
  const numMixers = mixers.length;
  const interpolator = (v) => {
    if (isZeroDeltaRange && v < input[0]) return output[0];
    let i = 0;
    if (numMixers > 1) {
      for (; i < input.length - 2; i++) {
        if (v < input[i + 1]) break;
      }
    }
    const progressInRange = /* @__PURE__ */ progress(input[i], input[i + 1], v);
    return mixers[i](progressInRange);
  };
  return isClamp ? (v) => interpolator(clamp$2(input[0], input[inputLength - 1], v)) : interpolator;
}
function fillOffset(offset2, remaining) {
  const min2 = offset2[offset2.length - 1];
  for (let i = 1; i <= remaining; i++) {
    const offsetProgress = /* @__PURE__ */ progress(0, remaining, i);
    offset2.push(mixNumber$1(min2, 1, offsetProgress));
  }
}
function defaultOffset(arr) {
  const offset2 = [0];
  fillOffset(offset2, arr.length - 1);
  return offset2;
}
function convertOffsetToTimes(offset2, duration) {
  return offset2.map((o) => o * duration);
}
function defaultEasing(values, easing) {
  return values.map(() => easing || easeInOut).splice(0, values.length - 1);
}
function keyframes({
  duration = 300,
  keyframes: keyframeValues,
  times,
  ease: ease2 = "easeInOut",
}) {
  const easingFunctions = isEasingArray(ease2)
    ? ease2.map(easingDefinitionToFunction)
    : easingDefinitionToFunction(ease2);
  const state = {
    done: false,
    value: keyframeValues[0],
  };
  const absoluteTimes = convertOffsetToTimes(
    // Only use the provided offsets if they're the correct length
    // TODO Maybe we should warn here if there's a length mismatch
    times && times.length === keyframeValues.length ? times : defaultOffset(keyframeValues),
    duration,
  );
  const mapTimeToKeyframe = interpolate(absoluteTimes, keyframeValues, {
    ease: Array.isArray(easingFunctions)
      ? easingFunctions
      : defaultEasing(keyframeValues, easingFunctions),
  });
  return {
    calculatedDuration: duration,
    next: (t) => {
      state.value = mapTimeToKeyframe(t);
      state.done = t >= duration;
      return state;
    },
  };
}
const isNotNull$1 = (value) => value !== null;
function getFinalKeyframe$1(keyframes2, { repeat, repeatType = "loop" }, finalKeyframe, speed = 1) {
  const resolvedKeyframes = keyframes2.filter(isNotNull$1);
  const useFirstKeyframe = speed < 0 || (repeat && repeatType !== "loop" && repeat % 2 === 1);
  const index2 = useFirstKeyframe ? 0 : resolvedKeyframes.length - 1;
  return !index2 || finalKeyframe === void 0 ? resolvedKeyframes[index2] : finalKeyframe;
}
const transitionTypeMap = {
  decay: inertia,
  inertia,
  tween: keyframes,
  keyframes,
  spring,
};
function replaceTransitionType(transition) {
  if (typeof transition.type === "string") {
    transition.type = transitionTypeMap[transition.type];
  }
}
class WithPromise {
  constructor() {
    this.updateFinished();
  }
  get finished() {
    return this._finished;
  }
  updateFinished() {
    this._finished = new Promise((resolve) => {
      this.resolve = resolve;
    });
  }
  notifyFinished() {
    this.resolve();
  }
  /**
   * Allows the animation to be awaited.
   *
   * @deprecated Use `finished` instead.
   */
  then(onResolve, onReject) {
    return this.finished.then(onResolve, onReject);
  }
}
const percentToProgress = (percent2) => percent2 / 100;
class JSAnimation extends WithPromise {
  constructor(options) {
    super();
    this.state = "idle";
    this.startTime = null;
    this.isStopped = false;
    this.currentTime = 0;
    this.holdTime = null;
    this.playbackSpeed = 1;
    this.stop = () => {
      var _a2, _b;
      const { motionValue: motionValue2 } = this.options;
      if (motionValue2 && motionValue2.updatedAt !== time.now()) {
        this.tick(time.now());
      }
      this.isStopped = true;
      if (this.state === "idle") return;
      this.teardown();
      (_b = (_a2 = this.options).onStop) == null ? void 0 : _b.call(_a2);
    };
    this.options = options;
    this.initAnimation();
    this.play();
    if (options.autoplay === false) this.pause();
  }
  initAnimation() {
    const { options } = this;
    replaceTransitionType(options);
    const { type = keyframes, repeat = 0, repeatDelay = 0, repeatType, velocity = 0 } = options;
    let { keyframes: keyframes$1 } = options;
    const generatorFactory = type || keyframes;
    if (generatorFactory !== keyframes && typeof keyframes$1[0] !== "number") {
      this.mixKeyframes = pipe(percentToProgress, mix(keyframes$1[0], keyframes$1[1]));
      keyframes$1 = [0, 100];
    }
    const generator = generatorFactory({ ...options, keyframes: keyframes$1 });
    if (repeatType === "mirror") {
      this.mirroredGenerator = generatorFactory({
        ...options,
        keyframes: [...keyframes$1].reverse(),
        velocity: -velocity,
      });
    }
    if (generator.calculatedDuration === null) {
      generator.calculatedDuration = calcGeneratorDuration(generator);
    }
    const { calculatedDuration } = generator;
    this.calculatedDuration = calculatedDuration;
    this.resolvedDuration = calculatedDuration + repeatDelay;
    this.totalDuration = this.resolvedDuration * (repeat + 1) - repeatDelay;
    this.generator = generator;
  }
  updateTime(timestamp) {
    const animationTime = Math.round(timestamp - this.startTime) * this.playbackSpeed;
    if (this.holdTime !== null) {
      this.currentTime = this.holdTime;
    } else {
      this.currentTime = animationTime;
    }
  }
  tick(timestamp, sample = false) {
    const {
      generator,
      totalDuration,
      mixKeyframes,
      mirroredGenerator,
      resolvedDuration,
      calculatedDuration,
    } = this;
    if (this.startTime === null) return generator.next(0);
    const {
      delay: delay2 = 0,
      keyframes: keyframes2,
      repeat,
      repeatType,
      repeatDelay,
      type,
      onUpdate,
      finalKeyframe,
    } = this.options;
    if (this.speed > 0) {
      this.startTime = Math.min(this.startTime, timestamp);
    } else if (this.speed < 0) {
      this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime);
    }
    if (sample) {
      this.currentTime = timestamp;
    } else {
      this.updateTime(timestamp);
    }
    const timeWithoutDelay = this.currentTime - delay2 * (this.playbackSpeed >= 0 ? 1 : -1);
    const isInDelayPhase =
      this.playbackSpeed >= 0 ? timeWithoutDelay < 0 : timeWithoutDelay > totalDuration;
    this.currentTime = Math.max(timeWithoutDelay, 0);
    if (this.state === "finished" && this.holdTime === null) {
      this.currentTime = totalDuration;
    }
    let elapsed = this.currentTime;
    let frameGenerator = generator;
    if (repeat) {
      const progress2 = Math.min(this.currentTime, totalDuration) / resolvedDuration;
      let currentIteration = Math.floor(progress2);
      let iterationProgress = progress2 % 1;
      if (!iterationProgress && progress2 >= 1) {
        iterationProgress = 1;
      }
      iterationProgress === 1 && currentIteration--;
      currentIteration = Math.min(currentIteration, repeat + 1);
      const isOddIteration = Boolean(currentIteration % 2);
      if (isOddIteration) {
        if (repeatType === "reverse") {
          iterationProgress = 1 - iterationProgress;
          if (repeatDelay) {
            iterationProgress -= repeatDelay / resolvedDuration;
          }
        } else if (repeatType === "mirror") {
          frameGenerator = mirroredGenerator;
        }
      }
      elapsed = clamp$2(0, 1, iterationProgress) * resolvedDuration;
    }
    const state = isInDelayPhase
      ? { done: false, value: keyframes2[0] }
      : frameGenerator.next(elapsed);
    if (mixKeyframes) {
      state.value = mixKeyframes(state.value);
    }
    let { done } = state;
    if (!isInDelayPhase && calculatedDuration !== null) {
      done = this.playbackSpeed >= 0 ? this.currentTime >= totalDuration : this.currentTime <= 0;
    }
    const isAnimationFinished =
      this.holdTime === null && (this.state === "finished" || (this.state === "running" && done));
    if (isAnimationFinished && type !== inertia) {
      state.value = getFinalKeyframe$1(keyframes2, this.options, finalKeyframe, this.speed);
    }
    if (onUpdate) {
      onUpdate(state.value);
    }
    if (isAnimationFinished) {
      this.finish();
    }
    return state;
  }
  /**
   * Allows the returned animation to be awaited or promise-chained. Currently
   * resolves when the animation finishes at all but in a future update could/should
   * reject if its cancels.
   */
  then(resolve, reject) {
    return this.finished.then(resolve, reject);
  }
  get duration() {
    return /* @__PURE__ */ millisecondsToSeconds(this.calculatedDuration);
  }
  get iterationDuration() {
    const { delay: delay2 = 0 } = this.options || {};
    return this.duration + /* @__PURE__ */ millisecondsToSeconds(delay2);
  }
  get time() {
    return /* @__PURE__ */ millisecondsToSeconds(this.currentTime);
  }
  set time(newTime) {
    var _a2;
    newTime = /* @__PURE__ */ secondsToMilliseconds(newTime);
    this.currentTime = newTime;
    if (this.startTime === null || this.holdTime !== null || this.playbackSpeed === 0) {
      this.holdTime = newTime;
    } else if (this.driver) {
      this.startTime = this.driver.now() - newTime / this.playbackSpeed;
    }
    (_a2 = this.driver) == null ? void 0 : _a2.start(false);
  }
  get speed() {
    return this.playbackSpeed;
  }
  set speed(newSpeed) {
    this.updateTime(time.now());
    const hasChanged = this.playbackSpeed !== newSpeed;
    this.playbackSpeed = newSpeed;
    if (hasChanged) {
      this.time = /* @__PURE__ */ millisecondsToSeconds(this.currentTime);
    }
  }
  play() {
    var _a2, _b;
    if (this.isStopped) return;
    const { driver = frameloopDriver, startTime } = this.options;
    if (!this.driver) {
      this.driver = driver((timestamp) => this.tick(timestamp));
    }
    (_b = (_a2 = this.options).onPlay) == null ? void 0 : _b.call(_a2);
    const now2 = this.driver.now();
    if (this.state === "finished") {
      this.updateFinished();
      this.startTime = now2;
    } else if (this.holdTime !== null) {
      this.startTime = now2 - this.holdTime;
    } else if (!this.startTime) {
      this.startTime = startTime ?? now2;
    }
    if (this.state === "finished" && this.speed < 0) {
      this.startTime += this.calculatedDuration;
    }
    this.holdTime = null;
    this.state = "running";
    this.driver.start();
  }
  pause() {
    this.state = "paused";
    this.updateTime(time.now());
    this.holdTime = this.currentTime;
  }
  complete() {
    if (this.state !== "running") {
      this.play();
    }
    this.state = "finished";
    this.holdTime = null;
  }
  finish() {
    var _a2, _b;
    this.notifyFinished();
    this.teardown();
    this.state = "finished";
    (_b = (_a2 = this.options).onComplete) == null ? void 0 : _b.call(_a2);
  }
  cancel() {
    var _a2, _b;
    this.holdTime = null;
    this.startTime = 0;
    this.tick(0);
    this.teardown();
    (_b = (_a2 = this.options).onCancel) == null ? void 0 : _b.call(_a2);
  }
  teardown() {
    this.state = "idle";
    this.stopDriver();
    this.startTime = this.holdTime = null;
  }
  stopDriver() {
    if (!this.driver) return;
    this.driver.stop();
    this.driver = void 0;
  }
  sample(sampleTime) {
    this.startTime = 0;
    return this.tick(sampleTime, true);
  }
  attachTimeline(timeline) {
    var _a2;
    if (this.options.allowFlatten) {
      this.options.type = "keyframes";
      this.options.ease = "linear";
      this.initAnimation();
    }
    (_a2 = this.driver) == null ? void 0 : _a2.stop();
    return timeline.observe(this);
  }
}
function fillWildcards(keyframes2) {
  for (let i = 1; i < keyframes2.length; i++) {
    keyframes2[i] ?? (keyframes2[i] = keyframes2[i - 1]);
  }
}
const radToDeg = (rad) => (rad * 180) / Math.PI;
const rotate = (v) => {
  const angle = radToDeg(Math.atan2(v[1], v[0]));
  return rebaseAngle(angle);
};
const matrix2dParsers = {
  x: 4,
  y: 5,
  translateX: 4,
  translateY: 5,
  scaleX: 0,
  scaleY: 3,
  scale: (v) => (Math.abs(v[0]) + Math.abs(v[3])) / 2,
  rotate,
  rotateZ: rotate,
  skewX: (v) => radToDeg(Math.atan(v[1])),
  skewY: (v) => radToDeg(Math.atan(v[2])),
  skew: (v) => (Math.abs(v[1]) + Math.abs(v[2])) / 2,
};
const rebaseAngle = (angle) => {
  angle = angle % 360;
  if (angle < 0) angle += 360;
  return angle;
};
const rotateZ = rotate;
const scaleX = (v) => Math.sqrt(v[0] * v[0] + v[1] * v[1]);
const scaleY = (v) => Math.sqrt(v[4] * v[4] + v[5] * v[5]);
const matrix3dParsers = {
  x: 12,
  y: 13,
  z: 14,
  translateX: 12,
  translateY: 13,
  translateZ: 14,
  scaleX,
  scaleY,
  scale: (v) => (scaleX(v) + scaleY(v)) / 2,
  rotateX: (v) => rebaseAngle(radToDeg(Math.atan2(v[6], v[5]))),
  rotateY: (v) => rebaseAngle(radToDeg(Math.atan2(-v[2], v[0]))),
  rotateZ,
  rotate: rotateZ,
  skewX: (v) => radToDeg(Math.atan(v[4])),
  skewY: (v) => radToDeg(Math.atan(v[1])),
  skew: (v) => (Math.abs(v[1]) + Math.abs(v[4])) / 2,
};
function defaultTransformValue(name) {
  return name.includes("scale") ? 1 : 0;
}
function parseValueFromTransform(transform, name) {
  if (!transform || transform === "none") {
    return defaultTransformValue(name);
  }
  const matrix3dMatch = transform.match(/^matrix3d\(([-\d.e\s,]+)\)$/u);
  let parsers;
  let match;
  if (matrix3dMatch) {
    parsers = matrix3dParsers;
    match = matrix3dMatch;
  } else {
    const matrix2dMatch = transform.match(/^matrix\(([-\d.e\s,]+)\)$/u);
    parsers = matrix2dParsers;
    match = matrix2dMatch;
  }
  if (!match) {
    return defaultTransformValue(name);
  }
  const valueParser = parsers[name];
  const values = match[1].split(",").map(convertTransformToNumber);
  return typeof valueParser === "function" ? valueParser(values) : values[valueParser];
}
const readTransformValue = (instance, name) => {
  const { transform = "none" } = getComputedStyle(instance);
  return parseValueFromTransform(transform, name);
};
function convertTransformToNumber(value) {
  return parseFloat(value.trim());
}
const transformPropOrder = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "skew",
  "skewX",
  "skewY",
];
const transformProps = /* @__PURE__ */ (() => new Set(transformPropOrder))();
const isNumOrPxType = (v) => v === number || v === px;
const transformKeys = /* @__PURE__ */ new Set(["x", "y", "z"]);
const nonTranslationalTransformKeys = transformPropOrder.filter((key) => !transformKeys.has(key));
function removeNonTranslationalTransform(visualElement) {
  const removedTransforms = [];
  nonTranslationalTransformKeys.forEach((key) => {
    const value = visualElement.getValue(key);
    if (value !== void 0) {
      removedTransforms.push([key, value.get()]);
      value.set(key.startsWith("scale") ? 1 : 0);
    }
  });
  return removedTransforms;
}
const positionalValues = {
  // Dimensions
  width: ({ x }, { paddingLeft = "0", paddingRight = "0" }) =>
    x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight),
  height: ({ y }, { paddingTop = "0", paddingBottom = "0" }) =>
    y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom),
  top: (_bbox, { top }) => parseFloat(top),
  left: (_bbox, { left }) => parseFloat(left),
  bottom: ({ y }, { top }) => parseFloat(top) + (y.max - y.min),
  right: ({ x }, { left }) => parseFloat(left) + (x.max - x.min),
  // Transform
  x: (_bbox, { transform }) => parseValueFromTransform(transform, "x"),
  y: (_bbox, { transform }) => parseValueFromTransform(transform, "y"),
};
positionalValues.translateX = positionalValues.x;
positionalValues.translateY = positionalValues.y;
const toResolve = /* @__PURE__ */ new Set();
let isScheduled = false;
let anyNeedsMeasurement = false;
let isForced = false;
function measureAllKeyframes() {
  if (anyNeedsMeasurement) {
    const resolversToMeasure = Array.from(toResolve).filter(
      (resolver) => resolver.needsMeasurement,
    );
    const elementsToMeasure = new Set(resolversToMeasure.map((resolver) => resolver.element));
    const transformsToRestore = /* @__PURE__ */ new Map();
    elementsToMeasure.forEach((element) => {
      const removedTransforms = removeNonTranslationalTransform(element);
      if (!removedTransforms.length) return;
      transformsToRestore.set(element, removedTransforms);
      element.render();
    });
    resolversToMeasure.forEach((resolver) => resolver.measureInitialState());
    elementsToMeasure.forEach((element) => {
      element.render();
      const restore = transformsToRestore.get(element);
      if (restore) {
        restore.forEach(([key, value]) => {
          var _a2;
          (_a2 = element.getValue(key)) == null ? void 0 : _a2.set(value);
        });
      }
    });
    resolversToMeasure.forEach((resolver) => resolver.measureEndState());
    resolversToMeasure.forEach((resolver) => {
      if (resolver.suspendedScrollY !== void 0) {
        window.scrollTo(0, resolver.suspendedScrollY);
      }
    });
  }
  anyNeedsMeasurement = false;
  isScheduled = false;
  toResolve.forEach((resolver) => resolver.complete(isForced));
  toResolve.clear();
}
function readAllKeyframes() {
  toResolve.forEach((resolver) => {
    resolver.readKeyframes();
    if (resolver.needsMeasurement) {
      anyNeedsMeasurement = true;
    }
  });
}
function flushKeyframeResolvers() {
  isForced = true;
  readAllKeyframes();
  measureAllKeyframes();
  isForced = false;
}
class KeyframeResolver {
  constructor(unresolvedKeyframes, onComplete, name, motionValue2, element, isAsync = false) {
    this.state = "pending";
    this.isAsync = false;
    this.needsMeasurement = false;
    this.unresolvedKeyframes = [...unresolvedKeyframes];
    this.onComplete = onComplete;
    this.name = name;
    this.motionValue = motionValue2;
    this.element = element;
    this.isAsync = isAsync;
  }
  scheduleResolve() {
    this.state = "scheduled";
    if (this.isAsync) {
      toResolve.add(this);
      if (!isScheduled) {
        isScheduled = true;
        frame.read(readAllKeyframes);
        frame.resolveKeyframes(measureAllKeyframes);
      }
    } else {
      this.readKeyframes();
      this.complete();
    }
  }
  readKeyframes() {
    const { unresolvedKeyframes, name, element, motionValue: motionValue2 } = this;
    if (unresolvedKeyframes[0] === null) {
      const currentValue = motionValue2 == null ? void 0 : motionValue2.get();
      const finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
      if (currentValue !== void 0) {
        unresolvedKeyframes[0] = currentValue;
      } else if (element && name) {
        const valueAsRead = element.readValue(name, finalKeyframe);
        if (valueAsRead !== void 0 && valueAsRead !== null) {
          unresolvedKeyframes[0] = valueAsRead;
        }
      }
      if (unresolvedKeyframes[0] === void 0) {
        unresolvedKeyframes[0] = finalKeyframe;
      }
      if (motionValue2 && currentValue === void 0) {
        motionValue2.set(unresolvedKeyframes[0]);
      }
    }
    fillWildcards(unresolvedKeyframes);
  }
  setFinalKeyframe() {}
  measureInitialState() {}
  renderEndStyles() {}
  measureEndState() {}
  complete(isForcedComplete = false) {
    this.state = "complete";
    this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, isForcedComplete);
    toResolve.delete(this);
  }
  cancel() {
    if (this.state === "scheduled") {
      toResolve.delete(this);
      this.state = "pending";
    }
  }
  resume() {
    if (this.state === "pending") this.scheduleResolve();
  }
}
const isCSSVar = (name) => name.startsWith("--");
function setStyle(element, name, value) {
  isCSSVar(name) ? element.style.setProperty(name, value) : (element.style[name] = value);
}
const supportsScrollTimeline = /* @__PURE__ */ memo(() => window.ScrollTimeline !== void 0);
const supportsFlags = {};
function memoSupports(callback, supportsFlag) {
  const memoized = /* @__PURE__ */ memo(callback);
  return () => supportsFlags[supportsFlag] ?? memoized();
}
const supportsLinearEasing = /* @__PURE__ */ memoSupports(() => {
  try {
    document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" });
  } catch (e) {
    return false;
  }
  return true;
}, "linearEasing");
const cubicBezierAsString = ([a, b, c, d]) => `cubic-bezier(${a}, ${b}, ${c}, ${d})`;
const supportedWaapiEasing = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  circIn: /* @__PURE__ */ cubicBezierAsString([0, 0.65, 0.55, 1]),
  circOut: /* @__PURE__ */ cubicBezierAsString([0.55, 0, 1, 0.45]),
  backIn: /* @__PURE__ */ cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),
  backOut: /* @__PURE__ */ cubicBezierAsString([0.33, 1.53, 0.69, 0.99]),
};
function mapEasingToNativeEasing(easing, duration) {
  if (!easing) {
    return void 0;
  } else if (typeof easing === "function") {
    return supportsLinearEasing() ? generateLinearEasing(easing, duration) : "ease-out";
  } else if (isBezierDefinition(easing)) {
    return cubicBezierAsString(easing);
  } else if (Array.isArray(easing)) {
    return easing.map(
      (segmentEasing) =>
        mapEasingToNativeEasing(segmentEasing, duration) || supportedWaapiEasing.easeOut,
    );
  } else {
    return supportedWaapiEasing[easing];
  }
}
function startWaapiAnimation(
  element,
  valueName,
  keyframes2,
  {
    delay: delay2 = 0,
    duration = 300,
    repeat = 0,
    repeatType = "loop",
    ease: ease2 = "easeOut",
    times,
  } = {},
  pseudoElement = void 0,
) {
  const keyframeOptions = {
    [valueName]: keyframes2,
  };
  if (times) keyframeOptions.offset = times;
  const easing = mapEasingToNativeEasing(ease2, duration);
  if (Array.isArray(easing)) keyframeOptions.easing = easing;
  const options = {
    delay: delay2,
    duration,
    easing: !Array.isArray(easing) ? easing : "linear",
    fill: "both",
    iterations: repeat + 1,
    direction: repeatType === "reverse" ? "alternate" : "normal",
  };
  if (pseudoElement) options.pseudoElement = pseudoElement;
  const animation = element.animate(keyframeOptions, options);
  return animation;
}
function isGenerator(type) {
  return typeof type === "function" && "applyToOptions" in type;
}
function applyGeneratorOptions({ type, ...options }) {
  if (isGenerator(type) && supportsLinearEasing()) {
    return type.applyToOptions(options);
  } else {
    options.duration ?? (options.duration = 300);
    options.ease ?? (options.ease = "easeOut");
  }
  return options;
}
class NativeAnimation extends WithPromise {
  constructor(options) {
    super();
    this.finishedTime = null;
    this.isStopped = false;
    this.manualStartTime = null;
    if (!options) return;
    const {
      element,
      name,
      keyframes: keyframes2,
      pseudoElement,
      allowFlatten = false,
      finalKeyframe,
      onComplete,
    } = options;
    this.isPseudoElement = Boolean(pseudoElement);
    this.allowFlatten = allowFlatten;
    this.options = options;
    invariant(
      typeof options.type !== "string",
      `Mini animate() doesn't support "type" as a string.`,
      "mini-spring",
    );
    const transition = applyGeneratorOptions(options);
    this.animation = startWaapiAnimation(element, name, keyframes2, transition, pseudoElement);
    if (transition.autoplay === false) {
      this.animation.pause();
    }
    this.animation.onfinish = () => {
      this.finishedTime = this.time;
      if (!pseudoElement) {
        const keyframe = getFinalKeyframe$1(keyframes2, this.options, finalKeyframe, this.speed);
        if (this.updateMotionValue) {
          this.updateMotionValue(keyframe);
        } else {
          setStyle(element, name, keyframe);
        }
        this.animation.cancel();
      }
      onComplete == null ? void 0 : onComplete();
      this.notifyFinished();
    };
  }
  play() {
    if (this.isStopped) return;
    this.manualStartTime = null;
    this.animation.play();
    if (this.state === "finished") {
      this.updateFinished();
    }
  }
  pause() {
    this.animation.pause();
  }
  complete() {
    var _a2, _b;
    (_b = (_a2 = this.animation).finish) == null ? void 0 : _b.call(_a2);
  }
  cancel() {
    try {
      this.animation.cancel();
    } catch (e) {}
  }
  stop() {
    if (this.isStopped) return;
    this.isStopped = true;
    const { state } = this;
    if (state === "idle" || state === "finished") {
      return;
    }
    if (this.updateMotionValue) {
      this.updateMotionValue();
    } else {
      this.commitStyles();
    }
    if (!this.isPseudoElement) this.cancel();
  }
  /**
   * WAAPI doesn't natively have any interruption capabilities.
   *
   * In this method, we commit styles back to the DOM before cancelling
   * the animation.
   *
   * This is designed to be overridden by NativeAnimationExtended, which
   * will create a renderless JS animation and sample it twice to calculate
   * its current value, "previous" value, and therefore allow
   * Motion to also correctly calculate velocity for any subsequent animation
   * while deferring the commit until the next animation frame.
   */
  commitStyles() {
    var _a2, _b;
    if (!this.isPseudoElement) {
      (_b = (_a2 = this.animation).commitStyles) == null ? void 0 : _b.call(_a2);
    }
  }
  get duration() {
    var _a2, _b;
    const duration =
      ((_b = (_a2 = this.animation.effect) == null ? void 0 : _a2.getComputedTiming) == null
        ? void 0
        : _b.call(_a2).duration) || 0;
    return /* @__PURE__ */ millisecondsToSeconds(Number(duration));
  }
  get iterationDuration() {
    const { delay: delay2 = 0 } = this.options || {};
    return this.duration + /* @__PURE__ */ millisecondsToSeconds(delay2);
  }
  get time() {
    return /* @__PURE__ */ millisecondsToSeconds(Number(this.animation.currentTime) || 0);
  }
  set time(newTime) {
    this.manualStartTime = null;
    this.finishedTime = null;
    this.animation.currentTime = /* @__PURE__ */ secondsToMilliseconds(newTime);
  }
  /**
   * The playback speed of the animation.
   * 1 = normal speed, 2 = double speed, 0.5 = half speed.
   */
  get speed() {
    return this.animation.playbackRate;
  }
  set speed(newSpeed) {
    if (newSpeed < 0) this.finishedTime = null;
    this.animation.playbackRate = newSpeed;
  }
  get state() {
    return this.finishedTime !== null ? "finished" : this.animation.playState;
  }
  get startTime() {
    return this.manualStartTime ?? Number(this.animation.startTime);
  }
  set startTime(newStartTime) {
    this.manualStartTime = this.animation.startTime = newStartTime;
  }
  /**
   * Attaches a timeline to the animation, for instance the `ScrollTimeline`.
   */
  attachTimeline({ timeline, observe }) {
    var _a2;
    if (this.allowFlatten) {
      (_a2 = this.animation.effect) == null ? void 0 : _a2.updateTiming({ easing: "linear" });
    }
    this.animation.onfinish = null;
    if (timeline && supportsScrollTimeline()) {
      this.animation.timeline = timeline;
      return noop$2;
    } else {
      return observe(this);
    }
  }
}
const unsupportedEasingFunctions = {
  anticipate,
  backInOut,
  circInOut,
};
function isUnsupportedEase(key) {
  return key in unsupportedEasingFunctions;
}
function replaceStringEasing(transition) {
  if (typeof transition.ease === "string" && isUnsupportedEase(transition.ease)) {
    transition.ease = unsupportedEasingFunctions[transition.ease];
  }
}
const sampleDelta = 10;
class NativeAnimationExtended extends NativeAnimation {
  constructor(options) {
    replaceStringEasing(options);
    replaceTransitionType(options);
    super(options);
    if (options.startTime !== void 0) {
      this.startTime = options.startTime;
    }
    this.options = options;
  }
  /**
   * WAAPI doesn't natively have any interruption capabilities.
   *
   * Rather than read committed styles back out of the DOM, we can
   * create a renderless JS animation and sample it twice to calculate
   * its current value, "previous" value, and therefore allow
   * Motion to calculate velocity for any subsequent animation.
   */
  updateMotionValue(value) {
    const { motionValue: motionValue2, onUpdate, onComplete, element, ...options } = this.options;
    if (!motionValue2) return;
    if (value !== void 0) {
      motionValue2.set(value);
      return;
    }
    const sampleAnimation = new JSAnimation({
      ...options,
      autoplay: false,
    });
    const sampleTime = Math.max(sampleDelta, time.now() - this.startTime);
    const delta = clamp$2(0, sampleDelta, sampleTime - sampleDelta);
    motionValue2.setWithVelocity(
      sampleAnimation.sample(Math.max(0, sampleTime - delta)).value,
      sampleAnimation.sample(sampleTime).value,
      delta,
    );
    sampleAnimation.stop();
  }
}
const isAnimatable = (value, name) => {
  if (name === "zIndex") return false;
  if (typeof value === "number" || Array.isArray(value)) return true;
  if (
    typeof value === "string" && // It's animatable if we have a string
    (complex.test(value) || value === "0") && // And it contains numbers and/or colors
    !value.startsWith("url(")
  ) {
    return true;
  }
  return false;
};
function hasKeyframesChanged(keyframes2) {
  const current = keyframes2[0];
  if (keyframes2.length === 1) return true;
  for (let i = 0; i < keyframes2.length; i++) {
    if (keyframes2[i] !== current) return true;
  }
}
function canAnimate(keyframes2, name, type, velocity) {
  const originKeyframe = keyframes2[0];
  if (originKeyframe === null) {
    return false;
  }
  if (name === "display" || name === "visibility") return true;
  const targetKeyframe = keyframes2[keyframes2.length - 1];
  const isOriginAnimatable = isAnimatable(originKeyframe, name);
  const isTargetAnimatable = isAnimatable(targetKeyframe, name);
  warning(
    isOriginAnimatable === isTargetAnimatable,
    `You are trying to animate ${name} from "${originKeyframe}" to "${targetKeyframe}". "${isOriginAnimatable ? targetKeyframe : originKeyframe}" is not an animatable value.`,
    "value-not-animatable",
  );
  if (!isOriginAnimatable || !isTargetAnimatable) {
    return false;
  }
  return hasKeyframesChanged(keyframes2) || ((type === "spring" || isGenerator(type)) && velocity);
}
function makeAnimationInstant(options) {
  options.duration = 0;
  options.type = "keyframes";
}
const acceleratedValues = /* @__PURE__ */ new Set([
  "opacity",
  "clipPath",
  "filter",
  "transform",
  // TODO: Could be re-enabled now we have support for linear() easing
  // "background-color"
]);
const supportsWaapi = /* @__PURE__ */ memo(() =>
  Object.hasOwnProperty.call(Element.prototype, "animate"),
);
function supportsBrowserAnimation(options) {
  var _a2;
  const { motionValue: motionValue2, name, repeatDelay, repeatType, damping, type } = options;
  const subject =
    (_a2 = motionValue2 == null ? void 0 : motionValue2.owner) == null ? void 0 : _a2.current;
  if (!(subject instanceof HTMLElement)) {
    return false;
  }
  const { onUpdate, transformTemplate } = motionValue2.owner.getProps();
  return (
    supportsWaapi() &&
    name &&
    acceleratedValues.has(name) &&
    (name !== "transform" || !transformTemplate) /**
     * If we're outputting values to onUpdate then we can't use WAAPI as there's
     * no way to read the value from WAAPI every frame.
     */ &&
    !onUpdate &&
    !repeatDelay &&
    repeatType !== "mirror" &&
    damping !== 0 &&
    type !== "inertia"
  );
}
const MAX_RESOLVE_DELAY = 40;
class AsyncMotionValueAnimation extends WithPromise {
  constructor({
    autoplay = true,
    delay: delay2 = 0,
    type = "keyframes",
    repeat = 0,
    repeatDelay = 0,
    repeatType = "loop",
    keyframes: keyframes2,
    name,
    motionValue: motionValue2,
    element,
    ...options
  }) {
    var _a2;
    super();
    this.stop = () => {
      var _a3, _b;
      if (this._animation) {
        this._animation.stop();
        (_a3 = this.stopTimeline) == null ? void 0 : _a3.call(this);
      }
      (_b = this.keyframeResolver) == null ? void 0 : _b.cancel();
    };
    this.createdAt = time.now();
    const optionsWithDefaults = {
      autoplay,
      delay: delay2,
      type,
      repeat,
      repeatDelay,
      repeatType,
      name,
      motionValue: motionValue2,
      element,
      ...options,
    };
    const KeyframeResolver$1 =
      (element == null ? void 0 : element.KeyframeResolver) || KeyframeResolver;
    this.keyframeResolver = new KeyframeResolver$1(
      keyframes2,
      (resolvedKeyframes, finalKeyframe, forced) =>
        this.onKeyframesResolved(resolvedKeyframes, finalKeyframe, optionsWithDefaults, !forced),
      name,
      motionValue2,
      element,
    );
    (_a2 = this.keyframeResolver) == null ? void 0 : _a2.scheduleResolve();
  }
  onKeyframesResolved(keyframes2, finalKeyframe, options, sync) {
    var _a2, _b;
    this.keyframeResolver = void 0;
    const { name, type, velocity, delay: delay2, isHandoff, onUpdate } = options;
    this.resolvedAt = time.now();
    if (!canAnimate(keyframes2, name, type, velocity)) {
      if (MotionGlobalConfig.instantAnimations || !delay2) {
        onUpdate == null
          ? void 0
          : onUpdate(getFinalKeyframe$1(keyframes2, options, finalKeyframe));
      }
      keyframes2[0] = keyframes2[keyframes2.length - 1];
      makeAnimationInstant(options);
      options.repeat = 0;
    }
    const startTime = sync
      ? !this.resolvedAt
        ? this.createdAt
        : this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY
          ? this.resolvedAt
          : this.createdAt
      : void 0;
    const resolvedOptions = {
      startTime,
      finalKeyframe,
      ...options,
      keyframes: keyframes2,
    };
    const useWaapi = !isHandoff && supportsBrowserAnimation(resolvedOptions);
    const element =
      (_b = (_a2 = resolvedOptions.motionValue) == null ? void 0 : _a2.owner) == null
        ? void 0
        : _b.current;
    const animation = useWaapi
      ? new NativeAnimationExtended({
          ...resolvedOptions,
          element,
        })
      : new JSAnimation(resolvedOptions);
    animation.finished
      .then(() => {
        this.notifyFinished();
      })
      .catch(noop$2);
    if (this.pendingTimeline) {
      this.stopTimeline = animation.attachTimeline(this.pendingTimeline);
      this.pendingTimeline = void 0;
    }
    this._animation = animation;
  }
  get finished() {
    if (!this._animation) {
      return this._finished;
    } else {
      return this.animation.finished;
    }
  }
  then(onResolve, _onReject) {
    return this.finished.finally(onResolve).then(() => {});
  }
  get animation() {
    var _a2;
    if (!this._animation) {
      (_a2 = this.keyframeResolver) == null ? void 0 : _a2.resume();
      flushKeyframeResolvers();
    }
    return this._animation;
  }
  get duration() {
    return this.animation.duration;
  }
  get iterationDuration() {
    return this.animation.iterationDuration;
  }
  get time() {
    return this.animation.time;
  }
  set time(newTime) {
    this.animation.time = newTime;
  }
  get speed() {
    return this.animation.speed;
  }
  get state() {
    return this.animation.state;
  }
  set speed(newSpeed) {
    this.animation.speed = newSpeed;
  }
  get startTime() {
    return this.animation.startTime;
  }
  attachTimeline(timeline) {
    if (this._animation) {
      this.stopTimeline = this.animation.attachTimeline(timeline);
    } else {
      this.pendingTimeline = timeline;
    }
    return () => this.stop();
  }
  play() {
    this.animation.play();
  }
  pause() {
    this.animation.pause();
  }
  complete() {
    this.animation.complete();
  }
  cancel() {
    var _a2;
    if (this._animation) {
      this.animation.cancel();
    }
    (_a2 = this.keyframeResolver) == null ? void 0 : _a2.cancel();
  }
}
function calcChildStagger(
  children,
  child,
  delayChildren,
  staggerChildren = 0,
  staggerDirection = 1,
) {
  const index2 = Array.from(children)
    .sort((a, b) => a.sortNodePosition(b))
    .indexOf(child);
  const numChildren = children.size;
  const maxStaggerDuration = (numChildren - 1) * staggerChildren;
  const delayIsFunction = typeof delayChildren === "function";
  return delayIsFunction
    ? delayChildren(index2, numChildren)
    : staggerDirection === 1
      ? index2 * staggerChildren
      : maxStaggerDuration - index2 * staggerChildren;
}
const splitCSSVariableRegex =
  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words
  /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;
function parseCSSVariable(current) {
  const match = splitCSSVariableRegex.exec(current);
  if (!match) return [,];
  const [, token1, token2, fallback] = match;
  return [`--${token1 ?? token2}`, fallback];
}
const maxDepth = 4;
function getVariableValue(current, element, depth = 1) {
  invariant(
    depth <= maxDepth,
    `Max CSS variable fallback depth detected in property "${current}". This may indicate a circular fallback dependency.`,
    "max-css-var-depth",
  );
  const [token, fallback] = parseCSSVariable(current);
  if (!token) return;
  const resolved = window.getComputedStyle(element).getPropertyValue(token);
  if (resolved) {
    const trimmed = resolved.trim();
    return isNumericalString(trimmed) ? parseFloat(trimmed) : trimmed;
  }
  return isCSSVariableToken(fallback) ? getVariableValue(fallback, element, depth + 1) : fallback;
}
const underDampedSpring = {
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10,
};
const criticallyDampedSpring = (target) => ({
  type: "spring",
  stiffness: 550,
  damping: target === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10,
});
const keyframesTransition = {
  type: "keyframes",
  duration: 0.8,
};
const ease = {
  type: "keyframes",
  ease: [0.25, 0.1, 0.35, 1],
  duration: 0.3,
};
const getDefaultTransition = (valueKey, { keyframes: keyframes2 }) => {
  if (keyframes2.length > 2) {
    return keyframesTransition;
  } else if (transformProps.has(valueKey)) {
    return valueKey.startsWith("scale") ? criticallyDampedSpring(keyframes2[1]) : underDampedSpring;
  }
  return ease;
};
const isNotNull = (value) => value !== null;
function getFinalKeyframe(keyframes2, { repeat, repeatType = "loop" }, finalKeyframe) {
  const resolvedKeyframes = keyframes2.filter(isNotNull);
  const index2 =
    repeat && repeatType !== "loop" && repeat % 2 === 1 ? 0 : resolvedKeyframes.length - 1;
  return resolvedKeyframes[index2];
}
function getValueTransition(transition, key) {
  return (
    (transition == null ? void 0 : transition[key]) ??
    (transition == null ? void 0 : transition["default"]) ??
    transition
  );
}
function isTransitionDefined({
  when,
  delay: _delay,
  delayChildren,
  staggerChildren,
  staggerDirection,
  repeat,
  repeatType,
  repeatDelay,
  from,
  elapsed,
  ...transition
}) {
  return !!Object.keys(transition).length;
}
const animateMotionValue =
  (name, value, target, transition = {}, element, isHandoff) =>
  (onComplete) => {
    const valueTransition = getValueTransition(transition, name) || {};
    const delay2 = valueTransition.delay || transition.delay || 0;
    let { elapsed = 0 } = transition;
    elapsed = elapsed - /* @__PURE__ */ secondsToMilliseconds(delay2);
    const options = {
      keyframes: Array.isArray(target) ? target : [null, target],
      ease: "easeOut",
      velocity: value.getVelocity(),
      ...valueTransition,
      delay: -elapsed,
      onUpdate: (v) => {
        value.set(v);
        valueTransition.onUpdate && valueTransition.onUpdate(v);
      },
      onComplete: () => {
        onComplete();
        valueTransition.onComplete && valueTransition.onComplete();
      },
      name,
      motionValue: value,
      element: isHandoff ? void 0 : element,
    };
    if (!isTransitionDefined(valueTransition)) {
      Object.assign(options, getDefaultTransition(name, options));
    }
    options.duration &&
      (options.duration = /* @__PURE__ */ secondsToMilliseconds(options.duration));
    options.repeatDelay &&
      (options.repeatDelay = /* @__PURE__ */ secondsToMilliseconds(options.repeatDelay));
    if (options.from !== void 0) {
      options.keyframes[0] = options.from;
    }
    let shouldSkip = false;
    if (options.type === false || (options.duration === 0 && !options.repeatDelay)) {
      makeAnimationInstant(options);
      if (options.delay === 0) {
        shouldSkip = true;
      }
    }
    if (MotionGlobalConfig.instantAnimations || MotionGlobalConfig.skipAnimations) {
      shouldSkip = true;
      makeAnimationInstant(options);
      options.delay = 0;
    }
    options.allowFlatten = !valueTransition.type && !valueTransition.ease;
    if (shouldSkip && !isHandoff && value.get() !== void 0) {
      const finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);
      if (finalKeyframe !== void 0) {
        frame.update(() => {
          options.onUpdate(finalKeyframe);
          options.onComplete();
        });
        return;
      }
    }
    return valueTransition.isSync
      ? new JSAnimation(options)
      : new AsyncMotionValueAnimation(options);
  };
function getValueState(visualElement) {
  const state = [{}, {}];
  visualElement == null
    ? void 0
    : visualElement.values.forEach((value, key) => {
        state[0][key] = value.get();
        state[1][key] = value.getVelocity();
      });
  return state;
}
function resolveVariantFromProps(props, definition, custom, visualElement) {
  if (typeof definition === "function") {
    const [current, velocity] = getValueState(visualElement);
    definition = definition(custom !== void 0 ? custom : props.custom, current, velocity);
  }
  if (typeof definition === "string") {
    definition = props.variants && props.variants[definition];
  }
  if (typeof definition === "function") {
    const [current, velocity] = getValueState(visualElement);
    definition = definition(custom !== void 0 ? custom : props.custom, current, velocity);
  }
  return definition;
}
function resolveVariant(visualElement, definition, custom) {
  const props = visualElement.getProps();
  return resolveVariantFromProps(
    props,
    definition,
    custom !== void 0 ? custom : props.custom,
    visualElement,
  );
}
const positionalKeys = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  ...transformPropOrder,
]);
const MAX_VELOCITY_DELTA = 30;
const isFloat = (value) => {
  return !isNaN(parseFloat(value));
};
class MotionValue {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   */
  constructor(init, options = {}) {
    this.canTrackVelocity = null;
    this.events = {};
    this.updateAndNotify = (v) => {
      var _a2;
      const currentTime = time.now();
      if (this.updatedAt !== currentTime) {
        this.setPrevFrameValue();
      }
      this.prev = this.current;
      this.setCurrent(v);
      if (this.current !== this.prev) {
        (_a2 = this.events.change) == null ? void 0 : _a2.notify(this.current);
        if (this.dependents) {
          for (const dependent of this.dependents) {
            dependent.dirty();
          }
        }
      }
    };
    this.hasAnimated = false;
    this.setCurrent(init);
    this.owner = options.owner;
  }
  setCurrent(current) {
    this.current = current;
    this.updatedAt = time.now();
    if (this.canTrackVelocity === null && current !== void 0) {
      this.canTrackVelocity = isFloat(this.current);
    }
  }
  setPrevFrameValue(prevFrameValue = this.current) {
    this.prevFrameValue = prevFrameValue;
    this.prevUpdatedAt = this.updatedAt;
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.on("change", updateOpacity)
   *     const unsubscribeY = y.on("change", updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @deprecated
   */
  onChange(subscription) {
    return this.on("change", subscription);
  }
  on(eventName, callback) {
    if (!this.events[eventName]) {
      this.events[eventName] = new SubscriptionManager();
    }
    const unsubscribe = this.events[eventName].add(callback);
    if (eventName === "change") {
      return () => {
        unsubscribe();
        frame.read(() => {
          if (!this.events.change.getSize()) {
            this.stop();
          }
        });
      };
    }
    return unsubscribe;
  }
  clearListeners() {
    for (const eventManagers in this.events) {
      this.events[eventManagers].clear();
    }
  }
  /**
   * Attaches a passive effect to the `MotionValue`.
   */
  attach(passiveEffect, stopPassiveEffect) {
    this.passiveEffect = passiveEffect;
    this.stopPassiveEffect = stopPassiveEffect;
  }
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  set(v) {
    if (!this.passiveEffect) {
      this.updateAndNotify(v);
    } else {
      this.passiveEffect(v, this.updateAndNotify);
    }
  }
  setWithVelocity(prev, current, delta) {
    this.set(current);
    this.prev = void 0;
    this.prevFrameValue = prev;
    this.prevUpdatedAt = this.updatedAt - delta;
  }
  /**
   * Set the state of the `MotionValue`, stopping any active animations,
   * effects, and resets velocity to `0`.
   */
  jump(v, endAnimation = true) {
    this.updateAndNotify(v);
    this.prev = v;
    this.prevUpdatedAt = this.prevFrameValue = void 0;
    endAnimation && this.stop();
    if (this.stopPassiveEffect) this.stopPassiveEffect();
  }
  dirty() {
    var _a2;
    (_a2 = this.events.change) == null ? void 0 : _a2.notify(this.current);
  }
  addDependent(dependent) {
    if (!this.dependents) {
      this.dependents = /* @__PURE__ */ new Set();
    }
    this.dependents.add(dependent);
  }
  removeDependent(dependent) {
    if (this.dependents) {
      this.dependents.delete(dependent);
    }
  }
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  get() {
    return this.current;
  }
  /**
   * @public
   */
  getPrevious() {
    return this.prev;
  }
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  getVelocity() {
    const currentTime = time.now();
    if (
      !this.canTrackVelocity ||
      this.prevFrameValue === void 0 ||
      currentTime - this.updatedAt > MAX_VELOCITY_DELTA
    ) {
      return 0;
    }
    const delta = Math.min(this.updatedAt - this.prevUpdatedAt, MAX_VELOCITY_DELTA);
    return velocityPerSecond(parseFloat(this.current) - parseFloat(this.prevFrameValue), delta);
  }
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   */
  start(startAnimation) {
    this.stop();
    return new Promise((resolve) => {
      this.hasAnimated = true;
      this.animation = startAnimation(resolve);
      if (this.events.animationStart) {
        this.events.animationStart.notify();
      }
    }).then(() => {
      if (this.events.animationComplete) {
        this.events.animationComplete.notify();
      }
      this.clearAnimation();
    });
  }
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  stop() {
    if (this.animation) {
      this.animation.stop();
      if (this.events.animationCancel) {
        this.events.animationCancel.notify();
      }
    }
    this.clearAnimation();
  }
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  destroy() {
    var _a2, _b;
    (_a2 = this.dependents) == null ? void 0 : _a2.clear();
    (_b = this.events.destroy) == null ? void 0 : _b.notify();
    this.clearListeners();
    this.stop();
    if (this.stopPassiveEffect) {
      this.stopPassiveEffect();
    }
  }
}
function motionValue(init, options) {
  return new MotionValue(init, options);
}
const isKeyframesTarget = (v) => {
  return Array.isArray(v);
};
function setMotionValue(visualElement, key, value) {
  if (visualElement.hasValue(key)) {
    visualElement.getValue(key).set(value);
  } else {
    visualElement.addValue(key, motionValue(value));
  }
}
function resolveFinalValueInKeyframes(v) {
  return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;
}
function setTarget(visualElement, definition) {
  const resolved = resolveVariant(visualElement, definition);
  let { transitionEnd = {}, transition = {}, ...target } = resolved || {};
  target = { ...target, ...transitionEnd };
  for (const key in target) {
    const value = resolveFinalValueInKeyframes(target[key]);
    setMotionValue(visualElement, key, value);
  }
}
const isMotionValue = (value) => Boolean(value && value.getVelocity);
function isWillChangeMotionValue(value) {
  return Boolean(isMotionValue(value) && value.add);
}
function addValueToWillChange(visualElement, key) {
  const willChange = visualElement.getValue("willChange");
  if (isWillChangeMotionValue(willChange)) {
    return willChange.add(key);
  } else if (!willChange && MotionGlobalConfig.WillChange) {
    const newWillChange = new MotionGlobalConfig.WillChange("auto");
    visualElement.addValue("willChange", newWillChange);
    newWillChange.add(key);
  }
}
function camelToDash(str) {
  return str.replace(/([A-Z])/g, (match) => `-${match.toLowerCase()}`);
}
const optimizedAppearDataId = "framerAppearId";
const optimizedAppearDataAttribute = "data-" + camelToDash(optimizedAppearDataId);
function getOptimisedAppearId(visualElement) {
  return visualElement.props[optimizedAppearDataAttribute];
}
function shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {
  const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;
  needsAnimating[key] = false;
  return shouldBlock;
}
function animateTarget(
  visualElement,
  targetAndTransition,
  { delay: delay2 = 0, transitionOverride, type } = {},
) {
  let {
    transition = visualElement.getDefaultTransition(),
    transitionEnd,
    ...target
  } = targetAndTransition;
  if (transitionOverride) transition = transitionOverride;
  const animations2 = [];
  const animationTypeState =
    type && visualElement.animationState && visualElement.animationState.getState()[type];
  for (const key in target) {
    const value = visualElement.getValue(key, visualElement.latestValues[key] ?? null);
    const valueTarget = target[key];
    if (
      valueTarget === void 0 ||
      (animationTypeState && shouldBlockAnimation(animationTypeState, key))
    ) {
      continue;
    }
    const valueTransition = {
      delay: delay2,
      ...getValueTransition(transition || {}, key),
    };
    const currentValue = value.get();
    if (
      currentValue !== void 0 &&
      !value.isAnimating &&
      !Array.isArray(valueTarget) &&
      valueTarget === currentValue &&
      !valueTransition.velocity
    ) {
      continue;
    }
    let isHandoff = false;
    if (window.MotionHandoffAnimation) {
      const appearId = getOptimisedAppearId(visualElement);
      if (appearId) {
        const startTime = window.MotionHandoffAnimation(appearId, key, frame);
        if (startTime !== null) {
          valueTransition.startTime = startTime;
          isHandoff = true;
        }
      }
    }
    addValueToWillChange(visualElement, key);
    value.start(
      animateMotionValue(
        key,
        value,
        valueTarget,
        visualElement.shouldReduceMotion && positionalKeys.has(key)
          ? { type: false }
          : valueTransition,
        visualElement,
        isHandoff,
      ),
    );
    const animation = value.animation;
    if (animation) {
      animations2.push(animation);
    }
  }
  if (transitionEnd) {
    Promise.all(animations2).then(() => {
      frame.update(() => {
        transitionEnd && setTarget(visualElement, transitionEnd);
      });
    });
  }
  return animations2;
}
function animateVariant(visualElement, variant, options = {}) {
  var _a2;
  const resolved = resolveVariant(
    visualElement,
    variant,
    options.type === "exit"
      ? (_a2 = visualElement.presenceContext) == null
        ? void 0
        : _a2.custom
      : void 0,
  );
  let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};
  if (options.transitionOverride) {
    transition = options.transitionOverride;
  }
  const getAnimation = resolved
    ? () => Promise.all(animateTarget(visualElement, resolved, options))
    : () => Promise.resolve();
  const getChildAnimations =
    visualElement.variantChildren && visualElement.variantChildren.size
      ? (forwardDelay = 0) => {
          const { delayChildren = 0, staggerChildren, staggerDirection } = transition;
          return animateChildren(
            visualElement,
            variant,
            forwardDelay,
            delayChildren,
            staggerChildren,
            staggerDirection,
            options,
          );
        }
      : () => Promise.resolve();
  const { when } = transition;
  if (when) {
    const [first, last] =
      when === "beforeChildren"
        ? [getAnimation, getChildAnimations]
        : [getChildAnimations, getAnimation];
    return first().then(() => last());
  } else {
    return Promise.all([getAnimation(), getChildAnimations(options.delay)]);
  }
}
function animateChildren(
  visualElement,
  variant,
  delay2 = 0,
  delayChildren = 0,
  staggerChildren = 0,
  staggerDirection = 1,
  options,
) {
  const animations2 = [];
  for (const child of visualElement.variantChildren) {
    child.notify("AnimationStart", variant);
    animations2.push(
      animateVariant(child, variant, {
        ...options,
        delay:
          delay2 +
          (typeof delayChildren === "function" ? 0 : delayChildren) +
          calcChildStagger(
            visualElement.variantChildren,
            child,
            delayChildren,
            staggerChildren,
            staggerDirection,
          ),
      }).then(() => child.notify("AnimationComplete", variant)),
    );
  }
  return Promise.all(animations2);
}
function animateVisualElement(visualElement, definition, options = {}) {
  visualElement.notify("AnimationStart", definition);
  let animation;
  if (Array.isArray(definition)) {
    const animations2 = definition.map((variant) =>
      animateVariant(visualElement, variant, options),
    );
    animation = Promise.all(animations2);
  } else if (typeof definition === "string") {
    animation = animateVariant(visualElement, definition, options);
  } else {
    const resolvedDefinition =
      typeof definition === "function"
        ? resolveVariant(visualElement, definition, options.custom)
        : definition;
    animation = Promise.all(animateTarget(visualElement, resolvedDefinition, options));
  }
  return animation.then(() => {
    visualElement.notify("AnimationComplete", definition);
  });
}
const auto = {
  test: (v) => v === "auto",
  parse: (v) => v,
};
const testValueType = (v) => (type) => type.test(v);
const dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];
const findDimensionValueType = (v) => dimensionValueTypes.find(testValueType(v));
function isNone(value) {
  if (typeof value === "number") {
    return value === 0;
  } else if (value !== null) {
    return value === "none" || value === "0" || isZeroValueString(value);
  } else {
    return true;
  }
}
const maxDefaults = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function applyDefaultFilter(v) {
  const [name, value] = v.slice(0, -1).split("(");
  if (name === "drop-shadow") return v;
  const [number2] = value.match(floatRegex) || [];
  if (!number2) return v;
  const unit = value.replace(number2, "");
  let defaultValue = maxDefaults.has(name) ? 1 : 0;
  if (number2 !== value) defaultValue *= 100;
  return name + "(" + defaultValue + unit + ")";
}
const functionRegex = /\b([a-z-]*)\(.*?\)/gu;
const filter = {
  ...complex,
  getAnimatableNone: (v) => {
    const functions = v.match(functionRegex);
    return functions ? functions.map(applyDefaultFilter).join(" ") : v;
  },
};
const int = {
  ...number,
  transform: Math.round,
};
const transformValueTypes = {
  rotate: degrees,
  rotateX: degrees,
  rotateY: degrees,
  rotateZ: degrees,
  scale,
  scaleX: scale,
  scaleY: scale,
  scaleZ: scale,
  skew: degrees,
  skewX: degrees,
  skewY: degrees,
  distance: px,
  translateX: px,
  translateY: px,
  translateZ: px,
  x: px,
  y: px,
  z: px,
  perspective: px,
  transformPerspective: px,
  opacity: alpha,
  originX: progressPercentage,
  originY: progressPercentage,
  originZ: px,
};
const numberValueTypes = {
  // Border props
  borderWidth: px,
  borderTopWidth: px,
  borderRightWidth: px,
  borderBottomWidth: px,
  borderLeftWidth: px,
  borderRadius: px,
  radius: px,
  borderTopLeftRadius: px,
  borderTopRightRadius: px,
  borderBottomRightRadius: px,
  borderBottomLeftRadius: px,
  // Positioning props
  width: px,
  maxWidth: px,
  height: px,
  maxHeight: px,
  top: px,
  right: px,
  bottom: px,
  left: px,
  inset: px,
  insetBlock: px,
  insetBlockStart: px,
  insetBlockEnd: px,
  insetInline: px,
  insetInlineStart: px,
  insetInlineEnd: px,
  // Spacing props
  padding: px,
  paddingTop: px,
  paddingRight: px,
  paddingBottom: px,
  paddingLeft: px,
  paddingBlock: px,
  paddingBlockStart: px,
  paddingBlockEnd: px,
  paddingInline: px,
  paddingInlineStart: px,
  paddingInlineEnd: px,
  margin: px,
  marginTop: px,
  marginRight: px,
  marginBottom: px,
  marginLeft: px,
  marginBlock: px,
  marginBlockStart: px,
  marginBlockEnd: px,
  marginInline: px,
  marginInlineStart: px,
  marginInlineEnd: px,
  // Misc
  backgroundPositionX: px,
  backgroundPositionY: px,
  ...transformValueTypes,
  zIndex: int,
  // SVG
  fillOpacity: alpha,
  strokeOpacity: alpha,
  numOctaves: int,
};
const defaultValueTypes = {
  ...numberValueTypes,
  // Color props
  color,
  backgroundColor: color,
  outlineColor: color,
  fill: color,
  stroke: color,
  // Border props
  borderColor: color,
  borderTopColor: color,
  borderRightColor: color,
  borderBottomColor: color,
  borderLeftColor: color,
  filter,
  WebkitFilter: filter,
};
const getDefaultValueType = (key) => defaultValueTypes[key];
function getAnimatableNone(key, value) {
  let defaultValueType = getDefaultValueType(key);
  if (defaultValueType !== filter) defaultValueType = complex;
  return defaultValueType.getAnimatableNone ? defaultValueType.getAnimatableNone(value) : void 0;
}
const invalidTemplates = /* @__PURE__ */ new Set(["auto", "none", "0"]);
function makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name) {
  let i = 0;
  let animatableTemplate = void 0;
  while (i < unresolvedKeyframes.length && !animatableTemplate) {
    const keyframe = unresolvedKeyframes[i];
    if (
      typeof keyframe === "string" &&
      !invalidTemplates.has(keyframe) &&
      analyseComplexValue(keyframe).values.length
    ) {
      animatableTemplate = unresolvedKeyframes[i];
    }
    i++;
  }
  if (animatableTemplate && name) {
    for (const noneIndex of noneKeyframeIndexes) {
      unresolvedKeyframes[noneIndex] = getAnimatableNone(name, animatableTemplate);
    }
  }
}
class DOMKeyframesResolver extends KeyframeResolver {
  constructor(unresolvedKeyframes, onComplete, name, motionValue2, element) {
    super(unresolvedKeyframes, onComplete, name, motionValue2, element, true);
  }
  readKeyframes() {
    const { unresolvedKeyframes, element, name } = this;
    if (!element || !element.current) return;
    super.readKeyframes();
    for (let i = 0; i < unresolvedKeyframes.length; i++) {
      let keyframe = unresolvedKeyframes[i];
      if (typeof keyframe === "string") {
        keyframe = keyframe.trim();
        if (isCSSVariableToken(keyframe)) {
          const resolved = getVariableValue(keyframe, element.current);
          if (resolved !== void 0) {
            unresolvedKeyframes[i] = resolved;
          }
          if (i === unresolvedKeyframes.length - 1) {
            this.finalKeyframe = keyframe;
          }
        }
      }
    }
    this.resolveNoneKeyframes();
    if (!positionalKeys.has(name) || unresolvedKeyframes.length !== 2) {
      return;
    }
    const [origin, target] = unresolvedKeyframes;
    const originType = findDimensionValueType(origin);
    const targetType = findDimensionValueType(target);
    const originHasVar = containsCSSVariable(origin);
    const targetHasVar = containsCSSVariable(target);
    if (originHasVar !== targetHasVar && positionalValues[name]) {
      this.needsMeasurement = true;
      return;
    }
    if (originType === targetType) return;
    if (isNumOrPxType(originType) && isNumOrPxType(targetType)) {
      for (let i = 0; i < unresolvedKeyframes.length; i++) {
        const value = unresolvedKeyframes[i];
        if (typeof value === "string") {
          unresolvedKeyframes[i] = parseFloat(value);
        }
      }
    } else if (positionalValues[name]) {
      this.needsMeasurement = true;
    }
  }
  resolveNoneKeyframes() {
    const { unresolvedKeyframes, name } = this;
    const noneKeyframeIndexes = [];
    for (let i = 0; i < unresolvedKeyframes.length; i++) {
      if (unresolvedKeyframes[i] === null || isNone(unresolvedKeyframes[i])) {
        noneKeyframeIndexes.push(i);
      }
    }
    if (noneKeyframeIndexes.length) {
      makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);
    }
  }
  measureInitialState() {
    const { element, unresolvedKeyframes, name } = this;
    if (!element || !element.current) return;
    if (name === "height") {
      this.suspendedScrollY = window.pageYOffset;
    }
    this.measuredOrigin = positionalValues[name](
      element.measureViewportBox(),
      window.getComputedStyle(element.current),
    );
    unresolvedKeyframes[0] = this.measuredOrigin;
    const measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
    if (measureKeyframe !== void 0) {
      element.getValue(name, measureKeyframe).jump(measureKeyframe, false);
    }
  }
  measureEndState() {
    var _a2;
    const { element, name, unresolvedKeyframes } = this;
    if (!element || !element.current) return;
    const value = element.getValue(name);
    value && value.jump(this.measuredOrigin, false);
    const finalKeyframeIndex = unresolvedKeyframes.length - 1;
    const finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];
    unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](
      element.measureViewportBox(),
      window.getComputedStyle(element.current),
    );
    if (finalKeyframe !== null && this.finalKeyframe === void 0) {
      this.finalKeyframe = finalKeyframe;
    }
    if ((_a2 = this.removedTransforms) == null ? void 0 : _a2.length) {
      this.removedTransforms.forEach(([unsetTransformName, unsetTransformValue]) => {
        element.getValue(unsetTransformName).set(unsetTransformValue);
      });
    }
    this.resolveNoneKeyframes();
  }
}
function resolveElements(elementOrSelector, scope, selectorCache) {
  if (elementOrSelector == null) {
    return [];
  }
  if (elementOrSelector instanceof EventTarget) {
    return [elementOrSelector];
  } else if (typeof elementOrSelector === "string") {
    let root = document;
    const elements =
      (selectorCache == null ? void 0 : selectorCache[elementOrSelector]) ??
      root.querySelectorAll(elementOrSelector);
    return elements ? Array.from(elements) : [];
  }
  return Array.from(elementOrSelector).filter((element) => element != null);
}
const getValueAsType = (value, type) => {
  return type && typeof value === "number" ? type.transform(value) : value;
};
function isHTMLElement$1(element) {
  return isObject(element) && "offsetHeight" in element;
}
const { schedule: microtask } = /* @__PURE__ */ createRenderBatcher(queueMicrotask, false);
const isDragging = {
  x: false,
  y: false,
};
function isDragActive() {
  return isDragging.x || isDragging.y;
}
function setDragLock(axis) {
  if (axis === "x" || axis === "y") {
    if (isDragging[axis]) {
      return null;
    } else {
      isDragging[axis] = true;
      return () => {
        isDragging[axis] = false;
      };
    }
  } else {
    if (isDragging.x || isDragging.y) {
      return null;
    } else {
      isDragging.x = isDragging.y = true;
      return () => {
        isDragging.x = isDragging.y = false;
      };
    }
  }
}
function setupGesture(elementOrSelector, options) {
  const elements = resolveElements(elementOrSelector);
  const gestureAbortController = new AbortController();
  const eventOptions = {
    passive: true,
    ...options,
    signal: gestureAbortController.signal,
  };
  const cancel = () => gestureAbortController.abort();
  return [elements, eventOptions, cancel];
}
function isValidHover(event) {
  return !(event.pointerType === "touch" || isDragActive());
}
function hover(elementOrSelector, onHoverStart, options = {}) {
  const [elements, eventOptions, cancel] = setupGesture(elementOrSelector, options);
  const onPointerEnter = (enterEvent) => {
    if (!isValidHover(enterEvent)) return;
    const { target } = enterEvent;
    const onHoverEnd = onHoverStart(target, enterEvent);
    if (typeof onHoverEnd !== "function" || !target) return;
    const onPointerLeave = (leaveEvent) => {
      if (!isValidHover(leaveEvent)) return;
      onHoverEnd(leaveEvent);
      target.removeEventListener("pointerleave", onPointerLeave);
    };
    target.addEventListener("pointerleave", onPointerLeave, eventOptions);
  };
  elements.forEach((element) => {
    element.addEventListener("pointerenter", onPointerEnter, eventOptions);
  });
  return cancel;
}
const isNodeOrChild = (parent, child) => {
  if (!child) {
    return false;
  } else if (parent === child) {
    return true;
  } else {
    return isNodeOrChild(parent, child.parentElement);
  }
};
const isPrimaryPointer = (event) => {
  if (event.pointerType === "mouse") {
    return typeof event.button !== "number" || event.button <= 0;
  } else {
    return event.isPrimary !== false;
  }
};
const interactiveElements = /* @__PURE__ */ new Set(["BUTTON", "INPUT", "SELECT", "TEXTAREA", "A"]);
function isElementKeyboardAccessible(element) {
  return interactiveElements.has(element.tagName) || element.isContentEditable === true;
}
const isPressing = /* @__PURE__ */ new WeakSet();
function filterEvents(callback) {
  return (event) => {
    if (event.key !== "Enter") return;
    callback(event);
  };
}
function firePointerEvent(target, type) {
  target.dispatchEvent(new PointerEvent("pointer" + type, { isPrimary: true, bubbles: true }));
}
const enableKeyboardPress = (focusEvent, eventOptions) => {
  const element = focusEvent.currentTarget;
  if (!element) return;
  const handleKeydown = filterEvents(() => {
    if (isPressing.has(element)) return;
    firePointerEvent(element, "down");
    const handleKeyup = filterEvents(() => {
      firePointerEvent(element, "up");
    });
    const handleBlur = () => firePointerEvent(element, "cancel");
    element.addEventListener("keyup", handleKeyup, eventOptions);
    element.addEventListener("blur", handleBlur, eventOptions);
  });
  element.addEventListener("keydown", handleKeydown, eventOptions);
  element.addEventListener(
    "blur",
    () => element.removeEventListener("keydown", handleKeydown),
    eventOptions,
  );
};
function isValidPressEvent(event) {
  return isPrimaryPointer(event) && !isDragActive();
}
function press(targetOrSelector, onPressStart, options = {}) {
  const [targets, eventOptions, cancelEvents] = setupGesture(targetOrSelector, options);
  const startPress = (startEvent) => {
    const target = startEvent.currentTarget;
    if (!isValidPressEvent(startEvent)) return;
    isPressing.add(target);
    const onPressEnd = onPressStart(target, startEvent);
    const onPointerEnd = (endEvent, success) => {
      window.removeEventListener("pointerup", onPointerUp);
      window.removeEventListener("pointercancel", onPointerCancel);
      if (isPressing.has(target)) {
        isPressing.delete(target);
      }
      if (!isValidPressEvent(endEvent)) {
        return;
      }
      if (typeof onPressEnd === "function") {
        onPressEnd(endEvent, { success });
      }
    };
    const onPointerUp = (upEvent) => {
      onPointerEnd(
        upEvent,
        target === window ||
          target === document ||
          options.useGlobalTarget ||
          isNodeOrChild(target, upEvent.target),
      );
    };
    const onPointerCancel = (cancelEvent) => {
      onPointerEnd(cancelEvent, false);
    };
    window.addEventListener("pointerup", onPointerUp, eventOptions);
    window.addEventListener("pointercancel", onPointerCancel, eventOptions);
  };
  targets.forEach((target) => {
    const pointerDownTarget = options.useGlobalTarget ? window : target;
    pointerDownTarget.addEventListener("pointerdown", startPress, eventOptions);
    if (isHTMLElement$1(target)) {
      target.addEventListener("focus", (event) => enableKeyboardPress(event, eventOptions));
      if (!isElementKeyboardAccessible(target) && !target.hasAttribute("tabindex")) {
        target.tabIndex = 0;
      }
    }
  });
  return cancelEvents;
}
function isSVGElement(element) {
  return isObject(element) && "ownerSVGElement" in element;
}
function isSVGSVGElement(element) {
  return isSVGElement(element) && element.tagName === "svg";
}
const valueTypes = [...dimensionValueTypes, color, complex];
const findValueType = (v) => valueTypes.find(testValueType(v));
const createAxisDelta = () => ({
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0,
});
const createDelta = () => ({
  x: createAxisDelta(),
  y: createAxisDelta(),
});
const createAxis = () => ({ min: 0, max: 0 });
const createBox = () => ({
  x: createAxis(),
  y: createAxis(),
});
const prefersReducedMotion = { current: null };
const hasReducedMotionListener = { current: false };
const isBrowser = typeof window !== "undefined";
function initPrefersReducedMotion() {
  hasReducedMotionListener.current = true;
  if (!isBrowser) return;
  if (window.matchMedia) {
    const motionMediaQuery = window.matchMedia("(prefers-reduced-motion)");
    const setReducedMotionPreferences = () =>
      (prefersReducedMotion.current = motionMediaQuery.matches);
    motionMediaQuery.addEventListener("change", setReducedMotionPreferences);
    setReducedMotionPreferences();
  } else {
    prefersReducedMotion.current = false;
  }
}
const visualElementStore = /* @__PURE__ */ new WeakMap();
function isAnimationControls(v) {
  return v !== null && typeof v === "object" && typeof v.start === "function";
}
function isVariantLabel(v) {
  return typeof v === "string" || Array.isArray(v);
}
const variantPriorityOrder = [
  "animate",
  "whileInView",
  "whileFocus",
  "whileHover",
  "whileTap",
  "whileDrag",
  "exit",
];
const variantProps = ["initial", ...variantPriorityOrder];
function isControllingVariants(props) {
  return (
    isAnimationControls(props.animate) || variantProps.some((name) => isVariantLabel(props[name]))
  );
}
function isVariantNode(props) {
  return Boolean(isControllingVariants(props) || props.variants);
}
function updateMotionValuesFromProps(element, next, prev) {
  for (const key in next) {
    const nextValue = next[key];
    const prevValue = prev[key];
    if (isMotionValue(nextValue)) {
      element.addValue(key, nextValue);
    } else if (isMotionValue(prevValue)) {
      element.addValue(key, motionValue(nextValue, { owner: element }));
    } else if (prevValue !== nextValue) {
      if (element.hasValue(key)) {
        const existingValue = element.getValue(key);
        if (existingValue.liveStyle === true) {
          existingValue.jump(nextValue);
        } else if (!existingValue.hasAnimated) {
          existingValue.set(nextValue);
        }
      } else {
        const latestValue = element.getStaticValue(key);
        element.addValue(
          key,
          motionValue(latestValue !== void 0 ? latestValue : nextValue, { owner: element }),
        );
      }
    }
  }
  for (const key in prev) {
    if (next[key] === void 0) element.removeValue(key);
  }
  return next;
}
const propEventHandlers = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete",
];
let featureDefinitions = {};
function setFeatureDefinitions(definitions) {
  featureDefinitions = definitions;
}
function getFeatureDefinitions() {
  return featureDefinitions;
}
class VisualElement {
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(_props, _prevProps, _visualElement) {
    return {};
  }
  constructor(
    { parent, props, presenceContext, reducedMotionConfig, blockInitialAnimation, visualState },
    options = {},
  ) {
    this.current = null;
    this.children = /* @__PURE__ */ new Set();
    this.isVariantNode = false;
    this.isControllingVariants = false;
    this.shouldReduceMotion = null;
    this.values = /* @__PURE__ */ new Map();
    this.KeyframeResolver = KeyframeResolver;
    this.features = {};
    this.valueSubscriptions = /* @__PURE__ */ new Map();
    this.prevMotionValues = {};
    this.events = {};
    this.propEventSubscriptions = {};
    this.notifyUpdate = () => this.notify("Update", this.latestValues);
    this.render = () => {
      if (!this.current) return;
      this.triggerBuild();
      this.renderInstance(this.current, this.renderState, this.props.style, this.projection);
    };
    this.renderScheduledAt = 0;
    this.scheduleRender = () => {
      const now2 = time.now();
      if (this.renderScheduledAt < now2) {
        this.renderScheduledAt = now2;
        frame.render(this.render, false, true);
      }
    };
    const { latestValues, renderState } = visualState;
    this.latestValues = latestValues;
    this.baseTarget = { ...latestValues };
    this.initialValues = props.initial ? { ...latestValues } : {};
    this.renderState = renderState;
    this.parent = parent;
    this.props = props;
    this.presenceContext = presenceContext;
    this.depth = parent ? parent.depth + 1 : 0;
    this.reducedMotionConfig = reducedMotionConfig;
    this.options = options;
    this.blockInitialAnimation = Boolean(blockInitialAnimation);
    this.isControllingVariants = isControllingVariants(props);
    this.isVariantNode = isVariantNode(props);
    if (this.isVariantNode) {
      this.variantChildren = /* @__PURE__ */ new Set();
    }
    this.manuallyAnimateOnMount = Boolean(parent && parent.current);
    const { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(
      props,
      {},
      this,
    );
    for (const key in initialMotionValues) {
      const value = initialMotionValues[key];
      if (latestValues[key] !== void 0 && isMotionValue(value)) {
        value.set(latestValues[key]);
      }
    }
  }
  mount(instance) {
    var _a2;
    this.current = instance;
    visualElementStore.set(instance, this);
    if (this.projection && !this.projection.instance) {
      this.projection.mount(instance);
    }
    if (this.parent && this.isVariantNode && !this.isControllingVariants) {
      this.removeFromVariantTree = this.parent.addVariantChild(this);
    }
    this.values.forEach((value, key) => this.bindToMotionValue(key, value));
    if (this.reducedMotionConfig === "never") {
      this.shouldReduceMotion = false;
    } else if (this.reducedMotionConfig === "always") {
      this.shouldReduceMotion = true;
    } else {
      if (!hasReducedMotionListener.current) {
        initPrefersReducedMotion();
      }
      this.shouldReduceMotion = prefersReducedMotion.current;
    }
    (_a2 = this.parent) == null ? void 0 : _a2.addChild(this);
    this.update(this.props, this.presenceContext);
  }
  unmount() {
    var _a2;
    this.projection && this.projection.unmount();
    cancelFrame(this.notifyUpdate);
    cancelFrame(this.render);
    this.valueSubscriptions.forEach((remove) => remove());
    this.valueSubscriptions.clear();
    this.removeFromVariantTree && this.removeFromVariantTree();
    (_a2 = this.parent) == null ? void 0 : _a2.removeChild(this);
    for (const key in this.events) {
      this.events[key].clear();
    }
    for (const key in this.features) {
      const feature = this.features[key];
      if (feature) {
        feature.unmount();
        feature.isMounted = false;
      }
    }
    this.current = null;
  }
  addChild(child) {
    this.children.add(child);
    this.enteringChildren ?? (this.enteringChildren = /* @__PURE__ */ new Set());
    this.enteringChildren.add(child);
  }
  removeChild(child) {
    this.children.delete(child);
    this.enteringChildren && this.enteringChildren.delete(child);
  }
  bindToMotionValue(key, value) {
    if (this.valueSubscriptions.has(key)) {
      this.valueSubscriptions.get(key)();
    }
    const valueIsTransform = transformProps.has(key);
    if (valueIsTransform && this.onBindTransform) {
      this.onBindTransform();
    }
    const removeOnChange = value.on("change", (latestValue) => {
      this.latestValues[key] = latestValue;
      this.props.onUpdate && frame.preRender(this.notifyUpdate);
      if (valueIsTransform && this.projection) {
        this.projection.isTransformDirty = true;
      }
      this.scheduleRender();
    });
    let removeSyncCheck;
    if (typeof window !== "undefined" && window.MotionCheckAppearSync) {
      removeSyncCheck = window.MotionCheckAppearSync(this, key, value);
    }
    this.valueSubscriptions.set(key, () => {
      removeOnChange();
      if (removeSyncCheck) removeSyncCheck();
      if (value.owner) value.stop();
    });
  }
  sortNodePosition(other) {
    if (!this.current || !this.sortInstanceNodePosition || this.type !== other.type) {
      return 0;
    }
    return this.sortInstanceNodePosition(this.current, other.current);
  }
  updateFeatures() {
    let key = "animation";
    for (key in featureDefinitions) {
      const featureDefinition = featureDefinitions[key];
      if (!featureDefinition) continue;
      const { isEnabled, Feature: FeatureConstructor } = featureDefinition;
      if (!this.features[key] && FeatureConstructor && isEnabled(this.props)) {
        this.features[key] = new FeatureConstructor(this);
      }
      if (this.features[key]) {
        const feature = this.features[key];
        if (feature.isMounted) {
          feature.update();
        } else {
          feature.mount();
          feature.isMounted = true;
        }
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox();
  }
  getStaticValue(key) {
    return this.latestValues[key];
  }
  setStaticValue(key, value) {
    this.latestValues[key] = value;
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  update(props, presenceContext) {
    if (props.transformTemplate || this.props.transformTemplate) {
      this.scheduleRender();
    }
    this.prevProps = this.props;
    this.props = props;
    this.prevPresenceContext = this.presenceContext;
    this.presenceContext = presenceContext;
    for (let i = 0; i < propEventHandlers.length; i++) {
      const key = propEventHandlers[i];
      if (this.propEventSubscriptions[key]) {
        this.propEventSubscriptions[key]();
        delete this.propEventSubscriptions[key];
      }
      const listenerName = "on" + key;
      const listener = props[listenerName];
      if (listener) {
        this.propEventSubscriptions[key] = this.on(key, listener);
      }
    }
    this.prevMotionValues = updateMotionValuesFromProps(
      this,
      this.scrapeMotionValuesFromProps(props, this.prevProps || {}, this),
      this.prevMotionValues,
    );
    if (this.handleChildMotionValue) {
      this.handleChildMotionValue();
    }
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(name) {
    return this.props.variants ? this.props.variants[name] : void 0;
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(child) {
    const closestVariantNode = this.getClosestVariantNode();
    if (closestVariantNode) {
      closestVariantNode.variantChildren && closestVariantNode.variantChildren.add(child);
      return () => closestVariantNode.variantChildren.delete(child);
    }
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(key, value) {
    const existingValue = this.values.get(key);
    if (value !== existingValue) {
      if (existingValue) this.removeValue(key);
      this.bindToMotionValue(key, value);
      this.values.set(key, value);
      this.latestValues[key] = value.get();
    }
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(key) {
    this.values.delete(key);
    const unsubscribe = this.valueSubscriptions.get(key);
    if (unsubscribe) {
      unsubscribe();
      this.valueSubscriptions.delete(key);
    }
    delete this.latestValues[key];
    this.removeValueFromRenderState(key, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(key) {
    return this.values.has(key);
  }
  getValue(key, defaultValue) {
    if (this.props.values && this.props.values[key]) {
      return this.props.values[key];
    }
    let value = this.values.get(key);
    if (value === void 0 && defaultValue !== void 0) {
      value = motionValue(defaultValue === null ? void 0 : defaultValue, { owner: this });
      this.addValue(key, value);
    }
    return value;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(key, target) {
    let value =
      this.latestValues[key] !== void 0 || !this.current
        ? this.latestValues[key]
        : (this.getBaseTargetFromProps(this.props, key) ??
          this.readValueFromInstance(this.current, key, this.options));
    if (value !== void 0 && value !== null) {
      if (typeof value === "string" && (isNumericalString(value) || isZeroValueString(value))) {
        value = parseFloat(value);
      } else if (!findValueType(value) && complex.test(target)) {
        value = getAnimatableNone(key, target);
      }
      this.setBaseTarget(key, isMotionValue(value) ? value.get() : value);
    }
    return isMotionValue(value) ? value.get() : value;
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(key, value) {
    this.baseTarget[key] = value;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(key) {
    var _a2;
    const { initial } = this.props;
    let valueFromInitial;
    if (typeof initial === "string" || typeof initial === "object") {
      const variant = resolveVariantFromProps(
        this.props,
        initial,
        (_a2 = this.presenceContext) == null ? void 0 : _a2.custom,
      );
      if (variant) {
        valueFromInitial = variant[key];
      }
    }
    if (initial && valueFromInitial !== void 0) {
      return valueFromInitial;
    }
    const target = this.getBaseTargetFromProps(this.props, key);
    if (target !== void 0 && !isMotionValue(target)) return target;
    return this.initialValues[key] !== void 0 && valueFromInitial === void 0
      ? void 0
      : this.baseTarget[key];
  }
  on(eventName, callback) {
    if (!this.events[eventName]) {
      this.events[eventName] = new SubscriptionManager();
    }
    return this.events[eventName].add(callback);
  }
  notify(eventName, ...args) {
    if (this.events[eventName]) {
      this.events[eventName].notify(...args);
    }
  }
  scheduleRenderMicrotask() {
    microtask.render(this.render);
  }
}
class DOMVisualElement extends VisualElement {
  constructor() {
    super(...arguments);
    this.KeyframeResolver = DOMKeyframesResolver;
  }
  sortInstanceNodePosition(a, b) {
    return a.compareDocumentPosition(b) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(props, key) {
    const style = props.style;
    return style ? style[key] : void 0;
  }
  removeValueFromRenderState(key, { vars, style }) {
    delete vars[key];
    delete style[key];
  }
  handleChildMotionValue() {
    if (this.childSubscription) {
      this.childSubscription();
      delete this.childSubscription;
    }
    const { children } = this.props;
    if (isMotionValue(children)) {
      this.childSubscription = children.on("change", (latest) => {
        if (this.current) {
          this.current.textContent = `${latest}`;
        }
      });
    }
  }
}
class Feature {
  constructor(node) {
    this.isMounted = false;
    this.node = node;
  }
  update() {}
}
function convertBoundingBoxToBox({ top, left, right, bottom }) {
  return {
    x: { min: left, max: right },
    y: { min: top, max: bottom },
  };
}
function convertBoxToBoundingBox({ x, y }) {
  return { top: y.min, right: x.max, bottom: y.max, left: x.min };
}
function transformBoxPoints(point, transformPoint2) {
  if (!transformPoint2) return point;
  const topLeft = transformPoint2({ x: point.left, y: point.top });
  const bottomRight = transformPoint2({ x: point.right, y: point.bottom });
  return {
    top: topLeft.y,
    left: topLeft.x,
    bottom: bottomRight.y,
    right: bottomRight.x,
  };
}
function isIdentityScale(scale2) {
  return scale2 === void 0 || scale2 === 1;
}
function hasScale({ scale: scale2, scaleX: scaleX2, scaleY: scaleY2 }) {
  return !isIdentityScale(scale2) || !isIdentityScale(scaleX2) || !isIdentityScale(scaleY2);
}
function hasTransform(values) {
  return (
    hasScale(values) ||
    has2DTranslate(values) ||
    values.z ||
    values.rotate ||
    values.rotateX ||
    values.rotateY ||
    values.skewX ||
    values.skewY
  );
}
function has2DTranslate(values) {
  return is2DTranslate(values.x) || is2DTranslate(values.y);
}
function is2DTranslate(value) {
  return value && value !== "0%";
}
function scalePoint(point, scale2, originPoint) {
  const distanceFromOrigin = point - originPoint;
  const scaled = scale2 * distanceFromOrigin;
  return originPoint + scaled;
}
function applyPointDelta(point, translate, scale2, originPoint, boxScale) {
  if (boxScale !== void 0) {
    point = scalePoint(point, boxScale, originPoint);
  }
  return scalePoint(point, scale2, originPoint) + translate;
}
function applyAxisDelta(axis, translate = 0, scale2 = 1, originPoint, boxScale) {
  axis.min = applyPointDelta(axis.min, translate, scale2, originPoint, boxScale);
  axis.max = applyPointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
function applyBoxDelta(box, { x, y }) {
  applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);
  applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);
}
const TREE_SCALE_SNAP_MIN = 0.999999999999;
const TREE_SCALE_SNAP_MAX = 1.0000000000001;
function applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {
  const treeLength = treePath.length;
  if (!treeLength) return;
  treeScale.x = treeScale.y = 1;
  let node;
  let delta;
  for (let i = 0; i < treeLength; i++) {
    node = treePath[i];
    delta = node.projectionDelta;
    const { visualElement } = node.options;
    if (
      visualElement &&
      visualElement.props.style &&
      visualElement.props.style.display === "contents"
    ) {
      continue;
    }
    if (isSharedTransition && node.options.layoutScroll && node.scroll && node !== node.root) {
      transformBox(box, {
        x: -node.scroll.offset.x,
        y: -node.scroll.offset.y,
      });
    }
    if (delta) {
      treeScale.x *= delta.x.scale;
      treeScale.y *= delta.y.scale;
      applyBoxDelta(box, delta);
    }
    if (isSharedTransition && hasTransform(node.latestValues)) {
      transformBox(box, node.latestValues);
    }
  }
  if (treeScale.x < TREE_SCALE_SNAP_MAX && treeScale.x > TREE_SCALE_SNAP_MIN) {
    treeScale.x = 1;
  }
  if (treeScale.y < TREE_SCALE_SNAP_MAX && treeScale.y > TREE_SCALE_SNAP_MIN) {
    treeScale.y = 1;
  }
}
function translateAxis(axis, distance2) {
  axis.min = axis.min + distance2;
  axis.max = axis.max + distance2;
}
function transformAxis(axis, axisTranslate, axisScale, boxScale, axisOrigin = 0.5) {
  const originPoint = mixNumber$1(axis.min, axis.max, axisOrigin);
  applyAxisDelta(axis, axisTranslate, axisScale, originPoint, boxScale);
}
function transformBox(box, transform) {
  transformAxis(box.x, transform.x, transform.scaleX, transform.scale, transform.originX);
  transformAxis(box.y, transform.y, transform.scaleY, transform.scale, transform.originY);
}
function measureViewportBox(instance, transformPoint2) {
  return convertBoundingBoxToBox(
    transformBoxPoints(instance.getBoundingClientRect(), transformPoint2),
  );
}
function measurePageBox(element, rootProjectionNode2, transformPagePoint) {
  const viewportBox = measureViewportBox(element, transformPagePoint);
  const { scroll } = rootProjectionNode2;
  if (scroll) {
    translateAxis(viewportBox.x, scroll.offset.x);
    translateAxis(viewportBox.y, scroll.offset.y);
  }
  return viewportBox;
}
const translateAlias = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective",
};
const numTransforms = transformPropOrder.length;
function buildTransform(latestValues, transform, transformTemplate) {
  let transformString = "";
  let transformIsDefault = true;
  for (let i = 0; i < numTransforms; i++) {
    const key = transformPropOrder[i];
    const value = latestValues[key];
    if (value === void 0) continue;
    let valueIsDefault = true;
    if (typeof value === "number") {
      valueIsDefault = value === (key.startsWith("scale") ? 1 : 0);
    } else {
      valueIsDefault = parseFloat(value) === 0;
    }
    if (!valueIsDefault || transformTemplate) {
      const valueAsType = getValueAsType(value, numberValueTypes[key]);
      if (!valueIsDefault) {
        transformIsDefault = false;
        const transformName = translateAlias[key] || key;
        transformString += `${transformName}(${valueAsType}) `;
      }
      if (transformTemplate) {
        transform[key] = valueAsType;
      }
    }
  }
  transformString = transformString.trim();
  if (transformTemplate) {
    transformString = transformTemplate(transform, transformIsDefault ? "" : transformString);
  } else if (transformIsDefault) {
    transformString = "none";
  }
  return transformString;
}
function buildHTMLStyles(state, latestValues, transformTemplate) {
  const { style, vars, transformOrigin } = state;
  let hasTransform2 = false;
  let hasTransformOrigin = false;
  for (const key in latestValues) {
    const value = latestValues[key];
    if (transformProps.has(key)) {
      hasTransform2 = true;
      continue;
    } else if (isCSSVariableName(key)) {
      vars[key] = value;
      continue;
    } else {
      const valueAsType = getValueAsType(value, numberValueTypes[key]);
      if (key.startsWith("origin")) {
        hasTransformOrigin = true;
        transformOrigin[key] = valueAsType;
      } else {
        style[key] = valueAsType;
      }
    }
  }
  if (!latestValues.transform) {
    if (hasTransform2 || transformTemplate) {
      style.transform = buildTransform(latestValues, state.transform, transformTemplate);
    } else if (style.transform) {
      style.transform = "none";
    }
  }
  if (hasTransformOrigin) {
    const { originX = "50%", originY = "50%", originZ = 0 } = transformOrigin;
    style.transformOrigin = `${originX} ${originY} ${originZ}`;
  }
}
function renderHTML(element, { style, vars }, styleProp, projection) {
  const elementStyle = element.style;
  let key;
  for (key in style) {
    elementStyle[key] = style[key];
  }
  projection == null ? void 0 : projection.applyProjectionStyles(elementStyle, styleProp);
  for (key in vars) {
    elementStyle.setProperty(key, vars[key]);
  }
}
function pixelsToPercent(pixels, axis) {
  if (axis.max === axis.min) return 0;
  return (pixels / (axis.max - axis.min)) * 100;
}
const correctBorderRadius = {
  correct: (latest, node) => {
    if (!node.target) return latest;
    if (typeof latest === "string") {
      if (px.test(latest)) {
        latest = parseFloat(latest);
      } else {
        return latest;
      }
    }
    const x = pixelsToPercent(latest, node.target.x);
    const y = pixelsToPercent(latest, node.target.y);
    return `${x}% ${y}%`;
  },
};
const correctBoxShadow = {
  correct: (latest, { treeScale, projectionDelta }) => {
    const original = latest;
    const shadow = complex.parse(latest);
    if (shadow.length > 5) return original;
    const template = complex.createTransformer(latest);
    const offset2 = typeof shadow[0] !== "number" ? 1 : 0;
    const xScale = projectionDelta.x.scale * treeScale.x;
    const yScale = projectionDelta.y.scale * treeScale.y;
    shadow[0 + offset2] /= xScale;
    shadow[1 + offset2] /= yScale;
    const averageScale = mixNumber$1(xScale, yScale, 0.5);
    if (typeof shadow[2 + offset2] === "number") shadow[2 + offset2] /= averageScale;
    if (typeof shadow[3 + offset2] === "number") shadow[3 + offset2] /= averageScale;
    return template(shadow);
  },
};
const scaleCorrectors = {
  borderRadius: {
    ...correctBorderRadius,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius",
    ],
  },
  borderTopLeftRadius: correctBorderRadius,
  borderTopRightRadius: correctBorderRadius,
  borderBottomLeftRadius: correctBorderRadius,
  borderBottomRightRadius: correctBorderRadius,
  boxShadow: correctBoxShadow,
};
function isForcedMotionValue(key, { layout: layout2, layoutId }) {
  return (
    transformProps.has(key) ||
    key.startsWith("origin") ||
    ((layout2 || layoutId !== void 0) && (!!scaleCorrectors[key] || key === "opacity"))
  );
}
function scrapeMotionValuesFromProps$1(props, prevProps, visualElement) {
  var _a2;
  const style = props.style;
  const prevStyle = prevProps == null ? void 0 : prevProps.style;
  const newValues = {};
  if (!style) return newValues;
  for (const key in style) {
    if (
      isMotionValue(style[key]) ||
      (prevStyle && isMotionValue(prevStyle[key])) ||
      isForcedMotionValue(key, props) ||
      ((_a2 = visualElement == null ? void 0 : visualElement.getValue(key)) == null
        ? void 0
        : _a2.liveStyle) !== void 0
    ) {
      newValues[key] = style[key];
    }
  }
  return newValues;
}
function getComputedStyle$2(element) {
  return window.getComputedStyle(element);
}
class HTMLVisualElement extends DOMVisualElement {
  constructor() {
    super(...arguments);
    this.type = "html";
    this.renderInstance = renderHTML;
  }
  readValueFromInstance(instance, key) {
    var _a2;
    if (transformProps.has(key)) {
      return ((_a2 = this.projection) == null ? void 0 : _a2.isProjecting)
        ? defaultTransformValue(key)
        : readTransformValue(instance, key);
    } else {
      const computedStyle = getComputedStyle$2(instance);
      const value =
        (isCSSVariableName(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;
      return typeof value === "string" ? value.trim() : value;
    }
  }
  measureInstanceViewportBox(instance, { transformPagePoint }) {
    return measureViewportBox(instance, transformPagePoint);
  }
  build(renderState, latestValues, props) {
    buildHTMLStyles(renderState, latestValues, props.transformTemplate);
  }
  scrapeMotionValuesFromProps(props, prevProps, visualElement) {
    return scrapeMotionValuesFromProps$1(props, prevProps, visualElement);
  }
}
const dashKeys = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray",
};
const camelKeys = {
  offset: "strokeDashoffset",
  array: "strokeDasharray",
};
function buildSVGPath(attrs, length, spacing = 1, offset2 = 0, useDashCase = true) {
  attrs.pathLength = 1;
  const keys = useDashCase ? dashKeys : camelKeys;
  attrs[keys.offset] = `${-offset2}`;
  attrs[keys.array] = `${length} ${spacing}`;
}
const cssMotionPathProperties = ["offsetDistance", "offsetPath", "offsetRotate", "offsetAnchor"];
function buildSVGAttrs(
  state,
  {
    attrX,
    attrY,
    attrScale,
    pathLength,
    pathSpacing = 1,
    pathOffset = 0,
    // This is object creation, which we try to avoid per-frame.
    ...latest
  },
  isSVGTag2,
  transformTemplate,
  styleProp,
) {
  buildHTMLStyles(state, latest, transformTemplate);
  if (isSVGTag2) {
    if (state.style.viewBox) {
      state.attrs.viewBox = state.style.viewBox;
    }
    return;
  }
  state.attrs = state.style;
  state.style = {};
  const { attrs, style } = state;
  if (attrs.transform) {
    style.transform = attrs.transform;
    delete attrs.transform;
  }
  if (style.transform || attrs.transformOrigin) {
    style.transformOrigin = attrs.transformOrigin ?? "50% 50%";
    delete attrs.transformOrigin;
  }
  if (style.transform) {
    style.transformBox = (styleProp == null ? void 0 : styleProp.transformBox) ?? "fill-box";
    delete attrs.transformBox;
  }
  for (const key of cssMotionPathProperties) {
    if (attrs[key] !== void 0) {
      style[key] = attrs[key];
      delete attrs[key];
    }
  }
  if (attrX !== void 0) attrs.x = attrX;
  if (attrY !== void 0) attrs.y = attrY;
  if (attrScale !== void 0) attrs.scale = attrScale;
  if (pathLength !== void 0) {
    buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);
  }
}
const camelCaseAttributes = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust",
]);
const isSVGTag = (tag) => typeof tag === "string" && tag.toLowerCase() === "svg";
function renderSVG(element, renderState, _styleProp, projection) {
  renderHTML(element, renderState, void 0, projection);
  for (const key in renderState.attrs) {
    element.setAttribute(
      !camelCaseAttributes.has(key) ? camelToDash(key) : key,
      renderState.attrs[key],
    );
  }
}
function scrapeMotionValuesFromProps(props, prevProps, visualElement) {
  const newValues = scrapeMotionValuesFromProps$1(props, prevProps, visualElement);
  for (const key in props) {
    if (isMotionValue(props[key]) || isMotionValue(prevProps[key])) {
      const targetKey =
        transformPropOrder.indexOf(key) !== -1
          ? "attr" + key.charAt(0).toUpperCase() + key.substring(1)
          : key;
      newValues[targetKey] = props[key];
    }
  }
  return newValues;
}
class SVGVisualElement extends DOMVisualElement {
  constructor() {
    super(...arguments);
    this.type = "svg";
    this.isSVGTag = false;
    this.measureInstanceViewportBox = createBox;
  }
  getBaseTargetFromProps(props, key) {
    return props[key];
  }
  readValueFromInstance(instance, key) {
    if (transformProps.has(key)) {
      const defaultType = getDefaultValueType(key);
      return defaultType ? defaultType.default || 0 : 0;
    }
    key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;
    return instance.getAttribute(key);
  }
  scrapeMotionValuesFromProps(props, prevProps, visualElement) {
    return scrapeMotionValuesFromProps(props, prevProps, visualElement);
  }
  build(renderState, latestValues, props) {
    buildSVGAttrs(renderState, latestValues, this.isSVGTag, props.transformTemplate, props.style);
  }
  renderInstance(instance, renderState, styleProp, projection) {
    renderSVG(instance, renderState, styleProp, projection);
  }
  mount(instance) {
    this.isSVGTag = isSVGTag(instance.tagName);
    super.mount(instance);
  }
}
const numVariantProps = variantProps.length;
function getVariantContext(visualElement) {
  if (!visualElement) return void 0;
  if (!visualElement.isControllingVariants) {
    const context2 = visualElement.parent ? getVariantContext(visualElement.parent) || {} : {};
    if (visualElement.props.initial !== void 0) {
      context2.initial = visualElement.props.initial;
    }
    return context2;
  }
  const context = {};
  for (let i = 0; i < numVariantProps; i++) {
    const name = variantProps[i];
    const prop = visualElement.props[name];
    if (isVariantLabel(prop) || prop === false) {
      context[name] = prop;
    }
  }
  return context;
}
function shallowCompare(next, prev) {
  if (!Array.isArray(prev)) return false;
  const prevLength = prev.length;
  if (prevLength !== next.length) return false;
  for (let i = 0; i < prevLength; i++) {
    if (prev[i] !== next[i]) return false;
  }
  return true;
}
const reversePriorityOrder = [...variantPriorityOrder].reverse();
const numAnimationTypes = variantPriorityOrder.length;
function createAnimateFunction(visualElement) {
  return (animations2) => {
    return Promise.all(
      animations2.map(({ animation, options }) =>
        animateVisualElement(visualElement, animation, options),
      ),
    );
  };
}
function createAnimationState(visualElement) {
  let animate = createAnimateFunction(visualElement);
  let state = createState();
  let isInitialRender = true;
  const buildResolvedTypeValues = (type) => (acc, definition) => {
    var _a2;
    const resolved = resolveVariant(
      visualElement,
      definition,
      type === "exit"
        ? (_a2 = visualElement.presenceContext) == null
          ? void 0
          : _a2.custom
        : void 0,
    );
    if (resolved) {
      const { transition, transitionEnd, ...target } = resolved;
      acc = { ...acc, ...target, ...transitionEnd };
    }
    return acc;
  };
  function setAnimateFunction(makeAnimator) {
    animate = makeAnimator(visualElement);
  }
  function animateChanges(changedActiveType) {
    const { props } = visualElement;
    const context = getVariantContext(visualElement.parent) || {};
    const animations2 = [];
    const removedKeys = /* @__PURE__ */ new Set();
    let encounteredKeys = {};
    let removedVariantIndex = Infinity;
    for (let i = 0; i < numAnimationTypes; i++) {
      const type = reversePriorityOrder[i];
      const typeState = state[type];
      const prop = props[type] !== void 0 ? props[type] : context[type];
      const propIsVariant = isVariantLabel(prop);
      const activeDelta = type === changedActiveType ? typeState.isActive : null;
      if (activeDelta === false) removedVariantIndex = i;
      let isInherited = prop === context[type] && prop !== props[type] && propIsVariant;
      if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount) {
        isInherited = false;
      }
      typeState.protectedKeys = { ...encounteredKeys };
      if (
        // If it isn't active and hasn't *just* been set as inactive
        (!typeState.isActive && activeDelta === null) || // If we didn't and don't have any defined prop for this animation type
        (!prop && !typeState.prevProp) || // Or if the prop doesn't define an animation
        isAnimationControls(prop) ||
        typeof prop === "boolean"
      ) {
        continue;
      }
      const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);
      let shouldAnimateType =
        variantDidChange || // If we're making this variant active, we want to always make it active
        (type === changedActiveType && typeState.isActive && !isInherited && propIsVariant) || // If we removed a higher-priority variant (i is in reverse order)
        (i > removedVariantIndex && propIsVariant);
      let handledRemovedValues = false;
      const definitionList = Array.isArray(prop) ? prop : [prop];
      let resolvedValues = definitionList.reduce(buildResolvedTypeValues(type), {});
      if (activeDelta === false) resolvedValues = {};
      const { prevResolvedValues = {} } = typeState;
      const allKeys = {
        ...prevResolvedValues,
        ...resolvedValues,
      };
      const markToAnimate = (key) => {
        shouldAnimateType = true;
        if (removedKeys.has(key)) {
          handledRemovedValues = true;
          removedKeys.delete(key);
        }
        typeState.needsAnimating[key] = true;
        const motionValue2 = visualElement.getValue(key);
        if (motionValue2) motionValue2.liveStyle = false;
      };
      for (const key in allKeys) {
        const next = resolvedValues[key];
        const prev = prevResolvedValues[key];
        if (encounteredKeys.hasOwnProperty(key)) continue;
        let valueHasChanged = false;
        if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {
          valueHasChanged = !shallowCompare(next, prev);
        } else {
          valueHasChanged = next !== prev;
        }
        if (valueHasChanged) {
          if (next !== void 0 && next !== null) {
            markToAnimate(key);
          } else {
            removedKeys.add(key);
          }
        } else if (next !== void 0 && removedKeys.has(key)) {
          markToAnimate(key);
        } else {
          typeState.protectedKeys[key] = true;
        }
      }
      typeState.prevProp = prop;
      typeState.prevResolvedValues = resolvedValues;
      if (typeState.isActive) {
        encounteredKeys = { ...encounteredKeys, ...resolvedValues };
      }
      if (isInitialRender && visualElement.blockInitialAnimation) {
        shouldAnimateType = false;
      }
      const willAnimateViaParent = isInherited && variantDidChange;
      const needsAnimating = !willAnimateViaParent || handledRemovedValues;
      if (shouldAnimateType && needsAnimating) {
        animations2.push(
          ...definitionList.map((animation) => {
            const options = { type };
            if (
              typeof animation === "string" &&
              isInitialRender &&
              !willAnimateViaParent &&
              visualElement.manuallyAnimateOnMount &&
              visualElement.parent
            ) {
              const { parent } = visualElement;
              const parentVariant = resolveVariant(parent, animation);
              if (parent.enteringChildren && parentVariant) {
                const { delayChildren } = parentVariant.transition || {};
                options.delay = calcChildStagger(
                  parent.enteringChildren,
                  visualElement,
                  delayChildren,
                );
              }
            }
            return {
              animation,
              options,
            };
          }),
        );
      }
    }
    if (removedKeys.size) {
      const fallbackAnimation = {};
      if (typeof props.initial !== "boolean") {
        const initialTransition = resolveVariant(
          visualElement,
          Array.isArray(props.initial) ? props.initial[0] : props.initial,
        );
        if (initialTransition && initialTransition.transition) {
          fallbackAnimation.transition = initialTransition.transition;
        }
      }
      removedKeys.forEach((key) => {
        const fallbackTarget = visualElement.getBaseTarget(key);
        const motionValue2 = visualElement.getValue(key);
        if (motionValue2) motionValue2.liveStyle = true;
        fallbackAnimation[key] = fallbackTarget ?? null;
      });
      animations2.push({ animation: fallbackAnimation });
    }
    let shouldAnimate = Boolean(animations2.length);
    if (
      isInitialRender &&
      (props.initial === false || props.initial === props.animate) &&
      !visualElement.manuallyAnimateOnMount
    ) {
      shouldAnimate = false;
    }
    isInitialRender = false;
    return shouldAnimate ? animate(animations2) : Promise.resolve();
  }
  function setActive(type, isActive) {
    var _a2;
    if (state[type].isActive === isActive) return Promise.resolve();
    (_a2 = visualElement.variantChildren) == null
      ? void 0
      : _a2.forEach((child) => {
          var _a3;
          return (_a3 = child.animationState) == null ? void 0 : _a3.setActive(type, isActive);
        });
    state[type].isActive = isActive;
    const animations2 = animateChanges(type);
    for (const key in state) {
      state[key].protectedKeys = {};
    }
    return animations2;
  }
  return {
    animateChanges,
    setActive,
    setAnimateFunction,
    getState: () => state,
    reset: () => {
      state = createState();
    },
  };
}
function checkVariantsDidChange(prev, next) {
  if (typeof next === "string") {
    return next !== prev;
  } else if (Array.isArray(next)) {
    return !shallowCompare(next, prev);
  }
  return false;
}
function createTypeState(isActive = false) {
  return {
    isActive,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {},
  };
}
function createState() {
  return {
    animate: createTypeState(true),
    whileInView: createTypeState(),
    whileHover: createTypeState(),
    whileTap: createTypeState(),
    whileDrag: createTypeState(),
    whileFocus: createTypeState(),
    exit: createTypeState(),
  };
}
function copyAxisInto(axis, originAxis) {
  axis.min = originAxis.min;
  axis.max = originAxis.max;
}
function copyBoxInto(box, originBox) {
  copyAxisInto(box.x, originBox.x);
  copyAxisInto(box.y, originBox.y);
}
function copyAxisDeltaInto(delta, originDelta) {
  delta.translate = originDelta.translate;
  delta.scale = originDelta.scale;
  delta.originPoint = originDelta.originPoint;
  delta.origin = originDelta.origin;
}
const SCALE_PRECISION = 1e-4;
const SCALE_MIN = 1 - SCALE_PRECISION;
const SCALE_MAX = 1 + SCALE_PRECISION;
const TRANSLATE_PRECISION = 0.01;
const TRANSLATE_MIN = 0 - TRANSLATE_PRECISION;
const TRANSLATE_MAX = 0 + TRANSLATE_PRECISION;
function calcLength(axis) {
  return axis.max - axis.min;
}
function isNear(value, target, maxDistance) {
  return Math.abs(value - target) <= maxDistance;
}
function calcAxisDelta(delta, source, target, origin = 0.5) {
  delta.origin = origin;
  delta.originPoint = mixNumber$1(source.min, source.max, delta.origin);
  delta.scale = calcLength(target) / calcLength(source);
  delta.translate = mixNumber$1(target.min, target.max, delta.origin) - delta.originPoint;
  if ((delta.scale >= SCALE_MIN && delta.scale <= SCALE_MAX) || isNaN(delta.scale)) {
    delta.scale = 1;
  }
  if (
    (delta.translate >= TRANSLATE_MIN && delta.translate <= TRANSLATE_MAX) ||
    isNaN(delta.translate)
  ) {
    delta.translate = 0;
  }
}
function calcBoxDelta(delta, source, target, origin) {
  calcAxisDelta(delta.x, source.x, target.x, origin ? origin.originX : void 0);
  calcAxisDelta(delta.y, source.y, target.y, origin ? origin.originY : void 0);
}
function calcRelativeAxis(target, relative, parent) {
  target.min = parent.min + relative.min;
  target.max = target.min + calcLength(relative);
}
function calcRelativeBox(target, relative, parent) {
  calcRelativeAxis(target.x, relative.x, parent.x);
  calcRelativeAxis(target.y, relative.y, parent.y);
}
function calcRelativeAxisPosition(target, layout2, parent) {
  target.min = layout2.min - parent.min;
  target.max = target.min + calcLength(layout2);
}
function calcRelativePosition(target, layout2, parent) {
  calcRelativeAxisPosition(target.x, layout2.x, parent.x);
  calcRelativeAxisPosition(target.y, layout2.y, parent.y);
}
function removePointDelta(point, translate, scale2, originPoint, boxScale) {
  point -= translate;
  point = scalePoint(point, 1 / scale2, originPoint);
  if (boxScale !== void 0) {
    point = scalePoint(point, 1 / boxScale, originPoint);
  }
  return point;
}
function removeAxisDelta(
  axis,
  translate = 0,
  scale2 = 1,
  origin = 0.5,
  boxScale,
  originAxis = axis,
  sourceAxis = axis,
) {
  if (percent.test(translate)) {
    translate = parseFloat(translate);
    const relativeProgress = mixNumber$1(sourceAxis.min, sourceAxis.max, translate / 100);
    translate = relativeProgress - sourceAxis.min;
  }
  if (typeof translate !== "number") return;
  let originPoint = mixNumber$1(originAxis.min, originAxis.max, origin);
  if (axis === originAxis) originPoint -= translate;
  axis.min = removePointDelta(axis.min, translate, scale2, originPoint, boxScale);
  axis.max = removePointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
function removeAxisTransforms(axis, transforms, [key, scaleKey, originKey], origin, sourceAxis) {
  removeAxisDelta(
    axis,
    transforms[key],
    transforms[scaleKey],
    transforms[originKey],
    transforms.scale,
    origin,
    sourceAxis,
  );
}
const xKeys = ["x", "scaleX", "originX"];
const yKeys = ["y", "scaleY", "originY"];
function removeBoxTransforms(box, transforms, originBox, sourceBox) {
  removeAxisTransforms(
    box.x,
    transforms,
    xKeys,
    originBox ? originBox.x : void 0,
    sourceBox ? sourceBox.x : void 0,
  );
  removeAxisTransforms(
    box.y,
    transforms,
    yKeys,
    originBox ? originBox.y : void 0,
    sourceBox ? sourceBox.y : void 0,
  );
}
function isAxisDeltaZero(delta) {
  return delta.translate === 0 && delta.scale === 1;
}
function isDeltaZero(delta) {
  return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);
}
function axisEquals(a, b) {
  return a.min === b.min && a.max === b.max;
}
function boxEquals(a, b) {
  return axisEquals(a.x, b.x) && axisEquals(a.y, b.y);
}
function axisEqualsRounded(a, b) {
  return Math.round(a.min) === Math.round(b.min) && Math.round(a.max) === Math.round(b.max);
}
function boxEqualsRounded(a, b) {
  return axisEqualsRounded(a.x, b.x) && axisEqualsRounded(a.y, b.y);
}
function aspectRatio(box) {
  return calcLength(box.x) / calcLength(box.y);
}
function axisDeltaEquals(a, b) {
  return a.translate === b.translate && a.scale === b.scale && a.originPoint === b.originPoint;
}
function eachAxis(callback) {
  return [callback("x"), callback("y")];
}
function buildProjectionTransform(delta, treeScale, latestTransform) {
  let transform = "";
  const xTranslate = delta.x.translate / treeScale.x;
  const yTranslate = delta.y.translate / treeScale.y;
  const zTranslate = (latestTransform == null ? void 0 : latestTransform.z) || 0;
  if (xTranslate || yTranslate || zTranslate) {
    transform = `translate3d(${xTranslate}px, ${yTranslate}px, ${zTranslate}px) `;
  }
  if (treeScale.x !== 1 || treeScale.y !== 1) {
    transform += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;
  }
  if (latestTransform) {
    const {
      transformPerspective,
      rotate: rotate2,
      rotateX,
      rotateY,
      skewX,
      skewY,
    } = latestTransform;
    if (transformPerspective) transform = `perspective(${transformPerspective}px) ${transform}`;
    if (rotate2) transform += `rotate(${rotate2}deg) `;
    if (rotateX) transform += `rotateX(${rotateX}deg) `;
    if (rotateY) transform += `rotateY(${rotateY}deg) `;
    if (skewX) transform += `skewX(${skewX}deg) `;
    if (skewY) transform += `skewY(${skewY}deg) `;
  }
  const elementScaleX = delta.x.scale * treeScale.x;
  const elementScaleY = delta.y.scale * treeScale.y;
  if (elementScaleX !== 1 || elementScaleY !== 1) {
    transform += `scale(${elementScaleX}, ${elementScaleY})`;
  }
  return transform || "none";
}
const borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"];
const numBorders = borders.length;
const asNumber = (value) => (typeof value === "string" ? parseFloat(value) : value);
const isPx = (value) => typeof value === "number" || px.test(value);
function mixValues(target, follow, lead, progress2, shouldCrossfadeOpacity, isOnlyMember) {
  if (shouldCrossfadeOpacity) {
    target.opacity = mixNumber$1(0, lead.opacity ?? 1, easeCrossfadeIn(progress2));
    target.opacityExit = mixNumber$1(follow.opacity ?? 1, 0, easeCrossfadeOut(progress2));
  } else if (isOnlyMember) {
    target.opacity = mixNumber$1(follow.opacity ?? 1, lead.opacity ?? 1, progress2);
  }
  for (let i = 0; i < numBorders; i++) {
    const borderLabel = `border${borders[i]}Radius`;
    let followRadius = getRadius(follow, borderLabel);
    let leadRadius = getRadius(lead, borderLabel);
    if (followRadius === void 0 && leadRadius === void 0) continue;
    followRadius || (followRadius = 0);
    leadRadius || (leadRadius = 0);
    const canMix =
      followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius);
    if (canMix) {
      target[borderLabel] = Math.max(
        mixNumber$1(asNumber(followRadius), asNumber(leadRadius), progress2),
        0,
      );
      if (percent.test(leadRadius) || percent.test(followRadius)) {
        target[borderLabel] += "%";
      }
    } else {
      target[borderLabel] = leadRadius;
    }
  }
  if (follow.rotate || lead.rotate) {
    target.rotate = mixNumber$1(follow.rotate || 0, lead.rotate || 0, progress2);
  }
}
function getRadius(values, radiusName) {
  return values[radiusName] !== void 0 ? values[radiusName] : values.borderRadius;
}
const easeCrossfadeIn = /* @__PURE__ */ compress(0, 0.5, circOut);
const easeCrossfadeOut = /* @__PURE__ */ compress(0.5, 0.95, noop$2);
function compress(min2, max2, easing) {
  return (p) => {
    if (p < min2) return 0;
    if (p > max2) return 1;
    return easing(/* @__PURE__ */ progress(min2, max2, p));
  };
}
function animateSingleValue(value, keyframes2, options) {
  const motionValue$1 = isMotionValue(value) ? value : motionValue(value);
  motionValue$1.start(animateMotionValue("", motionValue$1, keyframes2, options));
  return motionValue$1.animation;
}
function addDomEvent(target, eventName, handler, options = { passive: true }) {
  target.addEventListener(eventName, handler, options);
  return () => target.removeEventListener(eventName, handler);
}
const compareByDepth = (a, b) => a.depth - b.depth;
class FlatTree {
  constructor() {
    this.children = [];
    this.isDirty = false;
  }
  add(child) {
    addUniqueItem(this.children, child);
    this.isDirty = true;
  }
  remove(child) {
    removeItem(this.children, child);
    this.isDirty = true;
  }
  forEach(callback) {
    this.isDirty && this.children.sort(compareByDepth);
    this.isDirty = false;
    this.children.forEach(callback);
  }
}
function delay(callback, timeout) {
  const start = time.now();
  const checkElapsed = ({ timestamp }) => {
    const elapsed = timestamp - start;
    if (elapsed >= timeout) {
      cancelFrame(checkElapsed);
      callback(elapsed - timeout);
    }
  };
  frame.setup(checkElapsed, true);
  return () => cancelFrame(checkElapsed);
}
function resolveMotionValue(value) {
  return isMotionValue(value) ? value.get() : value;
}
class NodeStack {
  constructor() {
    this.members = [];
  }
  add(node) {
    addUniqueItem(this.members, node);
    node.scheduleRender();
  }
  remove(node) {
    removeItem(this.members, node);
    if (node === this.prevLead) {
      this.prevLead = void 0;
    }
    if (node === this.lead) {
      const prevLead = this.members[this.members.length - 1];
      if (prevLead) {
        this.promote(prevLead);
      }
    }
  }
  relegate(node) {
    const indexOfNode = this.members.findIndex((member) => node === member);
    if (indexOfNode === 0) return false;
    let prevLead;
    for (let i = indexOfNode; i >= 0; i--) {
      const member = this.members[i];
      if (member.isPresent !== false) {
        prevLead = member;
        break;
      }
    }
    if (prevLead) {
      this.promote(prevLead);
      return true;
    } else {
      return false;
    }
  }
  promote(node, preserveFollowOpacity) {
    const prevLead = this.lead;
    if (node === prevLead) return;
    this.prevLead = prevLead;
    this.lead = node;
    node.show();
    if (prevLead) {
      prevLead.instance && prevLead.scheduleRender();
      node.scheduleRender();
      node.resumeFrom = prevLead;
      if (preserveFollowOpacity) {
        node.resumeFrom.preserveOpacity = true;
      }
      if (prevLead.snapshot) {
        node.snapshot = prevLead.snapshot;
        node.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues;
      }
      if (node.root && node.root.isUpdating) {
        node.isLayoutDirty = true;
      }
      const { crossfade } = node.options;
      if (crossfade === false) {
        prevLead.hide();
      }
    }
  }
  exitAnimationComplete() {
    this.members.forEach((node) => {
      const { options, resumingFrom } = node;
      options.onExitComplete && options.onExitComplete();
      if (resumingFrom) {
        resumingFrom.options.onExitComplete && resumingFrom.options.onExitComplete();
      }
    });
  }
  scheduleRender() {
    this.members.forEach((node) => {
      node.instance && node.scheduleRender(false);
    });
  }
  /**
   * Clear any leads that have been removed this render to prevent them from being
   * used in future animations and to prevent memory leaks
   */
  removeLeadSnapshot() {
    if (this.lead && this.lead.snapshot) {
      this.lead.snapshot = void 0;
    }
  }
}
const globalProjectionState = {
  /**
   * Global flag as to whether the tree has animated since the last time
   * we resized the window
   */
  hasAnimatedSinceResize: true,
  /**
   * We set this to true once, on the first update. Any nodes added to the tree beyond that
   * update will be given a `data-projection-id` attribute.
   */
  hasEverUpdated: false,
};
const transformAxes = ["", "X", "Y", "Z"];
const animationTarget = 1e3;
let id$1 = 0;
function resetDistortingTransform(key, visualElement, values, sharedAnimationValues) {
  const { latestValues } = visualElement;
  if (latestValues[key]) {
    values[key] = latestValues[key];
    visualElement.setStaticValue(key, 0);
    if (sharedAnimationValues) {
      sharedAnimationValues[key] = 0;
    }
  }
}
function cancelTreeOptimisedTransformAnimations(projectionNode) {
  projectionNode.hasCheckedOptimisedAppear = true;
  if (projectionNode.root === projectionNode) return;
  const { visualElement } = projectionNode.options;
  if (!visualElement) return;
  const appearId = getOptimisedAppearId(visualElement);
  if (window.MotionHasOptimisedAnimation(appearId, "transform")) {
    const { layout: layout2, layoutId } = projectionNode.options;
    window.MotionCancelOptimisedAnimation(appearId, "transform", frame, !(layout2 || layoutId));
  }
  const { parent } = projectionNode;
  if (parent && !parent.hasCheckedOptimisedAppear) {
    cancelTreeOptimisedTransformAnimations(parent);
  }
}
function createProjectionNode$1({
  attachResizeListener,
  defaultParent,
  measureScroll,
  checkIsScrollRoot,
  resetTransform,
}) {
  return class ProjectionNode {
    constructor(latestValues = {}, parent = defaultParent == null ? void 0 : defaultParent()) {
      this.id = id$1++;
      this.animationId = 0;
      this.animationCommitId = 0;
      this.children = /* @__PURE__ */ new Set();
      this.options = {};
      this.isTreeAnimating = false;
      this.isAnimationBlocked = false;
      this.isLayoutDirty = false;
      this.isProjectionDirty = false;
      this.isSharedProjectionDirty = false;
      this.isTransformDirty = false;
      this.updateManuallyBlocked = false;
      this.updateBlockedByResize = false;
      this.isUpdating = false;
      this.isSVG = false;
      this.needsReset = false;
      this.shouldResetTransform = false;
      this.hasCheckedOptimisedAppear = false;
      this.treeScale = { x: 1, y: 1 };
      this.eventHandlers = /* @__PURE__ */ new Map();
      this.hasTreeAnimated = false;
      this.layoutVersion = 0;
      this.updateScheduled = false;
      this.scheduleUpdate = () => this.update();
      this.projectionUpdateScheduled = false;
      this.checkUpdateFailed = () => {
        if (this.isUpdating) {
          this.isUpdating = false;
          this.clearAllSnapshots();
        }
      };
      this.updateProjection = () => {
        this.projectionUpdateScheduled = false;
        this.nodes.forEach(propagateDirtyNodes);
        this.nodes.forEach(resolveTargetDelta);
        this.nodes.forEach(calcProjection);
        this.nodes.forEach(cleanDirtyNodes);
      };
      this.resolvedRelativeTargetAt = 0;
      this.linkedParentVersion = 0;
      this.hasProjected = false;
      this.isVisible = true;
      this.animationProgress = 0;
      this.sharedNodes = /* @__PURE__ */ new Map();
      this.latestValues = latestValues;
      this.root = parent ? parent.root || parent : this;
      this.path = parent ? [...parent.path, parent] : [];
      this.parent = parent;
      this.depth = parent ? parent.depth + 1 : 0;
      for (let i = 0; i < this.path.length; i++) {
        this.path[i].shouldResetTransform = true;
      }
      if (this.root === this) this.nodes = new FlatTree();
    }
    addEventListener(name, handler) {
      if (!this.eventHandlers.has(name)) {
        this.eventHandlers.set(name, new SubscriptionManager());
      }
      return this.eventHandlers.get(name).add(handler);
    }
    notifyListeners(name, ...args) {
      const subscriptionManager = this.eventHandlers.get(name);
      subscriptionManager && subscriptionManager.notify(...args);
    }
    hasListeners(name) {
      return this.eventHandlers.has(name);
    }
    /**
     * Lifecycles
     */
    mount(instance) {
      if (this.instance) return;
      this.isSVG = isSVGElement(instance) && !isSVGSVGElement(instance);
      this.instance = instance;
      const { layoutId, layout: layout2, visualElement } = this.options;
      if (visualElement && !visualElement.current) {
        visualElement.mount(instance);
      }
      this.root.nodes.add(this);
      this.parent && this.parent.children.add(this);
      if (this.root.hasTreeAnimated && (layout2 || layoutId)) {
        this.isLayoutDirty = true;
      }
      if (attachResizeListener) {
        let cancelDelay;
        let innerWidth = 0;
        const resizeUnblockUpdate = () => (this.root.updateBlockedByResize = false);
        frame.read(() => {
          innerWidth = window.innerWidth;
        });
        attachResizeListener(instance, () => {
          const newInnerWidth = window.innerWidth;
          if (newInnerWidth === innerWidth) return;
          innerWidth = newInnerWidth;
          this.root.updateBlockedByResize = true;
          cancelDelay && cancelDelay();
          cancelDelay = delay(resizeUnblockUpdate, 250);
          if (globalProjectionState.hasAnimatedSinceResize) {
            globalProjectionState.hasAnimatedSinceResize = false;
            this.nodes.forEach(finishAnimation);
          }
        });
      }
      if (layoutId) {
        this.root.registerSharedNode(layoutId, this);
      }
      if (this.options.animate !== false && visualElement && (layoutId || layout2)) {
        this.addEventListener(
          "didUpdate",
          ({ delta, hasLayoutChanged, hasRelativeLayoutChanged, layout: newLayout }) => {
            if (this.isTreeAnimationBlocked()) {
              this.target = void 0;
              this.relativeTarget = void 0;
              return;
            }
            const layoutTransition =
              this.options.transition ||
              visualElement.getDefaultTransition() ||
              defaultLayoutTransition;
            const { onLayoutAnimationStart, onLayoutAnimationComplete } = visualElement.getProps();
            const hasTargetChanged =
              !this.targetLayout || !boxEqualsRounded(this.targetLayout, newLayout);
            const hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeLayoutChanged;
            if (
              this.options.layoutRoot ||
              this.resumeFrom ||
              hasOnlyRelativeTargetChanged ||
              (hasLayoutChanged && (hasTargetChanged || !this.currentAnimation))
            ) {
              if (this.resumeFrom) {
                this.resumingFrom = this.resumeFrom;
                this.resumingFrom.resumingFrom = void 0;
              }
              const animationOptions = {
                ...getValueTransition(layoutTransition, "layout"),
                onPlay: onLayoutAnimationStart,
                onComplete: onLayoutAnimationComplete,
              };
              if (visualElement.shouldReduceMotion || this.options.layoutRoot) {
                animationOptions.delay = 0;
                animationOptions.type = false;
              }
              this.startAnimation(animationOptions);
              this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);
            } else {
              if (!hasLayoutChanged) {
                finishAnimation(this);
              }
              if (this.isLead() && this.options.onExitComplete) {
                this.options.onExitComplete();
              }
            }
            this.targetLayout = newLayout;
          },
        );
      }
    }
    unmount() {
      this.options.layoutId && this.willUpdate();
      this.root.nodes.remove(this);
      const stack = this.getStack();
      stack && stack.remove(this);
      this.parent && this.parent.children.delete(this);
      this.instance = void 0;
      this.eventHandlers.clear();
      cancelFrame(this.updateProjection);
    }
    // only on the root
    blockUpdate() {
      this.updateManuallyBlocked = true;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = false;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return (
        this.isAnimationBlocked || (this.parent && this.parent.isTreeAnimationBlocked()) || false
      );
    }
    // Note: currently only running on root node
    startUpdate() {
      if (this.isUpdateBlocked()) return;
      this.isUpdating = true;
      this.nodes && this.nodes.forEach(resetSkewAndRotation);
      this.animationId++;
    }
    getTransformTemplate() {
      const { visualElement } = this.options;
      return visualElement && visualElement.getProps().transformTemplate;
    }
    willUpdate(shouldNotifyListeners = true) {
      this.root.hasTreeAnimated = true;
      if (this.root.isUpdateBlocked()) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear) {
        cancelTreeOptimisedTransformAnimations(this);
      }
      !this.root.isUpdating && this.root.startUpdate();
      if (this.isLayoutDirty) return;
      this.isLayoutDirty = true;
      for (let i = 0; i < this.path.length; i++) {
        const node = this.path[i];
        node.shouldResetTransform = true;
        node.updateScroll("snapshot");
        if (node.options.layoutRoot) {
          node.willUpdate(false);
        }
      }
      const { layoutId, layout: layout2 } = this.options;
      if (layoutId === void 0 && !layout2) return;
      const transformTemplate = this.getTransformTemplate();
      this.prevTransformTemplateValue = transformTemplate
        ? transformTemplate(this.latestValues, "")
        : void 0;
      this.updateSnapshot();
      shouldNotifyListeners && this.notifyListeners("willUpdate");
    }
    update() {
      this.updateScheduled = false;
      const updateWasBlocked = this.isUpdateBlocked();
      if (updateWasBlocked) {
        this.unblockUpdate();
        this.clearAllSnapshots();
        this.nodes.forEach(clearMeasurements);
        return;
      }
      if (this.animationId <= this.animationCommitId) {
        this.nodes.forEach(clearIsLayoutDirty);
        return;
      }
      this.animationCommitId = this.animationId;
      if (!this.isUpdating) {
        this.nodes.forEach(clearIsLayoutDirty);
      } else {
        this.isUpdating = false;
        this.nodes.forEach(resetTransformStyle);
        this.nodes.forEach(updateLayout);
        this.nodes.forEach(notifyLayoutUpdate);
      }
      this.clearAllSnapshots();
      const now2 = time.now();
      frameData.delta = clamp$2(0, 1e3 / 60, now2 - frameData.timestamp);
      frameData.timestamp = now2;
      frameData.isProcessing = true;
      frameSteps.update.process(frameData);
      frameSteps.preRender.process(frameData);
      frameSteps.render.process(frameData);
      frameData.isProcessing = false;
    }
    didUpdate() {
      if (!this.updateScheduled) {
        this.updateScheduled = true;
        microtask.read(this.scheduleUpdate);
      }
    }
    clearAllSnapshots() {
      this.nodes.forEach(clearSnapshot);
      this.sharedNodes.forEach(removeLeadSnapshots);
    }
    scheduleUpdateProjection() {
      if (!this.projectionUpdateScheduled) {
        this.projectionUpdateScheduled = true;
        frame.preRender(this.updateProjection, false, true);
      }
    }
    scheduleCheckAfterUnmount() {
      frame.postRender(() => {
        if (this.isLayoutDirty) {
          this.root.didUpdate();
        } else {
          this.root.checkUpdateFailed();
        }
      });
    }
    /**
     * Update measurements
     */
    updateSnapshot() {
      if (this.snapshot || !this.instance) return;
      this.snapshot = this.measure();
      if (
        this.snapshot &&
        !calcLength(this.snapshot.measuredBox.x) &&
        !calcLength(this.snapshot.measuredBox.y)
      ) {
        this.snapshot = void 0;
      }
    }
    updateLayout() {
      if (!this.instance) return;
      this.updateScroll();
      if (!(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty) {
        return;
      }
      if (this.resumeFrom && !this.resumeFrom.instance) {
        for (let i = 0; i < this.path.length; i++) {
          const node = this.path[i];
          node.updateScroll();
        }
      }
      const prevLayout = this.layout;
      this.layout = this.measure(false);
      this.layoutVersion++;
      this.layoutCorrected = createBox();
      this.isLayoutDirty = false;
      this.projectionDelta = void 0;
      this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement } = this.options;
      visualElement &&
        visualElement.notify(
          "LayoutMeasure",
          this.layout.layoutBox,
          prevLayout ? prevLayout.layoutBox : void 0,
        );
    }
    updateScroll(phase = "measure") {
      let needsMeasurement = Boolean(this.options.layoutScroll && this.instance);
      if (
        this.scroll &&
        this.scroll.animationId === this.root.animationId &&
        this.scroll.phase === phase
      ) {
        needsMeasurement = false;
      }
      if (needsMeasurement && this.instance) {
        const isRoot = checkIsScrollRoot(this.instance);
        this.scroll = {
          animationId: this.root.animationId,
          phase,
          isRoot,
          offset: measureScroll(this.instance),
          wasRoot: this.scroll ? this.scroll.isRoot : isRoot,
        };
      }
    }
    resetTransform() {
      if (!resetTransform) return;
      const isResetRequested =
        this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout;
      const hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);
      const transformTemplate = this.getTransformTemplate();
      const transformTemplateValue = transformTemplate
        ? transformTemplate(this.latestValues, "")
        : void 0;
      const transformTemplateHasChanged =
        transformTemplateValue !== this.prevTransformTemplateValue;
      if (
        isResetRequested &&
        this.instance &&
        (hasProjection || hasTransform(this.latestValues) || transformTemplateHasChanged)
      ) {
        resetTransform(this.instance, transformTemplateValue);
        this.shouldResetTransform = false;
        this.scheduleRender();
      }
    }
    measure(removeTransform = true) {
      const pageBox = this.measurePageBox();
      let layoutBox = this.removeElementScroll(pageBox);
      if (removeTransform) {
        layoutBox = this.removeTransform(layoutBox);
      }
      roundBox(layoutBox);
      return {
        animationId: this.root.animationId,
        measuredBox: pageBox,
        layoutBox,
        latestValues: {},
        source: this.id,
      };
    }
    measurePageBox() {
      var _a2;
      const { visualElement } = this.options;
      if (!visualElement) return createBox();
      const box = visualElement.measureViewportBox();
      const wasInScrollRoot =
        ((_a2 = this.scroll) == null ? void 0 : _a2.wasRoot) ||
        this.path.some(checkNodeWasScrollRoot);
      if (!wasInScrollRoot) {
        const { scroll } = this.root;
        if (scroll) {
          translateAxis(box.x, scroll.offset.x);
          translateAxis(box.y, scroll.offset.y);
        }
      }
      return box;
    }
    removeElementScroll(box) {
      var _a2;
      const boxWithoutScroll = createBox();
      copyBoxInto(boxWithoutScroll, box);
      if ((_a2 = this.scroll) == null ? void 0 : _a2.wasRoot) {
        return boxWithoutScroll;
      }
      for (let i = 0; i < this.path.length; i++) {
        const node = this.path[i];
        const { scroll, options } = node;
        if (node !== this.root && scroll && options.layoutScroll) {
          if (scroll.wasRoot) {
            copyBoxInto(boxWithoutScroll, box);
          }
          translateAxis(boxWithoutScroll.x, scroll.offset.x);
          translateAxis(boxWithoutScroll.y, scroll.offset.y);
        }
      }
      return boxWithoutScroll;
    }
    applyTransform(box, transformOnly = false) {
      const withTransforms = createBox();
      copyBoxInto(withTransforms, box);
      for (let i = 0; i < this.path.length; i++) {
        const node = this.path[i];
        if (!transformOnly && node.options.layoutScroll && node.scroll && node !== node.root) {
          transformBox(withTransforms, {
            x: -node.scroll.offset.x,
            y: -node.scroll.offset.y,
          });
        }
        if (!hasTransform(node.latestValues)) continue;
        transformBox(withTransforms, node.latestValues);
      }
      if (hasTransform(this.latestValues)) {
        transformBox(withTransforms, this.latestValues);
      }
      return withTransforms;
    }
    removeTransform(box) {
      const boxWithoutTransform = createBox();
      copyBoxInto(boxWithoutTransform, box);
      for (let i = 0; i < this.path.length; i++) {
        const node = this.path[i];
        if (!node.instance) continue;
        if (!hasTransform(node.latestValues)) continue;
        hasScale(node.latestValues) && node.updateSnapshot();
        const sourceBox = createBox();
        const nodeBox = node.measurePageBox();
        copyBoxInto(sourceBox, nodeBox);
        removeBoxTransforms(
          boxWithoutTransform,
          node.latestValues,
          node.snapshot ? node.snapshot.layoutBox : void 0,
          sourceBox,
        );
      }
      if (hasTransform(this.latestValues)) {
        removeBoxTransforms(boxWithoutTransform, this.latestValues);
      }
      return boxWithoutTransform;
    }
    setTargetDelta(delta) {
      this.targetDelta = delta;
      this.root.scheduleUpdateProjection();
      this.isProjectionDirty = true;
    }
    setOptions(options) {
      this.options = {
        ...this.options,
        ...options,
        crossfade: options.crossfade !== void 0 ? options.crossfade : true,
      };
    }
    clearMeasurements() {
      this.scroll = void 0;
      this.layout = void 0;
      this.snapshot = void 0;
      this.prevTransformTemplateValue = void 0;
      this.targetDelta = void 0;
      this.target = void 0;
      this.isLayoutDirty = false;
    }
    forceRelativeParentToResolveTarget() {
      if (!this.relativeParent) return;
      if (this.relativeParent.resolvedRelativeTargetAt !== frameData.timestamp) {
        this.relativeParent.resolveTargetDelta(true);
      }
    }
    resolveTargetDelta(forceRecalculation = false) {
      var _a2;
      const lead = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = lead.isProjectionDirty);
      this.isTransformDirty || (this.isTransformDirty = lead.isTransformDirty);
      this.isSharedProjectionDirty || (this.isSharedProjectionDirty = lead.isSharedProjectionDirty);
      const isShared = Boolean(this.resumingFrom) || this !== lead;
      const canSkip = !(
        forceRecalculation ||
        (isShared && this.isSharedProjectionDirty) ||
        this.isProjectionDirty ||
        ((_a2 = this.parent) == null ? void 0 : _a2.isProjectionDirty) ||
        this.attemptToResolveRelativeTarget ||
        this.root.updateBlockedByResize
      );
      if (canSkip) return;
      const { layout: layout2, layoutId } = this.options;
      if (!this.layout || !(layout2 || layoutId)) return;
      this.resolvedRelativeTargetAt = frameData.timestamp;
      const relativeParent = this.getClosestProjectingParent();
      if (
        relativeParent &&
        this.linkedParentVersion !== relativeParent.layoutVersion &&
        !relativeParent.options.layoutRoot
      ) {
        this.removeRelativeTarget();
      }
      if (!this.targetDelta && !this.relativeTarget) {
        if (relativeParent && relativeParent.layout) {
          this.createRelativeTarget(
            relativeParent,
            this.layout.layoutBox,
            relativeParent.layout.layoutBox,
          );
        } else {
          this.removeRelativeTarget();
        }
      }
      if (!this.relativeTarget && !this.targetDelta) return;
      if (!this.target) {
        this.target = createBox();
        this.targetWithTransforms = createBox();
      }
      if (
        this.relativeTarget &&
        this.relativeTargetOrigin &&
        this.relativeParent &&
        this.relativeParent.target
      ) {
        this.forceRelativeParentToResolveTarget();
        calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);
      } else if (this.targetDelta) {
        if (Boolean(this.resumingFrom)) {
          this.target = this.applyTransform(this.layout.layoutBox);
        } else {
          copyBoxInto(this.target, this.layout.layoutBox);
        }
        applyBoxDelta(this.target, this.targetDelta);
      } else {
        copyBoxInto(this.target, this.layout.layoutBox);
      }
      if (this.attemptToResolveRelativeTarget) {
        this.attemptToResolveRelativeTarget = false;
        if (
          relativeParent &&
          Boolean(relativeParent.resumingFrom) === Boolean(this.resumingFrom) &&
          !relativeParent.options.layoutScroll &&
          relativeParent.target &&
          this.animationProgress !== 1
        ) {
          this.createRelativeTarget(relativeParent, this.target, relativeParent.target);
        } else {
          this.relativeParent = this.relativeTarget = void 0;
        }
      }
    }
    getClosestProjectingParent() {
      if (
        !this.parent ||
        hasScale(this.parent.latestValues) ||
        has2DTranslate(this.parent.latestValues)
      ) {
        return void 0;
      }
      if (this.parent.isProjecting()) {
        return this.parent;
      } else {
        return this.parent.getClosestProjectingParent();
      }
    }
    isProjecting() {
      return Boolean(
        (this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout,
      );
    }
    createRelativeTarget(relativeParent, layout2, parentLayout) {
      this.relativeParent = relativeParent;
      this.linkedParentVersion = relativeParent.layoutVersion;
      this.forceRelativeParentToResolveTarget();
      this.relativeTarget = createBox();
      this.relativeTargetOrigin = createBox();
      calcRelativePosition(this.relativeTargetOrigin, layout2, parentLayout);
      copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
    }
    removeRelativeTarget() {
      this.relativeParent = this.relativeTarget = void 0;
    }
    calcProjection() {
      var _a2;
      const lead = this.getLead();
      const isShared = Boolean(this.resumingFrom) || this !== lead;
      let canSkip = true;
      if (
        this.isProjectionDirty ||
        ((_a2 = this.parent) == null ? void 0 : _a2.isProjectionDirty)
      ) {
        canSkip = false;
      }
      if (isShared && (this.isSharedProjectionDirty || this.isTransformDirty)) {
        canSkip = false;
      }
      if (this.resolvedRelativeTargetAt === frameData.timestamp) {
        canSkip = false;
      }
      if (canSkip) return;
      const { layout: layout2, layoutId } = this.options;
      this.isTreeAnimating = Boolean(
        (this.parent && this.parent.isTreeAnimating) ||
        this.currentAnimation ||
        this.pendingAnimation,
      );
      if (!this.isTreeAnimating) {
        this.targetDelta = this.relativeTarget = void 0;
      }
      if (!this.layout || !(layout2 || layoutId)) return;
      copyBoxInto(this.layoutCorrected, this.layout.layoutBox);
      const prevTreeScaleX = this.treeScale.x;
      const prevTreeScaleY = this.treeScale.y;
      applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, isShared);
      if (lead.layout && !lead.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1)) {
        lead.target = lead.layout.layoutBox;
        lead.targetWithTransforms = createBox();
      }
      const { target } = lead;
      if (!target) {
        if (this.prevProjectionDelta) {
          this.createProjectionDeltas();
          this.scheduleRender();
        }
        return;
      }
      if (!this.projectionDelta || !this.prevProjectionDelta) {
        this.createProjectionDeltas();
      } else {
        copyAxisDeltaInto(this.prevProjectionDelta.x, this.projectionDelta.x);
        copyAxisDeltaInto(this.prevProjectionDelta.y, this.projectionDelta.y);
      }
      calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);
      if (
        this.treeScale.x !== prevTreeScaleX ||
        this.treeScale.y !== prevTreeScaleY ||
        !axisDeltaEquals(this.projectionDelta.x, this.prevProjectionDelta.x) ||
        !axisDeltaEquals(this.projectionDelta.y, this.prevProjectionDelta.y)
      ) {
        this.hasProjected = true;
        this.scheduleRender();
        this.notifyListeners("projectionUpdate", target);
      }
    }
    hide() {
      this.isVisible = false;
    }
    show() {
      this.isVisible = true;
    }
    scheduleRender(notifyAll = true) {
      var _a2;
      (_a2 = this.options.visualElement) == null ? void 0 : _a2.scheduleRender();
      if (notifyAll) {
        const stack = this.getStack();
        stack && stack.scheduleRender();
      }
      if (this.resumingFrom && !this.resumingFrom.instance) {
        this.resumingFrom = void 0;
      }
    }
    createProjectionDeltas() {
      this.prevProjectionDelta = createDelta();
      this.projectionDelta = createDelta();
      this.projectionDeltaWithTransform = createDelta();
    }
    setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = false) {
      const snapshot = this.snapshot;
      const snapshotLatestValues = snapshot ? snapshot.latestValues : {};
      const mixedValues = { ...this.latestValues };
      const targetDelta = createDelta();
      if (!this.relativeParent || !this.relativeParent.options.layoutRoot) {
        this.relativeTarget = this.relativeTargetOrigin = void 0;
      }
      this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;
      const relativeLayout = createBox();
      const snapshotSource = snapshot ? snapshot.source : void 0;
      const layoutSource = this.layout ? this.layout.source : void 0;
      const isSharedLayoutAnimation = snapshotSource !== layoutSource;
      const stack = this.getStack();
      const isOnlyMember = !stack || stack.members.length <= 1;
      const shouldCrossfadeOpacity = Boolean(
        isSharedLayoutAnimation &&
        !isOnlyMember &&
        this.options.crossfade === true &&
        !this.path.some(hasOpacityCrossfade),
      );
      this.animationProgress = 0;
      let prevRelativeTarget;
      this.mixTargetDelta = (latest) => {
        const progress2 = latest / 1e3;
        mixAxisDelta(targetDelta.x, delta.x, progress2);
        mixAxisDelta(targetDelta.y, delta.y, progress2);
        this.setTargetDelta(targetDelta);
        if (
          this.relativeTarget &&
          this.relativeTargetOrigin &&
          this.layout &&
          this.relativeParent &&
          this.relativeParent.layout
        ) {
          calcRelativePosition(
            relativeLayout,
            this.layout.layoutBox,
            this.relativeParent.layout.layoutBox,
          );
          mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress2);
          if (prevRelativeTarget && boxEquals(this.relativeTarget, prevRelativeTarget)) {
            this.isProjectionDirty = false;
          }
          if (!prevRelativeTarget) prevRelativeTarget = createBox();
          copyBoxInto(prevRelativeTarget, this.relativeTarget);
        }
        if (isSharedLayoutAnimation) {
          this.animationValues = mixedValues;
          mixValues(
            mixedValues,
            snapshotLatestValues,
            this.latestValues,
            progress2,
            shouldCrossfadeOpacity,
            isOnlyMember,
          );
        }
        this.root.scheduleUpdateProjection();
        this.scheduleRender();
        this.animationProgress = progress2;
      };
      this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(options) {
      var _a2, _b, _c;
      this.notifyListeners("animationStart");
      (_a2 = this.currentAnimation) == null ? void 0 : _a2.stop();
      (_c = (_b = this.resumingFrom) == null ? void 0 : _b.currentAnimation) == null
        ? void 0
        : _c.stop();
      if (this.pendingAnimation) {
        cancelFrame(this.pendingAnimation);
        this.pendingAnimation = void 0;
      }
      this.pendingAnimation = frame.update(() => {
        globalProjectionState.hasAnimatedSinceResize = true;
        this.motionValue || (this.motionValue = motionValue(0));
        this.currentAnimation = animateSingleValue(this.motionValue, [0, 1e3], {
          ...options,
          velocity: 0,
          isSync: true,
          onUpdate: (latest) => {
            this.mixTargetDelta(latest);
            options.onUpdate && options.onUpdate(latest);
          },
          onStop: () => {},
          onComplete: () => {
            options.onComplete && options.onComplete();
            this.completeAnimation();
          },
        });
        if (this.resumingFrom) {
          this.resumingFrom.currentAnimation = this.currentAnimation;
        }
        this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      if (this.resumingFrom) {
        this.resumingFrom.currentAnimation = void 0;
        this.resumingFrom.preserveOpacity = void 0;
      }
      const stack = this.getStack();
      stack && stack.exitAnimationComplete();
      this.resumingFrom = this.currentAnimation = this.animationValues = void 0;
      this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      if (this.currentAnimation) {
        this.mixTargetDelta && this.mixTargetDelta(animationTarget);
        this.currentAnimation.stop();
      }
      this.completeAnimation();
    }
    applyTransformsToTarget() {
      const lead = this.getLead();
      let { targetWithTransforms, target, layout: layout2, latestValues } = lead;
      if (!targetWithTransforms || !target || !layout2) return;
      if (
        this !== lead &&
        this.layout &&
        layout2 &&
        shouldAnimatePositionOnly(
          this.options.animationType,
          this.layout.layoutBox,
          layout2.layoutBox,
        )
      ) {
        target = this.target || createBox();
        const xLength = calcLength(this.layout.layoutBox.x);
        target.x.min = lead.target.x.min;
        target.x.max = target.x.min + xLength;
        const yLength = calcLength(this.layout.layoutBox.y);
        target.y.min = lead.target.y.min;
        target.y.max = target.y.min + yLength;
      }
      copyBoxInto(targetWithTransforms, target);
      transformBox(targetWithTransforms, latestValues);
      calcBoxDelta(
        this.projectionDeltaWithTransform,
        this.layoutCorrected,
        targetWithTransforms,
        latestValues,
      );
    }
    registerSharedNode(layoutId, node) {
      if (!this.sharedNodes.has(layoutId)) {
        this.sharedNodes.set(layoutId, new NodeStack());
      }
      const stack = this.sharedNodes.get(layoutId);
      stack.add(node);
      const config = node.options.initialPromotionConfig;
      node.promote({
        transition: config ? config.transition : void 0,
        preserveFollowOpacity:
          config && config.shouldPreserveFollowOpacity
            ? config.shouldPreserveFollowOpacity(node)
            : void 0,
      });
    }
    isLead() {
      const stack = this.getStack();
      return stack ? stack.lead === this : true;
    }
    getLead() {
      var _a2;
      const { layoutId } = this.options;
      return layoutId ? ((_a2 = this.getStack()) == null ? void 0 : _a2.lead) || this : this;
    }
    getPrevLead() {
      var _a2;
      const { layoutId } = this.options;
      return layoutId ? ((_a2 = this.getStack()) == null ? void 0 : _a2.prevLead) : void 0;
    }
    getStack() {
      const { layoutId } = this.options;
      if (layoutId) return this.root.sharedNodes.get(layoutId);
    }
    promote({ needsReset, transition, preserveFollowOpacity } = {}) {
      const stack = this.getStack();
      if (stack) stack.promote(this, preserveFollowOpacity);
      if (needsReset) {
        this.projectionDelta = void 0;
        this.needsReset = true;
      }
      if (transition) this.setOptions({ transition });
    }
    relegate() {
      const stack = this.getStack();
      if (stack) {
        return stack.relegate(this);
      } else {
        return false;
      }
    }
    resetSkewAndRotation() {
      const { visualElement } = this.options;
      if (!visualElement) return;
      let hasDistortingTransform = false;
      const { latestValues } = visualElement;
      if (
        latestValues.z ||
        latestValues.rotate ||
        latestValues.rotateX ||
        latestValues.rotateY ||
        latestValues.rotateZ ||
        latestValues.skewX ||
        latestValues.skewY
      ) {
        hasDistortingTransform = true;
      }
      if (!hasDistortingTransform) return;
      const resetValues = {};
      if (latestValues.z) {
        resetDistortingTransform("z", visualElement, resetValues, this.animationValues);
      }
      for (let i = 0; i < transformAxes.length; i++) {
        resetDistortingTransform(
          `rotate${transformAxes[i]}`,
          visualElement,
          resetValues,
          this.animationValues,
        );
        resetDistortingTransform(
          `skew${transformAxes[i]}`,
          visualElement,
          resetValues,
          this.animationValues,
        );
      }
      visualElement.render();
      for (const key in resetValues) {
        visualElement.setStaticValue(key, resetValues[key]);
        if (this.animationValues) {
          this.animationValues[key] = resetValues[key];
        }
      }
      visualElement.scheduleRender();
    }
    applyProjectionStyles(targetStyle, styleProp) {
      if (!this.instance || this.isSVG) return;
      if (!this.isVisible) {
        targetStyle.visibility = "hidden";
        return;
      }
      const transformTemplate = this.getTransformTemplate();
      if (this.needsReset) {
        this.needsReset = false;
        targetStyle.visibility = "";
        targetStyle.opacity = "";
        targetStyle.pointerEvents =
          resolveMotionValue(styleProp == null ? void 0 : styleProp.pointerEvents) || "";
        targetStyle.transform = transformTemplate
          ? transformTemplate(this.latestValues, "")
          : "none";
        return;
      }
      const lead = this.getLead();
      if (!this.projectionDelta || !this.layout || !lead.target) {
        if (this.options.layoutId) {
          targetStyle.opacity =
            this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1;
          targetStyle.pointerEvents =
            resolveMotionValue(styleProp == null ? void 0 : styleProp.pointerEvents) || "";
        }
        if (this.hasProjected && !hasTransform(this.latestValues)) {
          targetStyle.transform = transformTemplate ? transformTemplate({}, "") : "none";
          this.hasProjected = false;
        }
        return;
      }
      targetStyle.visibility = "";
      const valuesToRender = lead.animationValues || lead.latestValues;
      this.applyTransformsToTarget();
      let transform = buildProjectionTransform(
        this.projectionDeltaWithTransform,
        this.treeScale,
        valuesToRender,
      );
      if (transformTemplate) {
        transform = transformTemplate(valuesToRender, transform);
      }
      targetStyle.transform = transform;
      const { x, y } = this.projectionDelta;
      targetStyle.transformOrigin = `${x.origin * 100}% ${y.origin * 100}% 0`;
      if (lead.animationValues) {
        targetStyle.opacity =
          lead === this
            ? (valuesToRender.opacity ?? this.latestValues.opacity ?? 1)
            : this.preserveOpacity
              ? this.latestValues.opacity
              : valuesToRender.opacityExit;
      } else {
        targetStyle.opacity =
          lead === this
            ? valuesToRender.opacity !== void 0
              ? valuesToRender.opacity
              : ""
            : valuesToRender.opacityExit !== void 0
              ? valuesToRender.opacityExit
              : 0;
      }
      for (const key in scaleCorrectors) {
        if (valuesToRender[key] === void 0) continue;
        const { correct, applyTo, isCSSVariable } = scaleCorrectors[key];
        const corrected =
          transform === "none" ? valuesToRender[key] : correct(valuesToRender[key], lead);
        if (applyTo) {
          const num = applyTo.length;
          for (let i = 0; i < num; i++) {
            targetStyle[applyTo[i]] = corrected;
          }
        } else {
          if (isCSSVariable) {
            this.options.visualElement.renderState.vars[key] = corrected;
          } else {
            targetStyle[key] = corrected;
          }
        }
      }
      if (this.options.layoutId) {
        targetStyle.pointerEvents =
          lead === this
            ? resolveMotionValue(styleProp == null ? void 0 : styleProp.pointerEvents) || ""
            : "none";
      }
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    // Only run on root
    resetTree() {
      this.root.nodes.forEach((node) => {
        var _a2;
        return (_a2 = node.currentAnimation) == null ? void 0 : _a2.stop();
      });
      this.root.nodes.forEach(clearMeasurements);
      this.root.sharedNodes.clear();
    }
  };
}
function updateLayout(node) {
  node.updateLayout();
}
function notifyLayoutUpdate(node) {
  var _a2;
  const snapshot = ((_a2 = node.resumeFrom) == null ? void 0 : _a2.snapshot) || node.snapshot;
  if (node.isLead() && node.layout && snapshot && node.hasListeners("didUpdate")) {
    const { layoutBox: layout2, measuredBox: measuredLayout } = node.layout;
    const { animationType } = node.options;
    const isShared = snapshot.source !== node.layout.source;
    if (animationType === "size") {
      eachAxis((axis) => {
        const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
        const length = calcLength(axisSnapshot);
        axisSnapshot.min = layout2[axis].min;
        axisSnapshot.max = axisSnapshot.min + length;
      });
    } else if (shouldAnimatePositionOnly(animationType, snapshot.layoutBox, layout2)) {
      eachAxis((axis) => {
        const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
        const length = calcLength(layout2[axis]);
        axisSnapshot.max = axisSnapshot.min + length;
        if (node.relativeTarget && !node.currentAnimation) {
          node.isProjectionDirty = true;
          node.relativeTarget[axis].max = node.relativeTarget[axis].min + length;
        }
      });
    }
    const layoutDelta = createDelta();
    calcBoxDelta(layoutDelta, layout2, snapshot.layoutBox);
    const visualDelta = createDelta();
    if (isShared) {
      calcBoxDelta(visualDelta, node.applyTransform(measuredLayout, true), snapshot.measuredBox);
    } else {
      calcBoxDelta(visualDelta, layout2, snapshot.layoutBox);
    }
    const hasLayoutChanged = !isDeltaZero(layoutDelta);
    let hasRelativeLayoutChanged = false;
    if (!node.resumeFrom) {
      const relativeParent = node.getClosestProjectingParent();
      if (relativeParent && !relativeParent.resumeFrom) {
        const { snapshot: parentSnapshot, layout: parentLayout } = relativeParent;
        if (parentSnapshot && parentLayout) {
          const relativeSnapshot = createBox();
          calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox);
          const relativeLayout = createBox();
          calcRelativePosition(relativeLayout, layout2, parentLayout.layoutBox);
          if (!boxEqualsRounded(relativeSnapshot, relativeLayout)) {
            hasRelativeLayoutChanged = true;
          }
          if (relativeParent.options.layoutRoot) {
            node.relativeTarget = relativeLayout;
            node.relativeTargetOrigin = relativeSnapshot;
            node.relativeParent = relativeParent;
          }
        }
      }
    }
    node.notifyListeners("didUpdate", {
      layout: layout2,
      snapshot,
      delta: visualDelta,
      layoutDelta,
      hasLayoutChanged,
      hasRelativeLayoutChanged,
    });
  } else if (node.isLead()) {
    const { onExitComplete } = node.options;
    onExitComplete && onExitComplete();
  }
  node.options.transition = void 0;
}
function propagateDirtyNodes(node) {
  if (!node.parent) return;
  if (!node.isProjecting()) {
    node.isProjectionDirty = node.parent.isProjectionDirty;
  }
  node.isSharedProjectionDirty ||
    (node.isSharedProjectionDirty = Boolean(
      node.isProjectionDirty ||
      node.parent.isProjectionDirty ||
      node.parent.isSharedProjectionDirty,
    ));
  node.isTransformDirty || (node.isTransformDirty = node.parent.isTransformDirty);
}
function cleanDirtyNodes(node) {
  node.isProjectionDirty = node.isSharedProjectionDirty = node.isTransformDirty = false;
}
function clearSnapshot(node) {
  node.clearSnapshot();
}
function clearMeasurements(node) {
  node.clearMeasurements();
}
function clearIsLayoutDirty(node) {
  node.isLayoutDirty = false;
}
function resetTransformStyle(node) {
  const { visualElement } = node.options;
  if (visualElement && visualElement.getProps().onBeforeLayoutMeasure) {
    visualElement.notify("BeforeLayoutMeasure");
  }
  node.resetTransform();
}
function finishAnimation(node) {
  node.finishAnimation();
  node.targetDelta = node.relativeTarget = node.target = void 0;
  node.isProjectionDirty = true;
}
function resolveTargetDelta(node) {
  node.resolveTargetDelta();
}
function calcProjection(node) {
  node.calcProjection();
}
function resetSkewAndRotation(node) {
  node.resetSkewAndRotation();
}
function removeLeadSnapshots(stack) {
  stack.removeLeadSnapshot();
}
function mixAxisDelta(output, delta, p) {
  output.translate = mixNumber$1(delta.translate, 0, p);
  output.scale = mixNumber$1(delta.scale, 1, p);
  output.origin = delta.origin;
  output.originPoint = delta.originPoint;
}
function mixAxis(output, from, to, p) {
  output.min = mixNumber$1(from.min, to.min, p);
  output.max = mixNumber$1(from.max, to.max, p);
}
function mixBox(output, from, to, p) {
  mixAxis(output.x, from.x, to.x, p);
  mixAxis(output.y, from.y, to.y, p);
}
function hasOpacityCrossfade(node) {
  return node.animationValues && node.animationValues.opacityExit !== void 0;
}
const defaultLayoutTransition = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1],
};
const userAgentContains = (string) =>
  typeof navigator !== "undefined" &&
  navigator.userAgent &&
  navigator.userAgent.toLowerCase().includes(string);
const roundPoint =
  userAgentContains("applewebkit/") && !userAgentContains("chrome/") ? Math.round : noop$2;
function roundAxis(axis) {
  axis.min = roundPoint(axis.min);
  axis.max = roundPoint(axis.max);
}
function roundBox(box) {
  roundAxis(box.x);
  roundAxis(box.y);
}
function shouldAnimatePositionOnly(animationType, snapshot, layout2) {
  return (
    animationType === "position" ||
    (animationType === "preserve-aspect" &&
      !isNear(aspectRatio(snapshot), aspectRatio(layout2), 0.2))
  );
}
function checkNodeWasScrollRoot(node) {
  var _a2;
  return node !== node.root && ((_a2 = node.scroll) == null ? void 0 : _a2.wasRoot);
}
const DocumentProjectionNode = createProjectionNode$1({
  attachResizeListener: (ref, notify) => addDomEvent(ref, "resize", notify),
  measureScroll: () => {
    var _a2, _b;
    return {
      x:
        document.documentElement.scrollLeft ||
        ((_a2 = document.body) == null ? void 0 : _a2.scrollLeft) ||
        0,
      y:
        document.documentElement.scrollTop ||
        ((_b = document.body) == null ? void 0 : _b.scrollTop) ||
        0,
    };
  },
  checkIsScrollRoot: () => true,
});
const rootProjectionNode = {
  current: void 0,
};
const HTMLProjectionNode = createProjectionNode$1({
  measureScroll: (instance) => ({
    x: instance.scrollLeft,
    y: instance.scrollTop,
  }),
  defaultParent: () => {
    if (!rootProjectionNode.current) {
      const documentNode = new DocumentProjectionNode({});
      documentNode.mount(window);
      documentNode.setOptions({ layoutScroll: true });
      rootProjectionNode.current = documentNode;
    }
    return rootProjectionNode.current;
  },
  resetTransform: (instance, value) => {
    instance.style.transform = value !== void 0 ? value : "none";
  },
  checkIsScrollRoot: (instance) => Boolean(window.getComputedStyle(instance).position === "fixed"),
});
const MotionConfigContext = reactExports.createContext({
  transformPagePoint: (p) => p,
  isStatic: false,
  reducedMotion: "never",
});
function setRef(ref, value) {
  if (typeof ref === "function") {
    return ref(value);
  } else if (ref !== null && ref !== void 0) {
    ref.current = value;
  }
}
function composeRefs(...refs) {
  return (node) => {
    let hasCleanup = false;
    const cleanups = refs.map((ref) => {
      const cleanup = setRef(ref, node);
      if (!hasCleanup && typeof cleanup === "function") {
        hasCleanup = true;
      }
      return cleanup;
    });
    if (hasCleanup) {
      return () => {
        for (let i = 0; i < cleanups.length; i++) {
          const cleanup = cleanups[i];
          if (typeof cleanup === "function") {
            cleanup();
          } else {
            setRef(refs[i], null);
          }
        }
      };
    }
  };
}
function useComposedRefs(...refs) {
  return reactExports.useCallback(composeRefs(...refs), refs);
}
class PopChildMeasure extends reactExports.Component {
  getSnapshotBeforeUpdate(prevProps) {
    const element = this.props.childRef.current;
    if (element && prevProps.isPresent && !this.props.isPresent) {
      const parent = element.offsetParent;
      const parentWidth = isHTMLElement$1(parent) ? parent.offsetWidth || 0 : 0;
      const parentHeight = isHTMLElement$1(parent) ? parent.offsetHeight || 0 : 0;
      const size2 = this.props.sizeRef.current;
      size2.height = element.offsetHeight || 0;
      size2.width = element.offsetWidth || 0;
      size2.top = element.offsetTop;
      size2.left = element.offsetLeft;
      size2.right = parentWidth - size2.width - size2.left;
      size2.bottom = parentHeight - size2.height - size2.top;
    }
    return null;
  }
  /**
   * Required with getSnapshotBeforeUpdate to stop React complaining.
   */
  componentDidUpdate() {}
  render() {
    return this.props.children;
  }
}
function PopChild({ children, isPresent, anchorX, anchorY, root }) {
  var _a2;
  const id2 = reactExports.useId();
  const ref = reactExports.useRef(null);
  const size2 = reactExports.useRef({
    width: 0,
    height: 0,
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
  });
  const { nonce } = reactExports.useContext(MotionConfigContext);
  const childRef =
    ((_a2 = children.props) == null ? void 0 : _a2.ref) ??
    (children == null ? void 0 : children.ref);
  const composedRef = useComposedRefs(ref, childRef);
  reactExports.useInsertionEffect(() => {
    const { width, height, top, left, right, bottom } = size2.current;
    if (isPresent || !ref.current || !width || !height) return;
    const x = anchorX === "left" ? `left: ${left}` : `right: ${right}`;
    const y = anchorY === "bottom" ? `bottom: ${bottom}` : `top: ${top}`;
    ref.current.dataset.motionPopId = id2;
    const style = document.createElement("style");
    if (nonce) style.nonce = nonce;
    const parent = root ?? document.head;
    parent.appendChild(style);
    if (style.sheet) {
      style.sheet.insertRule(`
          [data-motion-pop-id="${id2}"] {
            position: absolute !important;
            width: ${width}px !important;
            height: ${height}px !important;
            ${x}px !important;
            ${y}px !important;
          }
        `);
    }
    return () => {
      if (parent.contains(style)) {
        parent.removeChild(style);
      }
    };
  }, [isPresent]);
  return jsxRuntimeExports.jsx(PopChildMeasure, {
    isPresent,
    childRef: ref,
    sizeRef: size2,
    children: reactExports.cloneElement(children, { ref: composedRef }),
  });
}
const PresenceChild = ({
  children,
  initial,
  isPresent,
  onExitComplete,
  custom,
  presenceAffectsLayout,
  mode,
  anchorX,
  anchorY,
  root,
}) => {
  const presenceChildren = useConstant(newChildrenMap);
  const id2 = reactExports.useId();
  let isReusedContext = true;
  let context = reactExports.useMemo(() => {
    isReusedContext = false;
    return {
      id: id2,
      initial,
      isPresent,
      custom,
      onExitComplete: (childId) => {
        presenceChildren.set(childId, true);
        for (const isComplete of presenceChildren.values()) {
          if (!isComplete) return;
        }
        onExitComplete && onExitComplete();
      },
      register: (childId) => {
        presenceChildren.set(childId, false);
        return () => presenceChildren.delete(childId);
      },
    };
  }, [isPresent, presenceChildren, onExitComplete]);
  if (presenceAffectsLayout && isReusedContext) {
    context = { ...context };
  }
  reactExports.useMemo(() => {
    presenceChildren.forEach((_, key) => presenceChildren.set(key, false));
  }, [isPresent]);
  reactExports.useEffect(() => {
    !isPresent && !presenceChildren.size && onExitComplete && onExitComplete();
  }, [isPresent]);
  if (mode === "popLayout") {
    children = jsxRuntimeExports.jsx(PopChild, { isPresent, anchorX, anchorY, root, children });
  }
  return jsxRuntimeExports.jsx(PresenceContext.Provider, { value: context, children });
};
function newChildrenMap() {
  return /* @__PURE__ */ new Map();
}
function usePresence(subscribe = true) {
  const context = reactExports.useContext(PresenceContext);
  if (context === null) return [true, null];
  const { isPresent, onExitComplete, register } = context;
  const id2 = reactExports.useId();
  reactExports.useEffect(() => {
    if (subscribe) {
      return register(id2);
    }
  }, [subscribe]);
  const safeToRemove = reactExports.useCallback(
    () => subscribe && onExitComplete && onExitComplete(id2),
    [id2, onExitComplete, subscribe],
  );
  return !isPresent && onExitComplete ? [false, safeToRemove] : [true];
}
const getChildKey = (child) => child.key || "";
function onlyElements(children) {
  const filtered = [];
  reactExports.Children.forEach(children, (child) => {
    if (reactExports.isValidElement(child)) filtered.push(child);
  });
  return filtered;
}
const AnimatePresence = ({
  children,
  custom,
  initial = true,
  onExitComplete,
  presenceAffectsLayout = true,
  mode = "sync",
  propagate = false,
  anchorX = "left",
  anchorY = "top",
  root,
}) => {
  const [isParentPresent, safeToRemove] = usePresence(propagate);
  const presentChildren = reactExports.useMemo(() => onlyElements(children), [children]);
  const presentKeys = propagate && !isParentPresent ? [] : presentChildren.map(getChildKey);
  const isInitialRender = reactExports.useRef(true);
  const pendingPresentChildren = reactExports.useRef(presentChildren);
  const exitComplete = useConstant(() => /* @__PURE__ */ new Map());
  const exitingComponents = reactExports.useRef(/* @__PURE__ */ new Set());
  const [diffedChildren, setDiffedChildren] = reactExports.useState(presentChildren);
  const [renderedChildren, setRenderedChildren] = reactExports.useState(presentChildren);
  useIsomorphicLayoutEffect(() => {
    isInitialRender.current = false;
    pendingPresentChildren.current = presentChildren;
    for (let i = 0; i < renderedChildren.length; i++) {
      const key = getChildKey(renderedChildren[i]);
      if (!presentKeys.includes(key)) {
        if (exitComplete.get(key) !== true) {
          exitComplete.set(key, false);
        }
      } else {
        exitComplete.delete(key);
        exitingComponents.current.delete(key);
      }
    }
  }, [renderedChildren, presentKeys.length, presentKeys.join("-")]);
  const exitingChildren = [];
  if (presentChildren !== diffedChildren) {
    let nextChildren = [...presentChildren];
    for (let i = 0; i < renderedChildren.length; i++) {
      const child = renderedChildren[i];
      const key = getChildKey(child);
      if (!presentKeys.includes(key)) {
        nextChildren.splice(i, 0, child);
        exitingChildren.push(child);
      }
    }
    if (mode === "wait" && exitingChildren.length) {
      nextChildren = exitingChildren;
    }
    setRenderedChildren(onlyElements(nextChildren));
    setDiffedChildren(presentChildren);
    return null;
  }
  const { forceRender } = reactExports.useContext(LayoutGroupContext);
  return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
    children: renderedChildren.map((child) => {
      const key = getChildKey(child);
      const isPresent =
        propagate && !isParentPresent
          ? false
          : presentChildren === renderedChildren || presentKeys.includes(key);
      const onExit = () => {
        if (exitingComponents.current.has(key)) {
          return;
        }
        exitingComponents.current.add(key);
        if (exitComplete.has(key)) {
          exitComplete.set(key, true);
        } else {
          return;
        }
        let isEveryExitComplete = true;
        exitComplete.forEach((isExitComplete) => {
          if (!isExitComplete) isEveryExitComplete = false;
        });
        if (isEveryExitComplete) {
          forceRender == null ? void 0 : forceRender();
          setRenderedChildren(pendingPresentChildren.current);
          propagate && (safeToRemove == null ? void 0 : safeToRemove());
          onExitComplete && onExitComplete();
        }
      };
      return jsxRuntimeExports.jsx(
        PresenceChild,
        {
          isPresent,
          initial: !isInitialRender.current || initial ? void 0 : false,
          custom,
          presenceAffectsLayout,
          mode,
          root,
          onExitComplete: isPresent ? void 0 : onExit,
          anchorX,
          anchorY,
          children: child,
        },
        key,
      );
    }),
  });
};
const LazyContext = reactExports.createContext({ strict: false });
const featureProps = {
  animation: [
    "animate",
    "variants",
    "whileHover",
    "whileTap",
    "exit",
    "whileInView",
    "whileFocus",
    "whileDrag",
  ],
  exit: ["exit"],
  drag: ["drag", "dragControls"],
  focus: ["whileFocus"],
  hover: ["whileHover", "onHoverStart", "onHoverEnd"],
  tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
  pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
  inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
  layout: ["layout", "layoutId"],
};
let isInitialized = false;
function initFeatureDefinitions() {
  if (isInitialized) return;
  const initialFeatureDefinitions = {};
  for (const key in featureProps) {
    initialFeatureDefinitions[key] = {
      isEnabled: (props) => featureProps[key].some((name) => !!props[name]),
    };
  }
  setFeatureDefinitions(initialFeatureDefinitions);
  isInitialized = true;
}
function getInitializedFeatureDefinitions() {
  initFeatureDefinitions();
  return getFeatureDefinitions();
}
function loadFeatures(features) {
  const featureDefinitions2 = getInitializedFeatureDefinitions();
  for (const key in features) {
    featureDefinitions2[key] = {
      ...featureDefinitions2[key],
      ...features[key],
    };
  }
  setFeatureDefinitions(featureDefinitions2);
}
const validMotionProps = /* @__PURE__ */ new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "custom",
  "inherit",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "globalTapTarget",
  "ignoreStrict",
  "viewport",
]);
function isValidMotionProp(key) {
  return (
    key.startsWith("while") ||
    (key.startsWith("drag") && key !== "draggable") ||
    key.startsWith("layout") ||
    key.startsWith("onTap") ||
    key.startsWith("onPan") ||
    key.startsWith("onLayout") ||
    validMotionProps.has(key)
  );
}
let shouldForward = (key) => !isValidMotionProp(key);
function loadExternalIsValidProp(isValidProp) {
  if (typeof isValidProp !== "function") return;
  shouldForward = (key) => (key.startsWith("on") ? !isValidMotionProp(key) : isValidProp(key));
}
try {
  loadExternalIsValidProp(require("@emotion/is-prop-valid").default);
} catch {}
function filterProps(props, isDom, forwardMotionProps) {
  const filteredProps = {};
  for (const key in props) {
    if (key === "values" && typeof props.values === "object") continue;
    if (
      shouldForward(key) ||
      (forwardMotionProps === true && isValidMotionProp(key)) ||
      (!isDom && !isValidMotionProp(key)) || // If trying to use native HTML drag events, forward drag listeners
      (props["draggable"] && key.startsWith("onDrag"))
    ) {
      filteredProps[key] = props[key];
    }
  }
  return filteredProps;
}
const MotionContext = /* @__PURE__ */ reactExports.createContext({});
function getCurrentTreeVariants(props, context) {
  if (isControllingVariants(props)) {
    const { initial, animate } = props;
    return {
      initial: initial === false || isVariantLabel(initial) ? initial : void 0,
      animate: isVariantLabel(animate) ? animate : void 0,
    };
  }
  return props.inherit !== false ? context : {};
}
function useCreateMotionContext(props) {
  const { initial, animate } = getCurrentTreeVariants(
    props,
    reactExports.useContext(MotionContext),
  );
  return reactExports.useMemo(
    () => ({ initial, animate }),
    [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate)],
  );
}
function variantLabelsAsDependency(prop) {
  return Array.isArray(prop) ? prop.join(" ") : prop;
}
const createHtmlRenderState = () => ({
  style: {},
  transform: {},
  transformOrigin: {},
  vars: {},
});
function copyRawValuesOnly(target, source, props) {
  for (const key in source) {
    if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {
      target[key] = source[key];
    }
  }
}
function useInitialMotionValues({ transformTemplate }, visualState) {
  return reactExports.useMemo(() => {
    const state = createHtmlRenderState();
    buildHTMLStyles(state, visualState, transformTemplate);
    return Object.assign({}, state.vars, state.style);
  }, [visualState]);
}
function useStyle(props, visualState) {
  const styleProp = props.style || {};
  const style = {};
  copyRawValuesOnly(style, styleProp, props);
  Object.assign(style, useInitialMotionValues(props, visualState));
  return style;
}
function useHTMLProps(props, visualState) {
  const htmlProps = {};
  const style = useStyle(props, visualState);
  if (props.drag && props.dragListener !== false) {
    htmlProps.draggable = false;
    style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout = "none";
    style.touchAction = props.drag === true ? "none" : `pan-${props.drag === "x" ? "y" : "x"}`;
  }
  if (props.tabIndex === void 0 && (props.onTap || props.onTapStart || props.whileTap)) {
    htmlProps.tabIndex = 0;
  }
  htmlProps.style = style;
  return htmlProps;
}
const createSvgRenderState = () => ({
  ...createHtmlRenderState(),
  attrs: {},
});
function useSVGProps(props, visualState, _isStatic, Component) {
  const visualProps = reactExports.useMemo(() => {
    const state = createSvgRenderState();
    buildSVGAttrs(state, visualState, isSVGTag(Component), props.transformTemplate, props.style);
    return {
      ...state.attrs,
      style: { ...state.style },
    };
  }, [visualState]);
  if (props.style) {
    const rawStyles = {};
    copyRawValuesOnly(rawStyles, props.style, props);
    visualProps.style = { ...rawStyles, ...visualProps.style };
  }
  return visualProps;
}
const lowercaseSVGElements = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view",
];
function isSVGComponent(Component) {
  if (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof Component !== "string" /**
     * If it contains a dash, the element is a custom HTML webcomponent.
     */ ||
    Component.includes("-")
  ) {
    return false;
  } else if (
    /**
     * If it's in our list of lowercase SVG tags, it's an SVG component
     */
    lowercaseSVGElements.indexOf(Component) > -1 /**
     * If it contains a capital letter, it's an SVG component
     */ ||
    /[A-Z]/u.test(Component)
  ) {
    return true;
  }
  return false;
}
function useRender(
  Component,
  props,
  ref,
  { latestValues },
  isStatic,
  forwardMotionProps = false,
  isSVG,
) {
  const useVisualProps = (isSVG ?? isSVGComponent(Component)) ? useSVGProps : useHTMLProps;
  const visualProps = useVisualProps(props, latestValues, isStatic, Component);
  const filteredProps = filterProps(props, typeof Component === "string", forwardMotionProps);
  const elementProps =
    Component !== reactExports.Fragment ? { ...filteredProps, ...visualProps, ref } : {};
  const { children } = props;
  const renderedChildren = reactExports.useMemo(
    () => (isMotionValue(children) ? children.get() : children),
    [children],
  );
  return reactExports.createElement(Component, {
    ...elementProps,
    children: renderedChildren,
  });
}
function makeState(
  { scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2, createRenderState },
  props,
  context,
  presenceContext,
) {
  const state = {
    latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps2),
    renderState: createRenderState(),
  };
  return state;
}
function makeLatestValues(props, context, presenceContext, scrapeMotionValues) {
  const values = {};
  const motionValues = scrapeMotionValues(props, {});
  for (const key in motionValues) {
    values[key] = resolveMotionValue(motionValues[key]);
  }
  let { initial, animate } = props;
  const isControllingVariants$1 = isControllingVariants(props);
  const isVariantNode$1 = isVariantNode(props);
  if (context && isVariantNode$1 && !isControllingVariants$1 && props.inherit !== false) {
    if (initial === void 0) initial = context.initial;
    if (animate === void 0) animate = context.animate;
  }
  let isInitialAnimationBlocked = presenceContext ? presenceContext.initial === false : false;
  isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;
  const variantToSet = isInitialAnimationBlocked ? animate : initial;
  if (variantToSet && typeof variantToSet !== "boolean" && !isAnimationControls(variantToSet)) {
    const list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];
    for (let i = 0; i < list.length; i++) {
      const resolved = resolveVariantFromProps(props, list[i]);
      if (resolved) {
        const { transitionEnd, transition, ...target } = resolved;
        for (const key in target) {
          let valueTarget = target[key];
          if (Array.isArray(valueTarget)) {
            const index2 = isInitialAnimationBlocked ? valueTarget.length - 1 : 0;
            valueTarget = valueTarget[index2];
          }
          if (valueTarget !== null) {
            values[key] = valueTarget;
          }
        }
        for (const key in transitionEnd) {
          values[key] = transitionEnd[key];
        }
      }
    }
  }
  return values;
}
const makeUseVisualState = (config) => (props, isStatic) => {
  const context = reactExports.useContext(MotionContext);
  const presenceContext = reactExports.useContext(PresenceContext);
  const make = () => makeState(config, props, context, presenceContext);
  return isStatic ? make() : useConstant(make);
};
const useHTMLVisualState = /* @__PURE__ */ makeUseVisualState({
  scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,
  createRenderState: createHtmlRenderState,
});
const useSVGVisualState = /* @__PURE__ */ makeUseVisualState({
  scrapeMotionValuesFromProps,
  createRenderState: createSvgRenderState,
});
const motionComponentSymbol = Symbol.for("motionComponentSymbol");
function useMotionRef(visualState, visualElement, externalRef) {
  const externalRefContainer = reactExports.useRef(externalRef);
  reactExports.useInsertionEffect(() => {
    externalRefContainer.current = externalRef;
  });
  const refCleanup = reactExports.useRef(null);
  return reactExports.useCallback(
    (instance) => {
      var _a2;
      if (instance) {
        (_a2 = visualState.onMount) == null ? void 0 : _a2.call(visualState, instance);
      }
      if (visualElement) {
        instance ? visualElement.mount(instance) : visualElement.unmount();
      }
      const ref = externalRefContainer.current;
      if (typeof ref === "function") {
        if (instance) {
          const cleanup = ref(instance);
          if (typeof cleanup === "function") {
            refCleanup.current = cleanup;
          }
        } else if (refCleanup.current) {
          refCleanup.current();
          refCleanup.current = null;
        } else {
          ref(instance);
        }
      } else if (ref) {
        ref.current = instance;
      }
    },
    [visualElement],
  );
}
const SwitchLayoutGroupContext = reactExports.createContext({});
function isRefObject(ref) {
  return ref && typeof ref === "object" && Object.prototype.hasOwnProperty.call(ref, "current");
}
function useVisualElement(
  Component,
  visualState,
  props,
  createVisualElement,
  ProjectionNodeConstructor,
  isSVG,
) {
  var _a2, _b;
  const { visualElement: parent } = reactExports.useContext(MotionContext);
  const lazyContext = reactExports.useContext(LazyContext);
  const presenceContext = reactExports.useContext(PresenceContext);
  const reducedMotionConfig = reactExports.useContext(MotionConfigContext).reducedMotion;
  const visualElementRef = reactExports.useRef(null);
  createVisualElement = createVisualElement || lazyContext.renderer;
  if (!visualElementRef.current && createVisualElement) {
    visualElementRef.current = createVisualElement(Component, {
      visualState,
      parent,
      props,
      presenceContext,
      blockInitialAnimation: presenceContext ? presenceContext.initial === false : false,
      reducedMotionConfig,
      isSVG,
    });
  }
  const visualElement = visualElementRef.current;
  const initialLayoutGroupConfig = reactExports.useContext(SwitchLayoutGroupContext);
  if (
    visualElement &&
    !visualElement.projection &&
    ProjectionNodeConstructor &&
    (visualElement.type === "html" || visualElement.type === "svg")
  ) {
    createProjectionNode(
      visualElementRef.current,
      props,
      ProjectionNodeConstructor,
      initialLayoutGroupConfig,
    );
  }
  const isMounted = reactExports.useRef(false);
  reactExports.useInsertionEffect(() => {
    if (visualElement && isMounted.current) {
      visualElement.update(props, presenceContext);
    }
  });
  const optimisedAppearId = props[optimizedAppearDataAttribute];
  const wantsHandoff = reactExports.useRef(
    Boolean(optimisedAppearId) &&
      !((_a2 = window.MotionHandoffIsComplete) == null
        ? void 0
        : _a2.call(window, optimisedAppearId)) &&
      ((_b = window.MotionHasOptimisedAnimation) == null
        ? void 0
        : _b.call(window, optimisedAppearId)),
  );
  useIsomorphicLayoutEffect(() => {
    if (!visualElement) return;
    isMounted.current = true;
    window.MotionIsMounted = true;
    visualElement.updateFeatures();
    visualElement.scheduleRenderMicrotask();
    if (wantsHandoff.current && visualElement.animationState) {
      visualElement.animationState.animateChanges();
    }
  });
  reactExports.useEffect(() => {
    if (!visualElement) return;
    if (!wantsHandoff.current && visualElement.animationState) {
      visualElement.animationState.animateChanges();
    }
    if (wantsHandoff.current) {
      queueMicrotask(() => {
        var _a3;
        (_a3 = window.MotionHandoffMarkAsComplete) == null
          ? void 0
          : _a3.call(window, optimisedAppearId);
      });
      wantsHandoff.current = false;
    }
    visualElement.enteringChildren = void 0;
  });
  return visualElement;
}
function createProjectionNode(
  visualElement,
  props,
  ProjectionNodeConstructor,
  initialPromotionConfig,
) {
  const {
    layoutId,
    layout: layout2,
    drag: drag2,
    dragConstraints,
    layoutScroll,
    layoutRoot,
    layoutCrossfade,
  } = props;
  visualElement.projection = new ProjectionNodeConstructor(
    visualElement.latestValues,
    props["data-framer-portal-id"] ? void 0 : getClosestProjectingNode(visualElement.parent),
  );
  visualElement.projection.setOptions({
    layoutId,
    layout: layout2,
    alwaysMeasureLayout: Boolean(drag2) || (dragConstraints && isRefObject(dragConstraints)),
    visualElement,
    /**
     * TODO: Update options in an effect. This could be tricky as it'll be too late
     * to update by the time layout animations run.
     * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
     * ensuring it gets called if there's no potential layout animations.
     *
     */
    animationType: typeof layout2 === "string" ? layout2 : "both",
    initialPromotionConfig,
    crossfade: layoutCrossfade,
    layoutScroll,
    layoutRoot,
  });
}
function getClosestProjectingNode(visualElement) {
  if (!visualElement) return void 0;
  return visualElement.options.allowProjection !== false
    ? visualElement.projection
    : getClosestProjectingNode(visualElement.parent);
}
function createMotionComponent(
  Component,
  { forwardMotionProps = false, type } = {},
  preloadedFeatures,
  createVisualElement,
) {
  preloadedFeatures && loadFeatures(preloadedFeatures);
  const isSVG = type ? type === "svg" : isSVGComponent(Component);
  const useVisualState = isSVG ? useSVGVisualState : useHTMLVisualState;
  function MotionDOMComponent(props, externalRef) {
    let MeasureLayout2;
    const configAndProps = {
      ...reactExports.useContext(MotionConfigContext),
      ...props,
      layoutId: useLayoutId(props),
    };
    const { isStatic } = configAndProps;
    const context = useCreateMotionContext(props);
    const visualState = useVisualState(props, isStatic);
    if (!isStatic && isBrowser$1) {
      useStrictMode();
      const layoutProjection = getProjectionFunctionality(configAndProps);
      MeasureLayout2 = layoutProjection.MeasureLayout;
      context.visualElement = useVisualElement(
        Component,
        visualState,
        configAndProps,
        createVisualElement,
        layoutProjection.ProjectionNode,
        isSVG,
      );
    }
    return jsxRuntimeExports.jsxs(MotionContext.Provider, {
      value: context,
      children: [
        MeasureLayout2 && context.visualElement
          ? jsxRuntimeExports.jsx(MeasureLayout2, {
              visualElement: context.visualElement,
              ...configAndProps,
            })
          : null,
        useRender(
          Component,
          props,
          useMotionRef(visualState, context.visualElement, externalRef),
          visualState,
          isStatic,
          forwardMotionProps,
          isSVG,
        ),
      ],
    });
  }
  MotionDOMComponent.displayName = `motion.${typeof Component === "string" ? Component : `create(${Component.displayName ?? Component.name ?? ""})`}`;
  const ForwardRefMotionComponent = reactExports.forwardRef(MotionDOMComponent);
  ForwardRefMotionComponent[motionComponentSymbol] = Component;
  return ForwardRefMotionComponent;
}
function useLayoutId({ layoutId }) {
  const layoutGroupId = reactExports.useContext(LayoutGroupContext).id;
  return layoutGroupId && layoutId !== void 0 ? layoutGroupId + "-" + layoutId : layoutId;
}
function useStrictMode(configAndProps, preloadedFeatures) {
  reactExports.useContext(LazyContext).strict;
}
function getProjectionFunctionality(props) {
  const featureDefinitions2 = getInitializedFeatureDefinitions();
  const { drag: drag2, layout: layout2 } = featureDefinitions2;
  if (!drag2 && !layout2) return {};
  const combined = { ...drag2, ...layout2 };
  return {
    MeasureLayout:
      (drag2 == null ? void 0 : drag2.isEnabled(props)) ||
      (layout2 == null ? void 0 : layout2.isEnabled(props))
        ? combined.MeasureLayout
        : void 0,
    ProjectionNode: combined.ProjectionNode,
  };
}
function createMotionProxy(preloadedFeatures, createVisualElement) {
  if (typeof Proxy === "undefined") {
    return createMotionComponent;
  }
  const componentCache = /* @__PURE__ */ new Map();
  const factory = (Component, options) => {
    return createMotionComponent(Component, options, preloadedFeatures, createVisualElement);
  };
  const deprecatedFactoryFunction = (Component, options) => {
    return factory(Component, options);
  };
  return new Proxy(deprecatedFactoryFunction, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: (_target, key) => {
      if (key === "create") return factory;
      if (!componentCache.has(key)) {
        componentCache.set(
          key,
          createMotionComponent(key, void 0, preloadedFeatures, createVisualElement),
        );
      }
      return componentCache.get(key);
    },
  });
}
const createDomVisualElement = (Component, options) => {
  const isSVG = options.isSVG ?? isSVGComponent(Component);
  return isSVG
    ? new SVGVisualElement(options)
    : new HTMLVisualElement(options, {
        allowProjection: Component !== reactExports.Fragment,
      });
};
class AnimationFeature extends Feature {
  /**
   * We dynamically generate the AnimationState manager as it contains a reference
   * to the underlying animation library. We only want to load that if we load this,
   * so people can optionally code split it out using the `m` component.
   */
  constructor(node) {
    super(node);
    node.animationState || (node.animationState = createAnimationState(node));
  }
  updateAnimationControlsSubscription() {
    const { animate } = this.node.getProps();
    if (isAnimationControls(animate)) {
      this.unmountControls = animate.subscribe(this.node);
    }
  }
  /**
   * Subscribe any provided AnimationControls to the component's VisualElement
   */
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate } = this.node.getProps();
    const { animate: prevAnimate } = this.node.prevProps || {};
    if (animate !== prevAnimate) {
      this.updateAnimationControlsSubscription();
    }
  }
  unmount() {
    var _a2;
    this.node.animationState.reset();
    (_a2 = this.unmountControls) == null ? void 0 : _a2.call(this);
  }
}
let id = 0;
class ExitAnimationFeature extends Feature {
  constructor() {
    super(...arguments);
    this.id = id++;
  }
  update() {
    if (!this.node.presenceContext) return;
    const { isPresent, onExitComplete } = this.node.presenceContext;
    const { isPresent: prevIsPresent } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || isPresent === prevIsPresent) {
      return;
    }
    const exitAnimation = this.node.animationState.setActive("exit", !isPresent);
    if (onExitComplete && !isPresent) {
      exitAnimation.then(() => {
        onExitComplete(this.id);
      });
    }
  }
  mount() {
    const { register, onExitComplete } = this.node.presenceContext || {};
    if (onExitComplete) {
      onExitComplete(this.id);
    }
    if (register) {
      this.unmount = register(this.id);
    }
  }
  unmount() {}
}
const animations = {
  animation: {
    Feature: AnimationFeature,
  },
  exit: {
    Feature: ExitAnimationFeature,
  },
};
function extractEventInfo(event) {
  return {
    point: {
      x: event.pageX,
      y: event.pageY,
    },
  };
}
const addPointerInfo = (handler) => {
  return (event) => isPrimaryPointer(event) && handler(event, extractEventInfo(event));
};
function addPointerEvent(target, eventName, handler, options) {
  return addDomEvent(target, eventName, addPointerInfo(handler), options);
}
const getContextWindow = ({ current }) => {
  return current ? current.ownerDocument.defaultView : null;
};
const distance = (a, b) => Math.abs(a - b);
function distance2D(a, b) {
  const xDelta = distance(a.x, b.x);
  const yDelta = distance(a.y, b.y);
  return Math.sqrt(xDelta ** 2 + yDelta ** 2);
}
const overflowStyles = /* @__PURE__ */ new Set(["auto", "scroll"]);
class PanSession {
  constructor(
    event,
    handlers,
    {
      transformPagePoint,
      contextWindow = window,
      dragSnapToOrigin = false,
      distanceThreshold = 3,
      element,
    } = {},
  ) {
    this.startEvent = null;
    this.lastMoveEvent = null;
    this.lastMoveEventInfo = null;
    this.handlers = {};
    this.contextWindow = window;
    this.scrollPositions = /* @__PURE__ */ new Map();
    this.removeScrollListeners = null;
    this.onElementScroll = (event2) => {
      this.handleScroll(event2.target);
    };
    this.onWindowScroll = () => {
      this.handleScroll(window);
    };
    this.updatePoint = () => {
      if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;
      const info2 = getPanInfo(this.lastMoveEventInfo, this.history);
      const isPanStarted = this.startEvent !== null;
      const isDistancePastThreshold =
        distance2D(info2.offset, { x: 0, y: 0 }) >= this.distanceThreshold;
      if (!isPanStarted && !isDistancePastThreshold) return;
      const { point: point2 } = info2;
      const { timestamp: timestamp2 } = frameData;
      this.history.push({ ...point2, timestamp: timestamp2 });
      const { onStart, onMove } = this.handlers;
      if (!isPanStarted) {
        onStart && onStart(this.lastMoveEvent, info2);
        this.startEvent = this.lastMoveEvent;
      }
      onMove && onMove(this.lastMoveEvent, info2);
    };
    this.handlePointerMove = (event2, info2) => {
      this.lastMoveEvent = event2;
      this.lastMoveEventInfo = transformPoint(info2, this.transformPagePoint);
      frame.update(this.updatePoint, true);
    };
    this.handlePointerUp = (event2, info2) => {
      this.end();
      const { onEnd, onSessionEnd, resumeAnimation } = this.handlers;
      if (this.dragSnapToOrigin || !this.startEvent) {
        resumeAnimation && resumeAnimation();
      }
      if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;
      const panInfo = getPanInfo(
        event2.type === "pointercancel"
          ? this.lastMoveEventInfo
          : transformPoint(info2, this.transformPagePoint),
        this.history,
      );
      if (this.startEvent && onEnd) {
        onEnd(event2, panInfo);
      }
      onSessionEnd && onSessionEnd(event2, panInfo);
    };
    if (!isPrimaryPointer(event)) return;
    this.dragSnapToOrigin = dragSnapToOrigin;
    this.handlers = handlers;
    this.transformPagePoint = transformPagePoint;
    this.distanceThreshold = distanceThreshold;
    this.contextWindow = contextWindow || window;
    const info = extractEventInfo(event);
    const initialInfo = transformPoint(info, this.transformPagePoint);
    const { point } = initialInfo;
    const { timestamp } = frameData;
    this.history = [{ ...point, timestamp }];
    const { onSessionStart } = handlers;
    onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));
    this.removeListeners = pipe(
      addPointerEvent(this.contextWindow, "pointermove", this.handlePointerMove),
      addPointerEvent(this.contextWindow, "pointerup", this.handlePointerUp),
      addPointerEvent(this.contextWindow, "pointercancel", this.handlePointerUp),
    );
    if (element) {
      this.startScrollTracking(element);
    }
  }
  /**
   * Start tracking scroll on ancestors and window.
   */
  startScrollTracking(element) {
    let current = element.parentElement;
    while (current) {
      const style = getComputedStyle(current);
      if (overflowStyles.has(style.overflowX) || overflowStyles.has(style.overflowY)) {
        this.scrollPositions.set(current, {
          x: current.scrollLeft,
          y: current.scrollTop,
        });
      }
      current = current.parentElement;
    }
    this.scrollPositions.set(window, {
      x: window.scrollX,
      y: window.scrollY,
    });
    window.addEventListener("scroll", this.onElementScroll, {
      capture: true,
      passive: true,
    });
    window.addEventListener("scroll", this.onWindowScroll, {
      passive: true,
    });
    this.removeScrollListeners = () => {
      window.removeEventListener("scroll", this.onElementScroll, {
        capture: true,
      });
      window.removeEventListener("scroll", this.onWindowScroll);
    };
  }
  /**
   * Handle scroll compensation during drag.
   *
   * For element scroll: adjusts history origin since pageX/pageY doesn't change.
   * For window scroll: adjusts lastMoveEventInfo since pageX/pageY would change.
   */
  handleScroll(target) {
    const initial = this.scrollPositions.get(target);
    if (!initial) return;
    const isWindow = target === window;
    const current = isWindow
      ? { x: window.scrollX, y: window.scrollY }
      : {
          x: target.scrollLeft,
          y: target.scrollTop,
        };
    const delta = { x: current.x - initial.x, y: current.y - initial.y };
    if (delta.x === 0 && delta.y === 0) return;
    if (isWindow) {
      if (this.lastMoveEventInfo) {
        this.lastMoveEventInfo.point.x += delta.x;
        this.lastMoveEventInfo.point.y += delta.y;
      }
    } else {
      if (this.history.length > 0) {
        this.history[0].x -= delta.x;
        this.history[0].y -= delta.y;
      }
    }
    this.scrollPositions.set(target, current);
    frame.update(this.updatePoint, true);
  }
  updateHandlers(handlers) {
    this.handlers = handlers;
  }
  end() {
    this.removeListeners && this.removeListeners();
    this.removeScrollListeners && this.removeScrollListeners();
    this.scrollPositions.clear();
    cancelFrame(this.updatePoint);
  }
}
function transformPoint(info, transformPagePoint) {
  return transformPagePoint ? { point: transformPagePoint(info.point) } : info;
}
function subtractPoint(a, b) {
  return { x: a.x - b.x, y: a.y - b.y };
}
function getPanInfo({ point }, history) {
  return {
    point,
    delta: subtractPoint(point, lastDevicePoint(history)),
    offset: subtractPoint(point, startDevicePoint(history)),
    velocity: getVelocity(history, 0.1),
  };
}
function startDevicePoint(history) {
  return history[0];
}
function lastDevicePoint(history) {
  return history[history.length - 1];
}
function getVelocity(history, timeDelta) {
  if (history.length < 2) {
    return { x: 0, y: 0 };
  }
  let i = history.length - 1;
  let timestampedPoint = null;
  const lastPoint = lastDevicePoint(history);
  while (i >= 0) {
    timestampedPoint = history[i];
    if (
      lastPoint.timestamp - timestampedPoint.timestamp >
      /* @__PURE__ */ secondsToMilliseconds(timeDelta)
    ) {
      break;
    }
    i--;
  }
  if (!timestampedPoint) {
    return { x: 0, y: 0 };
  }
  const time2 = /* @__PURE__ */ millisecondsToSeconds(
    lastPoint.timestamp - timestampedPoint.timestamp,
  );
  if (time2 === 0) {
    return { x: 0, y: 0 };
  }
  const currentVelocity = {
    x: (lastPoint.x - timestampedPoint.x) / time2,
    y: (lastPoint.y - timestampedPoint.y) / time2,
  };
  if (currentVelocity.x === Infinity) {
    currentVelocity.x = 0;
  }
  if (currentVelocity.y === Infinity) {
    currentVelocity.y = 0;
  }
  return currentVelocity;
}
function applyConstraints(point, { min: min2, max: max2 }, elastic) {
  if (min2 !== void 0 && point < min2) {
    point = elastic ? mixNumber$1(min2, point, elastic.min) : Math.max(point, min2);
  } else if (max2 !== void 0 && point > max2) {
    point = elastic ? mixNumber$1(max2, point, elastic.max) : Math.min(point, max2);
  }
  return point;
}
function calcRelativeAxisConstraints(axis, min2, max2) {
  return {
    min: min2 !== void 0 ? axis.min + min2 : void 0,
    max: max2 !== void 0 ? axis.max + max2 - (axis.max - axis.min) : void 0,
  };
}
function calcRelativeConstraints(layoutBox, { top, left, bottom, right }) {
  return {
    x: calcRelativeAxisConstraints(layoutBox.x, left, right),
    y: calcRelativeAxisConstraints(layoutBox.y, top, bottom),
  };
}
function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {
  let min2 = constraintsAxis.min - layoutAxis.min;
  let max2 = constraintsAxis.max - layoutAxis.max;
  if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {
    [min2, max2] = [max2, min2];
  }
  return { min: min2, max: max2 };
}
function calcViewportConstraints(layoutBox, constraintsBox) {
  return {
    x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),
    y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y),
  };
}
function calcOrigin(source, target) {
  let origin = 0.5;
  const sourceLength = calcLength(source);
  const targetLength = calcLength(target);
  if (targetLength > sourceLength) {
    origin = /* @__PURE__ */ progress(target.min, target.max - sourceLength, source.min);
  } else if (sourceLength > targetLength) {
    origin = /* @__PURE__ */ progress(source.min, source.max - targetLength, target.min);
  }
  return clamp$2(0, 1, origin);
}
function rebaseAxisConstraints(layout2, constraints) {
  const relativeConstraints = {};
  if (constraints.min !== void 0) {
    relativeConstraints.min = constraints.min - layout2.min;
  }
  if (constraints.max !== void 0) {
    relativeConstraints.max = constraints.max - layout2.min;
  }
  return relativeConstraints;
}
const defaultElastic = 0.35;
function resolveDragElastic(dragElastic = defaultElastic) {
  if (dragElastic === false) {
    dragElastic = 0;
  } else if (dragElastic === true) {
    dragElastic = defaultElastic;
  }
  return {
    x: resolveAxisElastic(dragElastic, "left", "right"),
    y: resolveAxisElastic(dragElastic, "top", "bottom"),
  };
}
function resolveAxisElastic(dragElastic, minLabel, maxLabel) {
  return {
    min: resolvePointElastic(dragElastic, minLabel),
    max: resolvePointElastic(dragElastic, maxLabel),
  };
}
function resolvePointElastic(dragElastic, label) {
  return typeof dragElastic === "number" ? dragElastic : dragElastic[label] || 0;
}
const elementDragControls = /* @__PURE__ */ new WeakMap();
class VisualElementDragControls {
  constructor(visualElement) {
    this.openDragLock = null;
    this.isDragging = false;
    this.currentDirection = null;
    this.originPoint = { x: 0, y: 0 };
    this.constraints = false;
    this.hasMutatedConstraints = false;
    this.elastic = createBox();
    this.latestPointerEvent = null;
    this.latestPanInfo = null;
    this.visualElement = visualElement;
  }
  start(originEvent, { snapToCursor = false, distanceThreshold } = {}) {
    const { presenceContext } = this.visualElement;
    if (presenceContext && presenceContext.isPresent === false) return;
    const onSessionStart = (event) => {
      if (snapToCursor) {
        this.stopAnimation();
        this.snapToCursor(extractEventInfo(event).point);
      } else {
        this.pauseAnimation();
      }
    };
    const onStart = (event, info) => {
      this.stopAnimation();
      const { drag: drag2, dragPropagation, onDragStart } = this.getProps();
      if (drag2 && !dragPropagation) {
        if (this.openDragLock) this.openDragLock();
        this.openDragLock = setDragLock(drag2);
        if (!this.openDragLock) return;
      }
      this.latestPointerEvent = event;
      this.latestPanInfo = info;
      this.isDragging = true;
      this.currentDirection = null;
      this.resolveConstraints();
      if (this.visualElement.projection) {
        this.visualElement.projection.isAnimationBlocked = true;
        this.visualElement.projection.target = void 0;
      }
      eachAxis((axis) => {
        let current = this.getAxisMotionValue(axis).get() || 0;
        if (percent.test(current)) {
          const { projection } = this.visualElement;
          if (projection && projection.layout) {
            const measuredAxis = projection.layout.layoutBox[axis];
            if (measuredAxis) {
              const length = calcLength(measuredAxis);
              current = length * (parseFloat(current) / 100);
            }
          }
        }
        this.originPoint[axis] = current;
      });
      if (onDragStart) {
        frame.postRender(() => onDragStart(event, info));
      }
      addValueToWillChange(this.visualElement, "transform");
      const { animationState } = this.visualElement;
      animationState && animationState.setActive("whileDrag", true);
    };
    const onMove = (event, info) => {
      this.latestPointerEvent = event;
      this.latestPanInfo = info;
      const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag } = this.getProps();
      if (!dragPropagation && !this.openDragLock) return;
      const { offset: offset2 } = info;
      if (dragDirectionLock && this.currentDirection === null) {
        this.currentDirection = getCurrentDirection(offset2);
        if (this.currentDirection !== null) {
          onDirectionLock && onDirectionLock(this.currentDirection);
        }
        return;
      }
      this.updateAxis("x", info.point, offset2);
      this.updateAxis("y", info.point, offset2);
      this.visualElement.render();
      onDrag && onDrag(event, info);
    };
    const onSessionEnd = (event, info) => {
      this.latestPointerEvent = event;
      this.latestPanInfo = info;
      this.stop(event, info);
      this.latestPointerEvent = null;
      this.latestPanInfo = null;
    };
    const resumeAnimation = () =>
      eachAxis((axis) => {
        var _a2;
        return (
          this.getAnimationState(axis) === "paused" &&
          ((_a2 = this.getAxisMotionValue(axis).animation) == null ? void 0 : _a2.play())
        );
      });
    const { dragSnapToOrigin } = this.getProps();
    this.panSession = new PanSession(
      originEvent,
      {
        onSessionStart,
        onStart,
        onMove,
        onSessionEnd,
        resumeAnimation,
      },
      {
        transformPagePoint: this.visualElement.getTransformPagePoint(),
        dragSnapToOrigin,
        distanceThreshold,
        contextWindow: getContextWindow(this.visualElement),
        element: this.visualElement.current,
      },
    );
  }
  /**
   * @internal
   */
  stop(event, panInfo) {
    const finalEvent = event || this.latestPointerEvent;
    const finalPanInfo = panInfo || this.latestPanInfo;
    const isDragging2 = this.isDragging;
    this.cancel();
    if (!isDragging2 || !finalPanInfo || !finalEvent) return;
    const { velocity } = finalPanInfo;
    this.startAnimation(velocity);
    const { onDragEnd } = this.getProps();
    if (onDragEnd) {
      frame.postRender(() => onDragEnd(finalEvent, finalPanInfo));
    }
  }
  /**
   * @internal
   */
  cancel() {
    this.isDragging = false;
    const { projection, animationState } = this.visualElement;
    if (projection) {
      projection.isAnimationBlocked = false;
    }
    this.endPanSession();
    const { dragPropagation } = this.getProps();
    if (!dragPropagation && this.openDragLock) {
      this.openDragLock();
      this.openDragLock = null;
    }
    animationState && animationState.setActive("whileDrag", false);
  }
  /**
   * Clean up the pan session without modifying other drag state.
   * This is used during unmount to ensure event listeners are removed
   * without affecting projection animations or drag locks.
   * @internal
   */
  endPanSession() {
    this.panSession && this.panSession.end();
    this.panSession = void 0;
  }
  updateAxis(axis, _point, offset2) {
    const { drag: drag2 } = this.getProps();
    if (!offset2 || !shouldDrag(axis, drag2, this.currentDirection)) return;
    const axisValue = this.getAxisMotionValue(axis);
    let next = this.originPoint[axis] + offset2[axis];
    if (this.constraints && this.constraints[axis]) {
      next = applyConstraints(next, this.constraints[axis], this.elastic[axis]);
    }
    axisValue.set(next);
  }
  resolveConstraints() {
    var _a2;
    const { dragConstraints, dragElastic } = this.getProps();
    const layout2 =
      this.visualElement.projection && !this.visualElement.projection.layout
        ? this.visualElement.projection.measure(false)
        : (_a2 = this.visualElement.projection) == null
          ? void 0
          : _a2.layout;
    const prevConstraints = this.constraints;
    if (dragConstraints && isRefObject(dragConstraints)) {
      if (!this.constraints) {
        this.constraints = this.resolveRefConstraints();
      }
    } else {
      if (dragConstraints && layout2) {
        this.constraints = calcRelativeConstraints(layout2.layoutBox, dragConstraints);
      } else {
        this.constraints = false;
      }
    }
    this.elastic = resolveDragElastic(dragElastic);
    if (
      prevConstraints !== this.constraints &&
      layout2 &&
      this.constraints &&
      !this.hasMutatedConstraints
    ) {
      eachAxis((axis) => {
        if (this.constraints !== false && this.getAxisMotionValue(axis)) {
          this.constraints[axis] = rebaseAxisConstraints(
            layout2.layoutBox[axis],
            this.constraints[axis],
          );
        }
      });
    }
  }
  resolveRefConstraints() {
    const { dragConstraints: constraints, onMeasureDragConstraints } = this.getProps();
    if (!constraints || !isRefObject(constraints)) return false;
    const constraintsElement = constraints.current;
    invariant(
      constraintsElement !== null,
      "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.",
      "drag-constraints-ref",
    );
    const { projection } = this.visualElement;
    if (!projection || !projection.layout) return false;
    const constraintsBox = measurePageBox(
      constraintsElement,
      projection.root,
      this.visualElement.getTransformPagePoint(),
    );
    let measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);
    if (onMeasureDragConstraints) {
      const userConstraints = onMeasureDragConstraints(
        convertBoxToBoundingBox(measuredConstraints),
      );
      this.hasMutatedConstraints = !!userConstraints;
      if (userConstraints) {
        measuredConstraints = convertBoundingBoxToBox(userConstraints);
      }
    }
    return measuredConstraints;
  }
  startAnimation(velocity) {
    const {
      drag: drag2,
      dragMomentum,
      dragElastic,
      dragTransition,
      dragSnapToOrigin,
      onDragTransitionEnd,
    } = this.getProps();
    const constraints = this.constraints || {};
    const momentumAnimations = eachAxis((axis) => {
      if (!shouldDrag(axis, drag2, this.currentDirection)) {
        return;
      }
      let transition = (constraints && constraints[axis]) || {};
      if (dragSnapToOrigin) transition = { min: 0, max: 0 };
      const bounceStiffness = dragElastic ? 200 : 1e6;
      const bounceDamping = dragElastic ? 40 : 1e7;
      const inertia2 = {
        type: "inertia",
        velocity: dragMomentum ? velocity[axis] : 0,
        bounceStiffness,
        bounceDamping,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...dragTransition,
        ...transition,
      };
      return this.startAxisValueAnimation(axis, inertia2);
    });
    return Promise.all(momentumAnimations).then(onDragTransitionEnd);
  }
  startAxisValueAnimation(axis, transition) {
    const axisValue = this.getAxisMotionValue(axis);
    addValueToWillChange(this.visualElement, axis);
    return axisValue.start(
      animateMotionValue(axis, axisValue, 0, transition, this.visualElement, false),
    );
  }
  stopAnimation() {
    eachAxis((axis) => this.getAxisMotionValue(axis).stop());
  }
  pauseAnimation() {
    eachAxis((axis) => {
      var _a2;
      return (_a2 = this.getAxisMotionValue(axis).animation) == null ? void 0 : _a2.pause();
    });
  }
  getAnimationState(axis) {
    var _a2;
    return (_a2 = this.getAxisMotionValue(axis).animation) == null ? void 0 : _a2.state;
  }
  /**
   * Drag works differently depending on which props are provided.
   *
   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
   * - Otherwise, we apply the delta to the x/y motion values.
   */
  getAxisMotionValue(axis) {
    const dragKey = `_drag${axis.toUpperCase()}`;
    const props = this.visualElement.getProps();
    const externalMotionValue = props[dragKey];
    return externalMotionValue
      ? externalMotionValue
      : this.visualElement.getValue(axis, (props.initial ? props.initial[axis] : void 0) || 0);
  }
  snapToCursor(point) {
    eachAxis((axis) => {
      const { drag: drag2 } = this.getProps();
      if (!shouldDrag(axis, drag2, this.currentDirection)) return;
      const { projection } = this.visualElement;
      const axisValue = this.getAxisMotionValue(axis);
      if (projection && projection.layout) {
        const { min: min2, max: max2 } = projection.layout.layoutBox[axis];
        const current = axisValue.get() || 0;
        axisValue.set(point[axis] - mixNumber$1(min2, max2, 0.5) + current);
      }
    });
  }
  /**
   * When the viewport resizes we want to check if the measured constraints
   * have changed and, if so, reposition the element within those new constraints
   * relative to where it was before the resize.
   */
  scalePositionWithinConstraints() {
    if (!this.visualElement.current) return;
    const { drag: drag2, dragConstraints } = this.getProps();
    const { projection } = this.visualElement;
    if (!isRefObject(dragConstraints) || !projection || !this.constraints) return;
    this.stopAnimation();
    const boxProgress = { x: 0, y: 0 };
    eachAxis((axis) => {
      const axisValue = this.getAxisMotionValue(axis);
      if (axisValue && this.constraints !== false) {
        const latest = axisValue.get();
        boxProgress[axis] = calcOrigin({ min: latest, max: latest }, this.constraints[axis]);
      }
    });
    const { transformTemplate } = this.visualElement.getProps();
    this.visualElement.current.style.transform = transformTemplate
      ? transformTemplate({}, "")
      : "none";
    projection.root && projection.root.updateScroll();
    projection.updateLayout();
    this.resolveConstraints();
    eachAxis((axis) => {
      if (!shouldDrag(axis, drag2, null)) return;
      const axisValue = this.getAxisMotionValue(axis);
      const { min: min2, max: max2 } = this.constraints[axis];
      axisValue.set(mixNumber$1(min2, max2, boxProgress[axis]));
    });
  }
  addListeners() {
    if (!this.visualElement.current) return;
    elementDragControls.set(this.visualElement, this);
    const element = this.visualElement.current;
    const stopPointerListener = addPointerEvent(element, "pointerdown", (event) => {
      const { drag: drag2, dragListener = true } = this.getProps();
      const target = event.target;
      const isClickingKeyboardAccessibleChild =
        target !== element && isElementKeyboardAccessible(target);
      if (drag2 && dragListener && !isClickingKeyboardAccessibleChild) {
        this.start(event);
      }
    });
    const measureDragConstraints = () => {
      const { dragConstraints } = this.getProps();
      if (isRefObject(dragConstraints) && dragConstraints.current) {
        this.constraints = this.resolveRefConstraints();
      }
    };
    const { projection } = this.visualElement;
    const stopMeasureLayoutListener = projection.addEventListener(
      "measure",
      measureDragConstraints,
    );
    if (projection && !projection.layout) {
      projection.root && projection.root.updateScroll();
      projection.updateLayout();
    }
    frame.read(measureDragConstraints);
    const stopResizeListener = addDomEvent(window, "resize", () =>
      this.scalePositionWithinConstraints(),
    );
    const stopLayoutUpdateListener = projection.addEventListener(
      "didUpdate",
      ({ delta, hasLayoutChanged }) => {
        if (this.isDragging && hasLayoutChanged) {
          eachAxis((axis) => {
            const motionValue2 = this.getAxisMotionValue(axis);
            if (!motionValue2) return;
            this.originPoint[axis] += delta[axis].translate;
            motionValue2.set(motionValue2.get() + delta[axis].translate);
          });
          this.visualElement.render();
        }
      },
    );
    return () => {
      stopResizeListener();
      stopPointerListener();
      stopMeasureLayoutListener();
      stopLayoutUpdateListener && stopLayoutUpdateListener();
    };
  }
  getProps() {
    const props = this.visualElement.getProps();
    const {
      drag: drag2 = false,
      dragDirectionLock = false,
      dragPropagation = false,
      dragConstraints = false,
      dragElastic = defaultElastic,
      dragMomentum = true,
    } = props;
    return {
      ...props,
      drag: drag2,
      dragDirectionLock,
      dragPropagation,
      dragConstraints,
      dragElastic,
      dragMomentum,
    };
  }
}
function shouldDrag(direction, drag2, currentDirection) {
  return (
    (drag2 === true || drag2 === direction) &&
    (currentDirection === null || currentDirection === direction)
  );
}
function getCurrentDirection(offset2, lockThreshold = 10) {
  let direction = null;
  if (Math.abs(offset2.y) > lockThreshold) {
    direction = "y";
  } else if (Math.abs(offset2.x) > lockThreshold) {
    direction = "x";
  }
  return direction;
}
class DragGesture extends Feature {
  constructor(node) {
    super(node);
    this.removeGroupControls = noop$2;
    this.removeListeners = noop$2;
    this.controls = new VisualElementDragControls(node);
  }
  mount() {
    const { dragControls } = this.node.getProps();
    if (dragControls) {
      this.removeGroupControls = dragControls.subscribe(this.controls);
    }
    this.removeListeners = this.controls.addListeners() || noop$2;
  }
  update() {
    const { dragControls } = this.node.getProps();
    const { dragControls: prevDragControls } = this.node.prevProps || {};
    if (dragControls !== prevDragControls) {
      this.removeGroupControls();
      if (dragControls) {
        this.removeGroupControls = dragControls.subscribe(this.controls);
      }
    }
  }
  unmount() {
    this.removeGroupControls();
    this.removeListeners();
    this.controls.endPanSession();
  }
}
const asyncHandler = (handler) => (event, info) => {
  if (handler) {
    frame.postRender(() => handler(event, info));
  }
};
class PanGesture extends Feature {
  constructor() {
    super(...arguments);
    this.removePointerDownListener = noop$2;
  }
  onPointerDown(pointerDownEvent) {
    this.session = new PanSession(pointerDownEvent, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: getContextWindow(this.node),
    });
  }
  createPanHandlers() {
    const { onPanSessionStart, onPanStart, onPan, onPanEnd } = this.node.getProps();
    return {
      onSessionStart: asyncHandler(onPanSessionStart),
      onStart: asyncHandler(onPanStart),
      onMove: onPan,
      onEnd: (event, info) => {
        delete this.session;
        if (onPanEnd) {
          frame.postRender(() => onPanEnd(event, info));
        }
      },
    };
  }
  mount() {
    this.removePointerDownListener = addPointerEvent(this.node.current, "pointerdown", (event) =>
      this.onPointerDown(event),
    );
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    this.removePointerDownListener();
    this.session && this.session.end();
  }
}
let hasTakenAnySnapshot = false;
class MeasureLayoutWithContext extends reactExports.Component {
  /**
   * This only mounts projection nodes for components that
   * need measuring, we might want to do it for all components
   * in order to incorporate transforms
   */
  componentDidMount() {
    const { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props;
    const { projection } = visualElement;
    if (projection) {
      if (layoutGroup.group) layoutGroup.group.add(projection);
      if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {
        switchLayoutGroup.register(projection);
      }
      if (hasTakenAnySnapshot) {
        projection.root.didUpdate();
      }
      projection.addEventListener("animationComplete", () => {
        this.safeToRemove();
      });
      projection.setOptions({
        ...projection.options,
        onExitComplete: () => this.safeToRemove(),
      });
    }
    globalProjectionState.hasEverUpdated = true;
  }
  getSnapshotBeforeUpdate(prevProps) {
    const { layoutDependency, visualElement, drag: drag2, isPresent } = this.props;
    const { projection } = visualElement;
    if (!projection) return null;
    projection.isPresent = isPresent;
    hasTakenAnySnapshot = true;
    if (
      drag2 ||
      prevProps.layoutDependency !== layoutDependency ||
      layoutDependency === void 0 ||
      prevProps.isPresent !== isPresent
    ) {
      projection.willUpdate();
    } else {
      this.safeToRemove();
    }
    if (prevProps.isPresent !== isPresent) {
      if (isPresent) {
        projection.promote();
      } else if (!projection.relegate()) {
        frame.postRender(() => {
          const stack = projection.getStack();
          if (!stack || !stack.members.length) {
            this.safeToRemove();
          }
        });
      }
    }
    return null;
  }
  componentDidUpdate() {
    const { projection } = this.props.visualElement;
    if (projection) {
      projection.root.didUpdate();
      microtask.postRender(() => {
        if (!projection.currentAnimation && projection.isLead()) {
          this.safeToRemove();
        }
      });
    }
  }
  componentWillUnmount() {
    const { visualElement, layoutGroup, switchLayoutGroup: promoteContext } = this.props;
    const { projection } = visualElement;
    hasTakenAnySnapshot = true;
    if (projection) {
      projection.scheduleCheckAfterUnmount();
      if (layoutGroup && layoutGroup.group) layoutGroup.group.remove(projection);
      if (promoteContext && promoteContext.deregister) promoteContext.deregister(projection);
    }
  }
  safeToRemove() {
    const { safeToRemove } = this.props;
    safeToRemove && safeToRemove();
  }
  render() {
    return null;
  }
}
function MeasureLayout(props) {
  const [isPresent, safeToRemove] = usePresence();
  const layoutGroup = reactExports.useContext(LayoutGroupContext);
  return jsxRuntimeExports.jsx(MeasureLayoutWithContext, {
    ...props,
    layoutGroup,
    switchLayoutGroup: reactExports.useContext(SwitchLayoutGroupContext),
    isPresent,
    safeToRemove,
  });
}
const drag = {
  pan: {
    Feature: PanGesture,
  },
  drag: {
    Feature: DragGesture,
    ProjectionNode: HTMLProjectionNode,
    MeasureLayout,
  },
};
function handleHoverEvent(node, event, lifecycle) {
  const { props } = node;
  if (node.animationState && props.whileHover) {
    node.animationState.setActive("whileHover", lifecycle === "Start");
  }
  const eventName = "onHover" + lifecycle;
  const callback = props[eventName];
  if (callback) {
    frame.postRender(() => callback(event, extractEventInfo(event)));
  }
}
class HoverGesture extends Feature {
  mount() {
    const { current } = this.node;
    if (!current) return;
    this.unmount = hover(current, (_element, startEvent) => {
      handleHoverEvent(this.node, startEvent, "Start");
      return (endEvent) => handleHoverEvent(this.node, endEvent, "End");
    });
  }
  unmount() {}
}
class FocusGesture extends Feature {
  constructor() {
    super(...arguments);
    this.isActive = false;
  }
  onFocus() {
    let isFocusVisible = false;
    try {
      isFocusVisible = this.node.current.matches(":focus-visible");
    } catch (e) {
      isFocusVisible = true;
    }
    if (!isFocusVisible || !this.node.animationState) return;
    this.node.animationState.setActive("whileFocus", true);
    this.isActive = true;
  }
  onBlur() {
    if (!this.isActive || !this.node.animationState) return;
    this.node.animationState.setActive("whileFocus", false);
    this.isActive = false;
  }
  mount() {
    this.unmount = pipe(
      addDomEvent(this.node.current, "focus", () => this.onFocus()),
      addDomEvent(this.node.current, "blur", () => this.onBlur()),
    );
  }
  unmount() {}
}
function handlePressEvent(node, event, lifecycle) {
  const { props } = node;
  if (node.current instanceof HTMLButtonElement && node.current.disabled) {
    return;
  }
  if (node.animationState && props.whileTap) {
    node.animationState.setActive("whileTap", lifecycle === "Start");
  }
  const eventName = "onTap" + (lifecycle === "End" ? "" : lifecycle);
  const callback = props[eventName];
  if (callback) {
    frame.postRender(() => callback(event, extractEventInfo(event)));
  }
}
class PressGesture extends Feature {
  mount() {
    const { current } = this.node;
    if (!current) return;
    this.unmount = press(
      current,
      (_element, startEvent) => {
        handlePressEvent(this.node, startEvent, "Start");
        return (endEvent, { success }) =>
          handlePressEvent(this.node, endEvent, success ? "End" : "Cancel");
      },
      { useGlobalTarget: this.node.props.globalTapTarget },
    );
  }
  unmount() {}
}
const observerCallbacks = /* @__PURE__ */ new WeakMap();
const observers = /* @__PURE__ */ new WeakMap();
const fireObserverCallback = (entry) => {
  const callback = observerCallbacks.get(entry.target);
  callback && callback(entry);
};
const fireAllObserverCallbacks = (entries) => {
  entries.forEach(fireObserverCallback);
};
function initIntersectionObserver({ root, ...options }) {
  const lookupRoot = root || document;
  if (!observers.has(lookupRoot)) {
    observers.set(lookupRoot, {});
  }
  const rootObservers = observers.get(lookupRoot);
  const key = JSON.stringify(options);
  if (!rootObservers[key]) {
    rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, { root, ...options });
  }
  return rootObservers[key];
}
function observeIntersection(element, options, callback) {
  const rootInteresectionObserver = initIntersectionObserver(options);
  observerCallbacks.set(element, callback);
  rootInteresectionObserver.observe(element);
  return () => {
    observerCallbacks.delete(element);
    rootInteresectionObserver.unobserve(element);
  };
}
const thresholdNames = {
  some: 0,
  all: 1,
};
class InViewFeature extends Feature {
  constructor() {
    super(...arguments);
    this.hasEnteredView = false;
    this.isInView = false;
  }
  startObserver() {
    this.unmount();
    const { viewport = {} } = this.node.getProps();
    const { root, margin: rootMargin, amount = "some", once } = viewport;
    const options = {
      root: root ? root.current : void 0,
      rootMargin,
      threshold: typeof amount === "number" ? amount : thresholdNames[amount],
    };
    const onIntersectionUpdate = (entry) => {
      const { isIntersecting } = entry;
      if (this.isInView === isIntersecting) return;
      this.isInView = isIntersecting;
      if (once && !isIntersecting && this.hasEnteredView) {
        return;
      } else if (isIntersecting) {
        this.hasEnteredView = true;
      }
      if (this.node.animationState) {
        this.node.animationState.setActive("whileInView", isIntersecting);
      }
      const { onViewportEnter, onViewportLeave } = this.node.getProps();
      const callback = isIntersecting ? onViewportEnter : onViewportLeave;
      callback && callback(entry);
    };
    return observeIntersection(this.node.current, options, onIntersectionUpdate);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver === "undefined") return;
    const { props, prevProps } = this.node;
    const hasOptionsChanged = ["amount", "margin", "root"].some(
      hasViewportOptionChanged(props, prevProps),
    );
    if (hasOptionsChanged) {
      this.startObserver();
    }
  }
  unmount() {}
}
function hasViewportOptionChanged({ viewport = {} }, { viewport: prevViewport = {} } = {}) {
  return (name) => viewport[name] !== prevViewport[name];
}
const gestureAnimations = {
  inView: {
    Feature: InViewFeature,
  },
  tap: {
    Feature: PressGesture,
  },
  focus: {
    Feature: FocusGesture,
  },
  hover: {
    Feature: HoverGesture,
  },
};
const layout = {
  layout: {
    ProjectionNode: HTMLProjectionNode,
    MeasureLayout,
  },
};
const featureBundle = {
  ...animations,
  ...gestureAnimations,
  ...drag,
  ...layout,
};
const motion = /* @__PURE__ */ createMotionProxy(featureBundle, createDomVisualElement);
function formatErrorMessage(code, ...args) {
  const url = new URL("https://base-ui.com/production-error");
  url.searchParams.set("code", code.toString());
  args.forEach((arg) => url.searchParams.append("args[]", arg));
  return `Base UI error #${code}; visit ${url} for the full message.`;
}
const MenuPositionerContext = /* @__PURE__ */ reactExports.createContext(void 0);
function useMenuPositionerContext(optional) {
  const context = reactExports.useContext(MenuPositionerContext);
  if (context === void 0 && !optional) {
    throw new Error(formatErrorMessage(33));
  }
  return context;
}
const MenuRootContext = /* @__PURE__ */ reactExports.createContext(void 0);
function useMenuRootContext(optional) {
  const context = reactExports.useContext(MenuRootContext);
  if (context === void 0 && !optional) {
    throw new Error(formatErrorMessage(36));
  }
  return context;
}
const UNINITIALIZED = {};
function useRefWithInit(init, initArg) {
  const ref = reactExports.useRef(UNINITIALIZED);
  if (ref.current === UNINITIALIZED) {
    ref.current = init(initArg);
  }
  return ref;
}
function useMergedRefs(a, b, c, d) {
  const forkRef = useRefWithInit(createForkRef).current;
  if (didChange(forkRef, a, b, c, d)) {
    update(forkRef, [a, b, c, d]);
  }
  return forkRef.callback;
}
function useMergedRefsN(refs) {
  const forkRef = useRefWithInit(createForkRef).current;
  if (didChangeN(forkRef, refs)) {
    update(forkRef, refs);
  }
  return forkRef.callback;
}
function createForkRef() {
  return {
    callback: null,
    cleanup: null,
    refs: [],
  };
}
function didChange(forkRef, a, b, c, d) {
  return (
    forkRef.refs[0] !== a || forkRef.refs[1] !== b || forkRef.refs[2] !== c || forkRef.refs[3] !== d
  );
}
function didChangeN(forkRef, newRefs) {
  return (
    forkRef.refs.length !== newRefs.length ||
    forkRef.refs.some((ref, index2) => ref !== newRefs[index2])
  );
}
function update(forkRef, refs) {
  forkRef.refs = refs;
  if (refs.every((ref) => ref == null)) {
    forkRef.callback = null;
    return;
  }
  forkRef.callback = (instance) => {
    if (forkRef.cleanup) {
      forkRef.cleanup();
      forkRef.cleanup = null;
    }
    if (instance != null) {
      const cleanupCallbacks = Array(refs.length).fill(null);
      for (let i = 0; i < refs.length; i += 1) {
        const ref = refs[i];
        if (ref == null) {
          continue;
        }
        switch (typeof ref) {
          case "function": {
            const refCleanup = ref(instance);
            if (typeof refCleanup === "function") {
              cleanupCallbacks[i] = refCleanup;
            }
            break;
          }
          case "object": {
            ref.current = instance;
            break;
          }
        }
      }
      forkRef.cleanup = () => {
        for (let i = 0; i < refs.length; i += 1) {
          const ref = refs[i];
          if (ref == null) {
            continue;
          }
          switch (typeof ref) {
            case "function": {
              const cleanupCallback = cleanupCallbacks[i];
              if (typeof cleanupCallback === "function") {
                cleanupCallback();
              } else {
                ref(null);
              }
              break;
            }
            case "object": {
              ref.current = null;
              break;
            }
          }
        }
      };
    }
  };
}
const majorVersion = parseInt(reactExports.version, 10);
function isReactVersionAtLeast(reactVersionToCheck) {
  return majorVersion >= reactVersionToCheck;
}
function getReactElementRef(element) {
  if (!(/* @__PURE__ */ reactExports.isValidElement(element))) {
    return null;
  }
  const reactElement = element;
  const propsWithRef = reactElement.props;
  return (
    (isReactVersionAtLeast(19)
      ? propsWithRef == null
        ? void 0
        : propsWithRef.ref
      : reactElement.ref) ?? null
  );
}
function mergeObjects(a, b) {
  if (a && !b) {
    return a;
  }
  if (!a && b) {
    return b;
  }
  if (a || b) {
    return {
      ...a,
      ...b,
    };
  }
  return void 0;
}
function getStateAttributesProps(state, customMapping) {
  const props = {};
  for (const key in state) {
    const value = state[key];
    if (customMapping == null ? void 0 : customMapping.hasOwnProperty(key)) {
      const customProps = customMapping[key](value);
      if (customProps != null) {
        Object.assign(props, customProps);
      }
      continue;
    }
    if (value === true) {
      props[`data-${key.toLowerCase()}`] = "";
    } else if (value) {
      props[`data-${key.toLowerCase()}`] = value.toString();
    }
  }
  return props;
}
function resolveClassName(className, state) {
  return typeof className === "function" ? className(state) : className;
}
function resolveStyle(style, state) {
  return typeof style === "function" ? style(state) : style;
}
const EMPTY_PROPS = {};
function mergeProps$1(a, b, c, d, e) {
  let merged = {
    ...resolvePropsGetter(a, EMPTY_PROPS),
  };
  if (b) {
    merged = mergeOne(merged, b);
  }
  if (c) {
    merged = mergeOne(merged, c);
  }
  if (d) {
    merged = mergeOne(merged, d);
  }
  return merged;
}
function mergePropsN(props) {
  if (props.length === 0) {
    return EMPTY_PROPS;
  }
  if (props.length === 1) {
    return resolvePropsGetter(props[0], EMPTY_PROPS);
  }
  let merged = {
    ...resolvePropsGetter(props[0], EMPTY_PROPS),
  };
  for (let i = 1; i < props.length; i += 1) {
    merged = mergeOne(merged, props[i]);
  }
  return merged;
}
function mergeOne(merged, inputProps) {
  if (isPropsGetter(inputProps)) {
    return inputProps(merged);
  }
  return mutablyMergeInto(merged, inputProps);
}
function mutablyMergeInto(mergedProps, externalProps) {
  if (!externalProps) {
    return mergedProps;
  }
  for (const propName in externalProps) {
    const externalPropValue = externalProps[propName];
    switch (propName) {
      case "style": {
        mergedProps[propName] = mergeObjects(mergedProps.style, externalPropValue);
        break;
      }
      case "className": {
        mergedProps[propName] = mergeClassNames(mergedProps.className, externalPropValue);
        break;
      }
      default: {
        if (isEventHandler(propName, externalPropValue)) {
          mergedProps[propName] = mergeEventHandlers(mergedProps[propName], externalPropValue);
        } else {
          mergedProps[propName] = externalPropValue;
        }
      }
    }
  }
  return mergedProps;
}
function isEventHandler(key, value) {
  const code0 = key.charCodeAt(0);
  const code1 = key.charCodeAt(1);
  const code2 = key.charCodeAt(2);
  return (
    code0 === 111 &&
    code1 === 110 &&
    code2 >= 65 &&
    code2 <= 90 &&
    (typeof value === "function" || typeof value === "undefined")
  );
}
function isPropsGetter(inputProps) {
  return typeof inputProps === "function";
}
function resolvePropsGetter(inputProps, previousProps) {
  if (isPropsGetter(inputProps)) {
    return inputProps(previousProps);
  }
  return inputProps ?? EMPTY_PROPS;
}
function mergeEventHandlers(ourHandler, theirHandler) {
  if (!theirHandler) {
    return ourHandler;
  }
  if (!ourHandler) {
    return theirHandler;
  }
  return (event) => {
    if (isSyntheticEvent(event)) {
      const baseUIEvent = event;
      makeEventPreventable(baseUIEvent);
      const result2 = theirHandler(baseUIEvent);
      if (!baseUIEvent.baseUIHandlerPrevented) {
        ourHandler == null ? void 0 : ourHandler(baseUIEvent);
      }
      return result2;
    }
    const result = theirHandler(event);
    ourHandler == null ? void 0 : ourHandler(event);
    return result;
  };
}
function makeEventPreventable(event) {
  event.preventBaseUIHandler = () => {
    event.baseUIHandlerPrevented = true;
  };
  return event;
}
function mergeClassNames(ourClassName, theirClassName) {
  if (theirClassName) {
    if (ourClassName) {
      return theirClassName + " " + ourClassName;
    }
    return theirClassName;
  }
  return ourClassName;
}
function isSyntheticEvent(event) {
  return event != null && typeof event === "object" && "nativeEvent" in event;
}
function NOOP() {}
const EMPTY_ARRAY$1 = Object.freeze([]);
const EMPTY_OBJECT = Object.freeze({});
const TYPEAHEAD_RESET_MS = 500;
const PATIENT_CLICK_THRESHOLD = 500;
const DISABLED_TRANSITIONS_STYLE = {
  style: {
    transition: "none",
  },
};
const CLICK_TRIGGER_IDENTIFIER = "data-base-ui-click-trigger";
const DROPDOWN_COLLISION_AVOIDANCE = {
  fallbackAxisSide: "none",
};
const POPUP_COLLISION_AVOIDANCE = {
  fallbackAxisSide: "end",
};
const ownerVisuallyHidden = {
  clipPath: "inset(50%)",
  position: "fixed",
  top: 0,
  left: 0,
};
function useRenderElement(element, componentProps, params = {}) {
  const renderProp = componentProps.render;
  const outProps = useRenderElementProps(componentProps, params);
  if (params.enabled === false) {
    return null;
  }
  const state = params.state ?? EMPTY_OBJECT;
  return evaluateRenderProp(element, renderProp, outProps, state);
}
function useRenderElementProps(componentProps, params = {}) {
  const { className: classNameProp, style: styleProp, render: renderProp } = componentProps;
  const {
    state = EMPTY_OBJECT,
    ref,
    props,
    stateAttributesMapping: stateAttributesMapping2,
    enabled = true,
  } = params;
  const className = enabled ? resolveClassName(classNameProp, state) : void 0;
  const style = enabled ? resolveStyle(styleProp, state) : void 0;
  const stateProps = enabled
    ? getStateAttributesProps(state, stateAttributesMapping2)
    : EMPTY_OBJECT;
  const outProps = enabled
    ? (mergeObjects(stateProps, Array.isArray(props) ? mergePropsN(props) : props) ?? EMPTY_OBJECT)
    : EMPTY_OBJECT;
  if (typeof document !== "undefined") {
    if (!enabled) {
      useMergedRefs(null, null);
    } else if (Array.isArray(ref)) {
      outProps.ref = useMergedRefsN([outProps.ref, getReactElementRef(renderProp), ...ref]);
    } else {
      outProps.ref = useMergedRefs(outProps.ref, getReactElementRef(renderProp), ref);
    }
  }
  if (!enabled) {
    return EMPTY_OBJECT;
  }
  if (className !== void 0) {
    outProps.className = mergeClassNames(outProps.className, className);
  }
  if (style !== void 0) {
    outProps.style = mergeObjects(outProps.style, style);
  }
  return outProps;
}
function evaluateRenderProp(element, render, props, state) {
  if (render) {
    if (typeof render === "function") {
      return render(props, state);
    }
    const mergedProps = mergeProps$1(props, render.props);
    mergedProps.ref = props.ref;
    return /* @__PURE__ */ reactExports.cloneElement(render, mergedProps);
  }
  if (element) {
    if (typeof element === "string") {
      return renderTag(element, props);
    }
  }
  throw new Error(formatErrorMessage(8));
}
function renderTag(Tag, props) {
  if (Tag === "button") {
    return /* @__PURE__ */ reactExports.createElement("button", {
      type: "button",
      ...props,
      key: props.key,
    });
  }
  if (Tag === "img") {
    return /* @__PURE__ */ reactExports.createElement("img", {
      alt: "",
      ...props,
      key: props.key,
    });
  }
  return /* @__PURE__ */ reactExports.createElement(Tag, props);
}
let TransitionStatusDataAttributes = /* @__PURE__ */ (function (TransitionStatusDataAttributes2) {
  TransitionStatusDataAttributes2["startingStyle"] = "data-starting-style";
  TransitionStatusDataAttributes2["endingStyle"] = "data-ending-style";
  return TransitionStatusDataAttributes2;
})({});
const STARTING_HOOK = {
  [TransitionStatusDataAttributes.startingStyle]: "",
};
const ENDING_HOOK = {
  [TransitionStatusDataAttributes.endingStyle]: "",
};
const transitionStatusMapping = {
  transitionStatus(value) {
    if (value === "starting") {
      return STARTING_HOOK;
    }
    if (value === "ending") {
      return ENDING_HOOK;
    }
    return null;
  },
};
let CommonPopupDataAttributes = (function (CommonPopupDataAttributes2) {
  CommonPopupDataAttributes2["open"] = "data-open";
  CommonPopupDataAttributes2["closed"] = "data-closed";
  CommonPopupDataAttributes2[
    (CommonPopupDataAttributes2["startingStyle"] = TransitionStatusDataAttributes.startingStyle)
  ] = "startingStyle";
  CommonPopupDataAttributes2[
    (CommonPopupDataAttributes2["endingStyle"] = TransitionStatusDataAttributes.endingStyle)
  ] = "endingStyle";
  CommonPopupDataAttributes2["anchorHidden"] = "data-anchor-hidden";
  return CommonPopupDataAttributes2;
})({});
let CommonTriggerDataAttributes = /* @__PURE__ */ (function (CommonTriggerDataAttributes2) {
  CommonTriggerDataAttributes2["popupOpen"] = "data-popup-open";
  CommonTriggerDataAttributes2["pressed"] = "data-pressed";
  return CommonTriggerDataAttributes2;
})({});
const TRIGGER_HOOK = {
  [CommonTriggerDataAttributes.popupOpen]: "",
};
const PRESSABLE_TRIGGER_HOOK = {
  [CommonTriggerDataAttributes.popupOpen]: "",
  [CommonTriggerDataAttributes.pressed]: "",
};
const POPUP_OPEN_HOOK = {
  [CommonPopupDataAttributes.open]: "",
};
const POPUP_CLOSED_HOOK = {
  [CommonPopupDataAttributes.closed]: "",
};
const ANCHOR_HIDDEN_HOOK = {
  [CommonPopupDataAttributes.anchorHidden]: "",
};
const triggerOpenStateMapping = {
  open(value) {
    if (value) {
      return TRIGGER_HOOK;
    }
    return null;
  },
};
const pressableTriggerOpenStateMapping = {
  open(value) {
    if (value) {
      return PRESSABLE_TRIGGER_HOOK;
    }
    return null;
  },
};
const popupStateMapping = {
  open(value) {
    if (value) {
      return POPUP_OPEN_HOOK;
    }
    return POPUP_CLOSED_HOOK;
  },
  anchorHidden(value) {
    if (value) {
      return ANCHOR_HIDDEN_HOOK;
    }
    return null;
  },
};
const ContextMenuRootContext = /* @__PURE__ */ reactExports.createContext(void 0);
function useContextMenuRootContext(optional = true) {
  const context = reactExports.useContext(ContextMenuRootContext);
  if (context === void 0 && !optional) {
    throw new Error(formatErrorMessage(25));
  }
  return context;
}
const none = "none";
const triggerPress = "trigger-press";
const triggerHover = "trigger-hover";
const triggerFocus = "trigger-focus";
const outsidePress = "outside-press";
const itemPress = "item-press";
const focusOut = "focus-out";
const escapeKey = "escape-key";
const listNavigation = "list-navigation";
const cancelOpen = "cancel-open";
const siblingOpen = "sibling-open";
const disabled = "disabled";
const imperativeAction = "imperative-action";
const useInsertionEffect = React[`useInsertionEffect${Math.random().toFixed(1)}`.slice(0, -3)];
const useSafeInsertionEffect =
  // React 17 doesn't have useInsertionEffect.
  useInsertionEffect && // Preact replaces useInsertionEffect with useLayoutEffect and fires too late.
  useInsertionEffect !== reactExports.useLayoutEffect
    ? useInsertionEffect
    : (fn) => fn();
function useStableCallback(callback) {
  const stable = useRefWithInit(createStableCallback).current;
  stable.next = callback;
  useSafeInsertionEffect(stable.effect);
  return stable.trampoline;
}
function createStableCallback() {
  const stable = {
    next: void 0,
    callback: assertNotCalled,
    trampoline: (...args) => {
      var _a2;
      return (_a2 = stable.callback) == null ? void 0 : _a2.call(stable, ...args);
    },
    effect: () => {
      stable.callback = stable.next;
    },
  };
  return stable;
}
function assertNotCalled() {}
function useControlled({ controlled, default: defaultProp, name, state = "value" }) {
  const { current: isControlled } = reactExports.useRef(controlled !== void 0);
  const [valueState, setValue] = reactExports.useState(defaultProp);
  const value = isControlled ? controlled : valueState;
  const setValueIfUncontrolled = reactExports.useCallback((newValue) => {
    if (!isControlled) {
      setValue(newValue);
    }
  }, []);
  return [value, setValueIfUncontrolled];
}
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (
    (node == null || (_node$ownerDocument = node.ownerDocument) == null
      ? void 0
      : _node$ownerDocument.defaultView) || window
  );
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null
    ? void 0
    : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
const invalidOverflowDisplayValues = /* @__PURE__ */ new Set(["inline", "contents"]);
function isOverflowElement(element) {
  const { overflow, overflowX, overflowY, display } = getComputedStyle$1(element);
  return (
    /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) &&
    !invalidOverflowDisplayValues.has(display)
  );
}
const tableElements = /* @__PURE__ */ new Set(["table", "td", "th"]);
function isTableElement(element) {
  return tableElements.has(getNodeName(element));
}
const topLayerSelectors = [":popover-open", ":modal"];
function isTopLayer(element) {
  return topLayerSelectors.some((selector) => {
    try {
      return element.matches(selector);
    } catch (_e) {
      return false;
    }
  });
}
const transformProperties = ["transform", "translate", "scale", "rotate", "perspective"];
const willChangeValues = ["transform", "translate", "scale", "rotate", "perspective", "filter"];
const containValues = ["paint", "layout", "strict", "content"];
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit$1();
  const css = isElement(elementOrCss) ? getComputedStyle$1(elementOrCss) : elementOrCss;
  return (
    transformProperties.some((value) => (css[value] ? css[value] !== "none" : false)) ||
    (css.containerType ? css.containerType !== "normal" : false) ||
    (!webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false)) ||
    (!webkit && (css.filter ? css.filter !== "none" : false)) ||
    willChangeValues.some((value) => (css.willChange || "").includes(value)) ||
    containValues.some((value) => (css.contain || "").includes(value))
  );
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit$1() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
const lastTraversableNodeNames = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function isLastTraversableNode(node) {
  return lastTraversableNodeNames.has(getNodeName(node));
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop,
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY,
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result =
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    (isShadowRoot(node) && node.host) || // Fallback.
    getDocumentElement(node);
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody =
    scrollableAncestor ===
    ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(
      win,
      win.visualViewport || [],
      isOverflowElement(scrollableAncestor) ? scrollableAncestor : [],
      frameElement && traverseIframes ? getOverflowAncestors(frameElement) : [],
    );
  }
  return list.concat(
    scrollableAncestor,
    getOverflowAncestors(scrollableAncestor, [], traverseIframes),
  );
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}
const noop$1 = () => {};
const useIsoLayoutEffect = typeof document !== "undefined" ? reactExports.useLayoutEffect : noop$1;
const CompositeRootContext = /* @__PURE__ */ reactExports.createContext(void 0);
function useCompositeRootContext(optional = false) {
  const context = reactExports.useContext(CompositeRootContext);
  if (context === void 0 && !optional) {
    throw new Error(formatErrorMessage(16));
  }
  return context;
}
function useFocusableWhenDisabled(parameters) {
  const {
    focusableWhenDisabled,
    disabled: disabled2,
    composite = false,
    tabIndex: tabIndexProp = 0,
    isNativeButton,
  } = parameters;
  const isFocusableComposite = composite && focusableWhenDisabled !== false;
  const isNonFocusableComposite = composite && focusableWhenDisabled === false;
  const props = reactExports.useMemo(() => {
    const additionalProps = {
      // allow Tabbing away from focusableWhenDisabled elements
      onKeyDown(event) {
        if (disabled2 && focusableWhenDisabled && event.key !== "Tab") {
          event.preventDefault();
        }
      },
    };
    if (!composite) {
      additionalProps.tabIndex = tabIndexProp;
      if (!isNativeButton && disabled2) {
        additionalProps.tabIndex = focusableWhenDisabled ? tabIndexProp : -1;
      }
    }
    if (
      (isNativeButton && (focusableWhenDisabled || isFocusableComposite)) ||
      (!isNativeButton && disabled2)
    ) {
      additionalProps["aria-disabled"] = disabled2;
    }
    if (isNativeButton && (!focusableWhenDisabled || isNonFocusableComposite)) {
      additionalProps.disabled = disabled2;
    }
    return additionalProps;
  }, [
    composite,
    disabled2,
    focusableWhenDisabled,
    isFocusableComposite,
    isNonFocusableComposite,
    isNativeButton,
    tabIndexProp,
  ]);
  return {
    props,
  };
}
function useButton(parameters = {}) {
  const {
    disabled: disabled2 = false,
    focusableWhenDisabled,
    tabIndex = 0,
    native: isNativeButton = true,
  } = parameters;
  const elementRef = reactExports.useRef(null);
  const isCompositeItem = useCompositeRootContext(true) !== void 0;
  const isValidLink = useStableCallback(() => {
    const element = elementRef.current;
    return Boolean(
      (element == null ? void 0 : element.tagName) === "A" &&
      (element == null ? void 0 : element.href),
    );
  });
  const { props: focusableWhenDisabledProps } = useFocusableWhenDisabled({
    focusableWhenDisabled,
    disabled: disabled2,
    composite: isCompositeItem,
    tabIndex,
    isNativeButton,
  });
  const updateDisabled = reactExports.useCallback(() => {
    const element = elementRef.current;
    if (!isButtonElement(element)) {
      return;
    }
    if (
      isCompositeItem &&
      disabled2 &&
      focusableWhenDisabledProps.disabled === void 0 &&
      element.disabled
    ) {
      element.disabled = false;
    }
  }, [disabled2, focusableWhenDisabledProps.disabled, isCompositeItem]);
  useIsoLayoutEffect(updateDisabled, [updateDisabled]);
  const getButtonProps = reactExports.useCallback(
    (externalProps = {}) => {
      const {
        onClick: externalOnClick,
        onMouseDown: externalOnMouseDown,
        onKeyUp: externalOnKeyUp,
        onKeyDown: externalOnKeyDown,
        onPointerDown: externalOnPointerDown,
        ...otherExternalProps
      } = externalProps;
      const type = isNativeButton ? "button" : void 0;
      return mergeProps$1(
        {
          type,
          onClick(event) {
            if (disabled2) {
              event.preventDefault();
              return;
            }
            externalOnClick == null ? void 0 : externalOnClick(event);
          },
          onMouseDown(event) {
            if (!disabled2) {
              externalOnMouseDown == null ? void 0 : externalOnMouseDown(event);
            }
          },
          onKeyDown(event) {
            if (!disabled2) {
              makeEventPreventable(event);
              externalOnKeyDown == null ? void 0 : externalOnKeyDown(event);
            }
            if (event.baseUIHandlerPrevented) {
              return;
            }
            const shouldClick =
              event.target === event.currentTarget &&
              !isNativeButton &&
              !isValidLink() &&
              !disabled2;
            const isEnterKey = event.key === "Enter";
            const isSpaceKey = event.key === " ";
            if (shouldClick) {
              if (isSpaceKey || isEnterKey) {
                event.preventDefault();
              }
              if (isEnterKey) {
                externalOnClick == null ? void 0 : externalOnClick(event);
              }
            }
          },
          onKeyUp(event) {
            if (!disabled2) {
              makeEventPreventable(event);
              externalOnKeyUp == null ? void 0 : externalOnKeyUp(event);
            }
            if (event.baseUIHandlerPrevented) {
              return;
            }
            if (
              event.target === event.currentTarget &&
              !isNativeButton &&
              !disabled2 &&
              event.key === " "
            ) {
              externalOnClick == null ? void 0 : externalOnClick(event);
            }
          },
          onPointerDown(event) {
            if (disabled2) {
              event.preventDefault();
              return;
            }
            externalOnPointerDown == null ? void 0 : externalOnPointerDown(event);
          },
        },
        !isNativeButton
          ? {
              role: "button",
            }
          : void 0,
        focusableWhenDisabledProps,
        otherExternalProps,
      );
    },
    [disabled2, focusableWhenDisabledProps, isNativeButton, isValidLink],
  );
  const buttonRef = useStableCallback((element) => {
    elementRef.current = element;
    updateDisabled();
  });
  return {
    getButtonProps,
    buttonRef,
  };
}
function isButtonElement(elem) {
  return isHTMLElement(elem) && elem.tagName === "BUTTON";
}
const REGULAR_ITEM = {
  type: "regular-item",
};
function useMenuItem(params) {
  const {
    closeOnClick,
    disabled: disabled2 = false,
    highlighted,
    id: id2,
    store,
    nativeButton,
    itemMetadata,
    nodeId,
  } = params;
  const itemRef = reactExports.useRef(null);
  const contextMenuContext = useContextMenuRootContext(true);
  const isContextMenu = contextMenuContext !== void 0;
  const { events: menuEvents } = store.useState("floatingTreeRoot");
  const { getButtonProps, buttonRef } = useButton({
    disabled: disabled2,
    focusableWhenDisabled: true,
    native: nativeButton,
  });
  const getItemProps = reactExports.useCallback(
    (externalProps) => {
      return mergeProps$1(
        {
          id: id2,
          role: "menuitem",
          tabIndex: highlighted ? 0 : -1,
          onMouseMove(event) {
            if (!nodeId) {
              return;
            }
            menuEvents.emit("itemhover", {
              nodeId,
              target: event.currentTarget,
            });
          },
          onMouseEnter() {
            if (itemMetadata.type !== "submenu-trigger") {
              return;
            }
            itemMetadata.setActive();
          },
          onKeyUp(event) {
            if (event.key === " " && store.context.typingRef.current) {
              event.preventBaseUIHandler();
            }
          },
          onClick(event) {
            if (closeOnClick) {
              menuEvents.emit("close", {
                domEvent: event,
                reason: itemPress,
              });
            }
          },
          onMouseUp(event) {
            if (contextMenuContext) {
              const initialCursorPoint = contextMenuContext.initialCursorPointRef.current;
              contextMenuContext.initialCursorPointRef.current = null;
              if (
                isContextMenu &&
                initialCursorPoint &&
                Math.abs(event.clientX - initialCursorPoint.x) <= 1 &&
                Math.abs(event.clientY - initialCursorPoint.y) <= 1
              ) {
                return;
              }
            }
            if (
              itemRef.current &&
              store.context.allowMouseUpTriggerRef.current &&
              (!isContextMenu || event.button === 2)
            ) {
              if (itemMetadata.type === "regular-item") {
                itemRef.current.click();
              }
            }
          },
        },
        externalProps,
        getButtonProps,
      );
    },
    [
      id2,
      highlighted,
      getButtonProps,
      closeOnClick,
      menuEvents,
      store,
      isContextMenu,
      contextMenuContext,
      itemMetadata,
      nodeId,
    ],
  );
  const mergedRef = useMergedRefs(itemRef, buttonRef);
  return reactExports.useMemo(
    () => ({
      getItemProps,
      itemRef: mergedRef,
    }),
    [getItemProps, mergedRef],
  );
}
const CompositeListContext = /* @__PURE__ */ reactExports.createContext({
  register: () => {},
  unregister: () => {},
  subscribeMapChange: () => {
    return () => {};
  },
  elementsRef: {
    current: [],
  },
  nextIndexRef: {
    current: 0,
  },
});
function useCompositeListContext() {
  return reactExports.useContext(CompositeListContext);
}
let IndexGuessBehavior = /* @__PURE__ */ (function (IndexGuessBehavior2) {
  IndexGuessBehavior2[(IndexGuessBehavior2["None"] = 0)] = "None";
  IndexGuessBehavior2[(IndexGuessBehavior2["GuessFromOrder"] = 1)] = "GuessFromOrder";
  return IndexGuessBehavior2;
})({});
function useCompositeListItem(params = {}) {
  const { label, metadata, textRef, indexGuessBehavior, index: externalIndex } = params;
  const { register, unregister, subscribeMapChange, elementsRef, labelsRef, nextIndexRef } =
    useCompositeListContext();
  const indexRef = reactExports.useRef(-1);
  const [index2, setIndex] = reactExports.useState(
    externalIndex ??
      (indexGuessBehavior === IndexGuessBehavior.GuessFromOrder
        ? () => {
            if (indexRef.current === -1) {
              const newIndex = nextIndexRef.current;
              nextIndexRef.current += 1;
              indexRef.current = newIndex;
            }
            return indexRef.current;
          }
        : -1),
  );
  const componentRef = reactExports.useRef(null);
  const ref = reactExports.useCallback(
    (node) => {
      var _a2;
      componentRef.current = node;
      if (index2 !== -1 && node !== null) {
        elementsRef.current[index2] = node;
        if (labelsRef) {
          const isLabelDefined = label !== void 0;
          labelsRef.current[index2] = isLabelDefined
            ? label
            : (((_a2 = textRef == null ? void 0 : textRef.current) == null
                ? void 0
                : _a2.textContent) ?? node.textContent);
        }
      }
    },
    [index2, elementsRef, labelsRef, label, textRef],
  );
  useIsoLayoutEffect(() => {
    if (externalIndex != null) {
      return void 0;
    }
    const node = componentRef.current;
    if (node) {
      register(node, metadata);
      return () => {
        unregister(node);
      };
    }
    return void 0;
  }, [externalIndex, register, unregister, metadata]);
  useIsoLayoutEffect(() => {
    if (externalIndex != null) {
      return void 0;
    }
    return subscribeMapChange((map) => {
      var _a2;
      const i = componentRef.current
        ? (_a2 = map.get(componentRef.current)) == null
          ? void 0
          : _a2.index
        : null;
      if (i != null) {
        setIndex(i);
      }
    });
  }, [externalIndex, subscribeMapChange, setIndex]);
  return reactExports.useMemo(
    () => ({
      ref,
      index: index2,
    }),
    [index2, ref],
  );
}
const SafeReact = {
  ...React,
};
let globalId = 0;
function useGlobalId(idOverride, prefix = "mui") {
  const [defaultId, setDefaultId] = reactExports.useState(idOverride);
  const id2 = idOverride || defaultId;
  reactExports.useEffect(() => {
    if (defaultId == null) {
      globalId += 1;
      setDefaultId(`${prefix}-${globalId}`);
    }
  }, [defaultId, prefix]);
  return id2;
}
const maybeReactUseId = SafeReact.useId;
function useId(idOverride, prefix) {
  if (maybeReactUseId !== void 0) {
    const reactId = maybeReactUseId();
    return idOverride ?? (prefix ? `${prefix}-${reactId}` : reactId);
  }
  return useGlobalId(idOverride, prefix);
}
function useBaseUiId(idOverride) {
  return useId(idOverride, "base-ui");
}
function createChangeEventDetails(reason, event, trigger, customProperties) {
  let canceled = false;
  let allowPropagation = false;
  const custom = customProperties ?? EMPTY_OBJECT;
  const details = {
    reason,
    event: event ?? new Event("base-ui"),
    cancel() {
      canceled = true;
    },
    allowPropagation() {
      allowPropagation = true;
    },
    get isCanceled() {
      return canceled;
    },
    get isPropagationAllowed() {
      return allowPropagation;
    },
    trigger,
    ...custom,
  };
  return details;
}
const EMPTY$2 = [];
function useOnMount(fn) {
  reactExports.useEffect(fn, EMPTY$2);
}
const EMPTY$1 = null;
class Scheduler {
  constructor() {
    /* This implementation uses an array as a backing data-structure for frame callbacks.
     * It allows `O(1)` callback cancelling by inserting a `null` in the array, though it
     * never calls the native `cancelAnimationFrame` if there are no frames left. This can
     * be much more efficient if there is a call pattern that alterns as
     * "request-cancel-request-cancel-".
     * But in the case of "request-request--cancel-cancel-", it leaves the final animation
     * frame to run anyway. We turn that frame into a `O(1)` no-op via `callbacksCount`. */
    __publicField(this, "callbacks", []);
    __publicField(this, "callbacksCount", 0);
    __publicField(this, "nextId", 1);
    __publicField(this, "startId", 1);
    __publicField(this, "isScheduled", false);
    __publicField(this, "tick", (timestamp) => {
      var _a2;
      this.isScheduled = false;
      const currentCallbacks = this.callbacks;
      const currentCallbacksCount = this.callbacksCount;
      this.callbacks = [];
      this.callbacksCount = 0;
      this.startId = this.nextId;
      if (currentCallbacksCount > 0) {
        for (let i = 0; i < currentCallbacks.length; i += 1) {
          (_a2 = currentCallbacks[i]) == null ? void 0 : _a2.call(currentCallbacks, timestamp);
        }
      }
    });
  }
  request(fn) {
    const id2 = this.nextId;
    this.nextId += 1;
    this.callbacks.push(fn);
    this.callbacksCount += 1;
    const didRAFChange = false;
    if (!this.isScheduled || didRAFChange) {
      requestAnimationFrame(this.tick);
      this.isScheduled = true;
    }
    return id2;
  }
  cancel(id2) {
    const index2 = id2 - this.startId;
    if (index2 < 0 || index2 >= this.callbacks.length) {
      return;
    }
    this.callbacks[index2] = null;
    this.callbacksCount -= 1;
  }
}
const scheduler = new Scheduler();
class AnimationFrame {
  constructor() {
    __publicField(this, "currentId", EMPTY$1);
    __publicField(this, "cancel", () => {
      if (this.currentId !== EMPTY$1) {
        scheduler.cancel(this.currentId);
        this.currentId = EMPTY$1;
      }
    });
    __publicField(this, "disposeEffect", () => {
      return this.cancel;
    });
  }
  static create() {
    return new AnimationFrame();
  }
  static request(fn) {
    return scheduler.request(fn);
  }
  static cancel(id2) {
    return scheduler.cancel(id2);
  }
  /**
   * Executes `fn` after `delay`, clearing any previously scheduled call.
   */
  request(fn) {
    this.cancel();
    this.currentId = scheduler.request(() => {
      this.currentId = EMPTY$1;
      fn();
    });
  }
}
function useAnimationFrame() {
  const timeout = useRefWithInit(AnimationFrame.create).current;
  useOnMount(timeout.disposeEffect);
  return timeout;
}
function useTransitionStatus(open, enableIdleState = false, deferEndingState = false) {
  const [transitionStatus, setTransitionStatus] = reactExports.useState(
    open && enableIdleState ? "idle" : void 0,
  );
  const [mounted, setMounted] = reactExports.useState(open);
  if (open && !mounted) {
    setMounted(true);
    setTransitionStatus("starting");
  }
  if (!open && mounted && transitionStatus !== "ending" && !deferEndingState) {
    setTransitionStatus("ending");
  }
  if (!open && !mounted && transitionStatus === "ending") {
    setTransitionStatus(void 0);
  }
  useIsoLayoutEffect(() => {
    if (!open && mounted && transitionStatus !== "ending" && deferEndingState) {
      const frame2 = AnimationFrame.request(() => {
        setTransitionStatus("ending");
      });
      return () => {
        AnimationFrame.cancel(frame2);
      };
    }
    return void 0;
  }, [open, mounted, transitionStatus, deferEndingState]);
  useIsoLayoutEffect(() => {
    if (!open || enableIdleState) {
      return void 0;
    }
    const frame2 = AnimationFrame.request(() => {
      setTransitionStatus(void 0);
    });
    return () => {
      AnimationFrame.cancel(frame2);
    };
  }, [enableIdleState, open]);
  useIsoLayoutEffect(() => {
    if (!open || !enableIdleState) {
      return void 0;
    }
    if (open && mounted && transitionStatus !== "idle") {
      setTransitionStatus("starting");
    }
    const frame2 = AnimationFrame.request(() => {
      setTransitionStatus("idle");
    });
    return () => {
      AnimationFrame.cancel(frame2);
    };
  }, [enableIdleState, open, mounted, setTransitionStatus, transitionStatus]);
  return reactExports.useMemo(
    () => ({
      mounted,
      setMounted,
      transitionStatus,
    }),
    [mounted, transitionStatus],
  );
}
function resolveRef(maybeRef) {
  if (maybeRef == null) {
    return maybeRef;
  }
  return "current" in maybeRef ? maybeRef.current : maybeRef;
}
function useAnimationsFinished(
  elementOrRef,
  waitForStartingStyleRemoved = false,
  treatAbortedAsFinished = true,
) {
  const frame2 = useAnimationFrame();
  return useStableCallback((fnToExecute, signal = null) => {
    frame2.cancel();
    function done() {
      reactDomExports.flushSync(fnToExecute);
    }
    const element = resolveRef(elementOrRef);
    if (element == null) {
      return;
    }
    const resolvedElement = element;
    if (
      typeof resolvedElement.getAnimations !== "function" ||
      globalThis.BASE_UI_ANIMATIONS_DISABLED
    ) {
      fnToExecute();
    } else {
      let execWaitForStartingStyleRemoved = function () {
          const startingStyleAttribute = TransitionStatusDataAttributes.startingStyle;
          if (!resolvedElement.hasAttribute(startingStyleAttribute)) {
            frame2.request(exec);
            return;
          }
          const attributeObserver = new MutationObserver(() => {
            if (!resolvedElement.hasAttribute(startingStyleAttribute)) {
              attributeObserver.disconnect();
              exec();
            }
          });
          attributeObserver.observe(resolvedElement, {
            attributes: true,
            attributeFilter: [startingStyleAttribute],
          });
          signal == null
            ? void 0
            : signal.addEventListener("abort", () => attributeObserver.disconnect(), {
                once: true,
              });
        },
        exec = function () {
          Promise.all(resolvedElement.getAnimations().map((anim) => anim.finished))
            .then(() => {
              if (signal == null ? void 0 : signal.aborted) {
                return;
              }
              done();
            })
            .catch(() => {
              const currentAnimations = resolvedElement.getAnimations();
              if (treatAbortedAsFinished) {
                if (signal == null ? void 0 : signal.aborted) {
                  return;
                }
                done();
              } else if (
                currentAnimations.length > 0 &&
                currentAnimations.some((anim) => anim.pending || anim.playState !== "finished")
              ) {
                exec();
              }
            });
        };
      if (waitForStartingStyleRemoved) {
        execWaitForStartingStyleRemoved();
        return;
      }
      frame2.request(exec);
    }
  });
}
function useOpenChangeComplete(parameters) {
  const { enabled = true, open, ref, onComplete: onCompleteParam } = parameters;
  const onComplete = useStableCallback(onCompleteParam);
  const runOnceAnimationsFinish = useAnimationsFinished(ref, open, false);
  reactExports.useEffect(() => {
    if (!enabled) {
      return void 0;
    }
    const abortController = new AbortController();
    runOnceAnimationsFinish(onComplete, abortController.signal);
    return () => {
      abortController.abort();
    };
  }, [enabled, open, onComplete, runOnceAnimationsFinish]);
}
const MenuItem = /* @__PURE__ */ reactExports.forwardRef(
  function MenuItem2(componentProps, forwardedRef) {
    const {
      render,
      className,
      id: idProp,
      label,
      nativeButton = false,
      disabled: disabled2 = false,
      closeOnClick = true,
      ...elementProps
    } = componentProps;
    const listItem = useCompositeListItem({
      label,
    });
    const menuPositionerContext = useMenuPositionerContext(true);
    const id2 = useBaseUiId(idProp);
    const { store } = useMenuRootContext();
    const highlighted = store.useState("isActive", listItem.index);
    const itemProps = store.useState("itemProps");
    const { getItemProps, itemRef } = useMenuItem({
      closeOnClick,
      disabled: disabled2,
      highlighted,
      id: id2,
      store,
      nativeButton,
      nodeId: menuPositionerContext == null ? void 0 : menuPositionerContext.nodeId,
      itemMetadata: REGULAR_ITEM,
    });
    const state = reactExports.useMemo(
      () => ({
        disabled: disabled2,
        highlighted,
      }),
      [disabled2, highlighted],
    );
    return useRenderElement("div", componentProps, {
      state,
      props: [itemProps, elementProps, getItemProps],
      ref: [itemRef, forwardedRef, listItem.ref],
    });
  },
);
const EMPTY = 0;
class Timeout {
  constructor() {
    __publicField(this, "currentId", EMPTY);
    __publicField(this, "clear", () => {
      if (this.currentId !== EMPTY) {
        clearTimeout(this.currentId);
        this.currentId = EMPTY;
      }
    });
    __publicField(this, "disposeEffect", () => {
      return this.clear;
    });
  }
  static create() {
    return new Timeout();
  }
  /**
   * Executes `fn` after `delay`, clearing any previously scheduled call.
   */
  start(delay2, fn) {
    this.clear();
    this.currentId = setTimeout(() => {
      this.currentId = EMPTY;
      fn();
    }, delay2);
  }
  isStarted() {
    return this.currentId !== EMPTY;
  }
}
function useTimeout() {
  const timeout = useRefWithInit(Timeout.create).current;
  useOnMount(timeout.disposeEffect);
  return timeout;
}
function useValueAsRef(value) {
  const latest = useRefWithInit(createLatestRef, value).current;
  latest.next = value;
  useIsoLayoutEffect(latest.effect);
  return latest;
}
function createLatestRef(value) {
  const latest = {
    current: value,
    next: value,
    effect: () => {
      latest.current = latest.next;
    },
  };
  return latest;
}
const hasNavigator = typeof navigator !== "undefined";
const nav = getNavigatorData();
const platform$1 = getPlatform();
const userAgent = getUserAgent();
const isWebKit =
  typeof CSS === "undefined" || !CSS.supports
    ? false
    : CSS.supports("-webkit-backdrop-filter:none");
const isIOS =
  // iPads can claim to be MacIntel
  nav.platform === "MacIntel" && nav.maxTouchPoints > 1
    ? true
    : /iP(hone|ad|od)|iOS/.test(nav.platform);
const isSafari = hasNavigator && /apple/i.test(navigator.vendor);
const isAndroid = (hasNavigator && /android/i.test(platform$1)) || /android/i.test(userAgent);
const isMac =
  hasNavigator && platform$1.toLowerCase().startsWith("mac") && !navigator.maxTouchPoints;
const isJSDOM = userAgent.includes("jsdom/");
function getNavigatorData() {
  if (!hasNavigator) {
    return {
      platform: "",
      maxTouchPoints: -1,
    };
  }
  const uaData = navigator.userAgentData;
  if (uaData == null ? void 0 : uaData.platform) {
    return {
      platform: uaData.platform,
      maxTouchPoints: navigator.maxTouchPoints,
    };
  }
  return {
    platform: navigator.platform ?? "",
    maxTouchPoints: navigator.maxTouchPoints ?? -1,
  };
}
function getUserAgent() {
  if (!hasNavigator) {
    return "";
  }
  const uaData = navigator.userAgentData;
  if (uaData && Array.isArray(uaData.brands)) {
    return uaData.brands.map(({ brand, version }) => `${brand}/${version}`).join(" ");
  }
  return navigator.userAgent;
}
function getPlatform() {
  if (!hasNavigator) {
    return "";
  }
  const uaData = navigator.userAgentData;
  if (uaData == null ? void 0 : uaData.platform) {
    return uaData.platform;
  }
  return navigator.platform ?? "";
}
const FOCUSABLE_ATTRIBUTE = "data-base-ui-focusable";
const ACTIVE_KEY = "active";
const SELECTED_KEY = "selected";
const TYPEABLE_SELECTOR =
  "input:not([type='hidden']):not([disabled]),[contenteditable]:not([contenteditable='false']),textarea:not([disabled])";
const ARROW_LEFT$1 = "ArrowLeft";
const ARROW_RIGHT$1 = "ArrowRight";
const ARROW_UP$1 = "ArrowUp";
const ARROW_DOWN$1 = "ArrowDown";
function activeElement(doc) {
  var _a2;
  let element = doc.activeElement;
  while (
    ((_a2 = element == null ? void 0 : element.shadowRoot) == null ? void 0 : _a2.activeElement) !=
    null
  ) {
    element = element.shadowRoot.activeElement;
  }
  return element;
}
function contains(parent, child) {
  var _a2;
  if (!parent || !child) {
    return false;
  }
  const rootNode = (_a2 = child.getRootNode) == null ? void 0 : _a2.call(child);
  if (parent.contains(child)) {
    return true;
  }
  if (rootNode && isShadowRoot(rootNode)) {
    let next = child;
    while (next) {
      if (parent === next) {
        return true;
      }
      next = next.parentNode || next.host;
    }
  }
  return false;
}
function getTarget(event) {
  if ("composedPath" in event) {
    return event.composedPath()[0];
  }
  return event.target;
}
function isEventTargetWithin(event, node) {
  if (node == null) {
    return false;
  }
  if ("composedPath" in event) {
    return event.composedPath().includes(node);
  }
  const eventAgain = event;
  return eventAgain.target != null && node.contains(eventAgain.target);
}
function isRootElement(element) {
  return element.matches("html,body");
}
function getDocument(node) {
  return (node == null ? void 0 : node.ownerDocument) || document;
}
function isTypeableElement(element) {
  return isHTMLElement(element) && element.matches(TYPEABLE_SELECTOR);
}
function isTypeableCombobox(element) {
  if (!element) {
    return false;
  }
  return element.getAttribute("role") === "combobox" && isTypeableElement(element);
}
function matchesFocusVisible(element) {
  if (!element || isJSDOM) {
    return true;
  }
  try {
    return element.matches(":focus-visible");
  } catch (_e) {
    return true;
  }
}
function getFloatingFocusElement(floatingElement) {
  if (!floatingElement) {
    return null;
  }
  return floatingElement.hasAttribute(FOCUSABLE_ATTRIBUTE)
    ? floatingElement
    : floatingElement.querySelector(`[${FOCUSABLE_ATTRIBUTE}]`) || floatingElement;
}
function getNodeChildren(nodes, id2, onlyOpenChildren = true) {
  const directChildren = nodes.filter((node) => {
    var _a2;
    return (
      node.parentId === id2 &&
      (!onlyOpenChildren || ((_a2 = node.context) == null ? void 0 : _a2.open))
    );
  });
  return directChildren.flatMap((child) => [
    child,
    ...getNodeChildren(nodes, child.id, onlyOpenChildren),
  ]);
}
function getNodeAncestors(nodes, id2) {
  var _a2;
  let allAncestors = [];
  let currentParentId =
    (_a2 = nodes.find((node) => node.id === id2)) == null ? void 0 : _a2.parentId;
  while (currentParentId) {
    const currentNode = nodes.find((node) => node.id === currentParentId);
    currentParentId = currentNode == null ? void 0 : currentNode.parentId;
    if (currentNode) {
      allAncestors = allAncestors.concat(currentNode);
    }
  }
  return allAncestors;
}
function stopEvent(event) {
  event.preventDefault();
  event.stopPropagation();
}
function isReactEvent(event) {
  return "nativeEvent" in event;
}
function isVirtualClick(event) {
  if (event.mozInputSource === 0 && event.isTrusted) {
    return true;
  }
  if (isAndroid && event.pointerType) {
    return event.type === "click" && event.buttons === 1;
  }
  return event.detail === 0 && !event.pointerType;
}
function isVirtualPointerEvent(event) {
  if (isJSDOM) {
    return false;
  }
  return (
    (!isAndroid && event.width === 0 && event.height === 0) ||
    (isAndroid &&
      event.width === 1 &&
      event.height === 1 &&
      event.pressure === 0 &&
      event.detail === 0 &&
      event.pointerType === "mouse") || // iOS VoiceOver returns 0.333 for width/height.
    (event.width < 1 &&
      event.height < 1 &&
      event.pressure === 0 &&
      event.detail === 0 &&
      event.pointerType === "touch")
  );
}
function isMouseLikePointerType(pointerType, strict) {
  const values = ["mouse", "pen"];
  if (!strict) {
    values.push("", void 0);
  }
  return values.includes(pointerType);
}
function isClickLikeEvent(event) {
  const type = event.type;
  return type === "click" || type === "mousedown" || type === "keydown" || type === "keyup";
}
const sides = ["top", "right", "bottom", "left"];
const min = Math.min;
const max = Math.max;
const round = Math.round;
const floor = Math.floor;
const createCoords = (v) => ({
  x: v,
  y: v,
});
const oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom",
};
const oppositeAlignmentMap = {
  start: "end",
  end: "start",
};
function clamp$1(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
const yAxisSides = /* @__PURE__ */ new Set(["top", "bottom"]);
function getSideAxis(placement) {
  return yAxisSides.has(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide =
    alignmentAxis === "x"
      ? alignment === (rtl ? "end" : "start")
        ? "right"
        : "left"
      : alignment === "start"
        ? "bottom"
        : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [
    getOppositeAlignmentPlacement(placement),
    oppositePlacement,
    getOppositeAlignmentPlacement(oppositePlacement),
  ];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
const lrPlacement = ["left", "right"];
const rlPlacement = ["right", "left"];
const tbPlacement = ["top", "bottom"];
const btPlacement = ["bottom", "top"];
function getSideList(side, isStart, rtl) {
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rlPlacement : lrPlacement;
      return isStart ? lrPlacement : rlPlacement;
    case "left":
    case "right":
      return isStart ? tbPlacement : btPlacement;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding,
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number"
    ? expandPaddingObject(padding)
    : {
        top: padding,
        right: padding,
        bottom: padding,
        left: padding,
      };
}
function rectToClientRect(rect) {
  const { x, y, width, height } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y,
  };
}
function isDifferentGridRow(index2, cols, prevRow) {
  return Math.floor(index2 / cols) !== prevRow;
}
function isIndexOutOfListBounds(listRef, index2) {
  return index2 < 0 || index2 >= listRef.current.length;
}
function getMinListIndex(listRef, disabledIndices) {
  return findNonDisabledListIndex(listRef, {
    disabledIndices,
  });
}
function getMaxListIndex(listRef, disabledIndices) {
  return findNonDisabledListIndex(listRef, {
    decrement: true,
    startingIndex: listRef.current.length,
    disabledIndices,
  });
}
function findNonDisabledListIndex(
  listRef,
  { startingIndex = -1, decrement = false, disabledIndices, amount = 1 } = {},
) {
  let index2 = startingIndex;
  do {
    index2 += decrement ? -amount : amount;
  } while (
    index2 >= 0 &&
    index2 <= listRef.current.length - 1 &&
    isListIndexDisabled(listRef, index2, disabledIndices)
  );
  return index2;
}
function getGridNavigatedIndex(
  listRef,
  {
    event,
    orientation,
    loopFocus,
    rtl,
    cols,
    disabledIndices,
    minIndex,
    maxIndex,
    prevIndex,
    stopEvent: stop = false,
  },
) {
  let nextIndex = prevIndex;
  const rows = [];
  const rowIndexMap = {};
  let hasRoleRow = false;
  {
    let currentRowEl = null;
    let currentRowIndex = -1;
    listRef.current.forEach((el, idx) => {
      if (el == null) {
        return;
      }
      const rowEl = el.closest('[role="row"]');
      if (rowEl) {
        hasRoleRow = true;
      }
      if (rowEl !== currentRowEl || currentRowIndex === -1) {
        currentRowEl = rowEl;
        currentRowIndex += 1;
        rows[currentRowIndex] = [];
      }
      rows[currentRowIndex].push(idx);
      rowIndexMap[idx] = currentRowIndex;
    });
  }
  const hasDomRows = hasRoleRow && rows.length > 0 && rows.some((row) => row.length !== cols);
  function navigateVertically(direction) {
    if (!hasDomRows || prevIndex === -1) {
      return void 0;
    }
    const currentRow = rowIndexMap[prevIndex];
    if (currentRow == null) {
      return void 0;
    }
    const colInRow = rows[currentRow].indexOf(prevIndex);
    let nextRow = direction === "up" ? currentRow - 1 : currentRow + 1;
    if (loopFocus) {
      if (nextRow < 0) {
        nextRow = rows.length - 1;
      } else if (nextRow >= rows.length) {
        nextRow = 0;
      }
    }
    const visited = /* @__PURE__ */ new Set();
    while (nextRow >= 0 && nextRow < rows.length && !visited.has(nextRow)) {
      visited.add(nextRow);
      const targetRow = rows[nextRow];
      if (targetRow.length === 0) {
        nextRow = direction === "up" ? nextRow - 1 : nextRow + 1;
        continue;
      }
      const clampedCol = Math.min(colInRow, targetRow.length - 1);
      for (let col = clampedCol; col >= 0; col -= 1) {
        const candidate = targetRow[col];
        if (!isListIndexDisabled(listRef, candidate, disabledIndices)) {
          return candidate;
        }
      }
      nextRow = direction === "up" ? nextRow - 1 : nextRow + 1;
      if (loopFocus) {
        if (nextRow < 0) {
          nextRow = rows.length - 1;
        } else if (nextRow >= rows.length) {
          nextRow = 0;
        }
      }
    }
    return void 0;
  }
  if (event.key === ARROW_UP$1) {
    const domBasedCandidate = navigateVertically("up");
    if (domBasedCandidate !== void 0) {
      if (stop) {
        stopEvent(event);
      }
      nextIndex = domBasedCandidate;
    } else {
      if (stop) {
        stopEvent(event);
      }
      if (prevIndex === -1) {
        nextIndex = maxIndex;
      } else {
        nextIndex = findNonDisabledListIndex(listRef, {
          startingIndex: nextIndex,
          amount: cols,
          decrement: true,
          disabledIndices,
        });
        if (loopFocus && (prevIndex - cols < minIndex || nextIndex < 0)) {
          const col = prevIndex % cols;
          const maxCol = maxIndex % cols;
          const offset2 = maxIndex - (maxCol - col);
          if (maxCol === col) {
            nextIndex = maxIndex;
          } else {
            nextIndex = maxCol > col ? offset2 : offset2 - cols;
          }
        }
      }
      if (isIndexOutOfListBounds(listRef, nextIndex)) {
        nextIndex = prevIndex;
      }
    }
  }
  if (event.key === ARROW_DOWN$1) {
    const domBasedCandidate = navigateVertically("down");
    if (domBasedCandidate !== void 0) {
      if (stop) {
        stopEvent(event);
      }
      nextIndex = domBasedCandidate;
    } else {
      if (stop) {
        stopEvent(event);
      }
      if (prevIndex === -1) {
        nextIndex = minIndex;
      } else {
        nextIndex = findNonDisabledListIndex(listRef, {
          startingIndex: prevIndex,
          amount: cols,
          disabledIndices,
        });
        if (loopFocus && prevIndex + cols > maxIndex) {
          nextIndex = findNonDisabledListIndex(listRef, {
            startingIndex: (prevIndex % cols) - cols,
            amount: cols,
            disabledIndices,
          });
        }
      }
      if (isIndexOutOfListBounds(listRef, nextIndex)) {
        nextIndex = prevIndex;
      }
    }
  }
  if (orientation === "both") {
    const prevRow = floor(prevIndex / cols);
    if (event.key === (rtl ? ARROW_LEFT$1 : ARROW_RIGHT$1)) {
      if (stop) {
        stopEvent(event);
      }
      if (prevIndex % cols !== cols - 1) {
        nextIndex = findNonDisabledListIndex(listRef, {
          startingIndex: prevIndex,
          disabledIndices,
        });
        if (loopFocus && isDifferentGridRow(nextIndex, cols, prevRow)) {
          nextIndex = findNonDisabledListIndex(listRef, {
            startingIndex: prevIndex - (prevIndex % cols) - 1,
            disabledIndices,
          });
        }
      } else if (loopFocus) {
        nextIndex = findNonDisabledListIndex(listRef, {
          startingIndex: prevIndex - (prevIndex % cols) - 1,
          disabledIndices,
        });
      }
      if (isDifferentGridRow(nextIndex, cols, prevRow)) {
        nextIndex = prevIndex;
      }
    }
    if (event.key === (rtl ? ARROW_RIGHT$1 : ARROW_LEFT$1)) {
      if (stop) {
        stopEvent(event);
      }
      if (prevIndex % cols !== 0) {
        nextIndex = findNonDisabledListIndex(listRef, {
          startingIndex: prevIndex,
          decrement: true,
          disabledIndices,
        });
        if (loopFocus && isDifferentGridRow(nextIndex, cols, prevRow)) {
          nextIndex = findNonDisabledListIndex(listRef, {
            startingIndex: prevIndex + (cols - (prevIndex % cols)),
            decrement: true,
            disabledIndices,
          });
        }
      } else if (loopFocus) {
        nextIndex = findNonDisabledListIndex(listRef, {
          startingIndex: prevIndex + (cols - (prevIndex % cols)),
          decrement: true,
          disabledIndices,
        });
      }
      if (isDifferentGridRow(nextIndex, cols, prevRow)) {
        nextIndex = prevIndex;
      }
    }
    const lastRow = floor(maxIndex / cols) === prevRow;
    if (isIndexOutOfListBounds(listRef, nextIndex)) {
      if (loopFocus && lastRow) {
        nextIndex =
          event.key === (rtl ? ARROW_RIGHT$1 : ARROW_LEFT$1)
            ? maxIndex
            : findNonDisabledListIndex(listRef, {
                startingIndex: prevIndex - (prevIndex % cols) - 1,
                disabledIndices,
              });
      } else {
        nextIndex = prevIndex;
      }
    }
  }
  return nextIndex;
}
function createGridCellMap(sizes, cols, dense) {
  const cellMap = [];
  let startIndex = 0;
  sizes.forEach(({ width, height }, index2) => {
    let itemPlaced = false;
    if (dense) {
      startIndex = 0;
    }
    while (!itemPlaced) {
      const targetCells = [];
      for (let i = 0; i < width; i += 1) {
        for (let j = 0; j < height; j += 1) {
          targetCells.push(startIndex + i + j * cols);
        }
      }
      if (
        (startIndex % cols) + width <= cols &&
        targetCells.every((cell) => cellMap[cell] == null)
      ) {
        targetCells.forEach((cell) => {
          cellMap[cell] = index2;
        });
        itemPlaced = true;
      } else {
        startIndex += 1;
      }
    }
  });
  return [...cellMap];
}
function getGridCellIndexOfCorner(index2, sizes, cellMap, cols, corner) {
  if (index2 === -1) {
    return -1;
  }
  const firstCellIndex = cellMap.indexOf(index2);
  const sizeItem = sizes[index2];
  switch (corner) {
    case "tl":
      return firstCellIndex;
    case "tr":
      if (!sizeItem) {
        return firstCellIndex;
      }
      return firstCellIndex + sizeItem.width - 1;
    case "bl":
      if (!sizeItem) {
        return firstCellIndex;
      }
      return firstCellIndex + (sizeItem.height - 1) * cols;
    case "br":
      return cellMap.lastIndexOf(index2);
    default:
      return -1;
  }
}
function getGridCellIndices(indices, cellMap) {
  return cellMap.flatMap((index2, cellIndex) => (indices.includes(index2) ? [cellIndex] : []));
}
function isListIndexDisabled(listRef, index2, disabledIndices) {
  if (typeof disabledIndices === "function") {
    return disabledIndices(index2);
  }
  if (disabledIndices) {
    return disabledIndices.includes(index2);
  }
  const element = listRef.current[index2];
  if (!element) {
    return false;
  }
  return element.hasAttribute("disabled") || element.getAttribute("aria-disabled") === "true";
}
/*!
 * tabbable 6.4.0
 * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
 */
var candidateSelectors = [
  "input:not([inert]):not([inert] *)",
  "select:not([inert]):not([inert] *)",
  "textarea:not([inert]):not([inert] *)",
  "a[href]:not([inert]):not([inert] *)",
  "button:not([inert]):not([inert] *)",
  "[tabindex]:not(slot):not([inert]):not([inert] *)",
  "audio[controls]:not([inert]):not([inert] *)",
  "video[controls]:not([inert]):not([inert] *)",
  '[contenteditable]:not([contenteditable="false"]):not([inert]):not([inert] *)',
  "details>summary:first-of-type:not([inert]):not([inert] *)",
  "details:not([inert]):not([inert] *)",
];
var candidateSelector = /* @__PURE__ */ candidateSelectors.join(",");
var NoElement = typeof Element === "undefined";
var matches = NoElement
  ? function () {}
  : Element.prototype.matches ||
    Element.prototype.msMatchesSelector ||
    Element.prototype.webkitMatchesSelector;
var getRootNode =
  !NoElement && Element.prototype.getRootNode
    ? function (element) {
        var _element$getRootNode;
        return element === null || element === void 0
          ? void 0
          : (_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0
            ? void 0
            : _element$getRootNode.call(element);
      }
    : function (element) {
        return element === null || element === void 0 ? void 0 : element.ownerDocument;
      };
var _isInert = function isInert(node, lookUp) {
  var _node$getAttribute;
  if (lookUp === void 0) {
    lookUp = true;
  }
  var inertAtt =
    node === null || node === void 0
      ? void 0
      : (_node$getAttribute = node.getAttribute) === null || _node$getAttribute === void 0
        ? void 0
        : _node$getAttribute.call(node, "inert");
  var inert = inertAtt === "" || inertAtt === "true";
  var result =
    inert ||
    (lookUp &&
      node && // closest does not exist on shadow roots, so we fall back to a manual
      // lookup upward, in case it is not defined.
      (typeof node.closest === "function" ? node.closest("[inert]") : _isInert(node.parentNode)));
  return result;
};
var isContentEditable = function isContentEditable2(node) {
  var _node$getAttribute2;
  var attValue =
    node === null || node === void 0
      ? void 0
      : (_node$getAttribute2 = node.getAttribute) === null || _node$getAttribute2 === void 0
        ? void 0
        : _node$getAttribute2.call(node, "contenteditable");
  return attValue === "" || attValue === "true";
};
var getCandidates = function getCandidates2(el, includeContainer, filter2) {
  if (_isInert(el)) {
    return [];
  }
  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
  if (includeContainer && matches.call(el, candidateSelector)) {
    candidates.unshift(el);
  }
  candidates = candidates.filter(filter2);
  return candidates;
};
var _getCandidatesIteratively = function getCandidatesIteratively(
  elements,
  includeContainer,
  options,
) {
  var candidates = [];
  var elementsToCheck = Array.from(elements);
  while (elementsToCheck.length) {
    var element = elementsToCheck.shift();
    if (_isInert(element, false)) {
      continue;
    }
    if (element.tagName === "SLOT") {
      var assigned = element.assignedElements();
      var content = assigned.length ? assigned : element.children;
      var nestedCandidates = _getCandidatesIteratively(content, true, options);
      if (options.flatten) {
        candidates.push.apply(candidates, nestedCandidates);
      } else {
        candidates.push({
          scopeParent: element,
          candidates: nestedCandidates,
        });
      }
    } else {
      var validCandidate = matches.call(element, candidateSelector);
      if (
        validCandidate &&
        options.filter(element) &&
        (includeContainer || !elements.includes(element))
      ) {
        candidates.push(element);
      }
      var shadowRoot =
        element.shadowRoot || // check for an undisclosed shadow
        (typeof options.getShadowRoot === "function" && options.getShadowRoot(element));
      var validShadowRoot =
        !_isInert(shadowRoot, false) &&
        (!options.shadowRootFilter || options.shadowRootFilter(element));
      if (shadowRoot && validShadowRoot) {
        var _nestedCandidates = _getCandidatesIteratively(
          shadowRoot === true ? element.children : shadowRoot.children,
          true,
          options,
        );
        if (options.flatten) {
          candidates.push.apply(candidates, _nestedCandidates);
        } else {
          candidates.push({
            scopeParent: element,
            candidates: _nestedCandidates,
          });
        }
      } else {
        elementsToCheck.unshift.apply(elementsToCheck, element.children);
      }
    }
  }
  return candidates;
};
var hasTabIndex = function hasTabIndex2(node) {
  return !isNaN(parseInt(node.getAttribute("tabindex"), 10));
};
var getTabIndex = function getTabIndex2(node) {
  if (!node) {
    throw new Error("No node provided");
  }
  if (node.tabIndex < 0) {
    if (
      (/^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || isContentEditable(node)) &&
      !hasTabIndex(node)
    ) {
      return 0;
    }
  }
  return node.tabIndex;
};
var getSortOrderTabIndex = function getSortOrderTabIndex2(node, isScope) {
  var tabIndex = getTabIndex(node);
  if (tabIndex < 0 && isScope && !hasTabIndex(node)) {
    return 0;
  }
  return tabIndex;
};
var sortOrderedTabbables = function sortOrderedTabbables2(a, b) {
  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;
};
var isInput = function isInput2(node) {
  return node.tagName === "INPUT";
};
var isHiddenInput = function isHiddenInput2(node) {
  return isInput(node) && node.type === "hidden";
};
var isDetailsWithSummary = function isDetailsWithSummary2(node) {
  var r2 =
    node.tagName === "DETAILS" &&
    Array.prototype.slice.apply(node.children).some(function (child) {
      return child.tagName === "SUMMARY";
    });
  return r2;
};
var getCheckedRadio = function getCheckedRadio2(nodes, form) {
  for (var i = 0; i < nodes.length; i++) {
    if (nodes[i].checked && nodes[i].form === form) {
      return nodes[i];
    }
  }
};
var isTabbableRadio = function isTabbableRadio2(node) {
  if (!node.name) {
    return true;
  }
  var radioScope = node.form || getRootNode(node);
  var queryRadios = function queryRadios2(name) {
    return radioScope.querySelectorAll('input[type="radio"][name="' + name + '"]');
  };
  var radioSet;
  if (
    typeof window !== "undefined" &&
    typeof window.CSS !== "undefined" &&
    typeof window.CSS.escape === "function"
  ) {
    radioSet = queryRadios(window.CSS.escape(node.name));
  } else {
    try {
      radioSet = queryRadios(node.name);
    } catch (err) {
      console.error(
        "Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s",
        err.message,
      );
      return false;
    }
  }
  var checked = getCheckedRadio(radioSet, node.form);
  return !checked || checked === node;
};
var isRadio = function isRadio2(node) {
  return isInput(node) && node.type === "radio";
};
var isNonTabbableRadio = function isNonTabbableRadio2(node) {
  return isRadio(node) && !isTabbableRadio(node);
};
var isNodeAttached = function isNodeAttached2(node) {
  var _nodeRoot;
  var nodeRoot = node && getRootNode(node);
  var nodeRootHost =
    (_nodeRoot = nodeRoot) === null || _nodeRoot === void 0 ? void 0 : _nodeRoot.host;
  var attached = false;
  if (nodeRoot && nodeRoot !== node) {
    var _nodeRootHost, _nodeRootHost$ownerDo, _node$ownerDocument;
    attached = !!(
      ((_nodeRootHost = nodeRootHost) !== null &&
        _nodeRootHost !== void 0 &&
        (_nodeRootHost$ownerDo = _nodeRootHost.ownerDocument) !== null &&
        _nodeRootHost$ownerDo !== void 0 &&
        _nodeRootHost$ownerDo.contains(nodeRootHost)) ||
      (node !== null &&
        node !== void 0 &&
        (_node$ownerDocument = node.ownerDocument) !== null &&
        _node$ownerDocument !== void 0 &&
        _node$ownerDocument.contains(node))
    );
    while (!attached && nodeRootHost) {
      var _nodeRoot2, _nodeRootHost2, _nodeRootHost2$ownerD;
      nodeRoot = getRootNode(nodeRootHost);
      nodeRootHost =
        (_nodeRoot2 = nodeRoot) === null || _nodeRoot2 === void 0 ? void 0 : _nodeRoot2.host;
      attached = !!(
        (_nodeRootHost2 = nodeRootHost) !== null &&
        _nodeRootHost2 !== void 0 &&
        (_nodeRootHost2$ownerD = _nodeRootHost2.ownerDocument) !== null &&
        _nodeRootHost2$ownerD !== void 0 &&
        _nodeRootHost2$ownerD.contains(nodeRootHost)
      );
    }
  }
  return attached;
};
var isZeroArea = function isZeroArea2(node) {
  var _node$getBoundingClie = node.getBoundingClientRect(),
    width = _node$getBoundingClie.width,
    height = _node$getBoundingClie.height;
  return width === 0 && height === 0;
};
var isHidden = function isHidden2(node, _ref) {
  var displayCheck = _ref.displayCheck,
    getShadowRoot = _ref.getShadowRoot;
  if (displayCheck === "full-native") {
    if ("checkVisibility" in node) {
      var visible = node.checkVisibility({
        // Checking opacity might be desirable for some use cases, but natively,
        // opacity zero elements _are_ focusable and tabbable.
        checkOpacity: false,
        opacityProperty: false,
        contentVisibilityAuto: true,
        visibilityProperty: true,
        // This is an alias for `visibilityProperty`. Contemporary browsers
        // support both. However, this alias has wider browser support (Chrome
        // >= 105 and Firefox >= 106, vs. Chrome >= 121 and Firefox >= 122), so
        // we include it anyway.
        checkVisibilityCSS: true,
      });
      return !visible;
    }
  }
  if (getComputedStyle(node).visibility === "hidden") {
    return true;
  }
  var isDirectSummary = matches.call(node, "details>summary:first-of-type");
  var nodeUnderDetails = isDirectSummary ? node.parentElement : node;
  if (matches.call(nodeUnderDetails, "details:not([open]) *")) {
    return true;
  }
  if (
    !displayCheck ||
    displayCheck === "full" || // full-native can run this branch when it falls through in case
    // Element#checkVisibility is unsupported
    displayCheck === "full-native" ||
    displayCheck === "legacy-full"
  ) {
    if (typeof getShadowRoot === "function") {
      var originalNode = node;
      while (node) {
        var parentElement = node.parentElement;
        var rootNode = getRootNode(node);
        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true) {
          return isZeroArea(node);
        } else if (node.assignedSlot) {
          node = node.assignedSlot;
        } else if (!parentElement && rootNode !== node.ownerDocument) {
          node = rootNode.host;
        } else {
          node = parentElement;
        }
      }
      node = originalNode;
    }
    if (isNodeAttached(node)) {
      return !node.getClientRects().length;
    }
    if (displayCheck !== "legacy-full") {
      return true;
    }
  } else if (displayCheck === "non-zero-area") {
    return isZeroArea(node);
  }
  return false;
};
var isDisabledFromFieldset = function isDisabledFromFieldset2(node) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
    var parentNode = node.parentElement;
    while (parentNode) {
      if (parentNode.tagName === "FIELDSET" && parentNode.disabled) {
        for (var i = 0; i < parentNode.children.length; i++) {
          var child = parentNode.children.item(i);
          if (child.tagName === "LEGEND") {
            return matches.call(parentNode, "fieldset[disabled] *") ? true : !child.contains(node);
          }
        }
        return true;
      }
      parentNode = parentNode.parentElement;
    }
  }
  return false;
};
var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable2(options, node) {
  if (
    node.disabled ||
    isHiddenInput(node) ||
    isHidden(node, options) || // For a details element with a summary, the summary element gets the focus
    isDetailsWithSummary(node) ||
    isDisabledFromFieldset(node)
  ) {
    return false;
  }
  return true;
};
var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable2(options, node) {
  if (
    isNonTabbableRadio(node) ||
    getTabIndex(node) < 0 ||
    !isNodeMatchingSelectorFocusable(options, node)
  ) {
    return false;
  }
  return true;
};
var isShadowRootTabbable = function isShadowRootTabbable2(shadowHostNode) {
  var tabIndex = parseInt(shadowHostNode.getAttribute("tabindex"), 10);
  if (isNaN(tabIndex) || tabIndex >= 0) {
    return true;
  }
  return false;
};
var _sortByOrder = function sortByOrder(candidates) {
  var regularTabbables = [];
  var orderedTabbables = [];
  candidates.forEach(function (item, i) {
    var isScope = !!item.scopeParent;
    var element = isScope ? item.scopeParent : item;
    var candidateTabindex = getSortOrderTabIndex(element, isScope);
    var elements = isScope ? _sortByOrder(item.candidates) : element;
    if (candidateTabindex === 0) {
      isScope
        ? regularTabbables.push.apply(regularTabbables, elements)
        : regularTabbables.push(element);
    } else {
      orderedTabbables.push({
        documentOrder: i,
        tabIndex: candidateTabindex,
        item,
        isScope,
        content: elements,
      });
    }
  });
  return orderedTabbables
    .sort(sortOrderedTabbables)
    .reduce(function (acc, sortable) {
      sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
      return acc;
    }, [])
    .concat(regularTabbables);
};
var tabbable = function tabbable2(container, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = _getCandidatesIteratively([container], options.includeContainer, {
      filter: isNodeMatchingSelectorTabbable.bind(null, options),
      flatten: false,
      getShadowRoot: options.getShadowRoot,
      shadowRootFilter: isShadowRootTabbable,
    });
  } else {
    candidates = getCandidates(
      container,
      options.includeContainer,
      isNodeMatchingSelectorTabbable.bind(null, options),
    );
  }
  return _sortByOrder(candidates);
};
var focusable = function focusable2(container, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = _getCandidatesIteratively([container], options.includeContainer, {
      filter: isNodeMatchingSelectorFocusable.bind(null, options),
      flatten: true,
      getShadowRoot: options.getShadowRoot,
    });
  } else {
    candidates = getCandidates(
      container,
      options.includeContainer,
      isNodeMatchingSelectorFocusable.bind(null, options),
    );
  }
  return candidates;
};
var isTabbable = function isTabbable2(node, options) {
  options = options || {};
  if (!node) {
    throw new Error("No node provided");
  }
  if (matches.call(node, candidateSelector) === false) {
    return false;
  }
  return isNodeMatchingSelectorTabbable(options, node);
};
const getTabbableOptions = () => ({
  getShadowRoot: true,
  displayCheck:
    // JSDOM does not support the `tabbable` library. To solve this we can
    // check if `ResizeObserver` is a real function (not polyfilled), which
    // determines if the current environment is JSDOM-like.
    typeof ResizeObserver === "function" && ResizeObserver.toString().includes("[native code]")
      ? "full"
      : "none",
});
function getTabbableIn(container, dir) {
  const list = tabbable(container, getTabbableOptions());
  const len = list.length;
  if (len === 0) {
    return void 0;
  }
  const active = activeElement(getDocument(container));
  const index2 = list.indexOf(active);
  const nextIndex = index2 === -1 ? (dir === 1 ? 0 : len - 1) : index2 + dir;
  return list[nextIndex];
}
function getNextTabbable(referenceElement) {
  return getTabbableIn(getDocument(referenceElement).body, 1) || referenceElement;
}
function getPreviousTabbable(referenceElement) {
  return getTabbableIn(getDocument(referenceElement).body, -1) || referenceElement;
}
function getTabbableNearElement(referenceElement, dir) {
  if (!referenceElement) {
    return null;
  }
  const list = tabbable(getDocument(referenceElement).body, getTabbableOptions());
  const elementCount = list.length;
  if (elementCount === 0) {
    return null;
  }
  const index2 = list.indexOf(referenceElement);
  if (index2 === -1) {
    return null;
  }
  const nextIndex = (index2 + dir + elementCount) % elementCount;
  return list[nextIndex];
}
function getTabbableAfterElement(referenceElement) {
  return getTabbableNearElement(referenceElement, 1);
}
function getTabbableBeforeElement(referenceElement) {
  return getTabbableNearElement(referenceElement, -1);
}
function isOutsideEvent(event, container) {
  const containerElement = container || event.currentTarget;
  const relatedTarget = event.relatedTarget;
  return !relatedTarget || !contains(containerElement, relatedTarget);
}
function disableFocusInside(container) {
  const tabbableElements = tabbable(container, getTabbableOptions());
  tabbableElements.forEach((element) => {
    element.dataset.tabindex = element.getAttribute("tabindex") || "";
    element.setAttribute("tabindex", "-1");
  });
}
function enableFocusInside(container) {
  const elements = container.querySelectorAll("[data-tabindex]");
  elements.forEach((element) => {
    const tabindex = element.dataset.tabindex;
    delete element.dataset.tabindex;
    if (tabindex) {
      element.setAttribute("tabindex", tabindex);
    } else {
      element.removeAttribute("tabindex");
    }
  });
}
function createEventEmitter() {
  const map = /* @__PURE__ */ new Map();
  return {
    emit(event, data) {
      var _a2;
      (_a2 = map.get(event)) == null ? void 0 : _a2.forEach((listener) => listener(data));
    },
    on(event, listener) {
      if (!map.has(event)) {
        map.set(event, /* @__PURE__ */ new Set());
      }
      map.get(event).add(listener);
    },
    off(event, listener) {
      var _a2;
      (_a2 = map.get(event)) == null ? void 0 : _a2.delete(listener);
    },
  };
}
class FloatingTreeStore {
  constructor() {
    __publicField(this, "nodesRef", {
      current: [],
    });
    __publicField(this, "events", createEventEmitter());
  }
  addNode(node) {
    this.nodesRef.current.push(node);
  }
  removeNode(node) {
    const index2 = this.nodesRef.current.findIndex((n) => n === node);
    if (index2 !== -1) {
      this.nodesRef.current.splice(index2, 1);
    }
  }
}
const FloatingNodeContext = /* @__PURE__ */ reactExports.createContext(null);
const FloatingTreeContext = /* @__PURE__ */ reactExports.createContext(null);
const useFloatingParentNodeId = () => {
  var _a2;
  return ((_a2 = reactExports.useContext(FloatingNodeContext)) == null ? void 0 : _a2.id) || null;
};
const useFloatingTree = (externalTree) => {
  const contextTree = reactExports.useContext(FloatingTreeContext);
  return externalTree ?? contextTree;
};
function useFloatingNodeId(externalTree) {
  const id2 = useId();
  const tree = useFloatingTree(externalTree);
  const parentId = useFloatingParentNodeId();
  useIsoLayoutEffect(() => {
    if (!id2) {
      return void 0;
    }
    const node = {
      id: id2,
      parentId,
    };
    tree == null ? void 0 : tree.addNode(node);
    return () => {
      tree == null ? void 0 : tree.removeNode(node);
    };
  }, [tree, id2, parentId]);
  return id2;
}
function FloatingNode(props) {
  const { children, id: id2 } = props;
  const parentId = useFloatingParentNodeId();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(FloatingNodeContext.Provider, {
    value: reactExports.useMemo(
      () => ({
        id: id2,
        parentId,
      }),
      [id2, parentId],
    ),
    children,
  });
}
function FloatingTree(props) {
  const { children, externalTree } = props;
  const tree = useRefWithInit(() => externalTree ?? new FloatingTreeStore()).current;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(FloatingTreeContext.Provider, {
    value: tree,
    children,
  });
}
function createAttribute(name) {
  return `data-base-ui-${name}`;
}
function getDelay$1(value, prop, pointerType) {
  if (pointerType && !isMouseLikePointerType(pointerType)) {
    return 0;
  }
  if (typeof value === "number") {
    return value;
  }
  if (typeof value === "function") {
    const result = value();
    if (typeof result === "number") {
      return result;
    }
    return result == null ? void 0 : result[prop];
  }
  return value == null ? void 0 : value[prop];
}
const FloatingDelayGroupContext = /* @__PURE__ */ reactExports.createContext({
  hasProvider: false,
  timeoutMs: 0,
  delayRef: {
    current: 0,
  },
  initialDelayRef: {
    current: 0,
  },
  timeout: new Timeout(),
  currentIdRef: {
    current: null,
  },
  currentContextRef: {
    current: null,
  },
});
function FloatingDelayGroup(props) {
  const { children, delay: delay2, timeoutMs = 0 } = props;
  const delayRef = reactExports.useRef(delay2);
  const initialDelayRef = reactExports.useRef(delay2);
  const currentIdRef = reactExports.useRef(null);
  const currentContextRef = reactExports.useRef(null);
  const timeout = useTimeout();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(FloatingDelayGroupContext.Provider, {
    value: reactExports.useMemo(
      () => ({
        hasProvider: true,
        delayRef,
        initialDelayRef,
        currentIdRef,
        timeoutMs,
        currentContextRef,
        timeout,
      }),
      [timeoutMs, timeout],
    ),
    children,
  });
}
function useDelayGroup(
  context,
  options = {
    open: false,
  },
) {
  const store = "rootStore" in context ? context.rootStore : context;
  const floatingId = store.useState("floatingId");
  const { enabled = true, open } = options;
  const groupContext = reactExports.useContext(FloatingDelayGroupContext);
  const {
    currentIdRef,
    delayRef,
    timeoutMs,
    initialDelayRef,
    currentContextRef,
    hasProvider,
    timeout,
  } = groupContext;
  const [isInstantPhase, setIsInstantPhase] = reactExports.useState(false);
  useIsoLayoutEffect(() => {
    function unset() {
      var _a2;
      setIsInstantPhase(false);
      (_a2 = currentContextRef.current) == null ? void 0 : _a2.setIsInstantPhase(false);
      currentIdRef.current = null;
      currentContextRef.current = null;
      delayRef.current = initialDelayRef.current;
    }
    if (!enabled) {
      return void 0;
    }
    if (!currentIdRef.current) {
      return void 0;
    }
    if (!open && currentIdRef.current === floatingId) {
      setIsInstantPhase(false);
      if (timeoutMs) {
        const closingId = floatingId;
        timeout.start(timeoutMs, () => {
          if (
            store.select("open") ||
            (currentIdRef.current && currentIdRef.current !== closingId)
          ) {
            return;
          }
          unset();
        });
        return () => {
          timeout.clear();
        };
      }
      unset();
    }
    return void 0;
  }, [
    enabled,
    open,
    floatingId,
    currentIdRef,
    delayRef,
    timeoutMs,
    initialDelayRef,
    currentContextRef,
    timeout,
    store,
  ]);
  useIsoLayoutEffect(() => {
    if (!enabled) {
      return;
    }
    if (!open) {
      return;
    }
    const prevContext = currentContextRef.current;
    const prevId = currentIdRef.current;
    timeout.clear();
    currentContextRef.current = {
      onOpenChange: store.setOpen,
      setIsInstantPhase,
    };
    currentIdRef.current = floatingId;
    delayRef.current = {
      open: 0,
      close: getDelay$1(initialDelayRef.current, "close"),
    };
    if (prevId !== null && prevId !== floatingId) {
      setIsInstantPhase(true);
      prevContext == null ? void 0 : prevContext.setIsInstantPhase(true);
      prevContext == null
        ? void 0
        : prevContext.onOpenChange(false, createChangeEventDetails(none));
    } else {
      setIsInstantPhase(false);
      prevContext == null ? void 0 : prevContext.setIsInstantPhase(false);
    }
  }, [
    enabled,
    open,
    floatingId,
    store,
    currentIdRef,
    delayRef,
    timeoutMs,
    initialDelayRef,
    currentContextRef,
    timeout,
  ]);
  useIsoLayoutEffect(() => {
    return () => {
      currentContextRef.current = null;
    };
  }, [currentContextRef]);
  return reactExports.useMemo(
    () => ({
      hasProvider,
      delayRef,
      isInstantPhase,
    }),
    [hasProvider, delayRef, isInstantPhase],
  );
}
const visuallyHiddenBase = {
  clipPath: "inset(50%)",
  overflow: "hidden",
  whiteSpace: "nowrap",
  border: 0,
  padding: 0,
  width: 1,
  height: 1,
  margin: -1,
};
const visuallyHidden = {
  ...visuallyHiddenBase,
  position: "fixed",
  top: 0,
  left: 0,
};
const visuallyHiddenInput = {
  ...visuallyHiddenBase,
  position: "absolute",
};
function ownerDocument(node) {
  return (node == null ? void 0 : node.ownerDocument) || document;
}
const FocusGuard = /* @__PURE__ */ reactExports.forwardRef(function FocusGuard2(props, ref) {
  const [role, setRole] = reactExports.useState();
  useIsoLayoutEffect(() => {
    if (isSafari) {
      setRole("button");
    }
  }, []);
  const restProps = {
    tabIndex: 0,
    // Role is only for VoiceOver
    role,
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
    ...props,
    ref,
    style: visuallyHidden,
    "aria-hidden": role ? void 0 : true,
    ...restProps,
    "data-base-ui-focus-guard": "",
  });
});
let rafId = 0;
function enqueueFocus(el, options = {}) {
  const { preventScroll = false, cancelPrevious = true, sync = false } = options;
  if (cancelPrevious) {
    cancelAnimationFrame(rafId);
  }
  const exec = () =>
    el == null
      ? void 0
      : el.focus({
          preventScroll,
        });
  if (sync) {
    exec();
  } else {
    rafId = requestAnimationFrame(exec);
  }
}
const counters = {
  inert: /* @__PURE__ */ new WeakMap(),
  "aria-hidden": /* @__PURE__ */ new WeakMap(),
  none: /* @__PURE__ */ new WeakMap(),
};
function getCounterMap(control) {
  if (control === "inert") {
    return counters.inert;
  }
  if (control === "aria-hidden") {
    return counters["aria-hidden"];
  }
  return counters.none;
}
let uncontrolledElementsSet = /* @__PURE__ */ new WeakSet();
let markerMap = {};
let lockCount = 0;
const unwrapHost = (node) => node && (node.host || unwrapHost(node.parentNode));
const correctElements = (parent, targets) =>
  targets
    .map((target) => {
      if (parent.contains(target)) {
        return target;
      }
      const correctedTarget = unwrapHost(target);
      if (parent.contains(correctedTarget)) {
        return correctedTarget;
      }
      return null;
    })
    .filter((x) => x != null);
function applyAttributeToOthers(uncorrectedAvoidElements, body, ariaHidden, inert) {
  const markerName = "data-base-ui-inert";
  const controlAttribute = inert ? "inert" : ariaHidden ? "aria-hidden" : null;
  const avoidElements = correctElements(body, uncorrectedAvoidElements);
  const elementsToKeep = /* @__PURE__ */ new Set();
  const elementsToStop = new Set(avoidElements);
  const hiddenElements = [];
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  const markerCounter = markerMap[markerName];
  avoidElements.forEach(keep);
  deep(body);
  elementsToKeep.clear();
  function keep(el) {
    if (!el || elementsToKeep.has(el)) {
      return;
    }
    elementsToKeep.add(el);
    if (el.parentNode) {
      keep(el.parentNode);
    }
  }
  function deep(parent) {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    [].forEach.call(parent.children, (node) => {
      if (getNodeName(node) === "script") {
        return;
      }
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        const attr2 = controlAttribute ? node.getAttribute(controlAttribute) : null;
        const alreadyHidden = attr2 !== null && attr2 !== "false";
        const counterMap = getCounterMap(controlAttribute);
        const counterValue = (counterMap.get(node) || 0) + 1;
        const markerValue = (markerCounter.get(node) || 0) + 1;
        counterMap.set(node, counterValue);
        markerCounter.set(node, markerValue);
        hiddenElements.push(node);
        if (counterValue === 1 && alreadyHidden) {
          uncontrolledElementsSet.add(node);
        }
        if (markerValue === 1) {
          node.setAttribute(markerName, "");
        }
        if (!alreadyHidden && controlAttribute) {
          node.setAttribute(controlAttribute, controlAttribute === "inert" ? "" : "true");
        }
      }
    });
  }
  lockCount += 1;
  return () => {
    hiddenElements.forEach((element) => {
      const counterMap = getCounterMap(controlAttribute);
      const currentCounterValue = counterMap.get(element) || 0;
      const counterValue = currentCounterValue - 1;
      const markerValue = (markerCounter.get(element) || 0) - 1;
      counterMap.set(element, counterValue);
      markerCounter.set(element, markerValue);
      if (!counterValue) {
        if (!uncontrolledElementsSet.has(element) && controlAttribute) {
          element.removeAttribute(controlAttribute);
        }
        uncontrolledElementsSet.delete(element);
      }
      if (!markerValue) {
        element.removeAttribute(markerName);
      }
    });
    lockCount -= 1;
    if (!lockCount) {
      counters.inert = /* @__PURE__ */ new WeakMap();
      counters["aria-hidden"] = /* @__PURE__ */ new WeakMap();
      counters.none = /* @__PURE__ */ new WeakMap();
      uncontrolledElementsSet = /* @__PURE__ */ new WeakSet();
      markerMap = {};
    }
  };
}
function markOthers(avoidElements, ariaHidden = false, inert = false) {
  const body = getDocument(avoidElements[0]).body;
  return applyAttributeToOthers(
    avoidElements.concat(Array.from(body.querySelectorAll("[aria-live]"))),
    body,
    ariaHidden,
    inert,
  );
}
const PortalContext = /* @__PURE__ */ reactExports.createContext(null);
const usePortalContext = () => reactExports.useContext(PortalContext);
const attr = createAttribute("portal");
function useFloatingPortalNode(props = {}) {
  const {
    ref,
    container: containerProp,
    componentProps = EMPTY_OBJECT,
    elementProps,
    elementState,
  } = props;
  const uniqueId = useId();
  const portalContext = usePortalContext();
  const parentPortalNode = portalContext == null ? void 0 : portalContext.portalNode;
  const [containerElement, setContainerElement] = reactExports.useState(null);
  const [portalNode, setPortalNode] = reactExports.useState(null);
  const setPortalNodeRef = useStableCallback((node) => {
    if (node !== null) {
      setPortalNode(node);
    }
  });
  const containerRef = reactExports.useRef(null);
  useIsoLayoutEffect(() => {
    if (containerProp === null) {
      if (containerRef.current) {
        containerRef.current = null;
        setPortalNode(null);
        setContainerElement(null);
      }
      return;
    }
    if (uniqueId == null) {
      return;
    }
    const resolvedContainer =
      (containerProp && (isNode(containerProp) ? containerProp : containerProp.current)) ??
      parentPortalNode ??
      document.body;
    if (resolvedContainer == null) {
      if (containerRef.current) {
        containerRef.current = null;
        setPortalNode(null);
        setContainerElement(null);
      }
      return;
    }
    if (containerRef.current !== resolvedContainer) {
      containerRef.current = resolvedContainer;
      setPortalNode(null);
      setContainerElement(resolvedContainer);
    }
  }, [containerProp, parentPortalNode, uniqueId]);
  const portalElement = useRenderElement("div", componentProps, {
    ref: [ref, setPortalNodeRef],
    state: elementState,
    props: [
      {
        id: uniqueId,
        [attr]: "",
      },
      elementProps,
    ],
  });
  const portalSubtree =
    containerElement && portalElement
      ? /* @__PURE__ */ reactDomExports.createPortal(portalElement, containerElement)
      : null;
  return {
    portalNode,
    portalSubtree,
  };
}
const FloatingPortal = /* @__PURE__ */ reactExports.forwardRef(
  function FloatingPortal2(componentProps, forwardedRef) {
    const { children, container, className, render, renderGuards, ...elementProps } =
      componentProps;
    const { portalNode, portalSubtree } = useFloatingPortalNode({
      container,
      ref: forwardedRef,
      componentProps,
      elementProps,
    });
    const beforeOutsideRef = reactExports.useRef(null);
    const afterOutsideRef = reactExports.useRef(null);
    const beforeInsideRef = reactExports.useRef(null);
    const afterInsideRef = reactExports.useRef(null);
    const [focusManagerState, setFocusManagerState] = reactExports.useState(null);
    const modal = focusManagerState == null ? void 0 : focusManagerState.modal;
    const open = focusManagerState == null ? void 0 : focusManagerState.open;
    const shouldRenderGuards =
      typeof renderGuards === "boolean"
        ? renderGuards
        : !!focusManagerState && !focusManagerState.modal && focusManagerState.open && !!portalNode;
    reactExports.useEffect(() => {
      if (!portalNode || modal) {
        return void 0;
      }
      function onFocus(event) {
        if (portalNode && event.relatedTarget && isOutsideEvent(event)) {
          const focusing = event.type === "focusin";
          const manageFocus = focusing ? enableFocusInside : disableFocusInside;
          manageFocus(portalNode);
        }
      }
      portalNode.addEventListener("focusin", onFocus, true);
      portalNode.addEventListener("focusout", onFocus, true);
      return () => {
        portalNode.removeEventListener("focusin", onFocus, true);
        portalNode.removeEventListener("focusout", onFocus, true);
      };
    }, [portalNode, modal]);
    reactExports.useEffect(() => {
      if (!portalNode || open) {
        return;
      }
      enableFocusInside(portalNode);
    }, [open, portalNode]);
    const portalContextValue = reactExports.useMemo(
      () => ({
        beforeOutsideRef,
        afterOutsideRef,
        beforeInsideRef,
        afterInsideRef,
        portalNode,
        setFocusManagerState,
      }),
      [portalNode],
    );
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
      children: [
        portalSubtree,
        /* @__PURE__ */ jsxRuntimeExports.jsxs(PortalContext.Provider, {
          value: portalContextValue,
          children: [
            shouldRenderGuards &&
              portalNode &&
              /* @__PURE__ */ jsxRuntimeExports.jsx(FocusGuard, {
                "data-type": "outside",
                ref: beforeOutsideRef,
                onFocus: (event) => {
                  var _a2;
                  if (isOutsideEvent(event, portalNode)) {
                    (_a2 = beforeInsideRef.current) == null ? void 0 : _a2.focus();
                  } else {
                    const domReference = focusManagerState ? focusManagerState.domReference : null;
                    const prevTabbable = getPreviousTabbable(domReference);
                    prevTabbable == null ? void 0 : prevTabbable.focus();
                  }
                },
              }),
            shouldRenderGuards &&
              portalNode &&
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
                "aria-owns": portalNode.id,
                style: ownerVisuallyHidden,
              }),
            portalNode && /* @__PURE__ */ reactDomExports.createPortal(children, portalNode),
            shouldRenderGuards &&
              portalNode &&
              /* @__PURE__ */ jsxRuntimeExports.jsx(FocusGuard, {
                "data-type": "outside",
                ref: afterOutsideRef,
                onFocus: (event) => {
                  var _a2;
                  if (isOutsideEvent(event, portalNode)) {
                    (_a2 = afterInsideRef.current) == null ? void 0 : _a2.focus();
                  } else {
                    const domReference = focusManagerState ? focusManagerState.domReference : null;
                    const nextTabbable = getNextTabbable(domReference);
                    nextTabbable == null ? void 0 : nextTabbable.focus();
                    if (focusManagerState == null ? void 0 : focusManagerState.closeOnFocusOut) {
                      focusManagerState == null
                        ? void 0
                        : focusManagerState.onOpenChange(
                            false,
                            createChangeEventDetails(focusOut, event.nativeEvent),
                          );
                    }
                  }
                },
              }),
          ],
        }),
      ],
    });
  },
);
function getEventType(event, lastInteractionType) {
  const win = getWindow(event.target);
  if (event instanceof win.KeyboardEvent) {
    return "keyboard";
  }
  if (event instanceof win.FocusEvent) {
    return lastInteractionType || "keyboard";
  }
  if ("pointerType" in event) {
    return event.pointerType || "keyboard";
  }
  if ("touches" in event) {
    return "touch";
  }
  if (event instanceof win.MouseEvent) {
    return lastInteractionType || (event.detail === 0 ? "keyboard" : "mouse");
  }
  return "";
}
const LIST_LIMIT = 20;
let previouslyFocusedElements = [];
function clearDisconnectedPreviouslyFocusedElements() {
  previouslyFocusedElements = previouslyFocusedElements.filter((el) => el.isConnected);
}
function addPreviouslyFocusedElement(element) {
  clearDisconnectedPreviouslyFocusedElements();
  if (element && getNodeName(element) !== "body") {
    previouslyFocusedElements.push(element);
    if (previouslyFocusedElements.length > LIST_LIMIT) {
      previouslyFocusedElements = previouslyFocusedElements.slice(-LIST_LIMIT);
    }
  }
}
function getPreviouslyFocusedElement() {
  clearDisconnectedPreviouslyFocusedElements();
  return previouslyFocusedElements[previouslyFocusedElements.length - 1];
}
function getFirstTabbableElement(container) {
  if (!container) {
    return null;
  }
  const tabbableOptions = getTabbableOptions();
  if (isTabbable(container, tabbableOptions)) {
    return container;
  }
  return tabbable(container, tabbableOptions)[0] || container;
}
function isFocusable(element) {
  if (!element || !element.isConnected) {
    return false;
  }
  if (typeof element.checkVisibility === "function") {
    return element.checkVisibility();
  }
  return getComputedStyle$1(element).display !== "none";
}
function handleTabIndex(floatingFocusElement, orderRef) {
  var _a2;
  if (
    !orderRef.current.includes("floating") &&
    !((_a2 = floatingFocusElement.getAttribute("role")) == null ? void 0 : _a2.includes("dialog"))
  ) {
    return;
  }
  const options = getTabbableOptions();
  const focusableElements = focusable(floatingFocusElement, options);
  const tabbableContent = focusableElements.filter((element) => {
    const dataTabIndex = element.getAttribute("data-tabindex") || "";
    return (
      isTabbable(element, options) ||
      (element.hasAttribute("data-tabindex") && !dataTabIndex.startsWith("-"))
    );
  });
  const tabIndex = floatingFocusElement.getAttribute("tabindex");
  if (orderRef.current.includes("floating") || tabbableContent.length === 0) {
    if (tabIndex !== "0") {
      floatingFocusElement.setAttribute("tabindex", "0");
    }
  } else if (
    tabIndex !== "-1" ||
    (floatingFocusElement.hasAttribute("data-tabindex") &&
      floatingFocusElement.getAttribute("data-tabindex") !== "-1")
  ) {
    floatingFocusElement.setAttribute("tabindex", "-1");
    floatingFocusElement.setAttribute("data-tabindex", "-1");
  }
}
function FloatingFocusManager(props) {
  const {
    context,
    children,
    disabled: disabled2 = false,
    order = ["content"],
    initialFocus = true,
    returnFocus = true,
    restoreFocus = false,
    modal = true,
    closeOnFocusOut = true,
    openInteractionType = "",
    getInsideElements: getInsideElementsProp = () => [],
    nextFocusableElement,
    previousFocusableElement,
    beforeContentFocusGuardRef,
    externalTree,
  } = props;
  const store = "rootStore" in context ? context.rootStore : context;
  const open = store.useState("open");
  const domReference = store.useState("domReferenceElement");
  const floating = store.useState("floatingElement");
  const { events, dataRef } = store.context;
  const getNodeId = useStableCallback(() => {
    var _a2;
    return (_a2 = dataRef.current.floatingContext) == null ? void 0 : _a2.nodeId;
  });
  const getInsideElements = useStableCallback(getInsideElementsProp);
  const ignoreInitialFocus = initialFocus === false;
  const isUntrappedTypeableCombobox = isTypeableCombobox(domReference) && ignoreInitialFocus;
  const orderRef = useValueAsRef(order);
  const initialFocusRef = useValueAsRef(initialFocus);
  const returnFocusRef = useValueAsRef(returnFocus);
  const openInteractionTypeRef = useValueAsRef(openInteractionType);
  const tree = useFloatingTree(externalTree);
  const portalContext = usePortalContext();
  const startDismissButtonRef = reactExports.useRef(null);
  const endDismissButtonRef = reactExports.useRef(null);
  const preventReturnFocusRef = reactExports.useRef(false);
  const isPointerDownRef = reactExports.useRef(false);
  const pointerDownOutsideRef = reactExports.useRef(false);
  const tabbableIndexRef = reactExports.useRef(-1);
  const closeTypeRef = reactExports.useRef("");
  const lastInteractionTypeRef = reactExports.useRef("");
  const beforeGuardRef = reactExports.useRef(null);
  const afterGuardRef = reactExports.useRef(null);
  const mergedBeforeGuardRef = useMergedRefs(
    beforeGuardRef,
    beforeContentFocusGuardRef,
    portalContext == null ? void 0 : portalContext.beforeInsideRef,
  );
  const mergedAfterGuardRef = useMergedRefs(
    afterGuardRef,
    portalContext == null ? void 0 : portalContext.afterInsideRef,
  );
  const blurTimeout = useTimeout();
  const pointerDownTimeout = useTimeout();
  const restoreFocusFrame = useAnimationFrame();
  const isInsidePortal = portalContext != null;
  const floatingFocusElement = getFloatingFocusElement(floating);
  const getTabbableContent = useStableCallback((container = floatingFocusElement) => {
    return container ? tabbable(container, getTabbableOptions()) : [];
  });
  const getTabbableElements = useStableCallback((container) => {
    const content = getTabbableContent(container);
    return orderRef.current
      .map(() => content)
      .filter(Boolean)
      .flat();
  });
  reactExports.useEffect(() => {
    if (disabled2) {
      return void 0;
    }
    if (!modal) {
      return void 0;
    }
    function onKeyDown(event) {
      if (event.key === "Tab") {
        if (
          contains(floatingFocusElement, activeElement(getDocument(floatingFocusElement))) &&
          getTabbableContent().length === 0 &&
          !isUntrappedTypeableCombobox
        ) {
          stopEvent(event);
        }
      }
    }
    const doc = getDocument(floatingFocusElement);
    doc.addEventListener("keydown", onKeyDown);
    return () => {
      doc.removeEventListener("keydown", onKeyDown);
    };
  }, [
    disabled2,
    domReference,
    floatingFocusElement,
    modal,
    orderRef,
    isUntrappedTypeableCombobox,
    getTabbableContent,
    getTabbableElements,
  ]);
  reactExports.useEffect(() => {
    if (disabled2) {
      return void 0;
    }
    if (!floating) {
      return void 0;
    }
    function handleFocusIn(event) {
      const target = getTarget(event);
      const tabbableContent = getTabbableContent();
      const tabbableIndex = tabbableContent.indexOf(target);
      if (tabbableIndex !== -1) {
        tabbableIndexRef.current = tabbableIndex;
      }
    }
    floating.addEventListener("focusin", handleFocusIn);
    return () => {
      floating.removeEventListener("focusin", handleFocusIn);
    };
  }, [disabled2, floating, getTabbableContent]);
  reactExports.useEffect(() => {
    if (disabled2 || !open) {
      return void 0;
    }
    const doc = getDocument(floatingFocusElement);
    function clearPointerDownOutside() {
      pointerDownOutsideRef.current = false;
    }
    function onPointerDown(event) {
      const target = getTarget(event);
      const pointerTargetInside =
        contains(floating, target) ||
        contains(domReference, target) ||
        contains(portalContext == null ? void 0 : portalContext.portalNode, target);
      pointerDownOutsideRef.current = !pointerTargetInside;
      lastInteractionTypeRef.current = event.pointerType || "keyboard";
    }
    function onKeyDown() {
      lastInteractionTypeRef.current = "keyboard";
    }
    doc.addEventListener("pointerdown", onPointerDown, true);
    doc.addEventListener("pointerup", clearPointerDownOutside, true);
    doc.addEventListener("pointercancel", clearPointerDownOutside, true);
    doc.addEventListener("keydown", onKeyDown, true);
    return () => {
      doc.removeEventListener("pointerdown", onPointerDown, true);
      doc.removeEventListener("pointerup", clearPointerDownOutside, true);
      doc.removeEventListener("pointercancel", clearPointerDownOutside, true);
      doc.removeEventListener("keydown", onKeyDown, true);
    };
  }, [disabled2, floating, domReference, floatingFocusElement, open, portalContext]);
  reactExports.useEffect(() => {
    if (disabled2) {
      return void 0;
    }
    if (!closeOnFocusOut) {
      return void 0;
    }
    function handlePointerDown() {
      isPointerDownRef.current = true;
      pointerDownTimeout.start(0, () => {
        isPointerDownRef.current = false;
      });
    }
    function handleFocusOutside(event) {
      const relatedTarget = event.relatedTarget;
      const currentTarget = event.currentTarget;
      const target = getTarget(event);
      queueMicrotask(() => {
        const nodeId = getNodeId();
        const triggers = store.context.triggerElements;
        const isRelatedFocusGuard =
          (relatedTarget == null
            ? void 0
            : relatedTarget.hasAttribute(createAttribute("focus-guard"))) &&
          [
            beforeGuardRef.current,
            afterGuardRef.current,
            portalContext == null ? void 0 : portalContext.beforeInsideRef.current,
            portalContext == null ? void 0 : portalContext.afterInsideRef.current,
            portalContext == null ? void 0 : portalContext.beforeOutsideRef.current,
            portalContext == null ? void 0 : portalContext.afterOutsideRef.current,
            resolveRef(previousFocusableElement),
            resolveRef(nextFocusableElement),
          ].includes(relatedTarget);
        const movedToUnrelatedNode = !(
          contains(domReference, relatedTarget) ||
          contains(floating, relatedTarget) ||
          contains(relatedTarget, floating) ||
          contains(portalContext == null ? void 0 : portalContext.portalNode, relatedTarget) ||
          (relatedTarget != null && triggers.hasElement(relatedTarget)) ||
          triggers.hasMatchingElement((trigger) => contains(trigger, relatedTarget)) ||
          isRelatedFocusGuard ||
          (tree &&
            (getNodeChildren(tree.nodesRef.current, nodeId).find((node) => {
              var _a2, _b;
              return (
                contains(
                  (_a2 = node.context) == null ? void 0 : _a2.elements.floating,
                  relatedTarget,
                ) ||
                contains(
                  (_b = node.context) == null ? void 0 : _b.elements.domReference,
                  relatedTarget,
                )
              );
            }) ||
              getNodeAncestors(tree.nodesRef.current, nodeId).find((node) => {
                var _a2, _b, _c;
                return (
                  [
                    (_a2 = node.context) == null ? void 0 : _a2.elements.floating,
                    getFloatingFocusElement(
                      (_b = node.context) == null ? void 0 : _b.elements.floating,
                    ),
                  ].includes(relatedTarget) ||
                  ((_c = node.context) == null ? void 0 : _c.elements.domReference) ===
                    relatedTarget
                );
              })))
        );
        if (currentTarget === domReference && floatingFocusElement) {
          handleTabIndex(floatingFocusElement, orderRef);
        }
        if (
          restoreFocus &&
          currentTarget !== domReference &&
          !isFocusable(target) &&
          activeElement(getDocument(floatingFocusElement)) ===
            getDocument(floatingFocusElement).body
        ) {
          if (isHTMLElement(floatingFocusElement)) {
            floatingFocusElement.focus();
            if (restoreFocus === "popup") {
              restoreFocusFrame.request(() => {
                floatingFocusElement.focus();
              });
              return;
            }
          }
          const prevTabbableIndex = tabbableIndexRef.current;
          const tabbableContent = getTabbableContent();
          const nodeToFocus =
            tabbableContent[prevTabbableIndex] ||
            tabbableContent[tabbableContent.length - 1] ||
            floatingFocusElement;
          if (isHTMLElement(nodeToFocus)) {
            nodeToFocus.focus();
          }
        }
        if (dataRef.current.insideReactTree) {
          dataRef.current.insideReactTree = false;
          return;
        }
        if (
          (isUntrappedTypeableCombobox ? true : !modal) &&
          relatedTarget &&
          movedToUnrelatedNode &&
          !isPointerDownRef.current && // Fix React 18 Strict Mode returnFocus due to double rendering.
          // For an "untrapped" typeable combobox (input role=combobox with
          // initialFocus=false), re-opening the popup and tabbing out should still close it even
          // when the previously focused element (e.g. the next tabbable outside the popup) is
          // focused again. Otherwise, the popup remains open on the second Tab sequence:
          // click input -> Tab (closes) -> click input -> Tab.
          // Allow closing when `isUntrappedTypeableCombobox` regardless of the previously focused element.
          (isUntrappedTypeableCombobox || relatedTarget !== getPreviouslyFocusedElement())
        ) {
          preventReturnFocusRef.current = true;
          store.setOpen(false, createChangeEventDetails(focusOut, event));
        }
      });
    }
    function markInsideReactTree() {
      if (pointerDownOutsideRef.current) {
        return;
      }
      dataRef.current.insideReactTree = true;
      blurTimeout.start(0, () => {
        dataRef.current.insideReactTree = false;
      });
    }
    const domReferenceElement = isHTMLElement(domReference) ? domReference : null;
    const cleanups = [];
    if (!floating && !domReferenceElement) {
      return void 0;
    }
    if (domReferenceElement) {
      domReferenceElement.addEventListener("focusout", handleFocusOutside);
      domReferenceElement.addEventListener("pointerdown", handlePointerDown);
      cleanups.push(() => {
        domReferenceElement.removeEventListener("focusout", handleFocusOutside);
        domReferenceElement.removeEventListener("pointerdown", handlePointerDown);
      });
    }
    if (floating) {
      floating.addEventListener("focusout", handleFocusOutside);
      if (portalContext) {
        floating.addEventListener("focusout", markInsideReactTree, true);
        cleanups.push(() => {
          floating.removeEventListener("focusout", markInsideReactTree, true);
        });
      }
      cleanups.push(() => {
        floating.removeEventListener("focusout", handleFocusOutside);
      });
    }
    return () => {
      cleanups.forEach((cleanup) => {
        cleanup();
      });
    };
  }, [
    disabled2,
    domReference,
    floating,
    floatingFocusElement,
    modal,
    tree,
    portalContext,
    store,
    closeOnFocusOut,
    restoreFocus,
    getTabbableContent,
    isUntrappedTypeableCombobox,
    getNodeId,
    orderRef,
    dataRef,
    blurTimeout,
    pointerDownTimeout,
    restoreFocusFrame,
    nextFocusableElement,
    previousFocusableElement,
  ]);
  reactExports.useEffect(() => {
    var _a2, _b, _c;
    if (disabled2 || !floating || !open) {
      return void 0;
    }
    const portalNodes = Array.from(
      ((_a2 = portalContext == null ? void 0 : portalContext.portalNode) == null
        ? void 0
        : _a2.querySelectorAll(`[${createAttribute("portal")}]`)) || [],
    );
    const ancestors = tree ? getNodeAncestors(tree.nodesRef.current, getNodeId()) : [];
    const rootAncestorComboboxDomReference =
      (_c =
        (_b = ancestors.find((node) => {
          var _a3;
          return isTypeableCombobox(
            ((_a3 = node.context) == null ? void 0 : _a3.elements.domReference) || null,
          );
        })) == null
          ? void 0
          : _b.context) == null
        ? void 0
        : _c.elements.domReference;
    const insideElements = [
      floating,
      rootAncestorComboboxDomReference,
      ...portalNodes,
      ...getInsideElements(),
      startDismissButtonRef.current,
      endDismissButtonRef.current,
      beforeGuardRef.current,
      afterGuardRef.current,
      portalContext == null ? void 0 : portalContext.beforeOutsideRef.current,
      portalContext == null ? void 0 : portalContext.afterOutsideRef.current,
      resolveRef(previousFocusableElement),
      resolveRef(nextFocusableElement),
      isUntrappedTypeableCombobox ? domReference : null,
    ].filter((x) => x != null);
    const cleanup = markOthers(insideElements, modal || isUntrappedTypeableCombobox);
    return () => {
      cleanup();
    };
  }, [
    open,
    disabled2,
    domReference,
    floating,
    modal,
    orderRef,
    portalContext,
    isUntrappedTypeableCombobox,
    tree,
    getNodeId,
    getInsideElements,
    nextFocusableElement,
    previousFocusableElement,
  ]);
  useIsoLayoutEffect(() => {
    if (!open || disabled2 || !isHTMLElement(floatingFocusElement)) {
      return;
    }
    const doc = getDocument(floatingFocusElement);
    const previouslyFocusedElement = activeElement(doc);
    queueMicrotask(() => {
      const focusableElements = getTabbableElements(floatingFocusElement);
      const initialFocusValueOrFn = initialFocusRef.current;
      const resolvedInitialFocus =
        typeof initialFocusValueOrFn === "function"
          ? initialFocusValueOrFn(openInteractionTypeRef.current || "")
          : initialFocusValueOrFn;
      if (resolvedInitialFocus === void 0 || resolvedInitialFocus === false) {
        return;
      }
      let elToFocus;
      if (resolvedInitialFocus === true || resolvedInitialFocus === null) {
        elToFocus = focusableElements[0] || floatingFocusElement;
      } else {
        elToFocus = resolveRef(resolvedInitialFocus);
      }
      elToFocus = elToFocus || focusableElements[0] || floatingFocusElement;
      const focusAlreadyInsideFloatingEl = contains(floatingFocusElement, previouslyFocusedElement);
      if (focusAlreadyInsideFloatingEl) {
        return;
      }
      enqueueFocus(elToFocus, {
        preventScroll: elToFocus === floatingFocusElement,
      });
    });
  }, [
    disabled2,
    open,
    floatingFocusElement,
    ignoreInitialFocus,
    getTabbableElements,
    initialFocusRef,
    openInteractionTypeRef,
  ]);
  useIsoLayoutEffect(() => {
    if (disabled2 || !floatingFocusElement) {
      return void 0;
    }
    const doc = getDocument(floatingFocusElement);
    const previouslyFocusedElement = activeElement(doc);
    addPreviouslyFocusedElement(previouslyFocusedElement);
    function onOpenChangeLocal(details) {
      if (!details.open) {
        closeTypeRef.current = getEventType(details.nativeEvent, lastInteractionTypeRef.current);
      }
      if (details.reason === triggerHover && details.nativeEvent.type === "mouseleave") {
        preventReturnFocusRef.current = true;
      }
      if (details.reason !== outsidePress) {
        return;
      }
      if (details.nested) {
        preventReturnFocusRef.current = false;
      } else if (
        isVirtualClick(details.nativeEvent) ||
        isVirtualPointerEvent(details.nativeEvent)
      ) {
        preventReturnFocusRef.current = false;
      } else {
        let isPreventScrollSupported = false;
        document.createElement("div").focus({
          get preventScroll() {
            isPreventScrollSupported = true;
            return false;
          },
        });
        if (isPreventScrollSupported) {
          preventReturnFocusRef.current = false;
        } else {
          preventReturnFocusRef.current = true;
        }
      }
    }
    events.on("openchange", onOpenChangeLocal);
    const fallbackEl = doc.createElement("span");
    fallbackEl.setAttribute("tabindex", "-1");
    fallbackEl.setAttribute("aria-hidden", "true");
    Object.assign(fallbackEl.style, visuallyHidden);
    if (isInsidePortal && domReference) {
      domReference.insertAdjacentElement("afterend", fallbackEl);
    }
    function getReturnElement() {
      const returnFocusValueOrFn = returnFocusRef.current;
      let resolvedReturnFocusValue =
        typeof returnFocusValueOrFn === "function"
          ? returnFocusValueOrFn(closeTypeRef.current)
          : returnFocusValueOrFn;
      if (resolvedReturnFocusValue === void 0 || resolvedReturnFocusValue === false) {
        return null;
      }
      if (resolvedReturnFocusValue === null) {
        resolvedReturnFocusValue = true;
      }
      if (typeof resolvedReturnFocusValue === "boolean") {
        const el = domReference || getPreviouslyFocusedElement();
        return el && el.isConnected ? el : fallbackEl;
      }
      const fallback = domReference || getPreviouslyFocusedElement() || fallbackEl;
      return resolveRef(resolvedReturnFocusValue) || fallback;
    }
    return () => {
      events.off("openchange", onOpenChangeLocal);
      const activeEl = activeElement(doc);
      const isFocusInsideFloatingTree =
        contains(floating, activeEl) ||
        (tree &&
          getNodeChildren(tree.nodesRef.current, getNodeId(), false).some((node) => {
            var _a2;
            return contains(
              (_a2 = node.context) == null ? void 0 : _a2.elements.floating,
              activeEl,
            );
          }));
      const returnElement = getReturnElement();
      queueMicrotask(() => {
        const tabbableReturnElement = getFirstTabbableElement(returnElement);
        const hasExplicitReturnFocus = typeof returnFocusRef.current !== "boolean";
        if (
          // eslint-disable-next-line react-hooks/exhaustive-deps
          returnFocusRef.current &&
          !preventReturnFocusRef.current &&
          isHTMLElement(tabbableReturnElement) && // If the focus moved somewhere else after mount, avoid returning focus
          // since it likely entered a different element which should be
          // respected: https://github.com/floating-ui/floating-ui/issues/2607
          (!hasExplicitReturnFocus && tabbableReturnElement !== activeEl && activeEl !== doc.body
            ? isFocusInsideFloatingTree
            : true)
        ) {
          tabbableReturnElement.focus({
            preventScroll: true,
          });
        }
        fallbackEl.remove();
      });
    };
  }, [
    disabled2,
    floating,
    floatingFocusElement,
    returnFocusRef,
    dataRef,
    events,
    tree,
    isInsidePortal,
    domReference,
    getNodeId,
  ]);
  reactExports.useEffect(() => {
    queueMicrotask(() => {
      preventReturnFocusRef.current = false;
    });
  }, [disabled2]);
  reactExports.useEffect(() => {
    if (disabled2 || !open) {
      return void 0;
    }
    function handlePointerDown(event) {
      const target = getTarget(event);
      if (target == null ? void 0 : target.closest(`[${CLICK_TRIGGER_IDENTIFIER}]`)) {
        isPointerDownRef.current = true;
      }
    }
    const doc = getDocument(floatingFocusElement);
    doc.addEventListener("pointerdown", handlePointerDown, true);
    return () => {
      doc.removeEventListener("pointerdown", handlePointerDown, true);
    };
  }, [disabled2, open, floatingFocusElement]);
  useIsoLayoutEffect(() => {
    if (disabled2) {
      return void 0;
    }
    if (!portalContext) {
      return void 0;
    }
    portalContext.setFocusManagerState({
      modal,
      closeOnFocusOut,
      open,
      onOpenChange: store.setOpen,
      domReference,
    });
    return () => {
      portalContext.setFocusManagerState(null);
    };
  }, [disabled2, portalContext, modal, open, store, closeOnFocusOut, domReference]);
  useIsoLayoutEffect(() => {
    if (disabled2 || !floatingFocusElement) {
      return void 0;
    }
    handleTabIndex(floatingFocusElement, orderRef);
    return () => {
      queueMicrotask(clearDisconnectedPreviouslyFocusedElements);
    };
  }, [disabled2, floatingFocusElement, orderRef]);
  const shouldRenderGuards =
    !disabled2 && (modal ? !isUntrappedTypeableCombobox : true) && (isInsidePortal || modal);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [
      shouldRenderGuards &&
        /* @__PURE__ */ jsxRuntimeExports.jsx(FocusGuard, {
          "data-type": "inside",
          ref: mergedBeforeGuardRef,
          onFocus: (event) => {
            var _a2;
            if (modal) {
              const els = getTabbableElements();
              enqueueFocus(els[els.length - 1]);
            } else if (portalContext == null ? void 0 : portalContext.portalNode) {
              preventReturnFocusRef.current = false;
              if (isOutsideEvent(event, portalContext.portalNode)) {
                const nextTabbable = getNextTabbable(domReference);
                nextTabbable == null ? void 0 : nextTabbable.focus();
              } else {
                (_a2 = resolveRef(previousFocusableElement ?? portalContext.beforeOutsideRef)) ==
                null
                  ? void 0
                  : _a2.focus();
              }
            }
          },
        }),
      children,
      shouldRenderGuards &&
        /* @__PURE__ */ jsxRuntimeExports.jsx(FocusGuard, {
          "data-type": "inside",
          ref: mergedAfterGuardRef,
          onFocus: (event) => {
            var _a2;
            if (modal) {
              enqueueFocus(getTabbableElements()[0]);
            } else if (portalContext == null ? void 0 : portalContext.portalNode) {
              if (closeOnFocusOut) {
                preventReturnFocusRef.current = true;
              }
              if (isOutsideEvent(event, portalContext.portalNode)) {
                const prevTabbable = getPreviousTabbable(domReference);
                prevTabbable == null ? void 0 : prevTabbable.focus();
              } else {
                (_a2 = resolveRef(nextFocusableElement ?? portalContext.afterOutsideRef)) == null
                  ? void 0
                  : _a2.focus();
              }
            }
          },
        }),
    ],
  });
}
function useClick(context, props = {}) {
  const store = "rootStore" in context ? context.rootStore : context;
  const dataRef = store.context.dataRef;
  const {
    enabled = true,
    event: eventOption = "click",
    toggle = true,
    ignoreMouse = false,
    stickIfOpen = true,
    touchOpenDelay = 0,
  } = props;
  const pointerTypeRef = reactExports.useRef(void 0);
  const frame2 = useAnimationFrame();
  const touchOpenTimeout = useTimeout();
  const reference = reactExports.useMemo(
    () => ({
      onPointerDown(event) {
        pointerTypeRef.current = event.pointerType;
      },
      onMouseDown(event) {
        const pointerType = pointerTypeRef.current;
        const nativeEvent = event.nativeEvent;
        const open = store.select("open");
        if (
          event.button !== 0 ||
          eventOption === "click" ||
          (isMouseLikePointerType(pointerType, true) && ignoreMouse)
        ) {
          return;
        }
        const openEvent = dataRef.current.openEvent;
        const openEventType = openEvent == null ? void 0 : openEvent.type;
        const hasClickedOnInactiveTrigger =
          store.select("domReferenceElement") !== event.currentTarget;
        const nextOpen =
          (open && hasClickedOnInactiveTrigger) ||
          !(
            open &&
            toggle &&
            (openEvent && stickIfOpen
              ? openEventType === "click" || openEventType === "mousedown"
              : true)
          );
        if (isTypeableElement(nativeEvent.target)) {
          const details = createChangeEventDetails(triggerPress, nativeEvent, nativeEvent.target);
          if (nextOpen && pointerType === "touch" && touchOpenDelay > 0) {
            touchOpenTimeout.start(touchOpenDelay, () => {
              store.setOpen(true, details);
            });
          } else {
            store.setOpen(nextOpen, details);
          }
          return;
        }
        const eventCurrentTarget = event.currentTarget;
        frame2.request(() => {
          const details = createChangeEventDetails(triggerPress, nativeEvent, eventCurrentTarget);
          if (nextOpen && pointerType === "touch" && touchOpenDelay > 0) {
            touchOpenTimeout.start(touchOpenDelay, () => {
              store.setOpen(true, details);
            });
          } else {
            store.setOpen(nextOpen, details);
          }
        });
      },
      onClick(event) {
        if (eventOption === "mousedown-only") {
          return;
        }
        const pointerType = pointerTypeRef.current;
        if (eventOption === "mousedown" && pointerType) {
          pointerTypeRef.current = void 0;
          return;
        }
        if (isMouseLikePointerType(pointerType, true) && ignoreMouse) {
          return;
        }
        const open = store.select("open");
        const openEvent = dataRef.current.openEvent;
        const hasClickedOnInactiveTrigger =
          store.select("domReferenceElement") !== event.currentTarget;
        const nextOpen =
          (open && hasClickedOnInactiveTrigger) ||
          !(open && toggle && (openEvent && stickIfOpen ? isClickLikeEvent(openEvent) : true));
        const details = createChangeEventDetails(
          triggerPress,
          event.nativeEvent,
          event.currentTarget,
        );
        if (nextOpen && pointerType === "touch" && touchOpenDelay > 0) {
          touchOpenTimeout.start(touchOpenDelay, () => {
            store.setOpen(true, details);
          });
        } else {
          store.setOpen(nextOpen, details);
        }
      },
      onKeyDown() {
        pointerTypeRef.current = void 0;
      },
    }),
    [
      dataRef,
      eventOption,
      ignoreMouse,
      store,
      stickIfOpen,
      toggle,
      frame2,
      touchOpenTimeout,
      touchOpenDelay,
    ],
  );
  return reactExports.useMemo(
    () =>
      enabled
        ? {
            reference,
          }
        : EMPTY_OBJECT,
    [enabled, reference],
  );
}
function createVirtualElement(domElement, data) {
  let offsetX = null;
  let offsetY = null;
  let isAutoUpdateEvent = false;
  return {
    contextElement: domElement || void 0,
    getBoundingClientRect() {
      var _a2;
      const domRect = (domElement == null ? void 0 : domElement.getBoundingClientRect()) || {
        width: 0,
        height: 0,
        x: 0,
        y: 0,
      };
      const isXAxis = data.axis === "x" || data.axis === "both";
      const isYAxis = data.axis === "y" || data.axis === "both";
      const canTrackCursorOnAutoUpdate =
        ["mouseenter", "mousemove"].includes(
          ((_a2 = data.dataRef.current.openEvent) == null ? void 0 : _a2.type) || "",
        ) && data.pointerType !== "touch";
      let width = domRect.width;
      let height = domRect.height;
      let x = domRect.x;
      let y = domRect.y;
      if (offsetX == null && data.x && isXAxis) {
        offsetX = domRect.x - data.x;
      }
      if (offsetY == null && data.y && isYAxis) {
        offsetY = domRect.y - data.y;
      }
      x -= offsetX || 0;
      y -= offsetY || 0;
      width = 0;
      height = 0;
      if (!isAutoUpdateEvent || canTrackCursorOnAutoUpdate) {
        width = data.axis === "y" ? domRect.width : 0;
        height = data.axis === "x" ? domRect.height : 0;
        x = isXAxis && data.x != null ? data.x : x;
        y = isYAxis && data.y != null ? data.y : y;
      } else if (isAutoUpdateEvent && !canTrackCursorOnAutoUpdate) {
        height = data.axis === "x" ? domRect.height : height;
        width = data.axis === "y" ? domRect.width : width;
      }
      isAutoUpdateEvent = true;
      return {
        width,
        height,
        x,
        y,
        top: y,
        right: x + width,
        bottom: y + height,
        left: x,
      };
    },
  };
}
function isMouseBasedEvent(event) {
  return event != null && event.clientX != null;
}
function useClientPoint(context, props = {}) {
  const store = "rootStore" in context ? context.rootStore : context;
  const open = store.useState("open");
  const floating = store.useState("floatingElement");
  const domReference = store.useState("domReferenceElement");
  const dataRef = store.context.dataRef;
  const { enabled = true, axis = "both", x = null, y = null } = props;
  const initialRef = reactExports.useRef(false);
  const cleanupListenerRef = reactExports.useRef(null);
  const [pointerType, setPointerType] = reactExports.useState();
  const [reactive, setReactive] = reactExports.useState([]);
  const setReference = useStableCallback((newX, newY, referenceElement) => {
    if (initialRef.current) {
      return;
    }
    if (dataRef.current.openEvent && !isMouseBasedEvent(dataRef.current.openEvent)) {
      return;
    }
    store.set(
      "positionReference",
      createVirtualElement(referenceElement ?? domReference, {
        x: newX,
        y: newY,
        axis,
        dataRef,
        pointerType,
      }),
    );
  });
  const handleReferenceEnterOrMove = useStableCallback((event) => {
    if (x != null || y != null) {
      return;
    }
    if (!open) {
      setReference(event.clientX, event.clientY, event.currentTarget);
    } else if (!cleanupListenerRef.current) {
      setReactive([]);
    }
  });
  const openCheck = isMouseLikePointerType(pointerType) ? floating : open;
  const addListener = reactExports.useCallback(() => {
    if (!openCheck || !enabled || x != null || y != null) {
      return void 0;
    }
    const win = getWindow(floating);
    function handleMouseMove(event) {
      const target = getTarget(event);
      if (!contains(floating, target)) {
        setReference(event.clientX, event.clientY);
      } else {
        win.removeEventListener("mousemove", handleMouseMove);
        cleanupListenerRef.current = null;
      }
    }
    if (!dataRef.current.openEvent || isMouseBasedEvent(dataRef.current.openEvent)) {
      win.addEventListener("mousemove", handleMouseMove);
      const cleanup = () => {
        win.removeEventListener("mousemove", handleMouseMove);
        cleanupListenerRef.current = null;
      };
      cleanupListenerRef.current = cleanup;
      return cleanup;
    }
    store.set("positionReference", domReference);
    return void 0;
  }, [openCheck, enabled, x, y, floating, dataRef, domReference, store, setReference]);
  reactExports.useEffect(() => {
    return addListener();
  }, [addListener, reactive]);
  reactExports.useEffect(() => {
    if (enabled && !floating) {
      initialRef.current = false;
    }
  }, [enabled, floating]);
  reactExports.useEffect(() => {
    if (!enabled && open) {
      initialRef.current = true;
    }
  }, [enabled, open]);
  useIsoLayoutEffect(() => {
    if (enabled && (x != null || y != null)) {
      initialRef.current = false;
      setReference(x, y);
    }
  }, [enabled, x, y, setReference]);
  const reference = reactExports.useMemo(() => {
    function setPointerTypeRef(event) {
      setPointerType(event.pointerType);
    }
    return {
      onPointerDown: setPointerTypeRef,
      onPointerEnter: setPointerTypeRef,
      onMouseMove: handleReferenceEnterOrMove,
      onMouseEnter: handleReferenceEnterOrMove,
    };
  }, [handleReferenceEnterOrMove]);
  return reactExports.useMemo(
    () =>
      enabled
        ? {
            reference,
            trigger: reference,
          }
        : {},
    [enabled, reference],
  );
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let { reference, floating } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height,
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height,
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY,
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY,
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y,
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
const computePosition$1 = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy,
  });
  let { x, y } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const { name, fn } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset,
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating,
      },
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data,
      },
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects =
            reset.rects === true
              ? await platform2.getElementRects({
                  reference,
                  floating,
                  strategy,
                })
              : reset.rects;
        }
        ({ x, y } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData,
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const { x, y, platform: platform2, rects, elements, strategy } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0,
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(
    await platform2.getClippingRect({
      element: (
        (_await$platform$isEle = await (platform2.isElement == null
          ? void 0
          : platform2.isElement(element))) != null
          ? _await$platform$isEle
          : true
      )
        ? element
        : element.contextElement ||
          (await (platform2.getDocumentElement == null
            ? void 0
            : platform2.getDocumentElement(elements.floating))),
      boundary,
      rootBoundary,
      strategy,
    }),
  );
  const rect =
    elementContext === "floating"
      ? {
          x,
          y,
          width: rects.floating.width,
          height: rects.floating.height,
        }
      : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null
    ? void 0
    : platform2.getOffsetParent(elements.floating));
  const offsetScale = (await (platform2.isElement == null
    ? void 0
    : platform2.isElement(offsetParent)))
    ? (await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent))) || {
        x: 1,
        y: 1,
      }
    : {
        x: 1,
        y: 1,
      };
  const elementClientRect = rectToClientRect(
    platform2.convertOffsetParentRelativeRectToViewportRelativeRect
      ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
          elements,
          rect,
          offsetParent,
          strategy,
        })
      : rect,
  );
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom:
      (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right:
      (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x,
  };
}
const flip$2 = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements,
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if (
        (_middlewareData$arrow = middlewareData.arrow) != null &&
        _middlewareData$arrow.alignmentOffset
      ) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements =
        specifiedFallbackPlacements ||
        (isBasePlacement || !flipAlignment
          ? [getOppositePlacement(initialPlacement)]
          : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(
          ...getOppositeAxisPlacements(
            initialPlacement,
            flipAlignment,
            fallbackAxisSideDirection,
            rtl,
          ),
        );
      }
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData =
        ((_middlewareData$flip = middlewareData.flip) == null
          ? void 0
          : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [
        ...overflowsData,
        {
          placement,
          overflows,
        },
      ];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex =
          (((_middlewareData$flip2 = middlewareData.flip) == null
            ? void 0
            : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          const ignoreCrossAxisOverflow =
            checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : false;
          if (
            !ignoreCrossAxisOverflow || // We leave the current main axis only if every placement on that axis
            // overflows the main axis.
            overflowsData.every((d) =>
              getSideAxis(d.placement) === initialSideAxis ? d.overflows[0] > 0 : true,
            )
          ) {
            return {
              data: {
                index: nextIndex,
                overflows: overflowsData,
              },
              reset: {
                placement: nextPlacement,
              },
            };
          }
        }
        let resetPlacement =
          (_overflowsData$filter = overflowsData
            .filter((d) => d.overflows[0] <= 0)
            .sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null
            ? void 0
            : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 =
                (_overflowsData$filter2 = overflowsData
                  .filter((d) => {
                    if (hasFallbackAxisSideDirection) {
                      const currentSideAxis = getSideAxis(d.placement);
                      return (
                        currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                        // reading directions favoring greater width.
                        currentSideAxis === "y"
                      );
                    }
                    return true;
                  })
                  .map((d) => [
                    d.placement,
                    d.overflows
                      .filter((overflow2) => overflow2 > 0)
                      .reduce((acc, overflow2) => acc + overflow2, 0),
                  ])
                  .sort((a, b) => a[1] - b[1])[0]) == null
                  ? void 0
                  : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement,
            },
          };
        }
      }
      return {};
    },
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width,
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
const hide$3 = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state) {
      const { rects } = state;
      const { strategy = "referenceHidden", ...detectOverflowOptions } = evaluate(options, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            elementContext: "reference",
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets),
            },
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            altBoundary: true,
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets),
            },
          };
        }
        default: {
          return {};
        }
      }
    },
  };
};
const originSides = /* @__PURE__ */ new Set(["left", "top"]);
async function convertValueToCoords(state, options) {
  const { placement, platform: platform2, elements } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = originSides.has(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let { mainAxis, crossAxis, alignmentAxis } =
    typeof rawValue === "number"
      ? {
          mainAxis: rawValue,
          crossAxis: 0,
          alignmentAxis: null,
        }
      : {
          mainAxis: rawValue.mainAxis || 0,
          crossAxis: rawValue.crossAxis || 0,
          alignmentAxis: rawValue.alignmentAxis,
        };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical
    ? {
        x: crossAxis * crossAxisMulti,
        y: mainAxis * mainAxisMulti,
      }
    : {
        x: mainAxis * mainAxisMulti,
        y: crossAxis * crossAxisMulti,
      };
}
const offset$2 = function (options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const { x, y, placement, middlewareData } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (
        placement ===
          ((_middlewareData$offse = middlewareData.offset) == null
            ? void 0
            : _middlewareData$offse.placement) &&
        (_middlewareData$arrow = middlewareData.arrow) != null &&
        _middlewareData$arrow.alignmentOffset
      ) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement,
        },
      };
    },
  };
};
const shift$2 = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const { x, y, placement } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let { x: x2, y: y2 } = _ref;
            return {
              x: x2,
              y: y2,
            };
          },
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x,
        y,
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp$1(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp$1(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord,
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis,
          },
        },
      };
    },
  };
};
const limitShift$2 = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state) {
      const { x, y, placement, rects, middlewareData } = state;
      const {
        offset: offset2 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
      } = evaluate(options, state);
      const coords = {
        x,
        y,
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset2, state);
      const computedOffset =
        typeof rawOffset === "number"
          ? {
              mainAxis: rawOffset,
              crossAxis: 0,
            }
          : {
              mainAxis: 0,
              crossAxis: 0,
              ...rawOffset,
            };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = originSides.has(getSide(placement));
        const limitMin =
          rects.reference[crossAxis] -
          rects.floating[len] +
          (isOriginSide
            ? ((_middlewareData$offse = middlewareData.offset) == null
                ? void 0
                : _middlewareData$offse[crossAxis]) || 0
            : 0) +
          (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax =
          rects.reference[crossAxis] +
          rects.reference[len] +
          (isOriginSide
            ? 0
            : ((_middlewareData$offse2 = middlewareData.offset) == null
                ? void 0
                : _middlewareData$offse2[crossAxis]) || 0) -
          (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord,
      };
    },
  };
};
const size$2 = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const { placement, rects, platform: platform2, elements } = state;
      const { apply = () => {}, ...detectOverflowOptions } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const { width, height } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide =
          alignment ===
          ((await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)))
            ? "start"
            : "end")
            ? "left"
            : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if (
        (_state$middlewareData = state.middlewareData.shift) != null &&
        _state$middlewareData.enabled.x
      ) {
        availableWidth = maximumClippingWidth;
      }
      if (
        (_state$middlewareData2 = state.middlewareData.shift) != null &&
        _state$middlewareData2.enabled.y
      ) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth =
            width -
            2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight =
            height -
            2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight,
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true,
          },
        };
      }
      return {};
    },
  };
};
function getCssDimensions(element) {
  const css = getComputedStyle$1(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback,
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const { width, height, $ } = getCssDimensions(domElement);
  let x = ($ ? round(rect.width) : rect.width) / width;
  let y = ($ ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y,
  };
}
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit$1() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop,
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || (isFixed && floatingOffsetParent !== getWindow(element))) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale2 = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale2 = getScale(offsetParent);
      }
    } else {
      scale2 = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent)
    ? getVisualOffsets(domElement)
    : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale2.x;
  let y = (clientRect.top + visualOffsets.y) / scale2.y;
  let width = clientRect.width / scale2.x;
  let height = clientRect.height / scale2.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin =
      offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle$1(currentIFrame);
      const left =
        iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top =
        iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y,
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll) {
  const htmlRect = documentElement.getBoundingClientRect();
  const x = htmlRect.left + scroll.scrollLeft - getWindowScrollBarX(documentElement, htmlRect);
  const y = htmlRect.top + scroll.scrollTop;
  return {
    x,
    y,
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let { elements, rect, offsetParent, strategy } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || (topLayer && isFixed)) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0,
  };
  let scale2 = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || (!isOffsetParentAnElement && !isFixed)) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale2 = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset =
    documentElement && !isOffsetParentAnElement && !isFixed
      ? getHTMLOffset(documentElement, scroll)
      : createCoords(0);
  return {
    width: rect.width * scale2.x,
    height: rect.height * scale2.y,
    x: rect.x * scale2.x - scroll.scrollLeft * scale2.x + offsets.x + htmlOffset.x,
    y: rect.y * scale2.y - scroll.scrollTop * scale2.y + offsets.y + htmlOffset.y,
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle$1(body).direction === "rtl") {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y,
  };
}
const SCROLLBAR_MAX = 25;
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit$1();
    if (!visualViewportBased || (visualViewportBased && strategy === "fixed")) {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  const windowScrollbarX = getWindowScrollBarX(html);
  if (windowScrollbarX <= 0) {
    const doc = html.ownerDocument;
    const body = doc.body;
    const bodyStyles = getComputedStyle(body);
    const bodyMarginInline =
      doc.compatMode === "CSS1Compat"
        ? parseFloat(bodyStyles.marginLeft) + parseFloat(bodyStyles.marginRight) || 0
        : 0;
    const clippingStableScrollbarWidth = Math.abs(
      html.clientWidth - body.clientWidth - bodyMarginInline,
    );
    if (clippingStableScrollbarWidth <= SCROLLBAR_MAX) {
      width -= clippingStableScrollbarWidth;
    }
  } else if (windowScrollbarX <= SCROLLBAR_MAX) {
    width += windowScrollbarX;
  }
  return {
    width,
    height,
    x,
    y,
  };
}
const absoluteOrFixed = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale2 = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale2.x;
  const height = element.clientHeight * scale2.y;
  const x = left * scale2.x;
  const y = top * scale2.y;
  return {
    width,
    height,
    x,
    y,
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height,
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return (
    getComputedStyle$1(parentNode).position === "fixed" ||
    hasFixedPositionAncestor(parentNode, stopNode)
  );
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter(
    (el) => isElement(el) && getNodeName(el) !== "body",
  );
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle$1(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed
      ? !currentNodeIsContaining && !currentContainingBlockComputedStyle
      : (!currentNodeIsContaining &&
          computedStyle.position === "static" &&
          !!currentContainingBlockComputedStyle &&
          absoluteOrFixed.has(currentContainingBlockComputedStyle.position)) ||
        (isOverflowElement(currentNode) &&
          !currentNodeIsContaining &&
          hasFixedPositionAncestor(element, currentNode));
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let { element, boundary, rootBoundary, strategy } = _ref;
  const elementClippingAncestors =
    boundary === "clippingAncestors"
      ? isTopLayer(element)
        ? []
        : getClippingElementAncestors(element, this._c)
      : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce(
    (accRect, clippingAncestor) => {
      const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
      accRect.top = max(rect.top, accRect.top);
      accRect.right = min(rect.right, accRect.right);
      accRect.bottom = min(rect.bottom, accRect.bottom);
      accRect.left = max(rect.left, accRect.left);
      return accRect;
    },
    getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy),
  );
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top,
  };
}
function getDimensions(element) {
  const { width, height } = getCssDimensions(element);
  return {
    width,
    height,
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0,
  };
  const offsets = createCoords(0);
  function setLeftRTLScrollbarOffset() {
    offsets.x = getWindowScrollBarX(documentElement);
  }
  if (isOffsetParentAnElement || (!isOffsetParentAnElement && !isFixed)) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      setLeftRTLScrollbarOffset();
    }
  }
  if (isFixed && !isOffsetParentAnElement && documentElement) {
    setLeftRTLScrollbarOffset();
  }
  const htmlOffset =
    documentElement && !isOffsetParentAnElement && !isFixed
      ? getHTMLOffset(documentElement, scroll)
      : createCoords(0);
  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height,
  };
}
function isStaticPositioned(element) {
  return getComputedStyle$1(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (
    offsetParent &&
    isLastTraversableNode(offsetParent) &&
    isStaticPositioned(offsetParent) &&
    !isContainingBlock(offsetParent)
  ) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
const getElementRects = async function (data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(
      data.reference,
      await getOffsetParentFn(data.floating),
      data.strategy,
    ),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height,
    },
  };
};
function isRTL(element) {
  return getComputedStyle$1(element).direction === "rtl";
}
const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL,
};
function rectsAreEqual(a, b) {
  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
}
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const elementRectForRootMargin = element.getBoundingClientRect();
    const { left, top, width, height } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin =
      -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1,
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      if (
        ratio === 1 &&
        !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())
      ) {
        refresh();
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument,
      });
    } catch (_e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update2, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false,
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors =
    ancestorScroll || ancestorResize
      ? [
          ...(referenceEl ? getOverflowAncestors(referenceEl) : []),
          ...getOverflowAncestors(floating),
        ]
      : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll &&
      ancestor.addEventListener("scroll", update2, {
        passive: true,
      });
    ancestorResize && ancestor.addEventListener("resize", update2);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update2) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update2();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update2();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update2();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update2);
      ancestorResize && ancestor.removeEventListener("resize", update2);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
const offset$1 = offset$2;
const shift$1 = shift$2;
const flip$1 = flip$2;
const size$1 = size$2;
const hide$2 = hide$3;
const limitShift$1 = limitShift$2;
const computePosition = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options,
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache,
  };
  return computePosition$1(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache,
  });
};
var isClient = typeof document !== "undefined";
var noop = function noop2() {};
var index = isClient ? reactExports.useLayoutEffect : noop;
function deepEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (typeof a !== typeof b) {
    return false;
  }
  if (typeof a === "function" && a.toString() === b.toString()) {
    return true;
  }
  let length;
  let i;
  let keys;
  if (a && b && typeof a === "object") {
    if (Array.isArray(a)) {
      length = a.length;
      if (length !== b.length) return false;
      for (i = length; i-- !== 0; ) {
        if (!deepEqual(a[i], b[i])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) {
      return false;
    }
    for (i = length; i-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b, keys[i])) {
        return false;
      }
    }
    for (i = length; i-- !== 0; ) {
      const key = keys[i];
      if (key === "_owner" && a.$$typeof) {
        continue;
      }
      if (!deepEqual(a[key], b[key])) {
        return false;
      }
    }
    return true;
  }
  return a !== a && b !== b;
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef(value) {
  const ref = reactExports.useRef(value);
  index(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating$1(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    elements: { reference: externalReference, floating: externalFloating } = {},
    transform = true,
    whileElementsMounted,
    open,
  } = options;
  const [data, setData] = reactExports.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false,
  });
  const [latestMiddleware, setLatestMiddleware] = reactExports.useState(middleware);
  if (!deepEqual(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const [_reference, _setReference] = reactExports.useState(null);
  const [_floating, _setFloating] = reactExports.useState(null);
  const setReference = reactExports.useCallback((node) => {
    if (node !== referenceRef.current) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, []);
  const setFloating = reactExports.useCallback((node) => {
    if (node !== floatingRef.current) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, []);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = reactExports.useRef(null);
  const floatingRef = reactExports.useRef(null);
  const dataRef = reactExports.useRef(data);
  const hasWhileElementsMounted = whileElementsMounted != null;
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const platformRef = useLatestRef(platform2);
  const openRef = useLatestRef(open);
  const update2 = reactExports.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config = {
      placement,
      strategy,
      middleware: latestMiddleware,
    };
    if (platformRef.current) {
      config.platform = platformRef.current;
    }
    computePosition(referenceRef.current, floatingRef.current, config).then((data2) => {
      const fullData = {
        ...data2,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: openRef.current !== false,
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        reactDomExports.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef, openRef]);
  index(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false,
      }));
    }
  }, [open]);
  const isMountedRef = reactExports.useRef(false);
  index(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index(() => {
    if (referenceEl) referenceRef.current = referenceEl;
    if (floatingEl) floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update2);
      }
      update2();
    }
  }, [referenceEl, floatingEl, update2, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = reactExports.useMemo(
    () => ({
      reference: referenceRef,
      floating: floatingRef,
      setReference,
      setFloating,
    }),
    [setReference, setFloating],
  );
  const elements = reactExports.useMemo(
    () => ({
      reference: referenceEl,
      floating: floatingEl,
    }),
    [referenceEl, floatingEl],
  );
  const floatingStyles = reactExports.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0,
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x = roundByDPR(elements.floating, data.x);
    const y = roundByDPR(elements.floating, data.y);
    if (transform) {
      return {
        ...initialStyles,
        transform: "translate(" + x + "px, " + y + "px)",
        ...(getDPR(elements.floating) >= 1.5 && {
          willChange: "transform",
        }),
      };
    }
    return {
      position: strategy,
      left: x,
      top: y,
    };
  }, [strategy, transform, elements.floating, data.x, data.y]);
  return reactExports.useMemo(
    () => ({
      ...data,
      update: update2,
      refs,
      elements,
      floatingStyles,
    }),
    [data, update2, refs, elements, floatingStyles],
  );
}
const offset = (options, deps) => ({
  ...offset$1(options),
  options: [options, deps],
});
const shift = (options, deps) => ({
  ...shift$1(options),
  options: [options, deps],
});
const limitShift = (options, deps) => ({
  ...limitShift$1(options),
  options: [options, deps],
});
const flip = (options, deps) => ({
  ...flip$1(options),
  options: [options, deps],
});
const size = (options, deps) => ({
  ...size$1(options),
  options: [options, deps],
});
const hide$1 = (options, deps) => ({
  ...hide$2(options),
  options: [options, deps],
});
const bubbleHandlerKeys = {
  intentional: "onClick",
  sloppy: "onPointerDown",
};
function normalizeProp(normalizable) {
  return {
    escapeKey:
      typeof normalizable === "boolean"
        ? normalizable
        : ((normalizable == null ? void 0 : normalizable.escapeKey) ?? false),
    outsidePress:
      typeof normalizable === "boolean"
        ? normalizable
        : ((normalizable == null ? void 0 : normalizable.outsidePress) ?? true),
  };
}
function useDismiss(context, props = {}) {
  const store = "rootStore" in context ? context.rootStore : context;
  const open = store.useState("open");
  const floatingElement = store.useState("floatingElement");
  const referenceElement = store.useState("referenceElement");
  const domReferenceElement = store.useState("domReferenceElement");
  const { onOpenChange, dataRef } = store.context;
  const {
    enabled = true,
    escapeKey: escapeKey$1 = true,
    outsidePress: outsidePressProp = true,
    outsidePressEvent = "sloppy",
    referencePress = false,
    referencePressEvent = "sloppy",
    ancestorScroll = false,
    bubbles,
    externalTree,
  } = props;
  const tree = useFloatingTree(externalTree);
  const outsidePressFn = useStableCallback(
    typeof outsidePressProp === "function" ? outsidePressProp : () => false,
  );
  const outsidePress$1 = typeof outsidePressProp === "function" ? outsidePressFn : outsidePressProp;
  const endedOrStartedInsideRef = reactExports.useRef(false);
  const { escapeKey: escapeKeyBubbles, outsidePress: outsidePressBubbles } = normalizeProp(bubbles);
  const touchStateRef = reactExports.useRef(null);
  const cancelDismissOnEndTimeout = useTimeout();
  const clearInsideReactTreeTimeout = useTimeout();
  const clearInsideReactTree = useStableCallback(() => {
    clearInsideReactTreeTimeout.clear();
    dataRef.current.insideReactTree = false;
  });
  const isComposingRef = reactExports.useRef(false);
  const currentPointerTypeRef = reactExports.useRef("");
  const trackPointerType = useStableCallback((event) => {
    currentPointerTypeRef.current = event.pointerType;
  });
  const getOutsidePressEvent = useStableCallback(() => {
    const type = currentPointerTypeRef.current;
    const computedType = type === "pen" || !type ? "mouse" : type;
    const resolved =
      typeof outsidePressEvent === "function" ? outsidePressEvent() : outsidePressEvent;
    if (typeof resolved === "string") {
      return resolved;
    }
    return resolved[computedType];
  });
  const closeOnEscapeKeyDown = useStableCallback((event) => {
    var _a2;
    if (!open || !enabled || !escapeKey$1 || event.key !== "Escape") {
      return;
    }
    if (isComposingRef.current) {
      return;
    }
    const nodeId = (_a2 = dataRef.current.floatingContext) == null ? void 0 : _a2.nodeId;
    const children = tree ? getNodeChildren(tree.nodesRef.current, nodeId) : [];
    if (!escapeKeyBubbles) {
      if (children.length > 0) {
        let shouldDismiss = true;
        children.forEach((child) => {
          var _a3;
          if (
            ((_a3 = child.context) == null ? void 0 : _a3.open) &&
            !child.context.dataRef.current.__escapeKeyBubbles
          ) {
            shouldDismiss = false;
          }
        });
        if (!shouldDismiss) {
          return;
        }
      }
    }
    const native = isReactEvent(event) ? event.nativeEvent : event;
    const eventDetails = createChangeEventDetails(escapeKey, native);
    store.setOpen(false, eventDetails);
    if (!escapeKeyBubbles && !eventDetails.isPropagationAllowed) {
      event.stopPropagation();
    }
  });
  const shouldIgnoreEvent = useStableCallback((event) => {
    const computedOutsidePressEvent = getOutsidePressEvent();
    return (
      (computedOutsidePressEvent === "intentional" && event.type !== "click") ||
      (computedOutsidePressEvent === "sloppy" && event.type === "click")
    );
  });
  const markInsideReactTree = useStableCallback(() => {
    dataRef.current.insideReactTree = true;
    clearInsideReactTreeTimeout.start(0, clearInsideReactTree);
  });
  const closeOnPressOutside = useStableCallback((event, endedOrStartedInside = false) => {
    var _a2;
    if (shouldIgnoreEvent(event)) {
      clearInsideReactTree();
      return;
    }
    if (dataRef.current.insideReactTree) {
      clearInsideReactTree();
      return;
    }
    if (getOutsidePressEvent() === "intentional" && endedOrStartedInside) {
      return;
    }
    if (typeof outsidePress$1 === "function" && !outsidePress$1(event)) {
      return;
    }
    const target = getTarget(event);
    const inertSelector = `[${createAttribute("inert")}]`;
    const markers = getDocument(store.select("floatingElement")).querySelectorAll(inertSelector);
    const triggers = store.context.triggerElements;
    if (
      target &&
      (triggers.hasElement(target) ||
        triggers.hasMatchingElement((trigger) => contains(trigger, target)))
    ) {
      return;
    }
    let targetRootAncestor = isElement(target) ? target : null;
    while (targetRootAncestor && !isLastTraversableNode(targetRootAncestor)) {
      const nextParent = getParentNode(targetRootAncestor);
      if (isLastTraversableNode(nextParent) || !isElement(nextParent)) {
        break;
      }
      targetRootAncestor = nextParent;
    }
    if (
      markers.length &&
      isElement(target) &&
      !isRootElement(target) && // Clicked on a direct ancestor (e.g. FloatingOverlay).
      !contains(target, store.select("floatingElement")) && // If the target root element contains none of the markers, then the
      // element was injected after the floating element rendered.
      Array.from(markers).every((marker) => !contains(targetRootAncestor, marker))
    ) {
      return;
    }
    if (isHTMLElement(target) && !("touches" in event)) {
      const lastTraversableNode = isLastTraversableNode(target);
      const style = getComputedStyle$1(target);
      const scrollRe = /auto|scroll/;
      const isScrollableX = lastTraversableNode || scrollRe.test(style.overflowX);
      const isScrollableY = lastTraversableNode || scrollRe.test(style.overflowY);
      const canScrollX =
        isScrollableX && target.clientWidth > 0 && target.scrollWidth > target.clientWidth;
      const canScrollY =
        isScrollableY && target.clientHeight > 0 && target.scrollHeight > target.clientHeight;
      const isRTL2 = style.direction === "rtl";
      const pressedVerticalScrollbar =
        canScrollY &&
        (isRTL2
          ? event.offsetX <= target.offsetWidth - target.clientWidth
          : event.offsetX > target.clientWidth);
      const pressedHorizontalScrollbar = canScrollX && event.offsetY > target.clientHeight;
      if (pressedVerticalScrollbar || pressedHorizontalScrollbar) {
        return;
      }
    }
    const nodeId = (_a2 = dataRef.current.floatingContext) == null ? void 0 : _a2.nodeId;
    const targetIsInsideChildren =
      tree &&
      getNodeChildren(tree.nodesRef.current, nodeId).some((node) => {
        var _a3;
        return isEventTargetWithin(
          event,
          (_a3 = node.context) == null ? void 0 : _a3.elements.floating,
        );
      });
    if (
      isEventTargetWithin(event, store.select("floatingElement")) ||
      isEventTargetWithin(event, store.select("domReferenceElement")) ||
      targetIsInsideChildren
    ) {
      return;
    }
    const children = tree ? getNodeChildren(tree.nodesRef.current, nodeId) : [];
    if (children.length > 0) {
      let shouldDismiss = true;
      children.forEach((child) => {
        var _a3;
        if (
          ((_a3 = child.context) == null ? void 0 : _a3.open) &&
          !child.context.dataRef.current.__outsidePressBubbles
        ) {
          shouldDismiss = false;
        }
      });
      if (!shouldDismiss) {
        return;
      }
    }
    store.setOpen(false, createChangeEventDetails(outsidePress, event));
    clearInsideReactTree();
  });
  const handlePointerDown = useStableCallback((event) => {
    if (
      getOutsidePressEvent() !== "sloppy" ||
      event.pointerType === "touch" ||
      !store.select("open") ||
      !enabled ||
      isEventTargetWithin(event, store.select("floatingElement")) ||
      isEventTargetWithin(event, store.select("domReferenceElement"))
    ) {
      return;
    }
    closeOnPressOutside(event);
  });
  const handleTouchStart = useStableCallback((event) => {
    if (
      getOutsidePressEvent() !== "sloppy" ||
      !store.select("open") ||
      !enabled ||
      isEventTargetWithin(event, store.select("floatingElement")) ||
      isEventTargetWithin(event, store.select("domReferenceElement"))
    ) {
      return;
    }
    const touch = event.touches[0];
    if (touch) {
      touchStateRef.current = {
        startTime: Date.now(),
        startX: touch.clientX,
        startY: touch.clientY,
        dismissOnTouchEnd: false,
        dismissOnMouseDown: true,
      };
      cancelDismissOnEndTimeout.start(1e3, () => {
        if (touchStateRef.current) {
          touchStateRef.current.dismissOnTouchEnd = false;
          touchStateRef.current.dismissOnMouseDown = false;
        }
      });
    }
  });
  const handleTouchStartCapture = useStableCallback((event) => {
    const target = getTarget(event);
    function callback() {
      handleTouchStart(event);
      target == null ? void 0 : target.removeEventListener(event.type, callback);
    }
    target == null ? void 0 : target.addEventListener(event.type, callback);
  });
  const closeOnPressOutsideCapture = useStableCallback((event) => {
    const endedOrStartedInside = endedOrStartedInsideRef.current;
    endedOrStartedInsideRef.current = false;
    cancelDismissOnEndTimeout.clear();
    if (
      event.type === "mousedown" &&
      touchStateRef.current &&
      !touchStateRef.current.dismissOnMouseDown
    ) {
      return;
    }
    const target = getTarget(event);
    function callback() {
      if (event.type === "pointerdown") {
        handlePointerDown(event);
      } else {
        closeOnPressOutside(event, endedOrStartedInside);
      }
      target == null ? void 0 : target.removeEventListener(event.type, callback);
    }
    target == null ? void 0 : target.addEventListener(event.type, callback);
  });
  const handleTouchMove = useStableCallback((event) => {
    if (
      getOutsidePressEvent() !== "sloppy" ||
      !touchStateRef.current ||
      isEventTargetWithin(event, store.select("floatingElement")) ||
      isEventTargetWithin(event, store.select("domReferenceElement"))
    ) {
      return;
    }
    const touch = event.touches[0];
    if (!touch) {
      return;
    }
    const deltaX = Math.abs(touch.clientX - touchStateRef.current.startX);
    const deltaY = Math.abs(touch.clientY - touchStateRef.current.startY);
    const distance2 = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    if (distance2 > 5) {
      touchStateRef.current.dismissOnTouchEnd = true;
    }
    if (distance2 > 10) {
      closeOnPressOutside(event);
      cancelDismissOnEndTimeout.clear();
      touchStateRef.current = null;
    }
  });
  const handleTouchMoveCapture = useStableCallback((event) => {
    const target = getTarget(event);
    function callback() {
      handleTouchMove(event);
      target == null ? void 0 : target.removeEventListener(event.type, callback);
    }
    target == null ? void 0 : target.addEventListener(event.type, callback);
  });
  const handleTouchEnd = useStableCallback((event) => {
    if (
      getOutsidePressEvent() !== "sloppy" ||
      !touchStateRef.current ||
      isEventTargetWithin(event, store.select("floatingElement")) ||
      isEventTargetWithin(event, store.select("domReferenceElement"))
    ) {
      return;
    }
    if (touchStateRef.current.dismissOnTouchEnd) {
      closeOnPressOutside(event);
    }
    cancelDismissOnEndTimeout.clear();
    touchStateRef.current = null;
  });
  const handleTouchEndCapture = useStableCallback((event) => {
    const target = getTarget(event);
    function callback() {
      handleTouchEnd(event);
      target == null ? void 0 : target.removeEventListener(event.type, callback);
    }
    target == null ? void 0 : target.addEventListener(event.type, callback);
  });
  reactExports.useEffect(() => {
    if (!open || !enabled) {
      return void 0;
    }
    dataRef.current.__escapeKeyBubbles = escapeKeyBubbles;
    dataRef.current.__outsidePressBubbles = outsidePressBubbles;
    const compositionTimeout = new Timeout();
    function onScroll(event) {
      store.setOpen(false, createChangeEventDetails(none, event));
    }
    function handleCompositionStart() {
      compositionTimeout.clear();
      isComposingRef.current = true;
    }
    function handleCompositionEnd() {
      compositionTimeout.start(
        // 0ms or 1ms don't work in Safari. 5ms appears to consistently work.
        // Only apply to WebKit for the test to remain 0ms.
        isWebKit$1() ? 5 : 0,
        () => {
          isComposingRef.current = false;
        },
      );
    }
    const doc = getDocument(floatingElement);
    doc.addEventListener("pointerdown", trackPointerType, true);
    if (escapeKey$1) {
      doc.addEventListener("keydown", closeOnEscapeKeyDown);
      doc.addEventListener("compositionstart", handleCompositionStart);
      doc.addEventListener("compositionend", handleCompositionEnd);
    }
    if (outsidePress$1) {
      doc.addEventListener("click", closeOnPressOutsideCapture, true);
      doc.addEventListener("pointerdown", closeOnPressOutsideCapture, true);
      doc.addEventListener("touchstart", handleTouchStartCapture, true);
      doc.addEventListener("touchmove", handleTouchMoveCapture, true);
      doc.addEventListener("touchend", handleTouchEndCapture, true);
      doc.addEventListener("mousedown", closeOnPressOutsideCapture, true);
    }
    let ancestors = [];
    if (ancestorScroll) {
      if (isElement(domReferenceElement)) {
        ancestors = getOverflowAncestors(domReferenceElement);
      }
      if (isElement(floatingElement)) {
        ancestors = ancestors.concat(getOverflowAncestors(floatingElement));
      }
      if (!isElement(referenceElement) && referenceElement && referenceElement.contextElement) {
        ancestors = ancestors.concat(getOverflowAncestors(referenceElement.contextElement));
      }
    }
    ancestors = ancestors.filter((ancestor) => {
      var _a2;
      return ancestor !== ((_a2 = doc.defaultView) == null ? void 0 : _a2.visualViewport);
    });
    ancestors.forEach((ancestor) => {
      ancestor.addEventListener("scroll", onScroll, {
        passive: true,
      });
    });
    return () => {
      doc.removeEventListener("pointerdown", trackPointerType, true);
      if (escapeKey$1) {
        doc.removeEventListener("keydown", closeOnEscapeKeyDown);
        doc.removeEventListener("compositionstart", handleCompositionStart);
        doc.removeEventListener("compositionend", handleCompositionEnd);
      }
      if (outsidePress$1) {
        doc.removeEventListener("click", closeOnPressOutsideCapture, true);
        doc.removeEventListener("pointerdown", closeOnPressOutsideCapture, true);
        doc.removeEventListener("touchstart", handleTouchStartCapture, true);
        doc.removeEventListener("touchmove", handleTouchMoveCapture, true);
        doc.removeEventListener("touchend", handleTouchEndCapture, true);
        doc.removeEventListener("mousedown", closeOnPressOutsideCapture, true);
      }
      ancestors.forEach((ancestor) => {
        ancestor.removeEventListener("scroll", onScroll);
      });
      compositionTimeout.clear();
      endedOrStartedInsideRef.current = false;
    };
  }, [
    dataRef,
    floatingElement,
    referenceElement,
    domReferenceElement,
    escapeKey$1,
    outsidePress$1,
    open,
    onOpenChange,
    ancestorScroll,
    enabled,
    escapeKeyBubbles,
    outsidePressBubbles,
    closeOnEscapeKeyDown,
    closeOnPressOutside,
    closeOnPressOutsideCapture,
    handlePointerDown,
    handleTouchStartCapture,
    handleTouchMoveCapture,
    handleTouchEndCapture,
    trackPointerType,
    store,
  ]);
  reactExports.useEffect(clearInsideReactTree, [outsidePress$1, clearInsideReactTree]);
  const reference = reactExports.useMemo(
    () => ({
      onKeyDown: closeOnEscapeKeyDown,
      ...(referencePress && {
        [bubbleHandlerKeys[referencePressEvent]]: (event) => {
          store.setOpen(false, createChangeEventDetails(triggerPress, event.nativeEvent));
        },
        ...(referencePressEvent !== "intentional" && {
          onClick(event) {
            store.setOpen(false, createChangeEventDetails(triggerPress, event.nativeEvent));
          },
        }),
      }),
    }),
    [closeOnEscapeKeyDown, store, referencePress, referencePressEvent],
  );
  const handlePressedInside = useStableCallback((event) => {
    const target = getTarget(event.nativeEvent);
    if (!contains(store.select("floatingElement"), target) || event.button !== 0) {
      return;
    }
    endedOrStartedInsideRef.current = true;
  });
  const markPressStartedInsideReactTree = useStableCallback((event) => {
    if (!open || !enabled || event.button !== 0) {
      return;
    }
    endedOrStartedInsideRef.current = true;
  });
  const floating = reactExports.useMemo(
    () => ({
      onKeyDown: closeOnEscapeKeyDown,
      // `onMouseDown` may be blocked if `event.preventDefault()` is called in
      // `onPointerDown`, such as with <NumberField.ScrubArea>.
      // See https://github.com/mui/base-ui/pull/3379
      onPointerDown: handlePressedInside,
      onMouseDown: handlePressedInside,
      onMouseUp: handlePressedInside,
      onClickCapture: markInsideReactTree,
      onMouseDownCapture(event) {
        markInsideReactTree();
        markPressStartedInsideReactTree(event);
      },
      onPointerDownCapture(event) {
        markInsideReactTree();
        markPressStartedInsideReactTree(event);
      },
      onMouseUpCapture: markInsideReactTree,
      onTouchEndCapture: markInsideReactTree,
      onTouchMoveCapture: markInsideReactTree,
    }),
    [
      closeOnEscapeKeyDown,
      handlePressedInside,
      markInsideReactTree,
      markPressStartedInsideReactTree,
    ],
  );
  return reactExports.useMemo(
    () =>
      enabled
        ? {
            reference,
            floating,
            trigger: reference,
          }
        : {},
    [enabled, reference, floating],
  );
}
var NOT_FOUND = /* @__PURE__ */ Symbol("NOT_FOUND");
function assertIsFunction(
  func,
  errorMessage = `expected a function, instead received ${typeof func}`,
) {
  if (typeof func !== "function") {
    throw new TypeError(errorMessage);
  }
}
function assertIsObject(
  object,
  errorMessage = `expected an object, instead received ${typeof object}`,
) {
  if (typeof object !== "object") {
    throw new TypeError(errorMessage);
  }
}
function assertIsArrayOfFunctions(
  array,
  errorMessage = `expected all items to be functions, instead received the following types: `,
) {
  if (!array.every((item) => typeof item === "function")) {
    const itemTypes = array
      .map((item) =>
        typeof item === "function" ? `function ${item.name || "unnamed"}()` : typeof item,
      )
      .join(", ");
    throw new TypeError(`${errorMessage}[${itemTypes}]`);
  }
}
var ensureIsArray = (item) => {
  return Array.isArray(item) ? item : [item];
};
function getDependencies(createSelectorArgs) {
  const dependencies = Array.isArray(createSelectorArgs[0])
    ? createSelectorArgs[0]
    : createSelectorArgs;
  assertIsArrayOfFunctions(
    dependencies,
    `createSelector expects all input-selectors to be functions, but received the following types: `,
  );
  return dependencies;
}
function collectInputSelectorResults(dependencies, inputSelectorArgs) {
  const inputSelectorResults = [];
  const { length } = dependencies;
  for (let i = 0; i < length; i++) {
    inputSelectorResults.push(dependencies[i].apply(null, inputSelectorArgs));
  }
  return inputSelectorResults;
}
function createSingletonCache(equals) {
  let entry;
  return {
    get(key) {
      if (entry && equals(entry.key, key)) {
        return entry.value;
      }
      return NOT_FOUND;
    },
    put(key, value) {
      entry = { key, value };
    },
    getEntries() {
      return entry ? [entry] : [];
    },
    clear() {
      entry = void 0;
    },
  };
}
function createLruCache$1(maxSize, equals) {
  let entries = [];
  function get(key) {
    const cacheIndex = entries.findIndex((entry) => equals(key, entry.key));
    if (cacheIndex > -1) {
      const entry = entries[cacheIndex];
      if (cacheIndex > 0) {
        entries.splice(cacheIndex, 1);
        entries.unshift(entry);
      }
      return entry.value;
    }
    return NOT_FOUND;
  }
  function put(key, value) {
    if (get(key) === NOT_FOUND) {
      entries.unshift({ key, value });
      if (entries.length > maxSize) {
        entries.pop();
      }
    }
  }
  function getEntries() {
    return entries;
  }
  function clear() {
    entries = [];
  }
  return { get, put, getEntries, clear };
}
var referenceEqualityCheck = (a, b) => a === b;
function createCacheKeyComparator(equalityCheck) {
  return function areArgumentsShallowlyEqual(prev, next) {
    if (prev === null || next === null || prev.length !== next.length) {
      return false;
    }
    const { length } = prev;
    for (let i = 0; i < length; i++) {
      if (!equalityCheck(prev[i], next[i])) {
        return false;
      }
    }
    return true;
  };
}
function lruMemoize(func, equalityCheckOrOptions) {
  const providedOptions =
    typeof equalityCheckOrOptions === "object"
      ? equalityCheckOrOptions
      : { equalityCheck: equalityCheckOrOptions };
  const {
    equalityCheck = referenceEqualityCheck,
    maxSize = 1,
    resultEqualityCheck,
  } = providedOptions;
  const comparator = createCacheKeyComparator(equalityCheck);
  let resultsCount = 0;
  const cache =
    maxSize <= 1 ? createSingletonCache(comparator) : createLruCache$1(maxSize, comparator);
  function memoized() {
    let value = cache.get(arguments);
    if (value === NOT_FOUND) {
      value = func.apply(null, arguments);
      resultsCount++;
      if (resultEqualityCheck) {
        const entries = cache.getEntries();
        const matchingEntry = entries.find((entry) => resultEqualityCheck(entry.value, value));
        if (matchingEntry) {
          value = matchingEntry.value;
          resultsCount !== 0 && resultsCount--;
        }
      }
      cache.put(arguments, value);
    }
    return value;
  }
  memoized.clearCache = () => {
    cache.clear();
    memoized.resetResultsCount();
  };
  memoized.resultsCount = () => resultsCount;
  memoized.resetResultsCount = () => {
    resultsCount = 0;
  };
  return memoized;
}
var StrongRef = class {
  constructor(value) {
    this.value = value;
  }
  deref() {
    return this.value;
  }
};
var Ref = typeof WeakRef !== "undefined" ? WeakRef : StrongRef;
var UNTERMINATED = 0;
var TERMINATED = 1;
function createCacheNode() {
  return {
    s: UNTERMINATED,
    v: void 0,
    o: null,
    p: null,
  };
}
function weakMapMemoize(func, options = {}) {
  let fnNode = createCacheNode();
  const { resultEqualityCheck } = options;
  let lastResult;
  let resultsCount = 0;
  function memoized() {
    var _a2;
    let cacheNode = fnNode;
    const { length } = arguments;
    for (let i = 0, l = length; i < l; i++) {
      const arg = arguments[i];
      if (typeof arg === "function" || (typeof arg === "object" && arg !== null)) {
        let objectCache = cacheNode.o;
        if (objectCache === null) {
          cacheNode.o = objectCache = /* @__PURE__ */ new WeakMap();
        }
        const objectNode = objectCache.get(arg);
        if (objectNode === void 0) {
          cacheNode = createCacheNode();
          objectCache.set(arg, cacheNode);
        } else {
          cacheNode = objectNode;
        }
      } else {
        let primitiveCache = cacheNode.p;
        if (primitiveCache === null) {
          cacheNode.p = primitiveCache = /* @__PURE__ */ new Map();
        }
        const primitiveNode = primitiveCache.get(arg);
        if (primitiveNode === void 0) {
          cacheNode = createCacheNode();
          primitiveCache.set(arg, cacheNode);
        } else {
          cacheNode = primitiveNode;
        }
      }
    }
    const terminatedNode = cacheNode;
    let result;
    if (cacheNode.s === TERMINATED) {
      result = cacheNode.v;
    } else {
      result = func.apply(null, arguments);
      resultsCount++;
      if (resultEqualityCheck) {
        const lastResultValue =
          ((_a2 = lastResult == null ? void 0 : lastResult.deref) == null
            ? void 0
            : _a2.call(lastResult)) ?? lastResult;
        if (lastResultValue != null && resultEqualityCheck(lastResultValue, result)) {
          result = lastResultValue;
          resultsCount !== 0 && resultsCount--;
        }
        const needsWeakRef =
          (typeof result === "object" && result !== null) || typeof result === "function";
        lastResult = needsWeakRef ? new Ref(result) : result;
      }
    }
    terminatedNode.s = TERMINATED;
    terminatedNode.v = result;
    return result;
  }
  memoized.clearCache = () => {
    fnNode = createCacheNode();
    memoized.resetResultsCount();
  };
  memoized.resultsCount = () => resultsCount;
  memoized.resetResultsCount = () => {
    resultsCount = 0;
  };
  return memoized;
}
function createSelectorCreator(memoizeOrOptions, ...memoizeOptionsFromArgs) {
  const createSelectorCreatorOptions =
    typeof memoizeOrOptions === "function"
      ? {
          memoize: memoizeOrOptions,
          memoizeOptions: memoizeOptionsFromArgs,
        }
      : memoizeOrOptions;
  const createSelector2 = (...createSelectorArgs) => {
    let recomputations = 0;
    let dependencyRecomputations = 0;
    let lastResult;
    let directlyPassedOptions = {};
    let resultFunc = createSelectorArgs.pop();
    if (typeof resultFunc === "object") {
      directlyPassedOptions = resultFunc;
      resultFunc = createSelectorArgs.pop();
    }
    assertIsFunction(
      resultFunc,
      `createSelector expects an output function after the inputs, but received: [${typeof resultFunc}]`,
    );
    const combinedOptions = {
      ...createSelectorCreatorOptions,
      ...directlyPassedOptions,
    };
    const {
      memoize,
      memoizeOptions = [],
      argsMemoize = weakMapMemoize,
      argsMemoizeOptions = [],
    } = combinedOptions;
    const finalMemoizeOptions = ensureIsArray(memoizeOptions);
    const finalArgsMemoizeOptions = ensureIsArray(argsMemoizeOptions);
    const dependencies = getDependencies(createSelectorArgs);
    const memoizedResultFunc = memoize(
      function recomputationWrapper() {
        recomputations++;
        return resultFunc.apply(null, arguments);
      },
      ...finalMemoizeOptions,
    );
    const selector = argsMemoize(
      function dependenciesChecker() {
        dependencyRecomputations++;
        const inputSelectorResults = collectInputSelectorResults(dependencies, arguments);
        lastResult = memoizedResultFunc.apply(null, inputSelectorResults);
        return lastResult;
      },
      ...finalArgsMemoizeOptions,
    );
    return Object.assign(selector, {
      resultFunc,
      memoizedResultFunc,
      dependencies,
      dependencyRecomputations: () => dependencyRecomputations,
      resetDependencyRecomputations: () => {
        dependencyRecomputations = 0;
      },
      lastResult: () => lastResult,
      recomputations: () => recomputations,
      resetRecomputations: () => {
        recomputations = 0;
      },
      memoize,
      argsMemoize,
    });
  };
  Object.assign(createSelector2, {
    withTypes: () => createSelector2,
  });
  return createSelector2;
}
var createSelector$1 = /* @__PURE__ */ createSelectorCreator(weakMapMemoize);
var createStructuredSelector = Object.assign(
  (inputSelectorsObject, selectorCreator = createSelector$1) => {
    assertIsObject(
      inputSelectorsObject,
      `createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ${typeof inputSelectorsObject}`,
    );
    const inputSelectorKeys = Object.keys(inputSelectorsObject);
    const dependencies = inputSelectorKeys.map((key) => inputSelectorsObject[key]);
    const structuredSelector = selectorCreator(dependencies, (...inputSelectorResults) => {
      return inputSelectorResults.reduce((composition, value, index2) => {
        composition[inputSelectorKeys[index2]] = value;
        return composition;
      }, {});
    });
    return structuredSelector;
  },
  { withTypes: () => createStructuredSelector },
);
createSelectorCreator({
  memoize: lruMemoize,
  memoizeOptions: {
    maxSize: 1,
    equalityCheck: Object.is,
  },
});
const createSelector = (a, b, c, d, e, f, ...other) => {
  if (other.length > 0) {
    throw new Error(formatErrorMessage(1));
  }
  let selector;
  if (a) {
    selector = a;
  } else {
    throw new Error("Missing arguments");
  }
  return selector;
};
var shimExports = requireShim();
const canUseRawUseSyncExternalStore = isReactVersionAtLeast(19);
const useStoreImplementation = canUseRawUseSyncExternalStore ? useStoreR19 : useStoreLegacy;
function useStore(store, selector, a1, a2, a3) {
  return useStoreImplementation(store, selector, a1, a2, a3);
}
function useStoreR19(store, selector, a1, a2, a3) {
  const getSelection = reactExports.useCallback(
    () => selector(store.getSnapshot(), a1, a2, a3),
    [store, selector, a1, a2, a3],
  );
  return shimExports.useSyncExternalStore(store.subscribe, getSelection, getSelection);
}
function useStoreLegacy(store, selector, a1, a2, a3) {
  return withSelectorExports.useSyncExternalStoreWithSelector(
    store.subscribe,
    store.getSnapshot,
    store.getSnapshot,
    (state) => selector(state, a1, a2, a3),
  );
}
class Store {
  /**
   * The current state of the store.
   * This property is updated immediately when the state changes as a result of calling {@link setState}, {@link update}, or {@link set}.
   * To subscribe to state changes, use the {@link useState} method. The value returned by {@link useState} is updated after the component renders (similarly to React's useState).
   * The values can be used directly (to avoid subscribing to the store) in effects or event handlers.
   *
   * Do not modify properties in state directly. Instead, use the provided methods to ensure proper state management and listener notification.
   */
  // Internal state to handle recursive `setState()` calls
  constructor(state) {
    /**
     * Registers a listener that will be called whenever the store's state changes.
     *
     * @param fn The listener function to be called on state changes.
     * @returns A function to unsubscribe the listener.
     */
    __publicField(this, "subscribe", (fn) => {
      this.listeners.add(fn);
      return () => {
        this.listeners.delete(fn);
      };
    });
    /**
     * Returns the current state of the store.
     */
    __publicField(this, "getSnapshot", () => {
      return this.state;
    });
    this.state = state;
    this.listeners = /* @__PURE__ */ new Set();
    this.updateTick = 0;
  }
  /**
   * Updates the entire store's state and notifies all registered listeners.
   *
   * @param newState The new state to set for the store.
   */
  setState(newState) {
    if (this.state === newState) {
      return;
    }
    this.state = newState;
    this.updateTick += 1;
    const currentTick = this.updateTick;
    for (const listener of this.listeners) {
      if (currentTick !== this.updateTick) {
        return;
      }
      listener(newState);
    }
  }
  /**
   * Merges the provided changes into the current state and notifies listeners if there are changes.
   *
   * @param changes An object containing the changes to apply to the current state.
   */
  update(changes) {
    for (const key in changes) {
      if (!Object.is(this.state[key], changes[key])) {
        Store.prototype.setState.call(this, {
          ...this.state,
          ...changes,
        });
        return;
      }
    }
  }
  /**
   * Sets a specific key in the store's state to a new value and notifies listeners if the value has changed.
   *
   * @param key The key in the store's state to update.
   * @param value The new value to set for the specified key.
   */
  set(key, value) {
    if (!Object.is(this.state[key], value)) {
      Store.prototype.setState.call(this, {
        ...this.state,
        [key]: value,
      });
    }
  }
  /**
   * Gives the state a new reference and updates all registered listeners.
   */
  notifyAll() {
    const newState = {
      ...this.state,
    };
    Store.prototype.setState.call(this, newState);
  }
}
class ReactStore extends Store {
  /**
   * Creates a new ReactStore instance.
   *
   * @param state Initial state of the store.
   * @param context Non-reactive context values.
   * @param selectors Optional selectors for use with `useState`.
   */
  constructor(state, context = {}, selectors2) {
    super(state);
    /**
     * Non-reactive values such as refs, callbacks, etc.
     */
    /**
     * Keeps track of which properties are controlled.
     */
    __publicField(this, "controlledValues", /* @__PURE__ */ new Map());
    /** Gets the current value from the store using a selector with the provided key.
     *
     * @param key Key of the selector to use.
     */
    __publicField(this, "select", (key, a1, a2, a3) => {
      const selector = this.selectors[key];
      return selector(this.state, a1, a2, a3);
    });
    /**
     * Returns a value from the store's state using a selector function.
     * Used to subscribe to specific parts of the state.
     * This methods causes a rerender whenever the selected state changes.
     *
     * @param key Key of the selector to use.
     */
    __publicField(this, "useState", (key, a1, a2, a3) => {
      reactExports.useDebugValue(key);
      const selector = this.selectors[key];
      const value = useStore(this, selector, a1, a2, a3);
      return value;
    });
    this.context = context;
    this.selectors = selectors2;
  }
  /**
   * Synchronizes a single external value into the store.
   *
   * Note that the while the value in `state` is updated immediately, the value returned
   * by `useState` is updated before the next render (similarly to React's `useState`).
   */
  useSyncedValue(key, value) {
    reactExports.useDebugValue(key);
    useIsoLayoutEffect(() => {
      if (this.state[key] !== value) {
        this.set(key, value);
      }
    }, [key, value]);
  }
  /**
   * Synchronizes a single external value into the store and
   * cleans it up (sets to `undefined`) on unmount.
   *
   * Note that the while the value in `state` is updated immediately, the value returned
   * by `useState` is updated before the next render (similarly to React's `useState`).
   */
  useSyncedValueWithCleanup(key, value) {
    const store = this;
    useIsoLayoutEffect(() => {
      if (store.state[key] !== value) {
        store.set(key, value);
      }
      return () => {
        store.set(key, void 0);
      };
    }, [store, key, value]);
  }
  /**
   * Synchronizes multiple external values into the store.
   *
   * Note that the while the values in `state` are updated immediately, the values returned
   * by `useState` are updated before the next render (similarly to React's `useState`).
   */
  useSyncedValues(statePart) {
    const store = this;
    const dependencies = Object.values(statePart);
    useIsoLayoutEffect(() => {
      store.update(statePart);
    }, [store, ...dependencies]);
  }
  /**
   * Registers a controllable prop pair (`controlled`, `defaultValue`) for a specific key.
   * - If `controlled` is non-undefined, the key is marked as controlled and the store's
   *   state at `key` is updated to match `controlled`. Local writes to that key are ignored.
   * - If `controlled` is undefined, the key is marked as uncontrolled. The store's state
   *   is initialized to `defaultValue` on first render and can be updated with local writes.
   */
  useControlledProp(key, controlled, defaultValue) {
    reactExports.useDebugValue(key);
    const store = this;
    const isControlled = controlled !== void 0;
    if (!this.controlledValues.has(key)) {
      this.controlledValues.set(key, isControlled);
      if (!isControlled && !Object.is(this.state[key], defaultValue)) {
        super.setState({
          ...this.state,
          [key]: defaultValue,
        });
      }
    }
    useIsoLayoutEffect(() => {
      if (isControlled && !Object.is(store.state[key], controlled)) {
        super.setState({
          ...store.state,
          [key]: controlled,
        });
      }
    }, [store, key, controlled, defaultValue, isControlled]);
  }
  /**
   * Sets a specific key in the store's state to a new value and notifies listeners if the value has changed.
   * If the key is controlled (registered via {@link useControlledProp} with a non-undefined value),
   * the update is ignored and no listeners are notified.
   *
   * @param key The state key to update.
   * @param value The new value to set for the specified key.
   */
  set(key, value) {
    if (this.controlledValues.get(key) === true) {
      return;
    }
    super.set(key, value);
  }
  /**
   * Merges the provided changes into the current state and notifies listeners if there are changes.
   * Controlled keys are filtered out and not updated.
   *
   * @param values An object containing the changes to apply to the current state.
   */
  update(values) {
    const newValues = {
      ...values,
    };
    for (const key in newValues) {
      if (!Object.hasOwn(newValues, key)) {
        continue;
      }
      if (this.controlledValues.get(key) === true) {
        delete newValues[key];
        continue;
      }
    }
    super.update(newValues);
  }
  /**
   * Updates the entire store's state and notifies all registered listeners.
   * Controlled keys are left unchanged; only uncontrolled keys from `newState` are applied.
   *
   * @param newState The new state to set for the store.
   */
  setState(newState) {
    const newValues = {
      ...newState,
    };
    for (const key in newValues) {
      if (!Object.hasOwn(newValues, key)) {
        continue;
      }
      if (this.controlledValues.get(key) === true) {
        delete newValues[key];
        continue;
      }
    }
    super.setState({
      ...this.state,
      ...newValues,
    });
  }
  /**
   * Wraps a function with `useStableCallback` to ensure it has a stable reference
   * and assigns it to the context.
   *
   * @param key Key of the event callback. Must be a function in the context.
   * @param fn Function to assign.
   */
  useContextCallback(key, fn) {
    reactExports.useDebugValue(key);
    const stableFunction = useStableCallback(fn ?? NOOP);
    this.context[key] = stableFunction;
  }
  /**
   * Returns a stable setter function for a specific key in the store's state.
   * It's commonly used to pass as a ref callback to React elements.
   *
   * @param key Key of the state to set.
   */
  useStateSetter(key) {
    const ref = reactExports.useRef(void 0);
    if (ref.current === void 0) {
      ref.current = (value) => {
        this.set(key, value);
      };
    }
    return ref.current;
  }
  /**
   * Observes changes derived from the store's selectors and calls the listener when the selected value changes.
   *
   * @param key Key of the selector to observe.
   * @param listener Listener function called when the selector result changes.
   */
  observe(selector, listener) {
    let selectFn;
    if (typeof selector === "function") {
      selectFn = selector;
    } else {
      selectFn = this.selectors[selector];
    }
    let prevValue = selectFn(this.state);
    listener(prevValue, prevValue, this);
    return this.subscribe((nextState) => {
      const nextValue = selectFn(nextState);
      if (!Object.is(prevValue, nextValue)) {
        const oldValue = prevValue;
        prevValue = nextValue;
        listener(nextValue, oldValue, this);
      }
    });
  }
}
const selectors$2 = {
  open: createSelector((state) => state.open),
  domReferenceElement: createSelector((state) => state.domReferenceElement),
  referenceElement: createSelector((state) => state.positionReference ?? state.referenceElement),
  floatingElement: createSelector((state) => state.floatingElement),
  floatingId: createSelector((state) => state.floatingId),
};
class FloatingRootStore extends ReactStore {
  constructor(options) {
    const { nested, noEmit, onOpenChange, triggerElements, ...initialState } = options;
    super(
      {
        ...initialState,
        positionReference: initialState.referenceElement,
        domReferenceElement: initialState.referenceElement,
      },
      {
        onOpenChange,
        dataRef: {
          current: {},
        },
        events: createEventEmitter(),
        nested,
        noEmit,
        triggerElements,
      },
      selectors$2,
    );
    /**
     * Emits the `openchange` event through the internal event emitter and calls the `onOpenChange` handler with the provided arguments.
     *
     * @param newOpen The new open state.
     * @param eventDetails Details about the event that triggered the open state change.
     */
    __publicField(this, "setOpen", (newOpen, eventDetails) => {
      var _a2, _b;
      if (
        !newOpen ||
        !this.state.open || // Prevent a pending hover-open from overwriting a click-open event, while allowing
        // click events to upgrade a hover-open.
        isClickLikeEvent(eventDetails.event)
      ) {
        this.context.dataRef.current.openEvent = newOpen ? eventDetails.event : void 0;
      }
      if (!this.context.noEmit) {
        const details = {
          open: newOpen,
          reason: eventDetails.reason,
          nativeEvent: eventDetails.event,
          nested: this.context.nested,
          triggerElement: eventDetails.trigger,
        };
        this.context.events.emit("openchange", details);
      }
      (_b = (_a2 = this.context).onOpenChange) == null
        ? void 0
        : _b.call(_a2, newOpen, eventDetails);
    });
  }
}
function useTriggerRegistration(id2, store) {
  const registeredElementIdRef = reactExports.useRef(null);
  const registeredElementRef = reactExports.useRef(null);
  return reactExports.useCallback(
    (element) => {
      if (id2 === void 0) {
        return;
      }
      if (registeredElementIdRef.current !== null) {
        const registeredId = registeredElementIdRef.current;
        const registeredElement = registeredElementRef.current;
        const currentElement = store.context.triggerElements.getById(registeredId);
        if (registeredElement && currentElement === registeredElement) {
          store.context.triggerElements.delete(registeredId);
        }
        registeredElementIdRef.current = null;
        registeredElementRef.current = null;
      }
      if (element !== null) {
        registeredElementIdRef.current = id2;
        registeredElementRef.current = element;
        store.context.triggerElements.add(id2, element);
      }
    },
    [store, id2],
  );
}
function useTriggerDataForwarding(triggerId, triggerElementRef, store, stateUpdates) {
  const isMountedByThisTrigger = store.useState("isMountedByTrigger", triggerId);
  const baseRegisterTrigger = useTriggerRegistration(triggerId, store);
  const registerTrigger = useStableCallback((element) => {
    baseRegisterTrigger(element);
    if (!element || !store.select("open")) {
      return;
    }
    const activeTriggerId = store.select("activeTriggerId");
    if (activeTriggerId === triggerId) {
      store.update({
        activeTriggerElement: element,
        ...stateUpdates,
      });
      return;
    }
    if (activeTriggerId == null) {
      store.update({
        activeTriggerId: triggerId,
        activeTriggerElement: element,
        ...stateUpdates,
      });
    }
  });
  useIsoLayoutEffect(() => {
    if (isMountedByThisTrigger) {
      store.update({
        activeTriggerElement: triggerElementRef.current,
        ...stateUpdates,
      });
    }
  }, [isMountedByThisTrigger, store, triggerElementRef, ...Object.values(stateUpdates)]);
  return {
    registerTrigger,
    isMountedByThisTrigger,
  };
}
function useImplicitActiveTrigger(store) {
  const open = store.useState("open");
  useIsoLayoutEffect(() => {
    if (open && !store.select("activeTriggerId") && store.context.triggerElements.size === 1) {
      const iteratorResult = store.context.triggerElements.entries().next();
      if (!iteratorResult.done) {
        const [implicitTriggerId, implicitTriggerElement] = iteratorResult.value;
        store.update({
          activeTriggerId: implicitTriggerId,
          activeTriggerElement: implicitTriggerElement,
        });
      }
    }
  }, [open, store]);
}
function useOpenStateTransitions(open, store, onUnmount) {
  const { mounted, setMounted, transitionStatus } = useTransitionStatus(open);
  store.useSyncedValues({
    mounted,
    transitionStatus,
  });
  const forceUnmount = useStableCallback(() => {
    var _a2, _b;
    setMounted(false);
    store.update({
      activeTriggerId: null,
      activeTriggerElement: null,
      mounted: false,
    });
    onUnmount == null ? void 0 : onUnmount();
    (_b = (_a2 = store.context).onOpenChangeComplete) == null ? void 0 : _b.call(_a2, false);
  });
  const preventUnmountingOnClose = store.useState("preventUnmountingOnClose");
  useOpenChangeComplete({
    enabled: !preventUnmountingOnClose,
    open,
    ref: store.context.popupRef,
    onComplete() {
      if (!open) {
        forceUnmount();
      }
    },
  });
  return {
    forceUnmount,
    transitionStatus,
  };
}
class PopupTriggerMap {
  constructor() {
    this.elements = /* @__PURE__ */ new Set();
    this.idMap = /* @__PURE__ */ new Map();
  }
  /**
   * Adds a trigger element with the given ID.
   *
   * Note: The provided element is assumed to not be registered under multiple IDs.
   */
  add(id2, element) {
    const existingElement = this.idMap.get(id2);
    if (existingElement === element) {
      return;
    }
    if (existingElement !== void 0) {
      this.elements.delete(existingElement);
    }
    this.elements.add(element);
    this.idMap.set(id2, element);
  }
  /**
   * Removes the trigger element with the given ID.
   */
  delete(id2) {
    const element = this.idMap.get(id2);
    if (element) {
      this.elements.delete(element);
      this.idMap.delete(id2);
    }
  }
  /**
   * Whether the given element is registered as a trigger.
   */
  hasElement(element) {
    return this.elements.has(element);
  }
  /**
   * Whether there is a registered trigger element matching the given predicate.
   */
  hasMatchingElement(predicate) {
    for (const element of this.elements) {
      if (predicate(element)) {
        return true;
      }
    }
    return false;
  }
  getById(id2) {
    return this.idMap.get(id2);
  }
  entries() {
    return this.idMap.entries();
  }
  get size() {
    return this.idMap.size;
  }
}
function getEmptyRootContext() {
  return new FloatingRootStore({
    open: false,
    floatingElement: null,
    referenceElement: null,
    triggerElements: new PopupTriggerMap(),
    floatingId: "",
    nested: false,
    noEmit: false,
    onOpenChange: void 0,
  });
}
function createInitialPopupStoreState() {
  return {
    open: false,
    mounted: false,
    transitionStatus: "idle",
    floatingRootContext: getEmptyRootContext(),
    preventUnmountingOnClose: false,
    payload: void 0,
    activeTriggerId: null,
    activeTriggerElement: null,
    popupElement: null,
    positionerElement: null,
    activeTriggerProps: EMPTY_OBJECT,
    inactiveTriggerProps: EMPTY_OBJECT,
    popupProps: EMPTY_OBJECT,
  };
}
const popupStoreSelectors = {
  open: createSelector((state) => state.open),
  mounted: createSelector((state) => state.mounted),
  transitionStatus: createSelector((state) => state.transitionStatus),
  floatingRootContext: createSelector((state) => state.floatingRootContext),
  preventUnmountingOnClose: createSelector((state) => state.preventUnmountingOnClose),
  payload: createSelector((state) => state.payload),
  activeTriggerId: createSelector((state) => state.activeTriggerId),
  activeTriggerElement: createSelector((state) =>
    state.mounted ? state.activeTriggerElement : null,
  ),
  /**
   * Whether the trigger with the given ID was used to open the popup.
   */
  isTriggerActive: createSelector(
    (state, triggerId) => triggerId !== void 0 && state.activeTriggerId === triggerId,
  ),
  /**
   * Whether the popup is open and was activated by a trigger with the given ID.
   */
  isOpenedByTrigger: createSelector(
    (state, triggerId) => triggerId !== void 0 && state.activeTriggerId === triggerId && state.open,
  ),
  /**
   * Whether the popup is mounted and was activated by a trigger with the given ID.
   */
  isMountedByTrigger: createSelector(
    (state, triggerId) =>
      triggerId !== void 0 && state.activeTriggerId === triggerId && state.mounted,
  ),
  triggerProps: createSelector((state, isActive) =>
    isActive ? state.activeTriggerProps : state.inactiveTriggerProps,
  ),
  popupProps: createSelector((state) => state.popupProps),
  popupElement: createSelector((state) => state.popupElement),
  positionerElement: createSelector((state) => state.positionerElement),
};
function useFloatingRootContext(options) {
  const { open = false, onOpenChange, elements = {} } = options;
  const floatingId = useId();
  const nested = useFloatingParentNodeId() != null;
  const store = useRefWithInit(
    () =>
      new FloatingRootStore({
        open,
        onOpenChange,
        referenceElement: elements.reference ?? null,
        floatingElement: elements.floating ?? null,
        triggerElements: elements.triggers ?? new PopupTriggerMap(),
        floatingId,
        nested,
        noEmit: options.noEmit || false,
      }),
  ).current;
  useIsoLayoutEffect(() => {
    const valuesToSync = {
      open,
      floatingId,
    };
    if (elements.reference !== void 0) {
      valuesToSync.referenceElement = elements.reference;
      valuesToSync.domReferenceElement = isElement(elements.reference) ? elements.reference : null;
    }
    if (elements.floating !== void 0) {
      valuesToSync.floatingElement = elements.floating;
    }
    store.update(valuesToSync);
  }, [open, floatingId, elements.reference, elements.floating, store]);
  store.context.onOpenChange = onOpenChange;
  store.context.nested = nested;
  store.context.noEmit = options.noEmit || false;
  return store;
}
function useFloating(options = {}) {
  const { nodeId, externalTree } = options;
  const internalRootStore = useFloatingRootContext(options);
  const rootContext = options.rootContext || internalRootStore;
  const rootContextElements = {
    reference: rootContext.useState("referenceElement"),
    floating: rootContext.useState("floatingElement"),
    domReference: rootContext.useState("domReferenceElement"),
  };
  const [positionReference, setPositionReferenceRaw] = reactExports.useState(null);
  const domReferenceRef = reactExports.useRef(null);
  const tree = useFloatingTree(externalTree);
  useIsoLayoutEffect(() => {
    if (rootContextElements.domReference) {
      domReferenceRef.current = rootContextElements.domReference;
    }
  }, [rootContextElements.domReference]);
  const position = useFloating$1({
    ...options,
    elements: {
      ...rootContextElements,
      ...(positionReference && {
        reference: positionReference,
      }),
    },
  });
  const setPositionReference = reactExports.useCallback(
    (node) => {
      const computedPositionReference = isElement(node)
        ? {
            getBoundingClientRect: () => node.getBoundingClientRect(),
            getClientRects: () => node.getClientRects(),
            contextElement: node,
          }
        : node;
      setPositionReferenceRaw(computedPositionReference);
      position.refs.setReference(computedPositionReference);
    },
    [position.refs],
  );
  const [localDomReference, setLocalDomReference] = reactExports.useState(null);
  const [localFloatingElement, setLocalFloatingElement] = reactExports.useState(null);
  rootContext.useSyncedValue("referenceElement", localDomReference);
  rootContext.useSyncedValue(
    "domReferenceElement",
    isElement(localDomReference) ? localDomReference : null,
  );
  rootContext.useSyncedValue("floatingElement", localFloatingElement);
  const setReference = reactExports.useCallback(
    (node) => {
      if (isElement(node) || node === null) {
        domReferenceRef.current = node;
        setLocalDomReference(node);
      }
      if (
        isElement(position.refs.reference.current) ||
        position.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to
        // `null` to support `positionReference` + an unstable `reference`
        // callback ref.
        (node !== null && !isElement(node))
      ) {
        position.refs.setReference(node);
      }
    },
    [position.refs, setLocalDomReference],
  );
  const setFloating = reactExports.useCallback(
    (node) => {
      setLocalFloatingElement(node);
      position.refs.setFloating(node);
    },
    [position.refs],
  );
  const refs = reactExports.useMemo(
    () => ({
      ...position.refs,
      setReference,
      setFloating,
      setPositionReference,
      domReference: domReferenceRef,
    }),
    [position.refs, setReference, setFloating, setPositionReference],
  );
  const elements = reactExports.useMemo(
    () => ({
      ...position.elements,
      domReference: rootContextElements.domReference,
    }),
    [position.elements, rootContextElements.domReference],
  );
  const open = rootContext.useState("open");
  const floatingId = rootContext.useState("floatingId");
  const context = reactExports.useMemo(
    () => ({
      ...position,
      dataRef: rootContext.context.dataRef,
      open,
      onOpenChange: rootContext.setOpen,
      events: rootContext.context.events,
      floatingId,
      refs,
      elements,
      nodeId,
      rootStore: rootContext,
    }),
    [position, refs, elements, nodeId, rootContext, open, floatingId],
  );
  useIsoLayoutEffect(() => {
    rootContext.context.dataRef.current.floatingContext = context;
    const node = tree == null ? void 0 : tree.nodesRef.current.find((n) => n.id === nodeId);
    if (node) {
      node.context = context;
    }
  });
  return reactExports.useMemo(
    () => ({
      ...position,
      context,
      refs,
      elements,
      rootStore: rootContext,
    }),
    [position, refs, elements, context, rootContext],
  );
}
function useSyncedFloatingRootContext(options) {
  const { popupStore, noEmit = false, treatPopupAsFloatingElement = false, onOpenChange } = options;
  const floatingId = useId();
  const nested = useFloatingParentNodeId() != null;
  const open = popupStore.useState("open");
  const referenceElement = popupStore.useState("activeTriggerElement");
  const floatingElement = popupStore.useState(
    treatPopupAsFloatingElement ? "popupElement" : "positionerElement",
  );
  const triggerElements = popupStore.context.triggerElements;
  const store = useRefWithInit(
    () =>
      new FloatingRootStore({
        open,
        referenceElement,
        floatingElement,
        triggerElements,
        onOpenChange,
        floatingId,
        nested,
        noEmit,
      }),
  ).current;
  useIsoLayoutEffect(() => {
    const valuesToSync = {
      open,
      floatingId,
      referenceElement,
      floatingElement,
    };
    if (isElement(referenceElement)) {
      valuesToSync.domReferenceElement = referenceElement;
    }
    if (store.state.positionReference === store.state.referenceElement) {
      valuesToSync.positionReference = referenceElement;
    }
    store.update(valuesToSync);
  }, [open, floatingId, referenceElement, floatingElement, store]);
  store.context.onOpenChange = onOpenChange;
  store.context.nested = nested;
  store.context.noEmit = noEmit;
  return store;
}
const isMacSafari = isMac && isSafari;
function useFocus(context, props = {}) {
  const store = "rootStore" in context ? context.rootStore : context;
  const { events, dataRef } = store.context;
  const { enabled = true, visibleOnly = true, delay: delay2 } = props;
  const blockFocusRef = reactExports.useRef(false);
  const blockedReferenceRef = reactExports.useRef(null);
  const timeout = useTimeout();
  const keyboardModalityRef = reactExports.useRef(true);
  reactExports.useEffect(() => {
    const domReference = store.select("domReferenceElement");
    if (!enabled) {
      return void 0;
    }
    const win = getWindow(domReference);
    function onBlur() {
      const currentDomReference = store.select("domReferenceElement");
      if (
        !store.select("open") &&
        isHTMLElement(currentDomReference) &&
        currentDomReference === activeElement(getDocument(currentDomReference))
      ) {
        blockFocusRef.current = true;
      }
    }
    function onKeyDown() {
      keyboardModalityRef.current = true;
    }
    function onPointerDown() {
      keyboardModalityRef.current = false;
    }
    win.addEventListener("blur", onBlur);
    if (isMacSafari) {
      win.addEventListener("keydown", onKeyDown, true);
      win.addEventListener("pointerdown", onPointerDown, true);
    }
    return () => {
      win.removeEventListener("blur", onBlur);
      if (isMacSafari) {
        win.removeEventListener("keydown", onKeyDown, true);
        win.removeEventListener("pointerdown", onPointerDown, true);
      }
    };
  }, [store, enabled]);
  reactExports.useEffect(() => {
    if (!enabled) {
      return void 0;
    }
    function onOpenChangeLocal(details) {
      if (details.reason === triggerPress || details.reason === escapeKey) {
        const referenceElement = store.select("domReferenceElement");
        if (isElement(referenceElement)) {
          blockedReferenceRef.current = referenceElement;
          blockFocusRef.current = true;
        }
      }
    }
    events.on("openchange", onOpenChangeLocal);
    return () => {
      events.off("openchange", onOpenChangeLocal);
    };
  }, [events, enabled, store]);
  const reference = reactExports.useMemo(
    () => ({
      onMouseLeave() {
        blockFocusRef.current = false;
        blockedReferenceRef.current = null;
      },
      onFocus(event) {
        const focusTarget = event.currentTarget;
        if (blockFocusRef.current) {
          if (blockedReferenceRef.current === focusTarget) {
            return;
          }
          blockFocusRef.current = false;
          blockedReferenceRef.current = null;
        }
        const target = getTarget(event.nativeEvent);
        if (visibleOnly && isElement(target)) {
          if (isMacSafari && !event.relatedTarget) {
            if (!keyboardModalityRef.current && !isTypeableElement(target)) {
              return;
            }
          } else if (!matchesFocusVisible(target)) {
            return;
          }
        }
        const movedFromOtherTrigger =
          event.relatedTarget && store.context.triggerElements.hasElement(event.relatedTarget);
        const { nativeEvent, currentTarget } = event;
        const delayValue = typeof delay2 === "function" ? delay2() : delay2;
        if (
          (store.select("open") && movedFromOtherTrigger) ||
          delayValue === 0 ||
          delayValue === void 0
        ) {
          store.setOpen(true, createChangeEventDetails(triggerFocus, nativeEvent, currentTarget));
          return;
        }
        timeout.start(delayValue, () => {
          if (blockFocusRef.current) {
            return;
          }
          store.setOpen(true, createChangeEventDetails(triggerFocus, nativeEvent, currentTarget));
        });
      },
      onBlur(event) {
        blockFocusRef.current = false;
        blockedReferenceRef.current = null;
        const relatedTarget = event.relatedTarget;
        const nativeEvent = event.nativeEvent;
        const movedToFocusGuard =
          isElement(relatedTarget) &&
          relatedTarget.hasAttribute(createAttribute("focus-guard")) &&
          relatedTarget.getAttribute("data-type") === "outside";
        timeout.start(0, () => {
          var _a2;
          const domReference = store.select("domReferenceElement");
          const activeEl = activeElement(domReference ? domReference.ownerDocument : document);
          if (!relatedTarget && activeEl === domReference) {
            return;
          }
          if (
            contains(
              (_a2 = dataRef.current.floatingContext) == null ? void 0 : _a2.refs.floating.current,
              activeEl,
            ) ||
            contains(domReference, activeEl) ||
            movedToFocusGuard
          ) {
            return;
          }
          const nextFocusedElement = relatedTarget ?? activeEl;
          if (isElement(nextFocusedElement)) {
            const triggerElements = store.context.triggerElements;
            if (
              triggerElements.hasElement(nextFocusedElement) ||
              triggerElements.hasMatchingElement((trigger) => contains(trigger, nextFocusedElement))
            ) {
              return;
            }
          }
          store.setOpen(false, createChangeEventDetails(triggerFocus, nativeEvent));
        });
      },
    }),
    [dataRef, store, visibleOnly, timeout, delay2],
  );
  return reactExports.useMemo(
    () =>
      enabled
        ? {
            reference,
            trigger: reference,
          }
        : {},
    [enabled, reference],
  );
}
const safePolygonIdentifier = createAttribute("safe-polygon");
const interactiveSelector = `button,a,[role="button"],select,[tabindex]:not([tabindex="-1"]),${TYPEABLE_SELECTOR}`;
function isInteractiveElement(element) {
  return element ? Boolean(element.closest(interactiveSelector)) : false;
}
function useHoverInteractionSharedState(store) {
  const pointerTypeRef = reactExports.useRef(void 0);
  const interactedInsideRef = reactExports.useRef(false);
  const handlerRef = reactExports.useRef(void 0);
  const blockMouseMoveRef = reactExports.useRef(true);
  const performedPointerEventsMutationRef = reactExports.useRef(false);
  const unbindMouseMoveRef = reactExports.useRef(() => {});
  const restTimeoutPendingRef = reactExports.useRef(false);
  const openChangeTimeout = useTimeout();
  const restTimeout = useTimeout();
  const handleCloseOptionsRef = reactExports.useRef(void 0);
  return reactExports.useMemo(() => {
    const data = store.context.dataRef.current;
    if (!data.hoverInteractionState) {
      data.hoverInteractionState = {
        pointerTypeRef,
        interactedInsideRef,
        handlerRef,
        blockMouseMoveRef,
        performedPointerEventsMutationRef,
        unbindMouseMoveRef,
        restTimeoutPendingRef,
        openChangeTimeout,
        restTimeout,
        handleCloseOptionsRef,
      };
    }
    return data.hoverInteractionState;
  }, [
    store,
    pointerTypeRef,
    interactedInsideRef,
    handlerRef,
    blockMouseMoveRef,
    performedPointerEventsMutationRef,
    unbindMouseMoveRef,
    restTimeoutPendingRef,
    openChangeTimeout,
    restTimeout,
    handleCloseOptionsRef,
  ]);
}
const clickLikeEvents = /* @__PURE__ */ new Set(["click", "mousedown"]);
function useHoverFloatingInteraction(context, parameters = {}) {
  const store = "rootStore" in context ? context.rootStore : context;
  const open = store.useState("open");
  const floatingElement = store.useState("floatingElement");
  const domReferenceElement = store.useState("domReferenceElement");
  const { dataRef } = store.context;
  const { enabled = true, closeDelay: closeDelayProp = 0, externalTree } = parameters;
  const {
    pointerTypeRef,
    interactedInsideRef,
    handlerRef,
    performedPointerEventsMutationRef,
    unbindMouseMoveRef,
    restTimeoutPendingRef,
    openChangeTimeout,
    handleCloseOptionsRef,
  } = useHoverInteractionSharedState(store);
  const tree = useFloatingTree(externalTree);
  const parentId = useFloatingParentNodeId();
  const isClickLikeOpenEvent = useStableCallback(() => {
    if (interactedInsideRef.current) {
      return true;
    }
    return dataRef.current.openEvent ? clickLikeEvents.has(dataRef.current.openEvent.type) : false;
  });
  const isHoverOpen = useStableCallback(() => {
    var _a2;
    const type = (_a2 = dataRef.current.openEvent) == null ? void 0 : _a2.type;
    return (type == null ? void 0 : type.includes("mouse")) && type !== "mousedown";
  });
  const closeWithDelay = reactExports.useCallback(
    (event, runElseBranch = true) => {
      const closeDelay = getDelay(closeDelayProp, pointerTypeRef.current);
      if (closeDelay && !handlerRef.current) {
        openChangeTimeout.start(closeDelay, () =>
          store.setOpen(false, createChangeEventDetails(triggerHover, event)),
        );
      } else if (runElseBranch) {
        openChangeTimeout.clear();
        store.setOpen(false, createChangeEventDetails(triggerHover, event));
      }
    },
    [closeDelayProp, handlerRef, store, pointerTypeRef, openChangeTimeout],
  );
  const cleanupMouseMoveHandler = useStableCallback(() => {
    unbindMouseMoveRef.current();
    handlerRef.current = void 0;
  });
  const clearPointerEvents = useStableCallback(() => {
    if (performedPointerEventsMutationRef.current) {
      const body = getDocument(floatingElement).body;
      body.style.pointerEvents = "";
      body.removeAttribute(safePolygonIdentifier);
      performedPointerEventsMutationRef.current = false;
    }
  });
  const handleInteractInside = useStableCallback((event) => {
    const target = getTarget(event);
    if (!isInteractiveElement(target)) {
      interactedInsideRef.current = false;
      return;
    }
    interactedInsideRef.current = true;
  });
  useIsoLayoutEffect(() => {
    if (!open) {
      pointerTypeRef.current = void 0;
      restTimeoutPendingRef.current = false;
      interactedInsideRef.current = false;
      cleanupMouseMoveHandler();
      clearPointerEvents();
    }
  }, [
    open,
    pointerTypeRef,
    restTimeoutPendingRef,
    interactedInsideRef,
    cleanupMouseMoveHandler,
    clearPointerEvents,
  ]);
  reactExports.useEffect(() => {
    return () => {
      cleanupMouseMoveHandler();
    };
  }, [cleanupMouseMoveHandler]);
  reactExports.useEffect(() => {
    return clearPointerEvents;
  }, [clearPointerEvents]);
  useIsoLayoutEffect(() => {
    var _a2, _b, _c;
    if (!enabled) {
      return void 0;
    }
    if (
      open &&
      ((_a2 = handleCloseOptionsRef.current) == null ? void 0 : _a2.blockPointerEvents) &&
      isHoverOpen() &&
      isElement(domReferenceElement) &&
      floatingElement
    ) {
      performedPointerEventsMutationRef.current = true;
      const body = getDocument(floatingElement).body;
      body.setAttribute(safePolygonIdentifier, "");
      const ref = domReferenceElement;
      const floatingEl = floatingElement;
      const parentFloating =
        (_c =
          (_b =
            tree == null ? void 0 : tree.nodesRef.current.find((node) => node.id === parentId)) ==
          null
            ? void 0
            : _b.context) == null
          ? void 0
          : _c.elements.floating;
      if (parentFloating) {
        parentFloating.style.pointerEvents = "";
      }
      body.style.pointerEvents = "none";
      ref.style.pointerEvents = "auto";
      floatingEl.style.pointerEvents = "auto";
      return () => {
        body.style.pointerEvents = "";
        ref.style.pointerEvents = "";
        floatingEl.style.pointerEvents = "";
      };
    }
    return void 0;
  }, [
    enabled,
    open,
    domReferenceElement,
    floatingElement,
    handleCloseOptionsRef,
    isHoverOpen,
    tree,
    parentId,
    performedPointerEventsMutationRef,
  ]);
  reactExports.useEffect(() => {
    if (!enabled) {
      return void 0;
    }
    function onScrollMouseLeave(event) {
      if (isClickLikeOpenEvent() || !dataRef.current.floatingContext || !store.select("open")) {
        return;
      }
      const triggerElements = store.context.triggerElements;
      if (event.relatedTarget && triggerElements.hasElement(event.relatedTarget)) {
        return;
      }
      clearPointerEvents();
      cleanupMouseMoveHandler();
      if (!isClickLikeOpenEvent()) {
        closeWithDelay(event);
      }
    }
    function onFloatingMouseEnter(event) {
      var _a2;
      openChangeTimeout.clear();
      clearPointerEvents();
      (_a2 = handlerRef.current) == null ? void 0 : _a2.call(handlerRef, event);
      cleanupMouseMoveHandler();
    }
    function onFloatingMouseLeave(event) {
      if (!isClickLikeOpenEvent()) {
        closeWithDelay(event, false);
      }
    }
    const floating = floatingElement;
    if (floating) {
      floating.addEventListener("mouseleave", onScrollMouseLeave);
      floating.addEventListener("mouseenter", onFloatingMouseEnter);
      floating.addEventListener("mouseleave", onFloatingMouseLeave);
      floating.addEventListener("pointerdown", handleInteractInside, true);
    }
    return () => {
      if (floating) {
        floating.removeEventListener("mouseleave", onScrollMouseLeave);
        floating.removeEventListener("mouseenter", onFloatingMouseEnter);
        floating.removeEventListener("mouseleave", onFloatingMouseLeave);
        floating.removeEventListener("pointerdown", handleInteractInside, true);
      }
    };
  });
}
function getDelay(value, pointerType) {
  if (pointerType && !isMouseLikePointerType(pointerType)) {
    return 0;
  }
  if (typeof value === "function") {
    return value();
  }
  return value;
}
function getRestMs(value) {
  if (typeof value === "function") {
    return value();
  }
  return value;
}
const EMPTY_REF = {
  current: null,
};
function useHoverReferenceInteraction(context, props = {}) {
  var _a2;
  const store = "rootStore" in context ? context.rootStore : context;
  const { dataRef, events } = store.context;
  const {
    enabled = true,
    delay: delay2 = 0,
    handleClose = null,
    mouseOnly = false,
    restMs = 0,
    move = true,
    triggerElementRef = EMPTY_REF,
    externalTree,
    isActiveTrigger = true,
  } = props;
  const tree = useFloatingTree(externalTree);
  const {
    pointerTypeRef,
    interactedInsideRef,
    handlerRef: closeHandlerRef,
    blockMouseMoveRef,
    performedPointerEventsMutationRef,
    unbindMouseMoveRef,
    restTimeoutPendingRef,
    openChangeTimeout,
    restTimeout,
    handleCloseOptionsRef,
  } = useHoverInteractionSharedState(store);
  const handleCloseRef = useValueAsRef(handleClose);
  const delayRef = useValueAsRef(delay2);
  const restMsRef = useValueAsRef(restMs);
  if (isActiveTrigger) {
    handleCloseOptionsRef.current = (_a2 = handleCloseRef.current) == null ? void 0 : _a2.__options;
  }
  const isClickLikeOpenEvent = useStableCallback(() => {
    if (interactedInsideRef.current) {
      return true;
    }
    return dataRef.current.openEvent
      ? ["click", "mousedown"].includes(dataRef.current.openEvent.type)
      : false;
  });
  const closeWithDelay = reactExports.useCallback(
    (event, runElseBranch = true) => {
      const closeDelay = getDelay$1(delayRef.current, "close", pointerTypeRef.current);
      if (closeDelay && !closeHandlerRef.current) {
        openChangeTimeout.start(closeDelay, () =>
          store.setOpen(false, createChangeEventDetails(triggerHover, event)),
        );
      } else if (runElseBranch) {
        openChangeTimeout.clear();
        store.setOpen(false, createChangeEventDetails(triggerHover, event));
      }
    },
    [delayRef, closeHandlerRef, store, pointerTypeRef, openChangeTimeout],
  );
  const cleanupMouseMoveHandler = useStableCallback(() => {
    unbindMouseMoveRef.current();
    closeHandlerRef.current = void 0;
  });
  const clearPointerEvents = useStableCallback(() => {
    if (performedPointerEventsMutationRef.current) {
      const body = getDocument(store.select("domReferenceElement")).body;
      body.style.pointerEvents = "";
      body.removeAttribute(safePolygonIdentifier);
      performedPointerEventsMutationRef.current = false;
    }
  });
  reactExports.useEffect(() => {
    if (!enabled) {
      return void 0;
    }
    function onOpenChangeLocal(details) {
      if (!details.open) {
        openChangeTimeout.clear();
        restTimeout.clear();
        blockMouseMoveRef.current = true;
        restTimeoutPendingRef.current = false;
      }
    }
    events.on("openchange", onOpenChangeLocal);
    return () => {
      events.off("openchange", onOpenChangeLocal);
    };
  }, [enabled, events, openChangeTimeout, restTimeout, blockMouseMoveRef, restTimeoutPendingRef]);
  const handleScrollMouseLeave = useStableCallback((event) => {
    var _a3;
    if (isClickLikeOpenEvent()) {
      return;
    }
    if (!dataRef.current.floatingContext) {
      return;
    }
    const triggerElements = store.context.triggerElements;
    if (event.relatedTarget && triggerElements.hasElement(event.relatedTarget)) {
      return;
    }
    const currentTrigger = triggerElementRef.current;
    (_a3 = handleCloseRef.current) == null
      ? void 0
      : _a3.call(handleCloseRef, {
          ...dataRef.current.floatingContext,
          tree,
          x: event.clientX,
          y: event.clientY,
          onClose() {
            clearPointerEvents();
            cleanupMouseMoveHandler();
            if (!isClickLikeOpenEvent() && currentTrigger === store.select("domReferenceElement")) {
              closeWithDelay(event);
            }
          },
        })(event);
  });
  reactExports.useEffect(() => {
    if (!enabled) {
      return void 0;
    }
    const trigger =
      triggerElementRef.current ?? (isActiveTrigger ? store.select("domReferenceElement") : null);
    if (!isElement(trigger)) {
      return void 0;
    }
    function onMouseEnter(event) {
      openChangeTimeout.clear();
      blockMouseMoveRef.current = false;
      if (mouseOnly && !isMouseLikePointerType(pointerTypeRef.current)) {
        return;
      }
      if (getRestMs(restMsRef.current) > 0 && !getDelay$1(delayRef.current, "open")) {
        return;
      }
      const openDelay = getDelay$1(delayRef.current, "open", pointerTypeRef.current);
      const currentDomReference = store.select("domReferenceElement");
      const allTriggers = store.context.triggerElements;
      const isOverInactiveTrigger =
        (allTriggers.hasElement(event.target) ||
          allTriggers.hasMatchingElement((t) => contains(t, event.target))) &&
        (!currentDomReference || !contains(currentDomReference, event.target));
      const triggerNode = event.currentTarget ?? null;
      const isOpen = store.select("open");
      const shouldOpen = !isOpen || isOverInactiveTrigger;
      if (isOverInactiveTrigger && isOpen) {
        store.setOpen(true, createChangeEventDetails(triggerHover, event, triggerNode));
      } else if (openDelay) {
        openChangeTimeout.start(openDelay, () => {
          if (shouldOpen) {
            store.setOpen(true, createChangeEventDetails(triggerHover, event, triggerNode));
          }
        });
      } else if (shouldOpen) {
        store.setOpen(true, createChangeEventDetails(triggerHover, event, triggerNode));
      }
    }
    function onMouseLeave(event) {
      if (isClickLikeOpenEvent()) {
        clearPointerEvents();
        return;
      }
      unbindMouseMoveRef.current();
      const domReferenceElement = store.select("domReferenceElement");
      const doc = getDocument(domReferenceElement);
      restTimeout.clear();
      restTimeoutPendingRef.current = false;
      const triggerElements = store.context.triggerElements;
      if (event.relatedTarget && triggerElements.hasElement(event.relatedTarget)) {
        return;
      }
      if (handleCloseRef.current && dataRef.current.floatingContext) {
        if (!store.select("open")) {
          openChangeTimeout.clear();
        }
        const currentTrigger = triggerElementRef.current;
        closeHandlerRef.current = handleCloseRef.current({
          ...dataRef.current.floatingContext,
          tree,
          x: event.clientX,
          y: event.clientY,
          onClose() {
            clearPointerEvents();
            cleanupMouseMoveHandler();
            if (!isClickLikeOpenEvent() && currentTrigger === store.select("domReferenceElement")) {
              closeWithDelay(event, true);
            }
          },
        });
        const handler = closeHandlerRef.current;
        handler(event);
        doc.addEventListener("mousemove", handler);
        unbindMouseMoveRef.current = () => {
          doc.removeEventListener("mousemove", handler);
        };
        return;
      }
      const shouldClose =
        pointerTypeRef.current === "touch"
          ? !contains(store.select("floatingElement"), event.relatedTarget)
          : true;
      if (shouldClose) {
        closeWithDelay(event);
      }
    }
    function onScrollMouseLeave(event) {
      handleScrollMouseLeave(event);
    }
    if (store.select("open")) {
      trigger.addEventListener("mouseleave", onScrollMouseLeave);
    }
    if (move) {
      trigger.addEventListener("mousemove", onMouseEnter, {
        once: true,
      });
    }
    trigger.addEventListener("mouseenter", onMouseEnter);
    trigger.addEventListener("mouseleave", onMouseLeave);
    return () => {
      trigger.removeEventListener("mouseleave", onScrollMouseLeave);
      if (move) {
        trigger.removeEventListener("mousemove", onMouseEnter);
      }
      trigger.removeEventListener("mouseenter", onMouseEnter);
      trigger.removeEventListener("mouseleave", onMouseLeave);
    };
  }, [
    cleanupMouseMoveHandler,
    clearPointerEvents,
    blockMouseMoveRef,
    dataRef,
    delayRef,
    closeWithDelay,
    store,
    enabled,
    handleCloseRef,
    handleScrollMouseLeave,
    isActiveTrigger,
    isClickLikeOpenEvent,
    mouseOnly,
    move,
    pointerTypeRef,
    restMsRef,
    restTimeout,
    restTimeoutPendingRef,
    openChangeTimeout,
    triggerElementRef,
    tree,
    unbindMouseMoveRef,
    closeHandlerRef,
  ]);
  return reactExports.useMemo(() => {
    function setPointerRef(event) {
      pointerTypeRef.current = event.pointerType;
    }
    return {
      onPointerDown: setPointerRef,
      onPointerEnter: setPointerRef,
      onMouseMove(event) {
        const { nativeEvent } = event;
        const trigger = event.currentTarget;
        const currentDomReference = store.select("domReferenceElement");
        const allTriggers = store.context.triggerElements;
        const currentOpen = store.select("open");
        const isOverInactiveTrigger =
          (allTriggers.hasElement(event.target) ||
            allTriggers.hasMatchingElement((t) => contains(t, event.target))) &&
          (!currentDomReference || !contains(currentDomReference, event.target));
        if (mouseOnly && !isMouseLikePointerType(pointerTypeRef.current)) {
          return;
        }
        if ((currentOpen && !isOverInactiveTrigger) || getRestMs(restMsRef.current) === 0) {
          return;
        }
        if (
          !isOverInactiveTrigger &&
          restTimeoutPendingRef.current &&
          event.movementX ** 2 + event.movementY ** 2 < 2
        ) {
          return;
        }
        restTimeout.clear();
        function handleMouseMove() {
          restTimeoutPendingRef.current = false;
          if (isClickLikeOpenEvent()) {
            return;
          }
          const latestOpen = store.select("open");
          if (!blockMouseMoveRef.current && (!latestOpen || isOverInactiveTrigger)) {
            store.setOpen(true, createChangeEventDetails(triggerHover, nativeEvent, trigger));
          }
        }
        if (pointerTypeRef.current === "touch") {
          reactDomExports.flushSync(() => {
            handleMouseMove();
          });
        } else if (isOverInactiveTrigger && currentOpen) {
          handleMouseMove();
        } else {
          restTimeoutPendingRef.current = true;
          restTimeout.start(getRestMs(restMsRef.current), handleMouseMove);
        }
      },
    };
  }, [
    blockMouseMoveRef,
    isClickLikeOpenEvent,
    mouseOnly,
    store,
    pointerTypeRef,
    restMsRef,
    restTimeout,
    restTimeoutPendingRef,
  ]);
}
function useInteractions(propsList = []) {
  const referenceDeps = propsList.map((key) => (key == null ? void 0 : key.reference));
  const floatingDeps = propsList.map((key) => (key == null ? void 0 : key.floating));
  const itemDeps = propsList.map((key) => (key == null ? void 0 : key.item));
  const triggerDeps = propsList.map((key) => (key == null ? void 0 : key.trigger));
  const getReferenceProps = reactExports.useCallback(
    (userProps) => mergeProps(userProps, propsList, "reference"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    referenceDeps,
  );
  const getFloatingProps = reactExports.useCallback(
    (userProps) => mergeProps(userProps, propsList, "floating"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    floatingDeps,
  );
  const getItemProps = reactExports.useCallback(
    (userProps) => mergeProps(userProps, propsList, "item"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    itemDeps,
  );
  const getTriggerProps = reactExports.useCallback(
    (userProps) => mergeProps(userProps, propsList, "trigger"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    triggerDeps,
  );
  return reactExports.useMemo(
    () => ({
      getReferenceProps,
      getFloatingProps,
      getItemProps,
      getTriggerProps,
    }),
    [getReferenceProps, getFloatingProps, getItemProps, getTriggerProps],
  );
}
function mergeProps(userProps, propsList, elementKey) {
  var _a2;
  const eventHandlers = /* @__PURE__ */ new Map();
  const isItem = elementKey === "item";
  const outputProps = {};
  if (elementKey === "floating") {
    outputProps.tabIndex = -1;
    outputProps[FOCUSABLE_ATTRIBUTE] = "";
  }
  for (const key in userProps) {
    if (isItem && userProps) {
      if (key === ACTIVE_KEY || key === SELECTED_KEY) {
        continue;
      }
    }
    outputProps[key] = userProps[key];
  }
  for (let i = 0; i < propsList.length; i += 1) {
    let props;
    const propsOrGetProps = (_a2 = propsList[i]) == null ? void 0 : _a2[elementKey];
    if (typeof propsOrGetProps === "function") {
      props = userProps ? propsOrGetProps(userProps) : null;
    } else {
      props = propsOrGetProps;
    }
    if (!props) {
      continue;
    }
    mutablyMergeProps(outputProps, props, isItem, eventHandlers);
  }
  mutablyMergeProps(outputProps, userProps, isItem, eventHandlers);
  return outputProps;
}
function mutablyMergeProps(outputProps, props, isItem, eventHandlers) {
  var _a2;
  for (const key in props) {
    const value = props[key];
    if (isItem && (key === ACTIVE_KEY || key === SELECTED_KEY)) {
      continue;
    }
    if (!key.startsWith("on")) {
      outputProps[key] = value;
    } else {
      if (!eventHandlers.has(key)) {
        eventHandlers.set(key, []);
      }
      if (typeof value === "function") {
        (_a2 = eventHandlers.get(key)) == null ? void 0 : _a2.push(value);
        outputProps[key] = (...args) => {
          var _a3;
          return (_a3 = eventHandlers.get(key)) == null
            ? void 0
            : _a3.map((fn) => fn(...args)).find((val) => val !== void 0);
        };
      }
    }
  }
}
const ESCAPE = "Escape";
function doSwitch(orientation, vertical, horizontal) {
  switch (orientation) {
    case "vertical":
      return vertical;
    case "horizontal":
      return horizontal;
    default:
      return vertical || horizontal;
  }
}
function isMainOrientationKey(key, orientation) {
  const vertical = key === ARROW_UP$1 || key === ARROW_DOWN$1;
  const horizontal = key === ARROW_LEFT$1 || key === ARROW_RIGHT$1;
  return doSwitch(orientation, vertical, horizontal);
}
function isMainOrientationToEndKey(key, orientation, rtl) {
  const vertical = key === ARROW_DOWN$1;
  const horizontal = rtl ? key === ARROW_LEFT$1 : key === ARROW_RIGHT$1;
  return (
    doSwitch(orientation, vertical, horizontal) || key === "Enter" || key === " " || key === ""
  );
}
function isCrossOrientationOpenKey(key, orientation, rtl) {
  const vertical = rtl ? key === ARROW_LEFT$1 : key === ARROW_RIGHT$1;
  const horizontal = key === ARROW_DOWN$1;
  return doSwitch(orientation, vertical, horizontal);
}
function isCrossOrientationCloseKey(key, orientation, rtl, cols) {
  const vertical = rtl ? key === ARROW_RIGHT$1 : key === ARROW_LEFT$1;
  const horizontal = key === ARROW_UP$1;
  if (orientation === "both" || (orientation === "horizontal" && cols && cols > 1)) {
    return key === ESCAPE;
  }
  return doSwitch(orientation, vertical, horizontal);
}
function useListNavigation(context, props) {
  const store = "rootStore" in context ? context.rootStore : context;
  const open = store.useState("open");
  const floatingElement = store.useState("floatingElement");
  const domReferenceElement = store.useState("domReferenceElement");
  const dataRef = store.context.dataRef;
  const {
    listRef,
    activeIndex,
    onNavigate: onNavigateProp = () => {},
    enabled = true,
    selectedIndex = null,
    allowEscape = false,
    loopFocus = false,
    nested = false,
    rtl = false,
    virtual = false,
    focusItemOnOpen = "auto",
    focusItemOnHover = true,
    openOnArrowKeyDown = true,
    disabledIndices = void 0,
    orientation = "vertical",
    parentOrientation,
    cols = 1,
    scrollItemIntoView = true,
    itemSizes,
    dense = false,
    id: id2,
    resetOnPointerLeave = true,
    externalTree,
  } = props;
  const floatingFocusElement = getFloatingFocusElement(floatingElement);
  const floatingFocusElementRef = useValueAsRef(floatingFocusElement);
  const parentId = useFloatingParentNodeId();
  const tree = useFloatingTree(externalTree);
  useIsoLayoutEffect(() => {
    dataRef.current.orientation = orientation;
  }, [dataRef, orientation]);
  const typeableComboboxReference = isTypeableCombobox(domReferenceElement);
  const focusItemOnOpenRef = reactExports.useRef(focusItemOnOpen);
  const indexRef = reactExports.useRef(selectedIndex ?? -1);
  const keyRef = reactExports.useRef(null);
  const isPointerModalityRef = reactExports.useRef(true);
  const onNavigate = useStableCallback((event) => {
    onNavigateProp(indexRef.current === -1 ? null : indexRef.current, event);
  });
  const previousOnNavigateRef = reactExports.useRef(onNavigate);
  const previousMountedRef = reactExports.useRef(!!floatingElement);
  const previousOpenRef = reactExports.useRef(open);
  const forceSyncFocusRef = reactExports.useRef(false);
  const forceScrollIntoViewRef = reactExports.useRef(false);
  const disabledIndicesRef = useValueAsRef(disabledIndices);
  const latestOpenRef = useValueAsRef(open);
  const scrollItemIntoViewRef = useValueAsRef(scrollItemIntoView);
  const selectedIndexRef = useValueAsRef(selectedIndex);
  const resetOnPointerLeaveRef = useValueAsRef(resetOnPointerLeave);
  const focusItem = useStableCallback(() => {
    function runFocus(item2) {
      if (virtual) {
        tree == null ? void 0 : tree.events.emit("virtualfocus", item2);
      } else {
        enqueueFocus(item2, {
          sync: forceSyncFocusRef.current,
          preventScroll: true,
        });
      }
    }
    const initialItem = listRef.current[indexRef.current];
    const forceScrollIntoView = forceScrollIntoViewRef.current;
    if (initialItem) {
      runFocus(initialItem);
    }
    const scheduler2 = forceSyncFocusRef.current ? (v) => v() : requestAnimationFrame;
    scheduler2(() => {
      var _a2;
      const waitedItem = listRef.current[indexRef.current] || initialItem;
      if (!waitedItem) {
        return;
      }
      if (!initialItem) {
        runFocus(waitedItem);
      }
      const scrollIntoViewOptions = scrollItemIntoViewRef.current;
      const shouldScrollIntoView =
        scrollIntoViewOptions && // eslint-disable-next-line @typescript-eslint/no-use-before-define
        item &&
        (forceScrollIntoView || !isPointerModalityRef.current);
      if (shouldScrollIntoView) {
        (_a2 = waitedItem.scrollIntoView) == null
          ? void 0
          : _a2.call(
              waitedItem,
              typeof scrollIntoViewOptions === "boolean"
                ? {
                    block: "nearest",
                    inline: "nearest",
                  }
                : scrollIntoViewOptions,
            );
      }
    });
  });
  useIsoLayoutEffect(() => {
    if (!enabled) {
      return;
    }
    if (open && floatingElement) {
      indexRef.current = selectedIndex ?? -1;
      if (focusItemOnOpenRef.current && selectedIndex != null) {
        forceScrollIntoViewRef.current = true;
        onNavigate();
      }
    } else if (previousMountedRef.current) {
      indexRef.current = -1;
      previousOnNavigateRef.current();
    }
  }, [enabled, open, floatingElement, selectedIndex, onNavigate]);
  useIsoLayoutEffect(() => {
    if (!enabled) {
      return;
    }
    if (!open) {
      forceSyncFocusRef.current = false;
      return;
    }
    if (!floatingElement) {
      return;
    }
    if (activeIndex == null) {
      forceSyncFocusRef.current = false;
      if (selectedIndexRef.current != null) {
        return;
      }
      if (previousMountedRef.current) {
        indexRef.current = -1;
        focusItem();
      }
      if (
        (!previousOpenRef.current || !previousMountedRef.current) &&
        focusItemOnOpenRef.current &&
        (keyRef.current != null || (focusItemOnOpenRef.current === true && keyRef.current == null))
      ) {
        let runs = 0;
        const waitForListPopulated = () => {
          if (listRef.current[0] == null) {
            if (runs < 2) {
              const scheduler2 = runs ? requestAnimationFrame : queueMicrotask;
              scheduler2(waitForListPopulated);
            }
            runs += 1;
          } else {
            indexRef.current =
              keyRef.current == null ||
              isMainOrientationToEndKey(keyRef.current, orientation, rtl) ||
              nested
                ? getMinListIndex(listRef)
                : getMaxListIndex(listRef);
            keyRef.current = null;
            onNavigate();
          }
        };
        waitForListPopulated();
      }
    } else if (!isIndexOutOfListBounds(listRef, activeIndex)) {
      indexRef.current = activeIndex;
      focusItem();
      forceScrollIntoViewRef.current = false;
    }
  }, [
    enabled,
    open,
    floatingElement,
    activeIndex,
    selectedIndexRef,
    nested,
    listRef,
    orientation,
    rtl,
    onNavigate,
    focusItem,
    disabledIndicesRef,
  ]);
  useIsoLayoutEffect(() => {
    var _a2, _b;
    if (!enabled || floatingElement || !tree || virtual || !previousMountedRef.current) {
      return;
    }
    const nodes = tree.nodesRef.current;
    const parent =
      (_b = (_a2 = nodes.find((node) => node.id === parentId)) == null ? void 0 : _a2.context) ==
      null
        ? void 0
        : _b.elements.floating;
    const activeEl = activeElement(getDocument(floatingElement));
    const treeContainsActiveEl = nodes.some(
      (node) => node.context && contains(node.context.elements.floating, activeEl),
    );
    if (parent && !treeContainsActiveEl && isPointerModalityRef.current) {
      parent.focus({
        preventScroll: true,
      });
    }
  }, [enabled, floatingElement, tree, parentId, virtual]);
  useIsoLayoutEffect(() => {
    previousOnNavigateRef.current = onNavigate;
    previousOpenRef.current = open;
    previousMountedRef.current = !!floatingElement;
  });
  useIsoLayoutEffect(() => {
    if (!open) {
      keyRef.current = null;
      focusItemOnOpenRef.current = focusItemOnOpen;
    }
  }, [open, focusItemOnOpen]);
  const hasActiveIndex = activeIndex != null;
  const item = reactExports.useMemo(() => {
    function syncCurrentTarget(event) {
      if (!latestOpenRef.current) {
        return;
      }
      const index2 = listRef.current.indexOf(event.currentTarget);
      if (index2 !== -1 && indexRef.current !== index2) {
        indexRef.current = index2;
        onNavigate(event);
      }
    }
    const itemProps = {
      onFocus(event) {
        forceSyncFocusRef.current = true;
        syncCurrentTarget(event);
      },
      onClick: ({ currentTarget }) =>
        currentTarget.focus({
          preventScroll: true,
        }),
      // Safari
      onMouseMove(event) {
        forceSyncFocusRef.current = true;
        forceScrollIntoViewRef.current = false;
        if (focusItemOnHover) {
          syncCurrentTarget(event);
        }
      },
      onPointerLeave(event) {
        var _a2;
        if (
          !latestOpenRef.current ||
          !isPointerModalityRef.current ||
          event.pointerType === "touch"
        ) {
          return;
        }
        forceSyncFocusRef.current = true;
        const relatedTarget = event.relatedTarget;
        if (!focusItemOnHover || listRef.current.includes(relatedTarget)) {
          return;
        }
        if (!resetOnPointerLeaveRef.current) {
          return;
        }
        indexRef.current = -1;
        onNavigate(event);
        if (!virtual) {
          (_a2 = floatingFocusElementRef.current) == null
            ? void 0
            : _a2.focus({
                preventScroll: true,
              });
        }
      },
    };
    return itemProps;
  }, [
    latestOpenRef,
    floatingFocusElementRef,
    focusItemOnHover,
    listRef,
    onNavigate,
    resetOnPointerLeaveRef,
    virtual,
  ]);
  const getParentOrientation = reactExports.useCallback(() => {
    var _a2, _b, _c;
    return (
      parentOrientation ??
      ((_c =
        (_b =
          (_a2 =
            tree == null ? void 0 : tree.nodesRef.current.find((node) => node.id === parentId)) ==
          null
            ? void 0
            : _a2.context) == null
          ? void 0
          : _b.dataRef) == null
        ? void 0
        : _c.current.orientation)
    );
  }, [parentId, tree, parentOrientation]);
  const commonOnKeyDown = useStableCallback((event) => {
    isPointerModalityRef.current = false;
    forceSyncFocusRef.current = true;
    if (event.which === 229) {
      return;
    }
    if (!latestOpenRef.current && event.currentTarget === floatingFocusElementRef.current) {
      return;
    }
    if (nested && isCrossOrientationCloseKey(event.key, orientation, rtl, cols)) {
      if (!isMainOrientationKey(event.key, getParentOrientation())) {
        stopEvent(event);
      }
      store.setOpen(false, createChangeEventDetails(listNavigation, event.nativeEvent));
      if (isHTMLElement(domReferenceElement)) {
        if (virtual) {
          tree == null ? void 0 : tree.events.emit("virtualfocus", domReferenceElement);
        } else {
          domReferenceElement.focus();
        }
      }
      return;
    }
    const currentIndex = indexRef.current;
    const minIndex = getMinListIndex(listRef, disabledIndices);
    const maxIndex = getMaxListIndex(listRef, disabledIndices);
    if (!typeableComboboxReference) {
      if (event.key === "Home") {
        stopEvent(event);
        indexRef.current = minIndex;
        onNavigate(event);
      }
      if (event.key === "End") {
        stopEvent(event);
        indexRef.current = maxIndex;
        onNavigate(event);
      }
    }
    if (cols > 1) {
      const sizes =
        itemSizes ||
        Array.from(
          {
            length: listRef.current.length,
          },
          () => ({
            width: 1,
            height: 1,
          }),
        );
      const cellMap = createGridCellMap(sizes, cols, dense);
      const minGridIndex = cellMap.findIndex(
        (index22) => index22 != null && !isListIndexDisabled(listRef, index22, disabledIndices),
      );
      const maxGridIndex = cellMap.reduce(
        (foundIndex, index22, cellIndex) =>
          index22 != null && !isListIndexDisabled(listRef, index22, disabledIndices)
            ? cellIndex
            : foundIndex,
        -1,
      );
      const index2 =
        cellMap[
          getGridNavigatedIndex(
            {
              current: cellMap.map((itemIndex) =>
                itemIndex != null ? listRef.current[itemIndex] : null,
              ),
            },
            {
              event,
              orientation,
              loopFocus,
              rtl,
              cols,
              // treat undefined (empty grid spaces) as disabled indices so we
              // don't end up in them
              disabledIndices: getGridCellIndices(
                [
                  ...((typeof disabledIndices !== "function" ? disabledIndices : null) ||
                    listRef.current.map((_, listIndex) =>
                      isListIndexDisabled(listRef, listIndex, disabledIndices) ? listIndex : void 0,
                    )),
                  void 0,
                ],
                cellMap,
              ),
              minIndex: minGridIndex,
              maxIndex: maxGridIndex,
              prevIndex: getGridCellIndexOfCorner(
                indexRef.current > maxIndex ? minIndex : indexRef.current,
                sizes,
                cellMap,
                cols,
                // use a corner matching the edge closest to the direction
                // we're moving in so we don't end up in the same item. Prefer
                // top/left over bottom/right.
                // eslint-disable-next-line no-nested-ternary
                event.key === ARROW_DOWN$1
                  ? "bl"
                  : event.key === (rtl ? ARROW_LEFT$1 : ARROW_RIGHT$1)
                    ? "tr"
                    : "tl",
              ),
              stopEvent: true,
            },
          )
        ];
      if (index2 != null) {
        indexRef.current = index2;
        onNavigate(event);
      }
      if (orientation === "both") {
        return;
      }
    }
    if (isMainOrientationKey(event.key, orientation)) {
      stopEvent(event);
      if (
        open &&
        !virtual &&
        activeElement(event.currentTarget.ownerDocument) === event.currentTarget
      ) {
        indexRef.current = isMainOrientationToEndKey(event.key, orientation, rtl)
          ? minIndex
          : maxIndex;
        onNavigate(event);
        return;
      }
      if (isMainOrientationToEndKey(event.key, orientation, rtl)) {
        if (loopFocus) {
          if (currentIndex >= maxIndex) {
            if (allowEscape && currentIndex !== listRef.current.length) {
              indexRef.current = -1;
            } else {
              forceSyncFocusRef.current = false;
              indexRef.current = minIndex;
            }
          } else {
            indexRef.current = findNonDisabledListIndex(listRef, {
              startingIndex: currentIndex,
              disabledIndices,
            });
          }
        } else {
          indexRef.current = Math.min(
            maxIndex,
            findNonDisabledListIndex(listRef, {
              startingIndex: currentIndex,
              disabledIndices,
            }),
          );
        }
      } else if (loopFocus) {
        if (currentIndex <= minIndex) {
          if (allowEscape && currentIndex !== -1) {
            indexRef.current = listRef.current.length;
          } else {
            forceSyncFocusRef.current = false;
            indexRef.current = maxIndex;
          }
        } else {
          indexRef.current = findNonDisabledListIndex(listRef, {
            startingIndex: currentIndex,
            decrement: true,
            disabledIndices,
          });
        }
      } else {
        indexRef.current = Math.max(
          minIndex,
          findNonDisabledListIndex(listRef, {
            startingIndex: currentIndex,
            decrement: true,
            disabledIndices,
          }),
        );
      }
      if (isIndexOutOfListBounds(listRef, indexRef.current)) {
        indexRef.current = -1;
      }
      onNavigate(event);
    }
  });
  const ariaActiveDescendantProp = reactExports.useMemo(() => {
    return (
      virtual &&
      open &&
      hasActiveIndex && {
        "aria-activedescendant": `${id2}-${activeIndex}`,
      }
    );
  }, [virtual, open, hasActiveIndex, id2, activeIndex]);
  const floating = reactExports.useMemo(() => {
    return {
      "aria-orientation": orientation === "both" ? void 0 : orientation,
      ...(!typeableComboboxReference ? ariaActiveDescendantProp : {}),
      onKeyDown(event) {
        if (event.key === "Tab" && event.shiftKey && open && !virtual) {
          const target = getTarget(event.nativeEvent);
          if (target && !contains(floatingFocusElementRef.current, target)) {
            return;
          }
          stopEvent(event);
          store.setOpen(false, createChangeEventDetails(focusOut, event.nativeEvent));
          if (isHTMLElement(domReferenceElement)) {
            domReferenceElement.focus();
          }
          return;
        }
        commonOnKeyDown(event);
      },
      onPointerMove() {
        isPointerModalityRef.current = true;
      },
    };
  }, [
    ariaActiveDescendantProp,
    commonOnKeyDown,
    floatingFocusElementRef,
    orientation,
    typeableComboboxReference,
    store,
    open,
    virtual,
    domReferenceElement,
  ]);
  const trigger = reactExports.useMemo(() => {
    function checkVirtualMouse(event) {
      if (focusItemOnOpen === "auto" && isVirtualClick(event.nativeEvent)) {
        focusItemOnOpenRef.current = !virtual;
      }
    }
    function checkVirtualPointer(event) {
      focusItemOnOpenRef.current = focusItemOnOpen;
      if (focusItemOnOpen === "auto" && isVirtualPointerEvent(event.nativeEvent)) {
        focusItemOnOpenRef.current = true;
      }
    }
    return {
      onKeyDown(event) {
        const currentOpen = store.select("open");
        isPointerModalityRef.current = false;
        const isArrowKey = event.key.startsWith("Arrow");
        const isParentCrossOpenKey = isCrossOrientationOpenKey(
          event.key,
          getParentOrientation(),
          rtl,
        );
        const isMainKey = isMainOrientationKey(event.key, orientation);
        const isNavigationKey =
          (nested ? isParentCrossOpenKey : isMainKey) ||
          event.key === "Enter" ||
          event.key.trim() === "";
        if (virtual && currentOpen) {
          return commonOnKeyDown(event);
        }
        if (!currentOpen && !openOnArrowKeyDown && isArrowKey) {
          return void 0;
        }
        if (isNavigationKey) {
          const isParentMainKey = isMainOrientationKey(event.key, getParentOrientation());
          keyRef.current = nested && isParentMainKey ? null : event.key;
        }
        if (nested) {
          if (isParentCrossOpenKey) {
            stopEvent(event);
            if (currentOpen) {
              indexRef.current = getMinListIndex(listRef, disabledIndicesRef.current);
              onNavigate(event);
            } else {
              store.setOpen(
                true,
                createChangeEventDetails(listNavigation, event.nativeEvent, event.currentTarget),
              );
            }
          }
          return void 0;
        }
        if (isMainKey) {
          if (selectedIndexRef.current != null) {
            indexRef.current = selectedIndexRef.current;
          }
          stopEvent(event);
          if (!currentOpen && openOnArrowKeyDown) {
            store.setOpen(
              true,
              createChangeEventDetails(listNavigation, event.nativeEvent, event.currentTarget),
            );
          } else {
            commonOnKeyDown(event);
          }
          if (currentOpen) {
            onNavigate(event);
          }
        }
        return void 0;
      },
      onFocus(event) {
        if (store.select("open") && !virtual) {
          indexRef.current = -1;
          onNavigate(event);
        }
      },
      onPointerDown: checkVirtualPointer,
      onPointerEnter: checkVirtualPointer,
      onMouseDown: checkVirtualMouse,
      onClick: checkVirtualMouse,
    };
  }, [
    commonOnKeyDown,
    disabledIndicesRef,
    focusItemOnOpen,
    listRef,
    nested,
    onNavigate,
    store,
    openOnArrowKeyDown,
    orientation,
    getParentOrientation,
    rtl,
    selectedIndexRef,
    virtual,
  ]);
  const reference = reactExports.useMemo(() => {
    return {
      ...ariaActiveDescendantProp,
      ...trigger,
    };
  }, [ariaActiveDescendantProp, trigger]);
  return reactExports.useMemo(
    () =>
      enabled
        ? {
            reference,
            floating,
            item,
            trigger,
          }
        : {},
    [enabled, reference, floating, trigger, item],
  );
}
const componentRoleToAriaRoleMap = /* @__PURE__ */ new Map([
  ["select", "listbox"],
  ["combobox", "listbox"],
  ["label", false],
]);
function useRole(context, props = {}) {
  const store = "rootStore" in context ? context.rootStore : context;
  const open = store.useState("open");
  const defaultFloatingId = store.useState("floatingId");
  const domReference = store.useState("domReferenceElement");
  const floatingElement = store.useState("floatingElement");
  const { enabled = true, role = "dialog" } = props;
  const defaultReferenceId = useId();
  const referenceId = (domReference == null ? void 0 : domReference.id) || defaultReferenceId;
  const floatingId = reactExports.useMemo(() => {
    var _a2;
    return (
      ((_a2 = getFloatingFocusElement(floatingElement)) == null ? void 0 : _a2.id) ||
      defaultFloatingId
    );
  }, [floatingElement, defaultFloatingId]);
  const ariaRole = componentRoleToAriaRoleMap.get(role) ?? role;
  const parentId = useFloatingParentNodeId();
  const isNested = parentId != null;
  const trigger = reactExports.useMemo(() => {
    if (ariaRole === "tooltip" || role === "label") {
      return EMPTY_OBJECT;
    }
    return {
      "aria-haspopup": ariaRole === "alertdialog" ? "dialog" : ariaRole,
      "aria-expanded": "false",
      ...(ariaRole === "listbox" && {
        role: "combobox",
      }),
      ...(ariaRole === "menu" &&
        isNested && {
          role: "menuitem",
        }),
      ...(role === "select" && {
        "aria-autocomplete": "none",
      }),
      ...(role === "combobox" && {
        "aria-autocomplete": "list",
      }),
    };
  }, [ariaRole, isNested, role]);
  const reference = reactExports.useMemo(() => {
    if (ariaRole === "tooltip" || role === "label") {
      return {
        [`aria-${role === "label" ? "labelledby" : "describedby"}`]: open ? floatingId : void 0,
      };
    }
    const triggerProps = trigger;
    return {
      ...triggerProps,
      "aria-expanded": open ? "true" : "false",
      "aria-controls": open ? floatingId : void 0,
      ...(ariaRole === "menu" && {
        id: referenceId,
      }),
    };
  }, [ariaRole, floatingId, open, referenceId, role, trigger]);
  const floating = reactExports.useMemo(() => {
    const floatingProps = {
      id: floatingId,
      ...(ariaRole && {
        role: ariaRole,
      }),
    };
    if (ariaRole === "tooltip" || role === "label") {
      return floatingProps;
    }
    return {
      ...floatingProps,
      ...(ariaRole === "menu" && {
        "aria-labelledby": referenceId,
      }),
    };
  }, [ariaRole, floatingId, referenceId, role]);
  const item = reactExports.useCallback(
    ({ active, selected }) => {
      const commonProps = {
        role: "option",
        ...(active && {
          id: `${floatingId}-fui-option`,
        }),
      };
      switch (role) {
        case "select":
        case "combobox":
          return {
            ...commonProps,
            "aria-selected": selected,
          };
      }
      return {};
    },
    [floatingId, role],
  );
  return reactExports.useMemo(
    () =>
      enabled
        ? {
            reference,
            floating,
            item,
            trigger,
          }
        : {},
    [enabled, reference, floating, trigger, item],
  );
}
function useTypeahead(context, props) {
  const store = "rootStore" in context ? context.rootStore : context;
  const open = store.useState("open");
  const dataRef = store.context.dataRef;
  const {
    listRef,
    activeIndex,
    onMatch: onMatchProp,
    onTypingChange,
    enabled = true,
    findMatch = null,
    resetMs = 750,
    ignoreKeys = EMPTY_ARRAY$1,
    selectedIndex = null,
  } = props;
  const timeout = useTimeout();
  const stringRef = reactExports.useRef("");
  const prevIndexRef = reactExports.useRef(selectedIndex ?? activeIndex ?? -1);
  const matchIndexRef = reactExports.useRef(null);
  useIsoLayoutEffect(() => {
    if (open) {
      timeout.clear();
      matchIndexRef.current = null;
      stringRef.current = "";
    }
  }, [open, timeout]);
  useIsoLayoutEffect(() => {
    if (open && stringRef.current === "") {
      prevIndexRef.current = selectedIndex ?? activeIndex ?? -1;
    }
  }, [open, selectedIndex, activeIndex]);
  const setTypingChange = useStableCallback((value) => {
    if (value) {
      if (!dataRef.current.typing) {
        dataRef.current.typing = value;
        onTypingChange == null ? void 0 : onTypingChange(value);
      }
    } else if (dataRef.current.typing) {
      dataRef.current.typing = value;
      onTypingChange == null ? void 0 : onTypingChange(value);
    }
  });
  const onKeyDown = useStableCallback((event) => {
    function getMatchingIndex(list, orderedList, string) {
      const str = findMatch
        ? findMatch(orderedList, string)
        : orderedList.find(
            (text) =>
              (text == null
                ? void 0
                : text.toLocaleLowerCase().indexOf(string.toLocaleLowerCase())) === 0,
          );
      return str ? list.indexOf(str) : -1;
    }
    const listContent = listRef.current;
    if (stringRef.current.length > 0 && stringRef.current[0] !== " ") {
      if (getMatchingIndex(listContent, listContent, stringRef.current) === -1) {
        setTypingChange(false);
      } else if (event.key === " ") {
        stopEvent(event);
      }
    }
    if (
      listContent == null ||
      ignoreKeys.includes(event.key) || // Character key.
      event.key.length !== 1 || // Modifier key.
      event.ctrlKey ||
      event.metaKey ||
      event.altKey
    ) {
      return;
    }
    if (open && event.key !== " ") {
      stopEvent(event);
      setTypingChange(true);
    }
    const allowRapidSuccessionOfFirstLetter = listContent.every((text) => {
      var _a2, _b;
      return text
        ? ((_a2 = text[0]) == null ? void 0 : _a2.toLocaleLowerCase()) !==
            ((_b = text[1]) == null ? void 0 : _b.toLocaleLowerCase())
        : true;
    });
    if (allowRapidSuccessionOfFirstLetter && stringRef.current === event.key) {
      stringRef.current = "";
      prevIndexRef.current = matchIndexRef.current;
    }
    stringRef.current += event.key;
    timeout.start(resetMs, () => {
      stringRef.current = "";
      prevIndexRef.current = matchIndexRef.current;
      setTypingChange(false);
    });
    const prevIndex = prevIndexRef.current;
    const index2 = getMatchingIndex(
      listContent,
      [...listContent.slice((prevIndex || 0) + 1), ...listContent.slice(0, (prevIndex || 0) + 1)],
      stringRef.current,
    );
    if (index2 !== -1) {
      onMatchProp == null ? void 0 : onMatchProp(index2);
      matchIndexRef.current = index2;
    } else if (event.key !== " ") {
      stringRef.current = "";
      setTypingChange(false);
    }
  });
  const reference = reactExports.useMemo(
    () => ({
      onKeyDown,
    }),
    [onKeyDown],
  );
  const floating = reactExports.useMemo(() => {
    return {
      onKeyDown,
      onKeyUp(event) {
        if (event.key === " ") {
          setTypingChange(false);
        }
      },
    };
  }, [onKeyDown, setTypingChange]);
  return reactExports.useMemo(
    () =>
      enabled
        ? {
            reference,
            floating,
          }
        : {},
    [enabled, reference, floating],
  );
}
function isPointInPolygon(point, polygon) {
  const [x, y] = point;
  let isInsideValue = false;
  const length = polygon.length;
  for (let i = 0, j = length - 1; i < length; j = i++) {
    const [xi, yi] = polygon[i] || [0, 0];
    const [xj, yj] = polygon[j] || [0, 0];
    const intersect = yi >= y !== yj >= y && x <= ((xj - xi) * (y - yi)) / (yj - yi) + xi;
    if (intersect) {
      isInsideValue = !isInsideValue;
    }
  }
  return isInsideValue;
}
function isInside(point, rect) {
  return (
    point[0] >= rect.x &&
    point[0] <= rect.x + rect.width &&
    point[1] >= rect.y &&
    point[1] <= rect.y + rect.height
  );
}
function safePolygon(options = {}) {
  const { buffer = 0.5, blockPointerEvents = false, requireIntent = true } = options;
  const timeout = new Timeout();
  let hasLanded = false;
  let lastX = null;
  let lastY = null;
  let lastCursorTime = typeof performance !== "undefined" ? performance.now() : 0;
  function getCursorSpeed(x, y) {
    const currentTime = performance.now();
    const elapsedTime = currentTime - lastCursorTime;
    if (lastX === null || lastY === null || elapsedTime === 0) {
      lastX = x;
      lastY = y;
      lastCursorTime = currentTime;
      return null;
    }
    const deltaX = x - lastX;
    const deltaY = y - lastY;
    const distance2 = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    const speed = distance2 / elapsedTime;
    lastX = x;
    lastY = y;
    lastCursorTime = currentTime;
    return speed;
  }
  const fn = ({ x, y, placement, elements, onClose, nodeId, tree }) => {
    return function onMouseMove(event) {
      function close() {
        timeout.clear();
        onClose();
      }
      timeout.clear();
      if (
        !elements.domReference ||
        !elements.floating ||
        placement == null ||
        x == null ||
        y == null
      ) {
        return void 0;
      }
      const { clientX, clientY } = event;
      const clientPoint = [clientX, clientY];
      const target = getTarget(event);
      const isLeave = event.type === "mouseleave";
      const isOverFloatingEl = contains(elements.floating, target);
      const isOverReferenceEl = contains(elements.domReference, target);
      const refRect = elements.domReference.getBoundingClientRect();
      const rect = elements.floating.getBoundingClientRect();
      const side = placement.split("-")[0];
      const cursorLeaveFromRight = x > rect.right - rect.width / 2;
      const cursorLeaveFromBottom = y > rect.bottom - rect.height / 2;
      const isOverReferenceRect = isInside(clientPoint, refRect);
      const isFloatingWider = rect.width > refRect.width;
      const isFloatingTaller = rect.height > refRect.height;
      const left = (isFloatingWider ? refRect : rect).left;
      const right = (isFloatingWider ? refRect : rect).right;
      const top = (isFloatingTaller ? refRect : rect).top;
      const bottom = (isFloatingTaller ? refRect : rect).bottom;
      if (isOverFloatingEl) {
        hasLanded = true;
        if (!isLeave) {
          return void 0;
        }
      }
      if (isOverReferenceEl) {
        hasLanded = false;
      }
      if (isOverReferenceEl && !isLeave) {
        hasLanded = true;
        return void 0;
      }
      if (
        isLeave &&
        isElement(event.relatedTarget) &&
        contains(elements.floating, event.relatedTarget)
      ) {
        return void 0;
      }
      if (
        tree &&
        getNodeChildren(tree.nodesRef.current, nodeId).some(({ context }) =>
          context == null ? void 0 : context.open,
        )
      ) {
        return void 0;
      }
      if (
        (side === "top" && y >= refRect.bottom - 1) ||
        (side === "bottom" && y <= refRect.top + 1) ||
        (side === "left" && x >= refRect.right - 1) ||
        (side === "right" && x <= refRect.left + 1)
      ) {
        return close();
      }
      let rectPoly = [];
      switch (side) {
        case "top":
          rectPoly = [
            [left, refRect.top + 1],
            [left, rect.bottom - 1],
            [right, rect.bottom - 1],
            [right, refRect.top + 1],
          ];
          break;
        case "bottom":
          rectPoly = [
            [left, rect.top + 1],
            [left, refRect.bottom - 1],
            [right, refRect.bottom - 1],
            [right, rect.top + 1],
          ];
          break;
        case "left":
          rectPoly = [
            [rect.right - 1, bottom],
            [rect.right - 1, top],
            [refRect.left + 1, top],
            [refRect.left + 1, bottom],
          ];
          break;
        case "right":
          rectPoly = [
            [refRect.right - 1, bottom],
            [refRect.right - 1, top],
            [rect.left + 1, top],
            [rect.left + 1, bottom],
          ];
          break;
      }
      function getPolygon([px2, py]) {
        switch (side) {
          case "top": {
            const cursorPointOne = [
              isFloatingWider
                ? px2 + buffer / 2
                : cursorLeaveFromRight
                  ? px2 + buffer * 4
                  : px2 - buffer * 4,
              py + buffer + 1,
            ];
            const cursorPointTwo = [
              isFloatingWider
                ? px2 - buffer / 2
                : cursorLeaveFromRight
                  ? px2 + buffer * 4
                  : px2 - buffer * 4,
              py + buffer + 1,
            ];
            const commonPoints = [
              [
                rect.left,
                cursorLeaveFromRight
                  ? rect.bottom - buffer
                  : isFloatingWider
                    ? rect.bottom - buffer
                    : rect.top,
              ],
              [
                rect.right,
                cursorLeaveFromRight
                  ? isFloatingWider
                    ? rect.bottom - buffer
                    : rect.top
                  : rect.bottom - buffer,
              ],
            ];
            return [cursorPointOne, cursorPointTwo, ...commonPoints];
          }
          case "bottom": {
            const cursorPointOne = [
              isFloatingWider
                ? px2 + buffer / 2
                : cursorLeaveFromRight
                  ? px2 + buffer * 4
                  : px2 - buffer * 4,
              py - buffer,
            ];
            const cursorPointTwo = [
              isFloatingWider
                ? px2 - buffer / 2
                : cursorLeaveFromRight
                  ? px2 + buffer * 4
                  : px2 - buffer * 4,
              py - buffer,
            ];
            const commonPoints = [
              [
                rect.left,
                cursorLeaveFromRight
                  ? rect.top + buffer
                  : isFloatingWider
                    ? rect.top + buffer
                    : rect.bottom,
              ],
              [
                rect.right,
                cursorLeaveFromRight
                  ? isFloatingWider
                    ? rect.top + buffer
                    : rect.bottom
                  : rect.top + buffer,
              ],
            ];
            return [cursorPointOne, cursorPointTwo, ...commonPoints];
          }
          case "left": {
            const cursorPointOne = [
              px2 + buffer + 1,
              isFloatingTaller
                ? py + buffer / 2
                : cursorLeaveFromBottom
                  ? py + buffer * 4
                  : py - buffer * 4,
            ];
            const cursorPointTwo = [
              px2 + buffer + 1,
              isFloatingTaller
                ? py - buffer / 2
                : cursorLeaveFromBottom
                  ? py + buffer * 4
                  : py - buffer * 4,
            ];
            const commonPoints = [
              [
                cursorLeaveFromBottom
                  ? rect.right - buffer
                  : isFloatingTaller
                    ? rect.right - buffer
                    : rect.left,
                rect.top,
              ],
              [
                cursorLeaveFromBottom
                  ? isFloatingTaller
                    ? rect.right - buffer
                    : rect.left
                  : rect.right - buffer,
                rect.bottom,
              ],
            ];
            return [...commonPoints, cursorPointOne, cursorPointTwo];
          }
          case "right": {
            const cursorPointOne = [
              px2 - buffer,
              isFloatingTaller
                ? py + buffer / 2
                : cursorLeaveFromBottom
                  ? py + buffer * 4
                  : py - buffer * 4,
            ];
            const cursorPointTwo = [
              px2 - buffer,
              isFloatingTaller
                ? py - buffer / 2
                : cursorLeaveFromBottom
                  ? py + buffer * 4
                  : py - buffer * 4,
            ];
            const commonPoints = [
              [
                cursorLeaveFromBottom
                  ? rect.left + buffer
                  : isFloatingTaller
                    ? rect.left + buffer
                    : rect.right,
                rect.top,
              ],
              [
                cursorLeaveFromBottom
                  ? isFloatingTaller
                    ? rect.left + buffer
                    : rect.right
                  : rect.left + buffer,
                rect.bottom,
              ],
            ];
            return [cursorPointOne, cursorPointTwo, ...commonPoints];
          }
          default:
            return [];
        }
      }
      if (isPointInPolygon([clientX, clientY], rectPoly)) {
        return void 0;
      }
      if (hasLanded && !isOverReferenceRect) {
        return close();
      }
      if (!isLeave && requireIntent) {
        const cursorSpeed = getCursorSpeed(event.clientX, event.clientY);
        const cursorSpeedThreshold = 0.1;
        if (cursorSpeed !== null && cursorSpeed < cursorSpeedThreshold) {
          return close();
        }
      }
      if (!isPointInPolygon([clientX, clientY], getPolygon([x, y]))) {
        close();
      } else if (!hasLanded && requireIntent) {
        timeout.start(40, close);
      }
      return void 0;
    };
  };
  fn.__options = {
    blockPointerEvents,
  };
  return fn;
}
const ToolbarRootContext = /* @__PURE__ */ reactExports.createContext(void 0);
function useToolbarRootContext(optional) {
  const context = reactExports.useContext(ToolbarRootContext);
  return context;
}
const ARROW_UP = "ArrowUp";
const ARROW_DOWN = "ArrowDown";
const ARROW_LEFT = "ArrowLeft";
const ARROW_RIGHT = "ArrowRight";
const HOME = "Home";
const END = "End";
const HORIZONTAL_KEYS = /* @__PURE__ */ new Set([ARROW_LEFT, ARROW_RIGHT]);
const HORIZONTAL_KEYS_WITH_EXTRA_KEYS = /* @__PURE__ */ new Set([
  ARROW_LEFT,
  ARROW_RIGHT,
  HOME,
  END,
]);
const VERTICAL_KEYS = /* @__PURE__ */ new Set([ARROW_UP, ARROW_DOWN]);
const VERTICAL_KEYS_WITH_EXTRA_KEYS = /* @__PURE__ */ new Set([ARROW_UP, ARROW_DOWN, HOME, END]);
const ARROW_KEYS = /* @__PURE__ */ new Set([...HORIZONTAL_KEYS, ...VERTICAL_KEYS]);
const ALL_KEYS = /* @__PURE__ */ new Set([...ARROW_KEYS, HOME, END]);
const COMPOSITE_KEYS = /* @__PURE__ */ new Set([
  ARROW_UP,
  ARROW_DOWN,
  ARROW_LEFT,
  ARROW_RIGHT,
  HOME,
  END,
]);
const SHIFT = "Shift";
const CONTROL = "Control";
const ALT = "Alt";
const META = "Meta";
const MODIFIER_KEYS = /* @__PURE__ */ new Set([SHIFT, CONTROL, ALT, META]);
function isInputElement(element) {
  return isHTMLElement(element) && element.tagName === "INPUT";
}
function isNativeInput(element) {
  if (isInputElement(element) && element.selectionStart != null) {
    return true;
  }
  if (isHTMLElement(element) && element.tagName === "TEXTAREA") {
    return true;
  }
  return false;
}
function scrollIntoViewIfNeeded(scrollContainer, element, direction, orientation) {
  if (!scrollContainer || !element || !element.scrollTo) {
    return;
  }
  let targetX = scrollContainer.scrollLeft;
  let targetY = scrollContainer.scrollTop;
  const isOverflowingX = scrollContainer.clientWidth < scrollContainer.scrollWidth;
  const isOverflowingY = scrollContainer.clientHeight < scrollContainer.scrollHeight;
  if (isOverflowingX && orientation !== "vertical") {
    const elementOffsetLeft = getOffset$1(scrollContainer, element, "left");
    const containerStyles = getStyles(scrollContainer);
    const elementStyles = getStyles(element);
    if (direction === "ltr") {
      if (
        elementOffsetLeft + element.offsetWidth + elementStyles.scrollMarginRight >
        scrollContainer.scrollLeft +
          scrollContainer.clientWidth -
          containerStyles.scrollPaddingRight
      ) {
        targetX =
          elementOffsetLeft +
          element.offsetWidth +
          elementStyles.scrollMarginRight -
          scrollContainer.clientWidth +
          containerStyles.scrollPaddingRight;
      } else if (
        elementOffsetLeft - elementStyles.scrollMarginLeft <
        scrollContainer.scrollLeft + containerStyles.scrollPaddingLeft
      ) {
        targetX =
          elementOffsetLeft - elementStyles.scrollMarginLeft - containerStyles.scrollPaddingLeft;
      }
    }
    if (direction === "rtl") {
      if (
        elementOffsetLeft - elementStyles.scrollMarginRight <
        scrollContainer.scrollLeft + containerStyles.scrollPaddingLeft
      ) {
        targetX =
          elementOffsetLeft - elementStyles.scrollMarginLeft - containerStyles.scrollPaddingLeft;
      } else if (
        elementOffsetLeft + element.offsetWidth + elementStyles.scrollMarginRight >
        scrollContainer.scrollLeft +
          scrollContainer.clientWidth -
          containerStyles.scrollPaddingRight
      ) {
        targetX =
          elementOffsetLeft +
          element.offsetWidth +
          elementStyles.scrollMarginRight -
          scrollContainer.clientWidth +
          containerStyles.scrollPaddingRight;
      }
    }
  }
  if (isOverflowingY && orientation !== "horizontal") {
    const elementOffsetTop = getOffset$1(scrollContainer, element, "top");
    const containerStyles = getStyles(scrollContainer);
    const elementStyles = getStyles(element);
    if (
      elementOffsetTop - elementStyles.scrollMarginTop <
      scrollContainer.scrollTop + containerStyles.scrollPaddingTop
    ) {
      targetY = elementOffsetTop - elementStyles.scrollMarginTop - containerStyles.scrollPaddingTop;
    } else if (
      elementOffsetTop + element.offsetHeight + elementStyles.scrollMarginBottom >
      scrollContainer.scrollTop + scrollContainer.clientHeight - containerStyles.scrollPaddingBottom
    ) {
      targetY =
        elementOffsetTop +
        element.offsetHeight +
        elementStyles.scrollMarginBottom -
        scrollContainer.clientHeight +
        containerStyles.scrollPaddingBottom;
    }
  }
  scrollContainer.scrollTo({
    left: targetX,
    top: targetY,
    behavior: "auto",
  });
}
function getOffset$1(ancestor, element, side) {
  const propName = side === "left" ? "offsetLeft" : "offsetTop";
  let result = 0;
  while (element.offsetParent) {
    result += element[propName];
    if (element.offsetParent === ancestor) {
      break;
    }
    element = element.offsetParent;
  }
  return result;
}
function getStyles(element) {
  const styles = getComputedStyle(element);
  return {
    scrollMarginTop: parseFloat(styles.scrollMarginTop) || 0,
    scrollMarginRight: parseFloat(styles.scrollMarginRight) || 0,
    scrollMarginBottom: parseFloat(styles.scrollMarginBottom) || 0,
    scrollMarginLeft: parseFloat(styles.scrollMarginLeft) || 0,
    scrollPaddingTop: parseFloat(styles.scrollPaddingTop) || 0,
    scrollPaddingRight: parseFloat(styles.scrollPaddingRight) || 0,
    scrollPaddingBottom: parseFloat(styles.scrollPaddingBottom) || 0,
    scrollPaddingLeft: parseFloat(styles.scrollPaddingLeft) || 0,
  };
}
function getDisabledMountTransitionStyles(transitionStatus) {
  return transitionStatus === "starting" ? DISABLED_TRANSITIONS_STYLE : EMPTY_OBJECT;
}
const stateAttributesMapping$2 = {
  ...popupStateMapping,
  ...transitionStatusMapping,
};
const MenuPopup = /* @__PURE__ */ reactExports.forwardRef(
  function MenuPopup2(componentProps, forwardedRef) {
    const { render, className, finalFocus, ...elementProps } = componentProps;
    const { store } = useMenuRootContext();
    const { side, align } = useMenuPositionerContext();
    const insideToolbar = useToolbarRootContext() != null;
    const open = store.useState("open");
    const transitionStatus = store.useState("transitionStatus");
    const popupProps = store.useState("popupProps");
    const mounted = store.useState("mounted");
    const instantType = store.useState("instantType");
    const triggerElement = store.useState("activeTriggerElement");
    const parent = store.useState("parent");
    const lastOpenChangeReason = store.useState("lastOpenChangeReason");
    const rootId = store.useState("rootId");
    const floatingContext = store.useState("floatingRootContext");
    const floatingTreeRoot = store.useState("floatingTreeRoot");
    const closeDelay = store.useState("closeDelay");
    const activeTriggerElement = store.useState("activeTriggerElement");
    const isContextMenu = parent.type === "context-menu";
    useOpenChangeComplete({
      open,
      ref: store.context.popupRef,
      onComplete() {
        var _a2, _b;
        if (open) {
          (_b = (_a2 = store.context).onOpenChangeComplete) == null ? void 0 : _b.call(_a2, true);
        }
      },
    });
    reactExports.useEffect(() => {
      function handleClose(event) {
        store.setOpen(false, createChangeEventDetails(event.reason, event.domEvent));
      }
      floatingTreeRoot.events.on("close", handleClose);
      return () => {
        floatingTreeRoot.events.off("close", handleClose);
      };
    }, [floatingTreeRoot.events, store]);
    const hoverEnabled = store.useState("hoverEnabled");
    const disabled2 = store.useState("disabled");
    useHoverFloatingInteraction(floatingContext, {
      enabled: hoverEnabled && !disabled2 && !isContextMenu && parent.type !== "menubar",
      closeDelay,
    });
    const state = reactExports.useMemo(
      () => ({
        transitionStatus,
        side,
        align,
        open,
        nested: parent.type === "menu",
        instant: instantType,
      }),
      [transitionStatus, side, align, open, parent.type, instantType],
    );
    const element = useRenderElement("div", componentProps, {
      state,
      ref: [forwardedRef, store.context.popupRef],
      stateAttributesMapping: stateAttributesMapping$2,
      props: [
        popupProps,
        {
          onKeyDown(event) {
            if (insideToolbar && COMPOSITE_KEYS.has(event.key)) {
              event.stopPropagation();
            }
          },
        },
        getDisabledMountTransitionStyles(transitionStatus),
        elementProps,
        {
          "data-rootownerid": rootId,
        },
      ],
    });
    let returnFocus = parent.type === void 0 || isContextMenu;
    if (triggerElement || (parent.type === "menubar" && lastOpenChangeReason !== outsidePress)) {
      returnFocus = true;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(FloatingFocusManager, {
      context: floatingContext,
      modal: isContextMenu,
      disabled: !mounted,
      returnFocus: finalFocus === void 0 ? returnFocus : finalFocus,
      initialFocus: parent.type !== "menu",
      restoreFocus: true,
      externalTree: parent.type !== "menubar" ? floatingTreeRoot : void 0,
      previousFocusableElement: activeTriggerElement,
      nextFocusableElement: parent.type === void 0 ? store.context.triggerFocusTargetRef : void 0,
      beforeContentFocusGuardRef:
        parent.type === void 0 ? store.context.beforeContentFocusGuardRef : void 0,
      children: element,
    });
  },
);
const MenuPortalContext = /* @__PURE__ */ reactExports.createContext(void 0);
function useMenuPortalContext() {
  const value = reactExports.useContext(MenuPortalContext);
  if (value === void 0) {
    throw new Error(formatErrorMessage(32));
  }
  return value;
}
const MenuPortal = /* @__PURE__ */ reactExports.forwardRef(
  function MenuPortal2(props, forwardedRef) {
    const { keepMounted = false, ...portalProps } = props;
    const { store } = useMenuRootContext();
    const mounted = store.useState("mounted");
    const shouldRender = mounted || keepMounted;
    if (!shouldRender) {
      return null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(MenuPortalContext.Provider, {
      value: keepMounted,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(FloatingPortal, {
        ref: forwardedRef,
        ...portalProps,
      }),
    });
  },
);
function inertValue(value) {
  if (isReactVersionAtLeast(19)) {
    return value;
  }
  return value ? "true" : void 0;
}
const DirectionContext = /* @__PURE__ */ reactExports.createContext(void 0);
function useDirection() {
  const context = reactExports.useContext(DirectionContext);
  return (context == null ? void 0 : context.direction) ?? "ltr";
}
const baseArrow = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    var _a2, _b;
    const { x, y, placement, rects, platform: platform2, elements, middlewareData } = state;
    const { element, padding = 0, offsetParent = "real" } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x,
      y,
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff =
      rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent =
      offsetParent === "real"
        ? await ((_a2 = platform2.getOffsetParent) == null ? void 0 : _a2.call(platform2, element))
        : elements.floating;
    let clientSize = elements.floating[clientProp] || rects.floating[length];
    if (
      !clientSize ||
      !(await ((_b = platform2.isElement) == null ? void 0 : _b.call(platform2, arrowOffsetParent)))
    ) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = Math.min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = Math.min(paddingObject[maxProp], largestPossiblePadding);
    const min2 = minPadding;
    const max2 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset2 = clamp$1(min2, center, max2);
    const shouldAddOffset =
      !middlewareData.arrow &&
      getAlignment(placement) != null &&
      center !== offset2 &&
      rects.reference[length] / 2 -
        (center < min2 ? minPadding : maxPadding) -
        arrowDimensions[length] / 2 <
        0;
    const alignmentOffset = shouldAddOffset ? (center < min2 ? center - min2 : center - max2) : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset2,
        centerOffset: center - offset2 - alignmentOffset,
        ...(shouldAddOffset && {
          alignmentOffset,
        }),
      },
      reset: shouldAddOffset,
    };
  },
});
const arrow = (options, deps) => ({
  ...baseArrow(options),
  options: [options, deps],
});
const hide = {
  name: "hide",
  async fn(state) {
    var _a2;
    const { width, height, x, y } = state.rects.reference;
    const anchorHidden = width === 0 && height === 0 && x === 0 && y === 0;
    const nativeHideResult = await hide$1().fn(state);
    return {
      data: {
        referenceHidden:
          ((_a2 = nativeHideResult.data) == null ? void 0 : _a2.referenceHidden) || anchorHidden,
      },
    };
  },
};
const DEFAULT_SIDES = {
  sideX: "left",
  sideY: "top",
};
const adaptiveOrigin = {
  name: "adaptiveOrigin",
  async fn(state) {
    var _a2, _b;
    const {
      x: rawX,
      y: rawY,
      rects: { floating: floatRect },
      elements: { floating },
      platform: platform2,
      strategy,
      placement,
    } = state;
    const win = getWindow(floating);
    const styles = win.getComputedStyle(floating);
    const hasTransition = styles.transitionDuration !== "0s" && styles.transitionDuration !== "";
    if (!hasTransition) {
      return {
        x: rawX,
        y: rawY,
        data: DEFAULT_SIDES,
      };
    }
    const offsetParent = await ((_a2 = platform2.getOffsetParent) == null
      ? void 0
      : _a2.call(platform2, floating));
    let offsetDimensions = {
      width: 0,
      height: 0,
    };
    if (strategy === "fixed" && (win == null ? void 0 : win.visualViewport)) {
      offsetDimensions = {
        width: win.visualViewport.width,
        height: win.visualViewport.height,
      };
    } else if (offsetParent === win) {
      const doc = ownerDocument(floating);
      offsetDimensions = {
        width: doc.documentElement.clientWidth,
        height: doc.documentElement.clientHeight,
      };
    } else if (
      await ((_b = platform2.isElement) == null ? void 0 : _b.call(platform2, offsetParent))
    ) {
      offsetDimensions = await platform2.getDimensions(offsetParent);
    }
    const currentSide = getSide(placement);
    let x = rawX;
    let y = rawY;
    if (currentSide === "left") {
      x = offsetDimensions.width - (rawX + floatRect.width);
    }
    if (currentSide === "top") {
      y = offsetDimensions.height - (rawY + floatRect.height);
    }
    const sideX = currentSide === "left" ? "right" : DEFAULT_SIDES.sideX;
    const sideY = currentSide === "top" ? "bottom" : DEFAULT_SIDES.sideY;
    return {
      x,
      y,
      data: {
        sideX,
        sideY,
      },
    };
  },
};
function getLogicalSide(sideParam, renderedSide, isRtl) {
  const isLogicalSideParam = sideParam === "inline-start" || sideParam === "inline-end";
  const logicalRight = isRtl ? "inline-start" : "inline-end";
  const logicalLeft = isRtl ? "inline-end" : "inline-start";
  return {
    top: "top",
    right: isLogicalSideParam ? logicalRight : "right",
    bottom: "bottom",
    left: isLogicalSideParam ? logicalLeft : "left",
  }[renderedSide];
}
function getOffsetData(state, sideParam, isRtl) {
  const { rects, placement } = state;
  const data = {
    side: getLogicalSide(sideParam, getSide(placement), isRtl),
    align: getAlignment(placement) || "center",
    anchor: {
      width: rects.reference.width,
      height: rects.reference.height,
    },
    positioner: {
      width: rects.floating.width,
      height: rects.floating.height,
    },
  };
  return data;
}
function useAnchorPositioning(params) {
  var _a2, _b;
  const {
    // Public parameters
    anchor,
    positionMethod = "absolute",
    side: sideParam = "bottom",
    sideOffset = 0,
    align = "center",
    alignOffset = 0,
    collisionBoundary,
    collisionPadding: collisionPaddingParam = 5,
    sticky = false,
    arrowPadding = 5,
    disableAnchorTracking = false,
    // Private parameters
    keepMounted = false,
    floatingRootContext,
    mounted,
    collisionAvoidance,
    shiftCrossAxis = false,
    nodeId,
    adaptiveOrigin: adaptiveOrigin2,
    lazyFlip = false,
    externalTree,
  } = params;
  const [mountSide, setMountSide] = reactExports.useState(null);
  if (!mounted && mountSide !== null) {
    setMountSide(null);
  }
  const collisionAvoidanceSide = collisionAvoidance.side || "flip";
  const collisionAvoidanceAlign = collisionAvoidance.align || "flip";
  const collisionAvoidanceFallbackAxisSide = collisionAvoidance.fallbackAxisSide || "end";
  const anchorFn = typeof anchor === "function" ? anchor : void 0;
  const anchorFnCallback = useStableCallback(anchorFn);
  const anchorDep = anchorFn ? anchorFnCallback : anchor;
  const anchorValueRef = useValueAsRef(anchor);
  const direction = useDirection();
  const isRtl = direction === "rtl";
  const side =
    mountSide ||
    {
      top: "top",
      right: "right",
      bottom: "bottom",
      left: "left",
      "inline-end": isRtl ? "left" : "right",
      "inline-start": isRtl ? "right" : "left",
    }[sideParam];
  const placement = align === "center" ? side : `${side}-${align}`;
  let collisionPadding = collisionPaddingParam;
  const bias = 1;
  const biasTop = sideParam === "bottom" ? bias : 0;
  const biasBottom = sideParam === "top" ? bias : 0;
  const biasLeft = sideParam === "right" ? bias : 0;
  const biasRight = sideParam === "left" ? bias : 0;
  if (typeof collisionPadding === "number") {
    collisionPadding = {
      top: collisionPadding + biasTop,
      right: collisionPadding + biasRight,
      bottom: collisionPadding + biasBottom,
      left: collisionPadding + biasLeft,
    };
  } else if (collisionPadding) {
    collisionPadding = {
      top: (collisionPadding.top || 0) + biasTop,
      right: (collisionPadding.right || 0) + biasRight,
      bottom: (collisionPadding.bottom || 0) + biasBottom,
      left: (collisionPadding.left || 0) + biasLeft,
    };
  }
  const commonCollisionProps = {
    boundary: collisionBoundary === "clipping-ancestors" ? "clippingAncestors" : collisionBoundary,
    padding: collisionPadding,
  };
  const arrowRef = reactExports.useRef(null);
  const sideOffsetRef = useValueAsRef(sideOffset);
  const alignOffsetRef = useValueAsRef(alignOffset);
  const sideOffsetDep = typeof sideOffset !== "function" ? sideOffset : 0;
  const alignOffsetDep = typeof alignOffset !== "function" ? alignOffset : 0;
  const middleware = [
    offset(
      (state) => {
        const data = getOffsetData(state, sideParam, isRtl);
        const sideAxis =
          typeof sideOffsetRef.current === "function"
            ? sideOffsetRef.current(data)
            : sideOffsetRef.current;
        const alignAxis =
          typeof alignOffsetRef.current === "function"
            ? alignOffsetRef.current(data)
            : alignOffsetRef.current;
        return {
          mainAxis: sideAxis,
          crossAxis: alignAxis,
          alignmentAxis: alignAxis,
        };
      },
      [sideOffsetDep, alignOffsetDep, isRtl, sideParam],
    ),
  ];
  const shiftDisabled = collisionAvoidanceAlign === "none" && collisionAvoidanceSide !== "shift";
  const crossAxisShiftEnabled =
    !shiftDisabled && (sticky || shiftCrossAxis || collisionAvoidanceSide === "shift");
  const flipMiddleware =
    collisionAvoidanceSide === "none"
      ? null
      : flip({
          ...commonCollisionProps,
          // Ensure the popup flips if it's been limited by its --available-height and it resizes.
          // Since the size() padding is smaller than the flip() padding, flip() will take precedence.
          padding: {
            top: collisionPadding.top + bias,
            right: collisionPadding.right + bias,
            bottom: collisionPadding.bottom + bias,
            left: collisionPadding.left + bias,
          },
          mainAxis: !shiftCrossAxis && collisionAvoidanceSide === "flip",
          crossAxis: collisionAvoidanceAlign === "flip" ? "alignment" : false,
          fallbackAxisSideDirection: collisionAvoidanceFallbackAxisSide,
        });
  const shiftMiddleware = shiftDisabled
    ? null
    : shift(
        (data) => {
          const html = ownerDocument(data.elements.floating).documentElement;
          return {
            ...commonCollisionProps,
            // Use the Layout Viewport to avoid shifting around when pinch-zooming
            // for context menus.
            rootBoundary: shiftCrossAxis
              ? {
                  x: 0,
                  y: 0,
                  width: html.clientWidth,
                  height: html.clientHeight,
                }
              : void 0,
            mainAxis: collisionAvoidanceAlign !== "none",
            crossAxis: crossAxisShiftEnabled,
            limiter:
              sticky || shiftCrossAxis
                ? void 0
                : limitShift((limitData) => {
                    if (!arrowRef.current) {
                      return {};
                    }
                    const { width, height } = arrowRef.current.getBoundingClientRect();
                    const sideAxis = getSideAxis(getSide(limitData.placement));
                    const arrowSize = sideAxis === "y" ? width : height;
                    const offsetAmount =
                      sideAxis === "y"
                        ? collisionPadding.left + collisionPadding.right
                        : collisionPadding.top + collisionPadding.bottom;
                    return {
                      offset: arrowSize / 2 + offsetAmount / 2,
                    };
                  }),
          };
        },
        [commonCollisionProps, sticky, shiftCrossAxis, collisionPadding, collisionAvoidanceAlign],
      );
  if (
    collisionAvoidanceSide === "shift" ||
    collisionAvoidanceAlign === "shift" ||
    align === "center"
  ) {
    middleware.push(shiftMiddleware, flipMiddleware);
  } else {
    middleware.push(flipMiddleware, shiftMiddleware);
  }
  middleware.push(
    size({
      ...commonCollisionProps,
      apply({ elements: { floating }, rects: { reference }, availableWidth, availableHeight }) {
        Object.entries({
          "--available-width": `${availableWidth}px`,
          "--available-height": `${availableHeight}px`,
          "--anchor-width": `${reference.width}px`,
          "--anchor-height": `${reference.height}px`,
        }).forEach(([key, value]) => {
          floating.style.setProperty(key, value);
        });
      },
    }),
    arrow(
      () => ({
        // `transform-origin` calculations rely on an element existing. If the arrow hasn't been set,
        // we'll create a fake element.
        element: arrowRef.current || document.createElement("div"),
        padding: arrowPadding,
        offsetParent: "floating",
      }),
      [arrowPadding],
    ),
    {
      name: "transformOrigin",
      fn(state) {
        var _a3, _b2, _c;
        const {
          elements: elements2,
          middlewareData: middlewareData2,
          placement: renderedPlacement2,
          rects,
          y: y2,
        } = state;
        const currentRenderedSide = getSide(renderedPlacement2);
        const currentRenderedAxis = getSideAxis(currentRenderedSide);
        const arrowEl = arrowRef.current;
        const arrowX = ((_a3 = middlewareData2.arrow) == null ? void 0 : _a3.x) || 0;
        const arrowY = ((_b2 = middlewareData2.arrow) == null ? void 0 : _b2.y) || 0;
        const arrowWidth = (arrowEl == null ? void 0 : arrowEl.clientWidth) || 0;
        const arrowHeight = (arrowEl == null ? void 0 : arrowEl.clientHeight) || 0;
        const transformX = arrowX + arrowWidth / 2;
        const transformY = arrowY + arrowHeight / 2;
        const shiftY = Math.abs(((_c = middlewareData2.shift) == null ? void 0 : _c.y) || 0);
        const halfAnchorHeight = rects.reference.height / 2;
        const sideOffsetValue =
          typeof sideOffset === "function"
            ? sideOffset(getOffsetData(state, sideParam, isRtl))
            : sideOffset;
        const isOverlappingAnchor = shiftY > sideOffsetValue;
        const adjacentTransformOrigin = {
          top: `${transformX}px calc(100% + ${sideOffsetValue}px)`,
          bottom: `${transformX}px ${-sideOffsetValue}px`,
          left: `calc(100% + ${sideOffsetValue}px) ${transformY}px`,
          right: `${-sideOffsetValue}px ${transformY}px`,
        }[currentRenderedSide];
        const overlapTransformOrigin = `${transformX}px ${rects.reference.y + halfAnchorHeight - y2}px`;
        elements2.floating.style.setProperty(
          "--transform-origin",
          crossAxisShiftEnabled && currentRenderedAxis === "y" && isOverlappingAnchor
            ? overlapTransformOrigin
            : adjacentTransformOrigin,
        );
        return {};
      },
    },
    hide,
    adaptiveOrigin2,
  );
  useIsoLayoutEffect(() => {
    if (!mounted && floatingRootContext) {
      floatingRootContext.update({
        referenceElement: null,
        floatingElement: null,
        domReferenceElement: null,
      });
    }
  }, [mounted, floatingRootContext]);
  const autoUpdateOptions = reactExports.useMemo(
    () => ({
      elementResize: !disableAnchorTracking && typeof ResizeObserver !== "undefined",
      layoutShift: !disableAnchorTracking && typeof IntersectionObserver !== "undefined",
    }),
    [disableAnchorTracking],
  );
  const {
    refs,
    elements,
    x,
    y,
    middlewareData,
    update: update2,
    placement: renderedPlacement,
    context,
    isPositioned,
    floatingStyles: originalFloatingStyles,
  } = useFloating({
    rootContext: floatingRootContext,
    placement,
    middleware,
    strategy: positionMethod,
    whileElementsMounted: keepMounted
      ? void 0
      : (...args) => autoUpdate(...args, autoUpdateOptions),
    nodeId,
    externalTree,
  });
  const { sideX, sideY } = middlewareData.adaptiveOrigin || DEFAULT_SIDES;
  const resolvedPosition = isPositioned ? positionMethod : "fixed";
  const floatingStyles = reactExports.useMemo(
    () =>
      adaptiveOrigin2
        ? {
            position: resolvedPosition,
            [sideX]: x,
            [sideY]: y,
          }
        : {
            position: resolvedPosition,
            ...originalFloatingStyles,
          },
    [adaptiveOrigin2, resolvedPosition, sideX, x, sideY, y, originalFloatingStyles],
  );
  const registeredPositionReferenceRef = reactExports.useRef(null);
  useIsoLayoutEffect(() => {
    if (!mounted) {
      return;
    }
    const anchorValue = anchorValueRef.current;
    const resolvedAnchor = typeof anchorValue === "function" ? anchorValue() : anchorValue;
    const unwrappedElement =
      (isRef(resolvedAnchor) ? resolvedAnchor.current : resolvedAnchor) || null;
    const finalAnchor = unwrappedElement || null;
    if (finalAnchor !== registeredPositionReferenceRef.current) {
      refs.setPositionReference(finalAnchor);
      registeredPositionReferenceRef.current = finalAnchor;
    }
  }, [mounted, refs, anchorDep, anchorValueRef]);
  reactExports.useEffect(() => {
    if (!mounted) {
      return;
    }
    const anchorValue = anchorValueRef.current;
    if (typeof anchorValue === "function") {
      return;
    }
    if (isRef(anchorValue) && anchorValue.current !== registeredPositionReferenceRef.current) {
      refs.setPositionReference(anchorValue.current);
      registeredPositionReferenceRef.current = anchorValue.current;
    }
  }, [mounted, refs, anchorDep, anchorValueRef]);
  reactExports.useEffect(() => {
    if (keepMounted && mounted && elements.domReference && elements.floating) {
      return autoUpdate(elements.domReference, elements.floating, update2, autoUpdateOptions);
    }
    return void 0;
  }, [keepMounted, mounted, elements, update2, autoUpdateOptions]);
  const renderedSide = getSide(renderedPlacement);
  const logicalRenderedSide = getLogicalSide(sideParam, renderedSide, isRtl);
  const renderedAlign = getAlignment(renderedPlacement) || "center";
  const anchorHidden = Boolean((_a2 = middlewareData.hide) == null ? void 0 : _a2.referenceHidden);
  useIsoLayoutEffect(() => {
    if (lazyFlip && mounted && isPositioned) {
      setMountSide(renderedSide);
    }
  }, [lazyFlip, mounted, isPositioned, renderedSide]);
  const arrowStyles = reactExports.useMemo(() => {
    var _a3, _b2;
    return {
      position: "absolute",
      top: (_a3 = middlewareData.arrow) == null ? void 0 : _a3.y,
      left: (_b2 = middlewareData.arrow) == null ? void 0 : _b2.x,
    };
  }, [middlewareData.arrow]);
  const arrowUncentered = ((_b = middlewareData.arrow) == null ? void 0 : _b.centerOffset) !== 0;
  return reactExports.useMemo(
    () => ({
      positionerStyles: floatingStyles,
      arrowStyles,
      arrowRef,
      arrowUncentered,
      side: logicalRenderedSide,
      align: renderedAlign,
      physicalSide: renderedSide,
      anchorHidden,
      refs,
      context,
      isPositioned,
      update: update2,
    }),
    [
      floatingStyles,
      arrowStyles,
      arrowRef,
      arrowUncentered,
      logicalRenderedSide,
      renderedAlign,
      renderedSide,
      anchorHidden,
      refs,
      context,
      isPositioned,
      update2,
    ],
  );
}
function isRef(param) {
  return param != null && "current" in param;
}
function CompositeList(props) {
  const { children, elementsRef, labelsRef, onMapChange: onMapChangeProp } = props;
  const onMapChange = useStableCallback(onMapChangeProp);
  const nextIndexRef = reactExports.useRef(0);
  const listeners = useRefWithInit(createListeners).current;
  const map = useRefWithInit(createMap).current;
  const [mapTick, setMapTick] = reactExports.useState(0);
  const lastTickRef = reactExports.useRef(mapTick);
  const register = useStableCallback((node, metadata) => {
    map.set(node, metadata ?? null);
    lastTickRef.current += 1;
    setMapTick(lastTickRef.current);
  });
  const unregister = useStableCallback((node) => {
    map.delete(node);
    lastTickRef.current += 1;
    setMapTick(lastTickRef.current);
  });
  const sortedMap = reactExports.useMemo(() => {
    const newMap = /* @__PURE__ */ new Map();
    const sortedNodes = Array.from(map.keys())
      .filter((node) => node.isConnected)
      .sort(sortByDocumentPosition);
    sortedNodes.forEach((node, index2) => {
      const metadata = map.get(node) ?? {};
      newMap.set(node, {
        ...metadata,
        index: index2,
      });
    });
    return newMap;
  }, [map, mapTick]);
  useIsoLayoutEffect(() => {
    if (typeof MutationObserver !== "function" || sortedMap.size === 0) {
      return void 0;
    }
    const mutationObserver = new MutationObserver((entries) => {
      const diff = /* @__PURE__ */ new Set();
      const updateDiff = (node) => (diff.has(node) ? diff.delete(node) : diff.add(node));
      entries.forEach((entry) => {
        entry.removedNodes.forEach(updateDiff);
        entry.addedNodes.forEach(updateDiff);
      });
      if (diff.size === 0) {
        lastTickRef.current += 1;
        setMapTick(lastTickRef.current);
      }
    });
    sortedMap.forEach((_, node) => {
      if (node.parentElement) {
        mutationObserver.observe(node.parentElement, {
          childList: true,
        });
      }
    });
    return () => {
      mutationObserver.disconnect();
    };
  }, [sortedMap]);
  useIsoLayoutEffect(() => {
    const shouldUpdateLengths = lastTickRef.current === mapTick;
    if (shouldUpdateLengths) {
      if (elementsRef.current.length !== sortedMap.size) {
        elementsRef.current.length = sortedMap.size;
      }
      if (labelsRef && labelsRef.current.length !== sortedMap.size) {
        labelsRef.current.length = sortedMap.size;
      }
      nextIndexRef.current = sortedMap.size;
    }
    onMapChange(sortedMap);
  }, [onMapChange, sortedMap, elementsRef, labelsRef, mapTick]);
  useIsoLayoutEffect(() => {
    return () => {
      elementsRef.current = [];
    };
  }, [elementsRef]);
  useIsoLayoutEffect(() => {
    return () => {
      if (labelsRef) {
        labelsRef.current = [];
      }
    };
  }, [labelsRef]);
  const subscribeMapChange = useStableCallback((fn) => {
    listeners.add(fn);
    return () => {
      listeners.delete(fn);
    };
  });
  useIsoLayoutEffect(() => {
    listeners.forEach((l) => l(sortedMap));
  }, [listeners, sortedMap]);
  const contextValue = reactExports.useMemo(
    () => ({
      register,
      unregister,
      subscribeMapChange,
      elementsRef,
      labelsRef,
      nextIndexRef,
    }),
    [register, unregister, subscribeMapChange, elementsRef, labelsRef, nextIndexRef],
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CompositeListContext.Provider, {
    value: contextValue,
    children,
  });
}
function createMap() {
  return /* @__PURE__ */ new Map();
}
function createListeners() {
  return /* @__PURE__ */ new Set();
}
function sortByDocumentPosition(a, b) {
  const position = a.compareDocumentPosition(b);
  if (
    position & Node.DOCUMENT_POSITION_FOLLOWING ||
    position & Node.DOCUMENT_POSITION_CONTAINED_BY
  ) {
    return -1;
  }
  if (position & Node.DOCUMENT_POSITION_PRECEDING || position & Node.DOCUMENT_POSITION_CONTAINS) {
    return 1;
  }
  return 0;
}
const InternalBackdrop = /* @__PURE__ */ reactExports.forwardRef(
  function InternalBackdrop2(props, ref) {
    const { cutout, ...otherProps } = props;
    let clipPath;
    if (cutout) {
      const rect = cutout == null ? void 0 : cutout.getBoundingClientRect();
      clipPath = `polygon(
      0% 0%,
      100% 0%,
      100% 100%,
      0% 100%,
      0% 0%,
      ${rect.left}px ${rect.top}px,
      ${rect.left}px ${rect.bottom}px,
      ${rect.right}px ${rect.bottom}px,
      ${rect.right}px ${rect.top}px,
      ${rect.left}px ${rect.top}px
    )`;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
      ref,
      role: "presentation",
      "data-base-ui-inert": "",
      ...otherProps,
      style: {
        position: "fixed",
        inset: 0,
        userSelect: "none",
        WebkitUserSelect: "none",
        clipPath,
      },
    });
  },
);
const MenuPositioner = /* @__PURE__ */ reactExports.forwardRef(
  function MenuPositioner2(componentProps, forwardedRef) {
    var _a2;
    const {
      anchor: anchorProp,
      positionMethod: positionMethodProp = "absolute",
      className,
      render,
      side,
      align: alignProp,
      sideOffset: sideOffsetProp = 0,
      alignOffset: alignOffsetProp = 0,
      collisionBoundary = "clipping-ancestors",
      collisionPadding = 5,
      arrowPadding = 5,
      sticky = false,
      disableAnchorTracking = false,
      collisionAvoidance: collisionAvoidanceProp = DROPDOWN_COLLISION_AVOIDANCE,
      ...elementProps
    } = componentProps;
    const { store } = useMenuRootContext();
    const keepMounted = useMenuPortalContext();
    const contextMenuContext = useContextMenuRootContext(true);
    const parent = store.useState("parent");
    const floatingRootContext = store.useState("floatingRootContext");
    const floatingTreeRoot = store.useState("floatingTreeRoot");
    const mounted = store.useState("mounted");
    const open = store.useState("open");
    const modal = store.useState("modal");
    const triggerElement = store.useState("activeTriggerElement");
    const lastOpenChangeReason = store.useState("lastOpenChangeReason");
    const floatingNodeId = store.useState("floatingNodeId");
    const floatingParentNodeId = store.useState("floatingParentNodeId");
    let anchor = anchorProp;
    let sideOffset = sideOffsetProp;
    let alignOffset = alignOffsetProp;
    let align = alignProp;
    let collisionAvoidance = collisionAvoidanceProp;
    if (parent.type === "context-menu") {
      anchor = anchorProp ?? ((_a2 = parent.context) == null ? void 0 : _a2.anchor);
      align = align ?? "start";
      if (!side && align !== "center") {
        alignOffset = componentProps.alignOffset ?? 2;
        sideOffset = componentProps.sideOffset ?? -5;
      }
    }
    let computedSide = side;
    let computedAlign = align;
    if (parent.type === "menu") {
      computedSide = computedSide ?? "inline-end";
      computedAlign = computedAlign ?? "start";
      collisionAvoidance = componentProps.collisionAvoidance ?? POPUP_COLLISION_AVOIDANCE;
    } else if (parent.type === "menubar") {
      computedSide = computedSide ?? "bottom";
      computedAlign = computedAlign ?? "start";
    }
    const contextMenu = parent.type === "context-menu";
    const positioner = useAnchorPositioning({
      anchor,
      floatingRootContext,
      positionMethod: contextMenuContext ? "fixed" : positionMethodProp,
      mounted,
      side: computedSide,
      sideOffset,
      align: computedAlign,
      alignOffset,
      arrowPadding: contextMenu ? 0 : arrowPadding,
      collisionBoundary,
      collisionPadding,
      sticky,
      nodeId: floatingNodeId,
      keepMounted,
      disableAnchorTracking,
      collisionAvoidance,
      shiftCrossAxis: contextMenu,
      externalTree: floatingTreeRoot,
    });
    const positionerProps = reactExports.useMemo(() => {
      const hiddenStyles = {};
      if (!open) {
        hiddenStyles.pointerEvents = "none";
      }
      return {
        role: "presentation",
        hidden: !mounted,
        style: {
          ...positioner.positionerStyles,
          ...hiddenStyles,
        },
      };
    }, [open, mounted, positioner.positionerStyles]);
    reactExports.useEffect(() => {
      function onMenuOpenChange(details) {
        if (details.open) {
          if (details.parentNodeId === floatingNodeId) {
            store.set("hoverEnabled", false);
          }
          if (
            details.nodeId !== floatingNodeId &&
            details.parentNodeId === store.select("floatingParentNodeId")
          ) {
            store.setOpen(false, createChangeEventDetails(siblingOpen));
          }
        } else if (details.parentNodeId === floatingNodeId) {
          if (details.reason !== siblingOpen) {
            store.set("hoverEnabled", true);
          }
        }
      }
      floatingTreeRoot.events.on("menuopenchange", onMenuOpenChange);
      return () => {
        floatingTreeRoot.events.off("menuopenchange", onMenuOpenChange);
      };
    }, [store, floatingTreeRoot.events, floatingNodeId]);
    reactExports.useEffect(() => {
      if (store.select("floatingParentNodeId") == null) {
        return void 0;
      }
      function onParentClose(details) {
        if (details.open || details.nodeId !== store.select("floatingParentNodeId")) {
          return;
        }
        const reason = details.reason ?? siblingOpen;
        store.setOpen(false, createChangeEventDetails(reason));
      }
      floatingTreeRoot.events.on("menuopenchange", onParentClose);
      return () => {
        floatingTreeRoot.events.off("menuopenchange", onParentClose);
      };
    }, [floatingTreeRoot.events, store]);
    reactExports.useEffect(() => {
      function onItemHover(event) {
        if (!open || event.nodeId !== store.select("floatingParentNodeId")) {
          return;
        }
        if (event.target && triggerElement && triggerElement !== event.target) {
          store.setOpen(false, createChangeEventDetails(siblingOpen));
        }
      }
      floatingTreeRoot.events.on("itemhover", onItemHover);
      return () => {
        floatingTreeRoot.events.off("itemhover", onItemHover);
      };
    }, [floatingTreeRoot.events, open, triggerElement, store]);
    reactExports.useEffect(() => {
      const eventDetails = {
        open,
        nodeId: floatingNodeId,
        parentNodeId: floatingParentNodeId,
        reason: store.select("lastOpenChangeReason"),
      };
      floatingTreeRoot.events.emit("menuopenchange", eventDetails);
    }, [floatingTreeRoot.events, open, store, floatingNodeId, floatingParentNodeId]);
    const state = reactExports.useMemo(
      () => ({
        open,
        side: positioner.side,
        align: positioner.align,
        anchorHidden: positioner.anchorHidden,
        nested: parent.type === "menu",
      }),
      [open, positioner.side, positioner.align, positioner.anchorHidden, parent.type],
    );
    const contextValue = reactExports.useMemo(
      () => ({
        side: positioner.side,
        align: positioner.align,
        arrowRef: positioner.arrowRef,
        arrowUncentered: positioner.arrowUncentered,
        arrowStyles: positioner.arrowStyles,
        nodeId: positioner.context.nodeId,
      }),
      [
        positioner.side,
        positioner.align,
        positioner.arrowRef,
        positioner.arrowUncentered,
        positioner.arrowStyles,
        positioner.context.nodeId,
      ],
    );
    const element = useRenderElement("div", componentProps, {
      state,
      stateAttributesMapping: popupStateMapping,
      ref: [forwardedRef, store.useStateSetter("positionerElement")],
      props: [positionerProps, elementProps],
    });
    const shouldRenderBackdrop =
      mounted &&
      parent.type !== "menu" &&
      ((parent.type !== "menubar" && modal && lastOpenChangeReason !== triggerHover) ||
        (parent.type === "menubar" && parent.context.modal));
    let backdropCutout = null;
    if (parent.type === "menubar") {
      backdropCutout = parent.context.contentElement;
    } else if (parent.type === void 0) {
      backdropCutout = triggerElement;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(MenuPositionerContext.Provider, {
      value: contextValue,
      children: [
        shouldRenderBackdrop &&
          /* @__PURE__ */ jsxRuntimeExports.jsx(InternalBackdrop, {
            ref:
              parent.type === "context-menu" || parent.type === "nested-context-menu"
                ? parent.context.internalBackdropRef
                : null,
            inert: inertValue(!open),
            cutout: backdropCutout,
          }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(FloatingNode, {
          id: floatingNodeId,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(CompositeList, {
            elementsRef: store.context.itemDomElements,
            labelsRef: store.context.itemLabels,
            children: element,
          }),
        }),
      ],
    });
  },
);
let originalHtmlStyles = {};
let originalBodyStyles = {};
let originalHtmlScrollBehavior = "";
function hasInsetScrollbars(referenceElement) {
  if (typeof document === "undefined") {
    return false;
  }
  const doc = ownerDocument(referenceElement);
  const win = getWindow(doc);
  return win.innerWidth - doc.documentElement.clientWidth > 0;
}
function supportsStableScrollbarGutter(referenceElement) {
  const supported =
    typeof CSS !== "undefined" && CSS.supports && CSS.supports("scrollbar-gutter", "stable");
  if (!supported || typeof document === "undefined") {
    return false;
  }
  const doc = ownerDocument(referenceElement);
  const html = doc.documentElement;
  const originalStyles = {
    scrollbarGutter: html.style.scrollbarGutter,
    overflowY: html.style.overflowY,
  };
  html.style.scrollbarGutter = "stable";
  html.style.overflowY = "scroll";
  const before = html.offsetWidth;
  html.style.overflowY = "hidden";
  const after = html.offsetWidth;
  Object.assign(html.style, originalStyles);
  return before === after;
}
function preventScrollOverlayScrollbars(referenceElement) {
  const doc = ownerDocument(referenceElement);
  const html = doc.documentElement;
  const body = doc.body;
  const elementToLock = isOverflowElement(html) ? html : body;
  const originalOverflow = elementToLock.style.overflow;
  elementToLock.style.overflow = "hidden";
  return () => {
    elementToLock.style.overflow = originalOverflow;
  };
}
function preventScrollInsetScrollbars(referenceElement) {
  var _a2;
  const doc = ownerDocument(referenceElement);
  const html = doc.documentElement;
  const body = doc.body;
  const win = getWindow(html);
  let scrollTop = 0;
  let scrollLeft = 0;
  let updateGutterOnly = false;
  const resizeFrame = AnimationFrame.create();
  if (isWebKit && (((_a2 = win.visualViewport) == null ? void 0 : _a2.scale) ?? 1) !== 1) {
    return () => {};
  }
  function lockScroll() {
    const htmlStyles = win.getComputedStyle(html);
    const bodyStyles = win.getComputedStyle(body);
    const htmlScrollbarGutterValue = htmlStyles.scrollbarGutter || "";
    const hasBothEdges = htmlScrollbarGutterValue.includes("both-edges");
    const scrollbarGutterValue = hasBothEdges ? "stable both-edges" : "stable";
    scrollTop = html.scrollTop;
    scrollLeft = html.scrollLeft;
    originalHtmlStyles = {
      scrollbarGutter: html.style.scrollbarGutter,
      overflowY: html.style.overflowY,
      overflowX: html.style.overflowX,
    };
    originalHtmlScrollBehavior = html.style.scrollBehavior;
    originalBodyStyles = {
      position: body.style.position,
      height: body.style.height,
      width: body.style.width,
      boxSizing: body.style.boxSizing,
      overflowY: body.style.overflowY,
      overflowX: body.style.overflowX,
      scrollBehavior: body.style.scrollBehavior,
    };
    const isScrollableY = html.scrollHeight > html.clientHeight;
    const isScrollableX = html.scrollWidth > html.clientWidth;
    const hasConstantOverflowY =
      htmlStyles.overflowY === "scroll" || bodyStyles.overflowY === "scroll";
    const hasConstantOverflowX =
      htmlStyles.overflowX === "scroll" || bodyStyles.overflowX === "scroll";
    const scrollbarWidth = Math.max(0, win.innerWidth - body.clientWidth);
    const scrollbarHeight = Math.max(0, win.innerHeight - body.clientHeight);
    const marginY = parseFloat(bodyStyles.marginTop) + parseFloat(bodyStyles.marginBottom);
    const marginX = parseFloat(bodyStyles.marginLeft) + parseFloat(bodyStyles.marginRight);
    const elementToLock = isOverflowElement(html) ? html : body;
    updateGutterOnly = supportsStableScrollbarGutter(referenceElement);
    if (updateGutterOnly) {
      html.style.scrollbarGutter = scrollbarGutterValue;
      elementToLock.style.overflowY = "hidden";
      elementToLock.style.overflowX = "hidden";
      return;
    }
    Object.assign(html.style, {
      scrollbarGutter: scrollbarGutterValue,
      overflowY: "hidden",
      overflowX: "hidden",
    });
    if (isScrollableY || hasConstantOverflowY) {
      html.style.overflowY = "scroll";
    }
    if (isScrollableX || hasConstantOverflowX) {
      html.style.overflowX = "scroll";
    }
    Object.assign(body.style, {
      position: "relative",
      height:
        marginY || scrollbarHeight ? `calc(100dvh - ${marginY + scrollbarHeight}px)` : "100dvh",
      width: marginX || scrollbarWidth ? `calc(100vw - ${marginX + scrollbarWidth}px)` : "100vw",
      boxSizing: "border-box",
      overflow: "hidden",
      scrollBehavior: "unset",
    });
    body.scrollTop = scrollTop;
    body.scrollLeft = scrollLeft;
    html.setAttribute("data-base-ui-scroll-locked", "");
    html.style.scrollBehavior = "unset";
  }
  function cleanup() {
    Object.assign(html.style, originalHtmlStyles);
    Object.assign(body.style, originalBodyStyles);
    if (!updateGutterOnly) {
      html.scrollTop = scrollTop;
      html.scrollLeft = scrollLeft;
      html.removeAttribute("data-base-ui-scroll-locked");
      html.style.scrollBehavior = originalHtmlScrollBehavior;
    }
  }
  function handleResize() {
    cleanup();
    resizeFrame.request(lockScroll);
  }
  lockScroll();
  win.addEventListener("resize", handleResize);
  return () => {
    resizeFrame.cancel();
    cleanup();
    if (typeof win.removeEventListener === "function") {
      win.removeEventListener("resize", handleResize);
    }
  };
}
class ScrollLocker {
  constructor() {
    __publicField(this, "lockCount", 0);
    __publicField(this, "restore", null);
    __publicField(this, "timeoutLock", Timeout.create());
    __publicField(this, "timeoutUnlock", Timeout.create());
    __publicField(this, "release", () => {
      this.lockCount -= 1;
      if (this.lockCount === 0 && this.restore) {
        this.timeoutUnlock.start(0, this.unlock);
      }
    });
    __publicField(this, "unlock", () => {
      var _a2;
      if (this.lockCount === 0 && this.restore) {
        (_a2 = this.restore) == null ? void 0 : _a2.call(this);
        this.restore = null;
      }
    });
  }
  acquire(referenceElement) {
    this.lockCount += 1;
    if (this.lockCount === 1 && this.restore === null) {
      this.timeoutLock.start(0, () => this.lock(referenceElement));
    }
    return this.release;
  }
  lock(referenceElement) {
    if (this.lockCount === 0 || this.restore !== null) {
      return;
    }
    const doc = ownerDocument(referenceElement);
    const html = doc.documentElement;
    const htmlOverflowY = getWindow(html).getComputedStyle(html).overflowY;
    if (htmlOverflowY === "hidden" || htmlOverflowY === "clip") {
      this.restore = NOOP;
      return;
    }
    const hasOverlayScrollbars = isIOS || !hasInsetScrollbars(referenceElement);
    this.restore = hasOverlayScrollbars
      ? preventScrollOverlayScrollbars(referenceElement)
      : preventScrollInsetScrollbars(referenceElement);
  }
}
const SCROLL_LOCKER = new ScrollLocker();
function useScrollLock(enabled = true, referenceElement = null) {
  useIsoLayoutEffect(() => {
    if (!enabled) {
      return void 0;
    }
    return SCROLL_LOCKER.acquire(referenceElement);
  }, [enabled, referenceElement]);
}
const MenubarContext = /* @__PURE__ */ reactExports.createContext(null);
function useMenubarContext(optional) {
  const context = reactExports.useContext(MenubarContext);
  return context;
}
function useEnhancedClickHandler(handler) {
  const lastClickInteractionTypeRef = reactExports.useRef("");
  const handlePointerDown = reactExports.useCallback(
    (event) => {
      if (event.defaultPrevented) {
        return;
      }
      lastClickInteractionTypeRef.current = event.pointerType;
      handler(event, event.pointerType);
    },
    [handler],
  );
  const handleClick = reactExports.useCallback(
    (event) => {
      if (event.detail === 0) {
        handler(event, "keyboard");
        return;
      }
      if ("pointerType" in event) {
        handler(event, event.pointerType);
      }
      handler(event, lastClickInteractionTypeRef.current);
      lastClickInteractionTypeRef.current = "";
    },
    [handler],
  );
  return {
    onClick: handleClick,
    onPointerDown: handlePointerDown,
  };
}
function useOpenInteractionType(open) {
  const [openMethod, setOpenMethod] = reactExports.useState(null);
  const handleTriggerClick = useStableCallback((_, interactionType) => {
    if (!open) {
      setOpenMethod(
        interactionType || // On iOS Safari, the hitslop around touch targets means tapping outside an element's
          // bounds does not fire `pointerdown` but does fire `mousedown`. The `interactionType`
          // will be "" in that case.
          (isIOS ? "touch" : ""),
      );
    }
  });
  const reset = reactExports.useCallback(() => {
    setOpenMethod(null);
  }, []);
  const { onClick, onPointerDown } = useEnhancedClickHandler(handleTriggerClick);
  return reactExports.useMemo(
    () => ({
      openMethod,
      reset,
      triggerProps: {
        onClick,
        onPointerDown,
      },
    }),
    [openMethod, reset, onClick, onPointerDown],
  );
}
const selectors$1 = {
  ...popupStoreSelectors,
  disabled: createSelector((state) =>
    state.parent.type === "menubar"
      ? state.parent.context.disabled || state.disabled
      : state.disabled,
  ),
  modal: createSelector(
    (state) =>
      (state.parent.type === void 0 || state.parent.type === "context-menu") &&
      (state.modal ?? true),
  ),
  allowMouseEnter: createSelector((state) =>
    state.parent.type === "menu"
      ? state.parent.store.select("allowMouseEnter")
      : state.allowMouseEnter,
  ),
  stickIfOpen: createSelector((state) => state.stickIfOpen),
  parent: createSelector((state) => state.parent),
  rootId: createSelector((state) => {
    if (state.parent.type === "menu") {
      return state.parent.store.select("rootId");
    }
    return state.parent.type !== void 0 ? state.parent.context.rootId : state.rootId;
  }),
  activeIndex: createSelector((state) => state.activeIndex),
  isActive: createSelector((state, itemIndex) => state.activeIndex === itemIndex),
  hoverEnabled: createSelector((state) => state.hoverEnabled),
  instantType: createSelector((state) => state.instantType),
  lastOpenChangeReason: createSelector((state) => state.openChangeReason),
  floatingTreeRoot: createSelector((state) => {
    if (state.parent.type === "menu") {
      return state.parent.store.select("floatingTreeRoot");
    }
    return state.floatingTreeRoot;
  }),
  floatingNodeId: createSelector((state) => state.floatingNodeId),
  floatingParentNodeId: createSelector((state) => state.floatingParentNodeId),
  itemProps: createSelector((state) => state.itemProps),
  closeDelay: createSelector((state) => state.closeDelay),
  keyboardEventRelay: createSelector((state) => {
    if (state.keyboardEventRelay) {
      return state.keyboardEventRelay;
    }
    if (state.parent.type === "menu") {
      return state.parent.store.select("keyboardEventRelay");
    }
    return void 0;
  }),
};
class MenuStore extends ReactStore {
  constructor(initialState) {
    super(
      {
        ...createInitialState$1(),
        ...initialState,
      },
      {
        positionerRef: /* @__PURE__ */ reactExports.createRef(),
        popupRef: /* @__PURE__ */ reactExports.createRef(),
        typingRef: {
          current: false,
        },
        itemDomElements: {
          current: [],
        },
        itemLabels: {
          current: [],
        },
        allowMouseUpTriggerRef: {
          current: false,
        },
        triggerFocusTargetRef: /* @__PURE__ */ reactExports.createRef(),
        beforeContentFocusGuardRef: /* @__PURE__ */ reactExports.createRef(),
        onOpenChangeComplete: void 0,
        triggerElements: new PopupTriggerMap(),
      },
      selectors$1,
    );
    __publicField(this, "unsubscribeParentListener", null);
    this.observe(
      createSelector((state) => state.allowMouseEnter),
      (allowMouseEnter, oldValue) => {
        if (this.state.parent.type === "menu" && allowMouseEnter !== oldValue) {
          this.state.parent.store.set("allowMouseEnter", allowMouseEnter);
        }
      },
    );
    this.unsubscribeParentListener = this.observe("parent", (parent) => {
      var _a2;
      (_a2 = this.unsubscribeParentListener) == null ? void 0 : _a2.call(this);
      if (parent.type === "menu") {
        this.unsubscribeParentListener = parent.store.subscribe(() => {
          this.notifyAll();
        });
        this.context.allowMouseUpTriggerRef = parent.store.context.allowMouseUpTriggerRef;
        return;
      }
      if (parent.type !== void 0) {
        this.context.allowMouseUpTriggerRef = parent.context.allowMouseUpTriggerRef;
      }
      this.unsubscribeParentListener = null;
    });
  }
  setOpen(open, eventDetails) {
    this.state.floatingRootContext.context.events.emit("setOpen", {
      open,
      eventDetails,
    });
  }
  static useStore(externalStore, initialState) {
    const internalStore = useRefWithInit(() => {
      return new MenuStore(initialState);
    }).current;
    return externalStore ?? internalStore;
  }
}
function createInitialState$1() {
  return {
    ...createInitialPopupStoreState(),
    disabled: false,
    modal: true,
    allowMouseEnter: true,
    stickIfOpen: true,
    parent: {
      type: void 0,
    },
    rootId: void 0,
    activeIndex: null,
    hoverEnabled: true,
    instantType: void 0,
    openChangeReason: null,
    floatingTreeRoot: new FloatingTreeStore(),
    floatingNodeId: void 0,
    floatingParentNodeId: null,
    itemProps: EMPTY_OBJECT,
    keyboardEventRelay: void 0,
    closeDelay: 0,
  };
}
const MenuSubmenuRootContext = /* @__PURE__ */ reactExports.createContext(void 0);
function useMenuSubmenuRootContext() {
  return reactExports.useContext(MenuSubmenuRootContext);
}
function MenuRoot(props) {
  const {
    children,
    open: openProp,
    onOpenChange,
    onOpenChangeComplete,
    defaultOpen = false,
    disabled: disabledProp = false,
    modal: modalProp,
    loopFocus = true,
    orientation = "vertical",
    actionsRef,
    closeParentOnEsc = false,
    handle,
    triggerId: triggerIdProp,
    defaultTriggerId: defaultTriggerIdProp = null,
    highlightItemOnHover = true,
  } = props;
  const contextMenuContext = useContextMenuRootContext(true);
  const parentMenuRootContext = useMenuRootContext(true);
  const menubarContext = useMenubarContext();
  const isSubmenu = useMenuSubmenuRootContext();
  const parentFromContext = reactExports.useMemo(() => {
    if (isSubmenu && parentMenuRootContext) {
      return {
        type: "menu",
        store: parentMenuRootContext.store,
      };
    }
    if (menubarContext) {
      return {
        type: "menubar",
        context: menubarContext,
      };
    }
    if (contextMenuContext && !parentMenuRootContext) {
      return {
        type: "context-menu",
        context: contextMenuContext,
      };
    }
    return {
      type: void 0,
    };
  }, [contextMenuContext, parentMenuRootContext, menubarContext, isSubmenu]);
  const store = MenuStore.useStore(handle == null ? void 0 : handle.store, {
    parent: parentFromContext,
  });
  const floatingTreeRoot = store.useState("floatingTreeRoot");
  const floatingNodeIdFromContext = useFloatingNodeId(floatingTreeRoot);
  const floatingParentNodeIdFromContext = useFloatingParentNodeId();
  useIsoLayoutEffect(() => {
    if (contextMenuContext && !parentMenuRootContext) {
      store.update({
        parent: {
          type: "context-menu",
          context: contextMenuContext,
        },
        floatingNodeId: floatingNodeIdFromContext,
        floatingParentNodeId: floatingParentNodeIdFromContext,
      });
    } else if (parentMenuRootContext) {
      store.update({
        floatingNodeId: floatingNodeIdFromContext,
        floatingParentNodeId: floatingParentNodeIdFromContext,
      });
    }
  }, [
    contextMenuContext,
    parentMenuRootContext,
    floatingNodeIdFromContext,
    floatingParentNodeIdFromContext,
    store,
  ]);
  store.useControlledProp("open", openProp, defaultOpen);
  store.useControlledProp("activeTriggerId", triggerIdProp, defaultTriggerIdProp);
  store.useContextCallback("onOpenChangeComplete", onOpenChangeComplete);
  const open = store.useState("open");
  const activeTriggerElement = store.useState("activeTriggerElement");
  const positionerElement = store.useState("positionerElement");
  const hoverEnabled = store.useState("hoverEnabled");
  const modal = store.useState("modal");
  const disabled2 = store.useState("disabled");
  const lastOpenChangeReason = store.useState("lastOpenChangeReason");
  const parent = store.useState("parent");
  const activeIndex = store.useState("activeIndex");
  const payload = store.useState("payload");
  const floatingParentNodeId = store.useState("floatingParentNodeId");
  const openEventRef = reactExports.useRef(null);
  const nested = floatingParentNodeId != null;
  let floatingEvents;
  store.useSyncedValues({
    disabled: disabledProp,
    modal: parent.type === void 0 ? modalProp : void 0,
    rootId: useId(),
  });
  const {
    openMethod,
    triggerProps: interactionTypeProps,
    reset: resetOpenInteractionType,
  } = useOpenInteractionType(open);
  useImplicitActiveTrigger(store);
  const { forceUnmount } = useOpenStateTransitions(open, store, () => {
    store.update({
      allowMouseEnter: false,
      stickIfOpen: true,
    });
    resetOpenInteractionType();
  });
  const allowOutsidePressDismissalRef = reactExports.useRef(parent.type !== "context-menu");
  const allowOutsidePressDismissalTimeout = useTimeout();
  reactExports.useEffect(() => {
    if (!open) {
      openEventRef.current = null;
    }
    if (parent.type !== "context-menu") {
      return;
    }
    if (!open) {
      allowOutsidePressDismissalTimeout.clear();
      allowOutsidePressDismissalRef.current = false;
      return;
    }
    allowOutsidePressDismissalTimeout.start(500, () => {
      allowOutsidePressDismissalRef.current = true;
    });
  }, [allowOutsidePressDismissalTimeout, open, parent.type]);
  useScrollLock(
    open && modal && lastOpenChangeReason !== triggerHover && openMethod !== "touch",
    positionerElement,
  );
  useIsoLayoutEffect(() => {
    if (!open && !hoverEnabled) {
      store.set("hoverEnabled", true);
    }
  }, [open, hoverEnabled, store]);
  const allowTouchToCloseRef = reactExports.useRef(true);
  const allowTouchToCloseTimeout = useTimeout();
  const setOpen = useStableCallback((nextOpen, eventDetails) => {
    const reason = eventDetails.reason;
    if (
      open === nextOpen &&
      eventDetails.trigger === activeTriggerElement &&
      lastOpenChangeReason === reason
    ) {
      return;
    }
    eventDetails.preventUnmountOnClose = () => {
      store.set("preventUnmountingOnClose", true);
    };
    if (!nextOpen && eventDetails.trigger == null) {
      eventDetails.trigger = activeTriggerElement ?? void 0;
    }
    onOpenChange == null ? void 0 : onOpenChange(nextOpen, eventDetails);
    if (eventDetails.isCanceled) {
      return;
    }
    const details = {
      open: nextOpen,
      nativeEvent: eventDetails.event,
      reason: eventDetails.reason,
      nested,
    };
    floatingEvents == null ? void 0 : floatingEvents.emit("openchange", details);
    const nativeEvent = eventDetails.event;
    if (
      nextOpen === false &&
      (nativeEvent == null ? void 0 : nativeEvent.type) === "click" &&
      nativeEvent.pointerType === "touch" &&
      !allowTouchToCloseRef.current
    ) {
      return;
    }
    if (!nextOpen && activeIndex !== null) {
      const activeOption = store.context.itemDomElements.current[activeIndex];
      queueMicrotask(() => {
        activeOption == null ? void 0 : activeOption.setAttribute("tabindex", "-1");
      });
    }
    if (nextOpen && reason === triggerFocus) {
      allowTouchToCloseRef.current = false;
      allowTouchToCloseTimeout.start(300, () => {
        allowTouchToCloseRef.current = true;
      });
    } else {
      allowTouchToCloseRef.current = true;
      allowTouchToCloseTimeout.clear();
    }
    const isKeyboardClick =
      (reason === triggerPress || reason === itemPress) &&
      nativeEvent.detail === 0 &&
      (nativeEvent == null ? void 0 : nativeEvent.isTrusted);
    const isDismissClose = !nextOpen && (reason === escapeKey || reason == null);
    function changeState() {
      var _a2;
      const updatedState = {
        open: nextOpen,
        openChangeReason: reason,
      };
      openEventRef.current = eventDetails.event ?? null;
      const newTriggerId = ((_a2 = eventDetails.trigger) == null ? void 0 : _a2.id) ?? null;
      if (newTriggerId || nextOpen) {
        updatedState.activeTriggerId = newTriggerId;
        updatedState.activeTriggerElement = eventDetails.trigger ?? null;
      }
      store.update(updatedState);
    }
    if (reason === triggerHover) {
      reactDomExports.flushSync(changeState);
    } else {
      changeState();
    }
    if (
      parent.type === "menubar" &&
      (reason === triggerFocus ||
        reason === focusOut ||
        reason === triggerHover ||
        reason === listNavigation ||
        reason === siblingOpen)
    ) {
      store.set("instantType", "group");
    } else if (isKeyboardClick || isDismissClose) {
      store.set("instantType", isKeyboardClick ? "click" : "dismiss");
    } else {
      store.set("instantType", void 0);
    }
  });
  const createMenuEventDetails = reactExports.useCallback(
    (reason) => {
      const details = createChangeEventDetails(reason);
      details.preventUnmountOnClose = () => {
        store.set("preventUnmountingOnClose", true);
      };
      return details;
    },
    [store],
  );
  const handleImperativeClose = reactExports.useCallback(() => {
    store.setOpen(false, createMenuEventDetails(imperativeAction));
  }, [store, createMenuEventDetails]);
  reactExports.useImperativeHandle(
    actionsRef,
    () => ({
      unmount: forceUnmount,
      close: handleImperativeClose,
    }),
    [forceUnmount, handleImperativeClose],
  );
  let ctx;
  if (parent.type === "context-menu") {
    ctx = parent.context;
  }
  reactExports.useImperativeHandle(
    ctx == null ? void 0 : ctx.positionerRef,
    () => positionerElement,
    [positionerElement],
  );
  reactExports.useImperativeHandle(
    ctx == null ? void 0 : ctx.actionsRef,
    () => ({
      setOpen,
    }),
    [setOpen],
  );
  const floatingRootContext = useSyncedFloatingRootContext({
    popupStore: store,
    onOpenChange: setOpen,
  });
  floatingEvents = floatingRootContext.context.events;
  reactExports.useEffect(() => {
    const handleSetOpenEvent = ({ open: nextOpen, eventDetails }) =>
      setOpen(nextOpen, eventDetails);
    floatingEvents.on("setOpen", handleSetOpenEvent);
    return () => {
      floatingEvents == null ? void 0 : floatingEvents.off("setOpen", handleSetOpenEvent);
    };
  }, [floatingEvents, setOpen]);
  const dismiss = useDismiss(floatingRootContext, {
    enabled: !disabled2,
    bubbles: {
      escapeKey: closeParentOnEsc && parent.type === "menu",
    },
    outsidePress() {
      var _a2;
      if (
        parent.type !== "context-menu" ||
        ((_a2 = openEventRef.current) == null ? void 0 : _a2.type) === "contextmenu"
      ) {
        return true;
      }
      return allowOutsidePressDismissalRef.current;
    },
    externalTree: nested ? floatingTreeRoot : void 0,
  });
  const role = useRole(floatingRootContext, {
    role: "menu",
  });
  const direction = useDirection();
  const setActiveIndex = reactExports.useCallback(
    (index2) => {
      if (store.select("activeIndex") === index2) {
        return;
      }
      store.set("activeIndex", index2);
    },
    [store],
  );
  const listNavigation$1 = useListNavigation(floatingRootContext, {
    enabled: !disabled2,
    listRef: store.context.itemDomElements,
    activeIndex,
    nested: parent.type !== void 0,
    loopFocus,
    orientation,
    parentOrientation: parent.type === "menubar" ? parent.context.orientation : void 0,
    rtl: direction === "rtl",
    disabledIndices: EMPTY_ARRAY$1,
    onNavigate: setActiveIndex,
    openOnArrowKeyDown: parent.type !== "context-menu",
    externalTree: nested ? floatingTreeRoot : void 0,
    focusItemOnHover: highlightItemOnHover,
  });
  const onTypingChange = reactExports.useCallback(
    (nextTyping) => {
      store.context.typingRef.current = nextTyping;
    },
    [store],
  );
  const typeahead = useTypeahead(floatingRootContext, {
    listRef: store.context.itemLabels,
    activeIndex,
    resetMs: TYPEAHEAD_RESET_MS,
    onMatch: (index2) => {
      if (open && index2 !== activeIndex) {
        store.set("activeIndex", index2);
      }
    },
    onTypingChange,
  });
  const { getReferenceProps, getFloatingProps, getItemProps, getTriggerProps } = useInteractions([
    dismiss,
    role,
    listNavigation$1,
    typeahead,
  ]);
  const activeTriggerProps = reactExports.useMemo(() => {
    const mergedProps = mergeProps$1(
      getReferenceProps(),
      {
        onMouseEnter() {
          store.set("hoverEnabled", true);
        },
        onMouseMove() {
          store.set("allowMouseEnter", true);
        },
      },
      interactionTypeProps,
    );
    delete mergedProps.role;
    return mergedProps;
  }, [getReferenceProps, store, interactionTypeProps]);
  const inactiveTriggerProps = reactExports.useMemo(() => {
    const triggerProps = getTriggerProps();
    if (!triggerProps) {
      return triggerProps;
    }
    const mergedProps = mergeProps$1(triggerProps, interactionTypeProps);
    delete mergedProps.role;
    delete mergedProps["aria-controls"];
    return mergedProps;
  }, [getTriggerProps, interactionTypeProps]);
  const disableHoverTimeout = useAnimationFrame();
  const popupProps = reactExports.useMemo(
    () =>
      getFloatingProps({
        onMouseEnter() {
          if (parent.type === "menu") {
            disableHoverTimeout.request(() => store.set("hoverEnabled", false));
          }
        },
        onMouseMove() {
          store.set("allowMouseEnter", true);
        },
        onClick() {
          if (store.select("hoverEnabled")) {
            store.set("hoverEnabled", false);
          }
        },
        onKeyDown(event) {
          const relay = store.select("keyboardEventRelay");
          if (relay && !event.isPropagationStopped()) {
            relay(event);
          }
        },
      }),
    [getFloatingProps, parent.type, disableHoverTimeout, store],
  );
  const itemProps = reactExports.useMemo(() => getItemProps(), [getItemProps]);
  store.useSyncedValues({
    floatingRootContext,
    activeTriggerProps,
    inactiveTriggerProps,
    popupProps,
    itemProps,
  });
  const context = reactExports.useMemo(
    () => ({
      store,
      parent: parentFromContext,
    }),
    [store, parentFromContext],
  );
  const content = /* @__PURE__ */ jsxRuntimeExports.jsx(MenuRootContext.Provider, {
    value: context,
    children:
      typeof children === "function"
        ? children({
            payload,
          })
        : children,
  });
  if (parent.type === void 0 || parent.type === "context-menu") {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(FloatingTree, {
      externalTree: floatingTreeRoot,
      children: content,
    });
  }
  return content;
}
function getPseudoElementBounds(element) {
  const elementRect = element.getBoundingClientRect();
  const beforeStyles = window.getComputedStyle(element, "::before");
  const afterStyles = window.getComputedStyle(element, "::after");
  const hasPseudoElements = beforeStyles.content !== "none" || afterStyles.content !== "none";
  if (!hasPseudoElements) {
    return elementRect;
  }
  const beforeWidth = parseFloat(beforeStyles.width) || 0;
  const beforeHeight = parseFloat(beforeStyles.height) || 0;
  const afterWidth = parseFloat(afterStyles.width) || 0;
  const afterHeight = parseFloat(afterStyles.height) || 0;
  const totalWidth = Math.max(elementRect.width, beforeWidth, afterWidth);
  const totalHeight = Math.max(elementRect.height, beforeHeight, afterHeight);
  const widthDiff = totalWidth - elementRect.width;
  const heightDiff = totalHeight - elementRect.height;
  return {
    left: elementRect.left - widthDiff / 2,
    right: elementRect.right + widthDiff / 2,
    top: elementRect.top - heightDiff / 2,
    bottom: elementRect.bottom + heightDiff / 2,
  };
}
function useCompositeItem(params = {}) {
  const { highlightItemOnHover, highlightedIndex, onHighlightedIndexChange } =
    useCompositeRootContext();
  const { ref, index: index2 } = useCompositeListItem(params);
  const isHighlighted = highlightedIndex === index2;
  const itemRef = reactExports.useRef(null);
  const mergedRef = useMergedRefs(ref, itemRef);
  const compositeProps = reactExports.useMemo(
    () => ({
      tabIndex: isHighlighted ? 0 : -1,
      onFocus() {
        onHighlightedIndexChange(index2);
      },
      onMouseMove() {
        const item = itemRef.current;
        if (!highlightItemOnHover || !item) {
          return;
        }
        const disabled2 = item.hasAttribute("disabled") || item.ariaDisabled === "true";
        if (!isHighlighted && !disabled2) {
          item.focus();
        }
      },
    }),
    [isHighlighted, onHighlightedIndexChange, index2, highlightItemOnHover],
  );
  return {
    compositeProps,
    compositeRef: mergedRef,
    index: index2,
  };
}
function CompositeItem(componentProps) {
  const {
    render,
    className,
    state = EMPTY_OBJECT,
    props = EMPTY_ARRAY$1,
    refs = EMPTY_ARRAY$1,
    metadata,
    stateAttributesMapping: stateAttributesMapping2,
    tag = "div",
    ...elementProps
  } = componentProps;
  const { compositeProps, compositeRef } = useCompositeItem({
    metadata,
  });
  return useRenderElement(tag, componentProps, {
    state,
    ref: [...refs, compositeRef],
    props: [compositeProps, ...props, elementProps],
    stateAttributesMapping: stateAttributesMapping2,
  });
}
function findRootOwnerId(node) {
  if (isHTMLElement(node) && node.hasAttribute("data-rootownerid")) {
    return node.getAttribute("data-rootownerid") ?? void 0;
  }
  if (isLastTraversableNode(node)) {
    return void 0;
  }
  return findRootOwnerId(getParentNode(node));
}
function useMixedToggleClickHandler(params) {
  const { enabled = true, mouseDownAction, open } = params;
  const ignoreClickRef = reactExports.useRef(false);
  return reactExports.useMemo(() => {
    if (!enabled) {
      return EMPTY_OBJECT;
    }
    return {
      onMouseDown: (event) => {
        if ((mouseDownAction === "open" && !open) || (mouseDownAction === "close" && open)) {
          ignoreClickRef.current = true;
          ownerDocument(event.currentTarget).addEventListener(
            "click",
            () => {
              ignoreClickRef.current = false;
            },
            {
              once: true,
            },
          );
        }
      },
      onClick: (event) => {
        if (ignoreClickRef.current) {
          ignoreClickRef.current = false;
          event.preventBaseUIHandler();
        }
      },
    };
  }, [enabled, mouseDownAction, open]);
}
const BOUNDARY_OFFSET = 2;
const MenuTrigger = /* @__PURE__ */ reactExports.forwardRef(
  function MenuTrigger2(componentProps, forwardedRef) {
    const {
      render,
      className,
      disabled: disabledProp = false,
      nativeButton = true,
      id: idProp,
      openOnHover: openOnHoverProp,
      delay: delay2 = 100,
      closeDelay = 0,
      handle,
      payload,
      ...elementProps
    } = componentProps;
    const rootContext = useMenuRootContext(true);
    const store =
      (handle == null ? void 0 : handle.store) ??
      (rootContext == null ? void 0 : rootContext.store);
    if (!store) {
      throw new Error(formatErrorMessage(85));
    }
    const thisTriggerId = useBaseUiId(idProp);
    const isTriggerActive = store.useState("isTriggerActive", thisTriggerId);
    const floatingRootContext = store.useState("floatingRootContext");
    const isOpenedByThisTrigger = store.useState("isOpenedByTrigger", thisTriggerId);
    const triggerElementRef = reactExports.useRef(null);
    const parent = useMenuParent();
    const compositeRootContext = useCompositeRootContext(true);
    const floatingTreeRootFromContext = useFloatingTree();
    const floatingTreeRoot = reactExports.useMemo(() => {
      return floatingTreeRootFromContext ?? new FloatingTreeStore();
    }, [floatingTreeRootFromContext]);
    const floatingNodeId = useFloatingNodeId(floatingTreeRoot);
    const floatingParentNodeId = useFloatingParentNodeId();
    const { registerTrigger, isMountedByThisTrigger } = useTriggerDataForwarding(
      thisTriggerId,
      triggerElementRef,
      store,
      {
        payload,
        closeDelay,
        parent,
        floatingTreeRoot,
        floatingNodeId,
        floatingParentNodeId,
        keyboardEventRelay:
          compositeRootContext == null ? void 0 : compositeRootContext.relayKeyboardEvent,
      },
    );
    const isInMenubar = parent.type === "menubar";
    const rootDisabled = store.useState("disabled");
    const disabled2 = disabledProp || rootDisabled || (isInMenubar && parent.context.disabled);
    const { getButtonProps, buttonRef } = useButton({
      disabled: disabled2,
      native: nativeButton,
    });
    reactExports.useEffect(() => {
      if (!isOpenedByThisTrigger && parent.type === void 0) {
        store.context.allowMouseUpTriggerRef.current = false;
      }
    }, [store, isOpenedByThisTrigger, parent.type]);
    const triggerRef = reactExports.useRef(null);
    const allowMouseUpTriggerTimeout = useTimeout();
    const handleDocumentMouseUp = useStableCallback((mouseEvent) => {
      if (!triggerRef.current) {
        return;
      }
      allowMouseUpTriggerTimeout.clear();
      store.context.allowMouseUpTriggerRef.current = false;
      const mouseUpTarget = mouseEvent.target;
      if (
        contains(triggerRef.current, mouseUpTarget) ||
        contains(store.select("positionerElement"), mouseUpTarget) ||
        mouseUpTarget === triggerRef.current
      ) {
        return;
      }
      if (mouseUpTarget != null && findRootOwnerId(mouseUpTarget) === store.select("rootId")) {
        return;
      }
      const bounds = getPseudoElementBounds(triggerRef.current);
      if (
        mouseEvent.clientX >= bounds.left - BOUNDARY_OFFSET &&
        mouseEvent.clientX <= bounds.right + BOUNDARY_OFFSET &&
        mouseEvent.clientY >= bounds.top - BOUNDARY_OFFSET &&
        mouseEvent.clientY <= bounds.bottom + BOUNDARY_OFFSET
      ) {
        return;
      }
      floatingTreeRoot.events.emit("close", {
        domEvent: mouseEvent,
        reason: cancelOpen,
      });
    });
    reactExports.useEffect(() => {
      if (isOpenedByThisTrigger && store.select("lastOpenChangeReason") === triggerHover) {
        const doc = ownerDocument(triggerRef.current);
        doc.addEventListener("mouseup", handleDocumentMouseUp, {
          once: true,
        });
      }
    }, [isOpenedByThisTrigger, handleDocumentMouseUp, store]);
    const parentMenubarHasSubmenuOpen = isInMenubar && parent.context.hasSubmenuOpen;
    const openOnHover = openOnHoverProp ?? parentMenubarHasSubmenuOpen;
    const hoverProps = useHoverReferenceInteraction(floatingRootContext, {
      enabled:
        openOnHover &&
        !disabled2 &&
        parent.type !== "context-menu" &&
        (!isInMenubar || (parentMenubarHasSubmenuOpen && !isMountedByThisTrigger)),
      handleClose: safePolygon({
        blockPointerEvents: !isInMenubar,
      }),
      mouseOnly: true,
      move: false,
      restMs: parent.type === void 0 ? delay2 : void 0,
      delay: {
        close: closeDelay,
      },
      triggerElementRef,
      externalTree: floatingTreeRoot,
      isActiveTrigger: isTriggerActive,
    });
    const stickIfOpen = useStickIfOpen(isOpenedByThisTrigger, store.select("lastOpenChangeReason"));
    const click = useClick(floatingRootContext, {
      enabled: !disabled2 && parent.type !== "context-menu",
      event: isOpenedByThisTrigger && isInMenubar ? "click" : "mousedown",
      toggle: true,
      ignoreMouse: false,
      stickIfOpen: parent.type === void 0 ? stickIfOpen : false,
    });
    const focus = useFocus(floatingRootContext, {
      enabled: !disabled2 && parentMenubarHasSubmenuOpen,
    });
    const mixedToggleHandlers = useMixedToggleClickHandler({
      open: isOpenedByThisTrigger,
      enabled: isInMenubar,
      mouseDownAction: "open",
    });
    const localInteractionProps = useInteractions([click, focus]);
    const state = reactExports.useMemo(
      () => ({
        disabled: disabled2,
        open: isOpenedByThisTrigger,
      }),
      [disabled2, isOpenedByThisTrigger],
    );
    const rootTriggerProps = store.useState("triggerProps", isMountedByThisTrigger);
    const ref = [triggerRef, forwardedRef, buttonRef, registerTrigger, triggerElementRef];
    const props = [
      localInteractionProps.getReferenceProps(),
      hoverProps ?? EMPTY_OBJECT,
      rootTriggerProps,
      {
        "aria-haspopup": "menu",
        id: thisTriggerId,
        onMouseDown: (event) => {
          if (store.select("open")) {
            return;
          }
          allowMouseUpTriggerTimeout.start(200, () => {
            store.context.allowMouseUpTriggerRef.current = true;
          });
          const doc = ownerDocument(event.currentTarget);
          doc.addEventListener("mouseup", handleDocumentMouseUp, {
            once: true,
          });
        },
      },
      isInMenubar
        ? {
            role: "menuitem",
          }
        : {},
      mixedToggleHandlers,
      elementProps,
      getButtonProps,
    ];
    const preFocusGuardRef = reactExports.useRef(null);
    const handlePreFocusGuardFocus = useStableCallback((event) => {
      reactDomExports.flushSync(() => {
        store.setOpen(
          false,
          createChangeEventDetails(focusOut, event.nativeEvent, event.currentTarget),
        );
      });
      const previousTabbable = getTabbableBeforeElement(preFocusGuardRef.current);
      previousTabbable == null ? void 0 : previousTabbable.focus();
    });
    const handleFocusTargetFocus = useStableCallback((event) => {
      var _a2;
      const currentPositionerElement = store.select("positionerElement");
      if (currentPositionerElement && isOutsideEvent(event, currentPositionerElement)) {
        (_a2 = store.context.beforeContentFocusGuardRef.current) == null ? void 0 : _a2.focus();
      } else {
        reactDomExports.flushSync(() => {
          store.setOpen(
            false,
            createChangeEventDetails(focusOut, event.nativeEvent, event.currentTarget),
          );
        });
        let nextTabbable = getTabbableAfterElement(
          store.context.triggerFocusTargetRef.current || triggerElementRef.current,
        );
        while (nextTabbable !== null && contains(currentPositionerElement, nextTabbable)) {
          const prevTabbable = nextTabbable;
          nextTabbable = getNextTabbable(nextTabbable);
          if (nextTabbable === prevTabbable) {
            break;
          }
        }
        nextTabbable == null ? void 0 : nextTabbable.focus();
      }
    });
    const element = useRenderElement("button", componentProps, {
      enabled: !isInMenubar,
      stateAttributesMapping: pressableTriggerOpenStateMapping,
      state,
      ref,
      props,
    });
    if (isInMenubar) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(CompositeItem, {
        tag: "button",
        render,
        className,
        state,
        refs: ref,
        props,
        stateAttributesMapping: pressableTriggerOpenStateMapping,
      });
    }
    if (isOpenedByThisTrigger) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            FocusGuard,
            {
              ref: preFocusGuardRef,
              onFocus: handlePreFocusGuardFocus,
            },
            `${thisTriggerId}-pre-focus-guard`,
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            reactExports.Fragment,
            {
              children: element,
            },
            thisTriggerId,
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            FocusGuard,
            {
              ref: store.context.triggerFocusTargetRef,
              onFocus: handleFocusTargetFocus,
            },
            `${thisTriggerId}-post-focus-guard`,
          ),
        ],
      });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      reactExports.Fragment,
      {
        children: element,
      },
      thisTriggerId,
    );
  },
);
function useStickIfOpen(open, openReason) {
  const stickIfOpenTimeout = useTimeout();
  const [stickIfOpen, setStickIfOpen] = reactExports.useState(false);
  useIsoLayoutEffect(() => {
    if (open && openReason === "trigger-hover") {
      setStickIfOpen(true);
      stickIfOpenTimeout.start(PATIENT_CLICK_THRESHOLD, () => {
        setStickIfOpen(false);
      });
    } else if (!open) {
      stickIfOpenTimeout.clear();
      setStickIfOpen(false);
    }
  }, [open, openReason, stickIfOpenTimeout]);
  return stickIfOpen;
}
function useMenuParent() {
  const contextMenuContext = useContextMenuRootContext(true);
  const parentContext = useMenuRootContext(true);
  const menubarContext = useMenubarContext();
  const parent = reactExports.useMemo(() => {
    if (menubarContext) {
      return {
        type: "menubar",
        context: menubarContext,
      };
    }
    if (contextMenuContext && !parentContext) {
      return {
        type: "context-menu",
        context: contextMenuContext,
      };
    }
    return {
      type: void 0,
    };
  }, [contextMenuContext, parentContext, menubarContext]);
  return parent;
}
function r(e) {
  var t,
    f,
    n = "";
  if ("string" == typeof e || "number" == typeof e) n += e;
  else if ("object" == typeof e)
    if (Array.isArray(e)) {
      var o = e.length;
      for (t = 0; t < o; t++) e[t] && (f = r(e[t])) && (n && (n += " "), (n += f));
    } else for (f in e) e[f] && (n && (n += " "), (n += f));
  return n;
}
function clsx() {
  for (var e, t, f = 0, n = "", o = arguments.length; f < o; f++)
    (e = arguments[f]) && (t = r(e)) && (n && (n += " "), (n += t));
  return n;
}
const concatArrays = (array1, array2) => {
  const combinedArray = new Array(array1.length + array2.length);
  for (let i = 0; i < array1.length; i++) {
    combinedArray[i] = array1[i];
  }
  for (let i = 0; i < array2.length; i++) {
    combinedArray[array1.length + i] = array2[i];
  }
  return combinedArray;
};
const createClassValidatorObject = (classGroupId, validator) => ({
  classGroupId,
  validator,
});
const createClassPartObject = (
  nextPart = /* @__PURE__ */ new Map(),
  validators = null,
  classGroupId,
) => ({
  nextPart,
  validators,
  classGroupId,
});
const CLASS_PART_SEPARATOR = "-";
const EMPTY_CONFLICTS = [];
const ARBITRARY_PROPERTY_PREFIX = "arbitrary..";
const createClassGroupUtils = (config) => {
  const classMap = createClassMap(config);
  const { conflictingClassGroups, conflictingClassGroupModifiers } = config;
  const getClassGroupId = (className) => {
    if (className.startsWith("[") && className.endsWith("]")) {
      return getGroupIdForArbitraryProperty(className);
    }
    const classParts = className.split(CLASS_PART_SEPARATOR);
    const startIndex = classParts[0] === "" && classParts.length > 1 ? 1 : 0;
    return getGroupRecursive(classParts, startIndex, classMap);
  };
  const getConflictingClassGroupIds = (classGroupId, hasPostfixModifier) => {
    if (hasPostfixModifier) {
      const modifierConflicts = conflictingClassGroupModifiers[classGroupId];
      const baseConflicts = conflictingClassGroups[classGroupId];
      if (modifierConflicts) {
        if (baseConflicts) {
          return concatArrays(baseConflicts, modifierConflicts);
        }
        return modifierConflicts;
      }
      return baseConflicts || EMPTY_CONFLICTS;
    }
    return conflictingClassGroups[classGroupId] || EMPTY_CONFLICTS;
  };
  return {
    getClassGroupId,
    getConflictingClassGroupIds,
  };
};
const getGroupRecursive = (classParts, startIndex, classPartObject) => {
  const classPathsLength = classParts.length - startIndex;
  if (classPathsLength === 0) {
    return classPartObject.classGroupId;
  }
  const currentClassPart = classParts[startIndex];
  const nextClassPartObject = classPartObject.nextPart.get(currentClassPart);
  if (nextClassPartObject) {
    const result = getGroupRecursive(classParts, startIndex + 1, nextClassPartObject);
    if (result) return result;
  }
  const validators = classPartObject.validators;
  if (validators === null) {
    return void 0;
  }
  const classRest =
    startIndex === 0
      ? classParts.join(CLASS_PART_SEPARATOR)
      : classParts.slice(startIndex).join(CLASS_PART_SEPARATOR);
  const validatorsLength = validators.length;
  for (let i = 0; i < validatorsLength; i++) {
    const validatorObj = validators[i];
    if (validatorObj.validator(classRest)) {
      return validatorObj.classGroupId;
    }
  }
  return void 0;
};
const getGroupIdForArbitraryProperty = (className) =>
  className.slice(1, -1).indexOf(":") === -1
    ? void 0
    : (() => {
        const content = className.slice(1, -1);
        const colonIndex = content.indexOf(":");
        const property = content.slice(0, colonIndex);
        return property ? ARBITRARY_PROPERTY_PREFIX + property : void 0;
      })();
const createClassMap = (config) => {
  const { theme, classGroups } = config;
  return processClassGroups(classGroups, theme);
};
const processClassGroups = (classGroups, theme) => {
  const classMap = createClassPartObject();
  for (const classGroupId in classGroups) {
    const group = classGroups[classGroupId];
    processClassesRecursively(group, classMap, classGroupId, theme);
  }
  return classMap;
};
const processClassesRecursively = (classGroup, classPartObject, classGroupId, theme) => {
  const len = classGroup.length;
  for (let i = 0; i < len; i++) {
    const classDefinition = classGroup[i];
    processClassDefinition(classDefinition, classPartObject, classGroupId, theme);
  }
};
const processClassDefinition = (classDefinition, classPartObject, classGroupId, theme) => {
  if (typeof classDefinition === "string") {
    processStringDefinition(classDefinition, classPartObject, classGroupId);
    return;
  }
  if (typeof classDefinition === "function") {
    processFunctionDefinition(classDefinition, classPartObject, classGroupId, theme);
    return;
  }
  processObjectDefinition(classDefinition, classPartObject, classGroupId, theme);
};
const processStringDefinition = (classDefinition, classPartObject, classGroupId) => {
  const classPartObjectToEdit =
    classDefinition === "" ? classPartObject : getPart(classPartObject, classDefinition);
  classPartObjectToEdit.classGroupId = classGroupId;
};
const processFunctionDefinition = (classDefinition, classPartObject, classGroupId, theme) => {
  if (isThemeGetter(classDefinition)) {
    processClassesRecursively(classDefinition(theme), classPartObject, classGroupId, theme);
    return;
  }
  if (classPartObject.validators === null) {
    classPartObject.validators = [];
  }
  classPartObject.validators.push(createClassValidatorObject(classGroupId, classDefinition));
};
const processObjectDefinition = (classDefinition, classPartObject, classGroupId, theme) => {
  const entries = Object.entries(classDefinition);
  const len = entries.length;
  for (let i = 0; i < len; i++) {
    const [key, value] = entries[i];
    processClassesRecursively(value, getPart(classPartObject, key), classGroupId, theme);
  }
};
const getPart = (classPartObject, path) => {
  let current = classPartObject;
  const parts = path.split(CLASS_PART_SEPARATOR);
  const len = parts.length;
  for (let i = 0; i < len; i++) {
    const part = parts[i];
    let next = current.nextPart.get(part);
    if (!next) {
      next = createClassPartObject();
      current.nextPart.set(part, next);
    }
    current = next;
  }
  return current;
};
const isThemeGetter = (func) => "isThemeGetter" in func && func.isThemeGetter === true;
const createLruCache = (maxCacheSize) => {
  if (maxCacheSize < 1) {
    return {
      get: () => void 0,
      set: () => {},
    };
  }
  let cacheSize = 0;
  let cache = /* @__PURE__ */ Object.create(null);
  let previousCache = /* @__PURE__ */ Object.create(null);
  const update2 = (key, value) => {
    cache[key] = value;
    cacheSize++;
    if (cacheSize > maxCacheSize) {
      cacheSize = 0;
      previousCache = cache;
      cache = /* @__PURE__ */ Object.create(null);
    }
  };
  return {
    get(key) {
      let value = cache[key];
      if (value !== void 0) {
        return value;
      }
      if ((value = previousCache[key]) !== void 0) {
        update2(key, value);
        return value;
      }
    },
    set(key, value) {
      if (key in cache) {
        cache[key] = value;
      } else {
        update2(key, value);
      }
    },
  };
};
const IMPORTANT_MODIFIER = "!";
const MODIFIER_SEPARATOR = ":";
const EMPTY_MODIFIERS = [];
const createResultObject = (
  modifiers,
  hasImportantModifier,
  baseClassName,
  maybePostfixModifierPosition,
  isExternal,
) => ({
  modifiers,
  hasImportantModifier,
  baseClassName,
  maybePostfixModifierPosition,
  isExternal,
});
const createParseClassName = (config) => {
  const { prefix, experimentalParseClassName } = config;
  let parseClassName = (className) => {
    const modifiers = [];
    let bracketDepth = 0;
    let parenDepth = 0;
    let modifierStart = 0;
    let postfixModifierPosition;
    const len = className.length;
    for (let index2 = 0; index2 < len; index2++) {
      const currentCharacter = className[index2];
      if (bracketDepth === 0 && parenDepth === 0) {
        if (currentCharacter === MODIFIER_SEPARATOR) {
          modifiers.push(className.slice(modifierStart, index2));
          modifierStart = index2 + 1;
          continue;
        }
        if (currentCharacter === "/") {
          postfixModifierPosition = index2;
          continue;
        }
      }
      if (currentCharacter === "[") bracketDepth++;
      else if (currentCharacter === "]") bracketDepth--;
      else if (currentCharacter === "(") parenDepth++;
      else if (currentCharacter === ")") parenDepth--;
    }
    const baseClassNameWithImportantModifier =
      modifiers.length === 0 ? className : className.slice(modifierStart);
    let baseClassName = baseClassNameWithImportantModifier;
    let hasImportantModifier = false;
    if (baseClassNameWithImportantModifier.endsWith(IMPORTANT_MODIFIER)) {
      baseClassName = baseClassNameWithImportantModifier.slice(0, -1);
      hasImportantModifier = true;
    } else if (
      /**
       * In Tailwind CSS v3 the important modifier was at the start of the base class name. This is still supported for legacy reasons.
       * @see https://github.com/dcastil/tailwind-merge/issues/513#issuecomment-2614029864
       */
      baseClassNameWithImportantModifier.startsWith(IMPORTANT_MODIFIER)
    ) {
      baseClassName = baseClassNameWithImportantModifier.slice(1);
      hasImportantModifier = true;
    }
    const maybePostfixModifierPosition =
      postfixModifierPosition && postfixModifierPosition > modifierStart
        ? postfixModifierPosition - modifierStart
        : void 0;
    return createResultObject(
      modifiers,
      hasImportantModifier,
      baseClassName,
      maybePostfixModifierPosition,
    );
  };
  if (prefix) {
    const fullPrefix = prefix + MODIFIER_SEPARATOR;
    const parseClassNameOriginal = parseClassName;
    parseClassName = (className) =>
      className.startsWith(fullPrefix)
        ? parseClassNameOriginal(className.slice(fullPrefix.length))
        : createResultObject(EMPTY_MODIFIERS, false, className, void 0, true);
  }
  if (experimentalParseClassName) {
    const parseClassNameOriginal = parseClassName;
    parseClassName = (className) =>
      experimentalParseClassName({
        className,
        parseClassName: parseClassNameOriginal,
      });
  }
  return parseClassName;
};
const createSortModifiers = (config) => {
  const modifierWeights = /* @__PURE__ */ new Map();
  config.orderSensitiveModifiers.forEach((mod, index2) => {
    modifierWeights.set(mod, 1e6 + index2);
  });
  return (modifiers) => {
    const result = [];
    let currentSegment = [];
    for (let i = 0; i < modifiers.length; i++) {
      const modifier = modifiers[i];
      const isArbitrary = modifier[0] === "[";
      const isOrderSensitive = modifierWeights.has(modifier);
      if (isArbitrary || isOrderSensitive) {
        if (currentSegment.length > 0) {
          currentSegment.sort();
          result.push(...currentSegment);
          currentSegment = [];
        }
        result.push(modifier);
      } else {
        currentSegment.push(modifier);
      }
    }
    if (currentSegment.length > 0) {
      currentSegment.sort();
      result.push(...currentSegment);
    }
    return result;
  };
};
const createConfigUtils = (config) => ({
  cache: createLruCache(config.cacheSize),
  parseClassName: createParseClassName(config),
  sortModifiers: createSortModifiers(config),
  ...createClassGroupUtils(config),
});
const SPLIT_CLASSES_REGEX = /\s+/;
const mergeClassList = (classList, configUtils) => {
  const { parseClassName, getClassGroupId, getConflictingClassGroupIds, sortModifiers } =
    configUtils;
  const classGroupsInConflict = [];
  const classNames = classList.trim().split(SPLIT_CLASSES_REGEX);
  let result = "";
  for (let index2 = classNames.length - 1; index2 >= 0; index2 -= 1) {
    const originalClassName = classNames[index2];
    const {
      isExternal,
      modifiers,
      hasImportantModifier,
      baseClassName,
      maybePostfixModifierPosition,
    } = parseClassName(originalClassName);
    if (isExternal) {
      result = originalClassName + (result.length > 0 ? " " + result : result);
      continue;
    }
    let hasPostfixModifier = !!maybePostfixModifierPosition;
    let classGroupId = getClassGroupId(
      hasPostfixModifier ? baseClassName.substring(0, maybePostfixModifierPosition) : baseClassName,
    );
    if (!classGroupId) {
      if (!hasPostfixModifier) {
        result = originalClassName + (result.length > 0 ? " " + result : result);
        continue;
      }
      classGroupId = getClassGroupId(baseClassName);
      if (!classGroupId) {
        result = originalClassName + (result.length > 0 ? " " + result : result);
        continue;
      }
      hasPostfixModifier = false;
    }
    const variantModifier =
      modifiers.length === 0
        ? ""
        : modifiers.length === 1
          ? modifiers[0]
          : sortModifiers(modifiers).join(":");
    const modifierId = hasImportantModifier
      ? variantModifier + IMPORTANT_MODIFIER
      : variantModifier;
    const classId = modifierId + classGroupId;
    if (classGroupsInConflict.indexOf(classId) > -1) {
      continue;
    }
    classGroupsInConflict.push(classId);
    const conflictGroups = getConflictingClassGroupIds(classGroupId, hasPostfixModifier);
    for (let i = 0; i < conflictGroups.length; ++i) {
      const group = conflictGroups[i];
      classGroupsInConflict.push(modifierId + group);
    }
    result = originalClassName + (result.length > 0 ? " " + result : result);
  }
  return result;
};
const twJoin = (...classLists) => {
  let index2 = 0;
  let argument;
  let resolvedValue;
  let string = "";
  while (index2 < classLists.length) {
    if ((argument = classLists[index2++])) {
      if ((resolvedValue = toValue(argument))) {
        string && (string += " ");
        string += resolvedValue;
      }
    }
  }
  return string;
};
const toValue = (mix2) => {
  if (typeof mix2 === "string") {
    return mix2;
  }
  let resolvedValue;
  let string = "";
  for (let k = 0; k < mix2.length; k++) {
    if (mix2[k]) {
      if ((resolvedValue = toValue(mix2[k]))) {
        string && (string += " ");
        string += resolvedValue;
      }
    }
  }
  return string;
};
const createTailwindMerge = (createConfigFirst, ...createConfigRest) => {
  let configUtils;
  let cacheGet;
  let cacheSet;
  let functionToCall;
  const initTailwindMerge = (classList) => {
    const config = createConfigRest.reduce(
      (previousConfig, createConfigCurrent) => createConfigCurrent(previousConfig),
      createConfigFirst(),
    );
    configUtils = createConfigUtils(config);
    cacheGet = configUtils.cache.get;
    cacheSet = configUtils.cache.set;
    functionToCall = tailwindMerge;
    return tailwindMerge(classList);
  };
  const tailwindMerge = (classList) => {
    const cachedResult = cacheGet(classList);
    if (cachedResult) {
      return cachedResult;
    }
    const result = mergeClassList(classList, configUtils);
    cacheSet(classList, result);
    return result;
  };
  functionToCall = initTailwindMerge;
  return (...args) => functionToCall(twJoin(...args));
};
const fallbackThemeArr = [];
const fromTheme = (key) => {
  const themeGetter = (theme) => theme[key] || fallbackThemeArr;
  themeGetter.isThemeGetter = true;
  return themeGetter;
};
const arbitraryValueRegex = /^\[(?:(\w[\w-]*):)?(.+)\]$/i;
const arbitraryVariableRegex = /^\((?:(\w[\w-]*):)?(.+)\)$/i;
const fractionRegex = /^\d+\/\d+$/;
const tshirtUnitRegex = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/;
const lengthUnitRegex =
  /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/;
const colorFunctionRegex = /^(rgba?|hsla?|hwb|(ok)?(lab|lch)|color-mix)\(.+\)$/;
const shadowRegex = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
const imageRegex =
  /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/;
const isFraction = (value) => fractionRegex.test(value);
const isNumber = (value) => !!value && !Number.isNaN(Number(value));
const isInteger = (value) => !!value && Number.isInteger(Number(value));
const isPercent = (value) => value.endsWith("%") && isNumber(value.slice(0, -1));
const isTshirtSize = (value) => tshirtUnitRegex.test(value);
const isAny = () => true;
const isLengthOnly = (value) =>
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  lengthUnitRegex.test(value) && !colorFunctionRegex.test(value);
const isNever = () => false;
const isShadow = (value) => shadowRegex.test(value);
const isImage = (value) => imageRegex.test(value);
const isAnyNonArbitrary = (value) => !isArbitraryValue(value) && !isArbitraryVariable(value);
const isArbitrarySize = (value) => getIsArbitraryValue(value, isLabelSize, isNever);
const isArbitraryValue = (value) => arbitraryValueRegex.test(value);
const isArbitraryLength = (value) => getIsArbitraryValue(value, isLabelLength, isLengthOnly);
const isArbitraryNumber = (value) => getIsArbitraryValue(value, isLabelNumber, isNumber);
const isArbitraryPosition = (value) => getIsArbitraryValue(value, isLabelPosition, isNever);
const isArbitraryImage = (value) => getIsArbitraryValue(value, isLabelImage, isImage);
const isArbitraryShadow = (value) => getIsArbitraryValue(value, isLabelShadow, isShadow);
const isArbitraryVariable = (value) => arbitraryVariableRegex.test(value);
const isArbitraryVariableLength = (value) => getIsArbitraryVariable(value, isLabelLength);
const isArbitraryVariableFamilyName = (value) => getIsArbitraryVariable(value, isLabelFamilyName);
const isArbitraryVariablePosition = (value) => getIsArbitraryVariable(value, isLabelPosition);
const isArbitraryVariableSize = (value) => getIsArbitraryVariable(value, isLabelSize);
const isArbitraryVariableImage = (value) => getIsArbitraryVariable(value, isLabelImage);
const isArbitraryVariableShadow = (value) => getIsArbitraryVariable(value, isLabelShadow, true);
const getIsArbitraryValue = (value, testLabel, testValue) => {
  const result = arbitraryValueRegex.exec(value);
  if (result) {
    if (result[1]) {
      return testLabel(result[1]);
    }
    return testValue(result[2]);
  }
  return false;
};
const getIsArbitraryVariable = (value, testLabel, shouldMatchNoLabel = false) => {
  const result = arbitraryVariableRegex.exec(value);
  if (result) {
    if (result[1]) {
      return testLabel(result[1]);
    }
    return shouldMatchNoLabel;
  }
  return false;
};
const isLabelPosition = (label) => label === "position" || label === "percentage";
const isLabelImage = (label) => label === "image" || label === "url";
const isLabelSize = (label) => label === "length" || label === "size" || label === "bg-size";
const isLabelLength = (label) => label === "length";
const isLabelNumber = (label) => label === "number";
const isLabelFamilyName = (label) => label === "family-name";
const isLabelShadow = (label) => label === "shadow";
const getDefaultConfig = () => {
  const themeColor = fromTheme("color");
  const themeFont = fromTheme("font");
  const themeText = fromTheme("text");
  const themeFontWeight = fromTheme("font-weight");
  const themeTracking = fromTheme("tracking");
  const themeLeading = fromTheme("leading");
  const themeBreakpoint = fromTheme("breakpoint");
  const themeContainer = fromTheme("container");
  const themeSpacing = fromTheme("spacing");
  const themeRadius = fromTheme("radius");
  const themeShadow = fromTheme("shadow");
  const themeInsetShadow = fromTheme("inset-shadow");
  const themeTextShadow = fromTheme("text-shadow");
  const themeDropShadow = fromTheme("drop-shadow");
  const themeBlur = fromTheme("blur");
  const themePerspective = fromTheme("perspective");
  const themeAspect = fromTheme("aspect");
  const themeEase = fromTheme("ease");
  const themeAnimate = fromTheme("animate");
  const scaleBreak = () => [
    "auto",
    "avoid",
    "all",
    "avoid-page",
    "page",
    "left",
    "right",
    "column",
  ];
  const scalePosition = () => [
    "center",
    "top",
    "bottom",
    "left",
    "right",
    "top-left",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "left-top",
    "top-right",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "right-top",
    "bottom-right",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "right-bottom",
    "bottom-left",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "left-bottom",
  ];
  const scalePositionWithArbitrary = () => [
    ...scalePosition(),
    isArbitraryVariable,
    isArbitraryValue,
  ];
  const scaleOverflow = () => ["auto", "hidden", "clip", "visible", "scroll"];
  const scaleOverscroll = () => ["auto", "contain", "none"];
  const scaleUnambiguousSpacing = () => [isArbitraryVariable, isArbitraryValue, themeSpacing];
  const scaleInset = () => [isFraction, "full", "auto", ...scaleUnambiguousSpacing()];
  const scaleGridTemplateColsRows = () => [
    isInteger,
    "none",
    "subgrid",
    isArbitraryVariable,
    isArbitraryValue,
  ];
  const scaleGridColRowStartAndEnd = () => [
    "auto",
    {
      span: ["full", isInteger, isArbitraryVariable, isArbitraryValue],
    },
    isInteger,
    isArbitraryVariable,
    isArbitraryValue,
  ];
  const scaleGridColRowStartOrEnd = () => [
    isInteger,
    "auto",
    isArbitraryVariable,
    isArbitraryValue,
  ];
  const scaleGridAutoColsRows = () => [
    "auto",
    "min",
    "max",
    "fr",
    isArbitraryVariable,
    isArbitraryValue,
  ];
  const scaleAlignPrimaryAxis = () => [
    "start",
    "end",
    "center",
    "between",
    "around",
    "evenly",
    "stretch",
    "baseline",
    "center-safe",
    "end-safe",
  ];
  const scaleAlignSecondaryAxis = () => [
    "start",
    "end",
    "center",
    "stretch",
    "center-safe",
    "end-safe",
  ];
  const scaleMargin = () => ["auto", ...scaleUnambiguousSpacing()];
  const scaleSizing = () => [
    isFraction,
    "auto",
    "full",
    "dvw",
    "dvh",
    "lvw",
    "lvh",
    "svw",
    "svh",
    "min",
    "max",
    "fit",
    ...scaleUnambiguousSpacing(),
  ];
  const scaleColor = () => [themeColor, isArbitraryVariable, isArbitraryValue];
  const scaleBgPosition = () => [
    ...scalePosition(),
    isArbitraryVariablePosition,
    isArbitraryPosition,
    {
      position: [isArbitraryVariable, isArbitraryValue],
    },
  ];
  const scaleBgRepeat = () => [
    "no-repeat",
    {
      repeat: ["", "x", "y", "space", "round"],
    },
  ];
  const scaleBgSize = () => [
    "auto",
    "cover",
    "contain",
    isArbitraryVariableSize,
    isArbitrarySize,
    {
      size: [isArbitraryVariable, isArbitraryValue],
    },
  ];
  const scaleGradientStopPosition = () => [isPercent, isArbitraryVariableLength, isArbitraryLength];
  const scaleRadius = () => [
    // Deprecated since Tailwind CSS v4.0.0
    "",
    "none",
    "full",
    themeRadius,
    isArbitraryVariable,
    isArbitraryValue,
  ];
  const scaleBorderWidth = () => ["", isNumber, isArbitraryVariableLength, isArbitraryLength];
  const scaleLineStyle = () => ["solid", "dashed", "dotted", "double"];
  const scaleBlendMode = () => [
    "normal",
    "multiply",
    "screen",
    "overlay",
    "darken",
    "lighten",
    "color-dodge",
    "color-burn",
    "hard-light",
    "soft-light",
    "difference",
    "exclusion",
    "hue",
    "saturation",
    "color",
    "luminosity",
  ];
  const scaleMaskImagePosition = () => [
    isNumber,
    isPercent,
    isArbitraryVariablePosition,
    isArbitraryPosition,
  ];
  const scaleBlur = () => [
    // Deprecated since Tailwind CSS v4.0.0
    "",
    "none",
    themeBlur,
    isArbitraryVariable,
    isArbitraryValue,
  ];
  const scaleRotate = () => ["none", isNumber, isArbitraryVariable, isArbitraryValue];
  const scaleScale = () => ["none", isNumber, isArbitraryVariable, isArbitraryValue];
  const scaleSkew = () => [isNumber, isArbitraryVariable, isArbitraryValue];
  const scaleTranslate = () => [isFraction, "full", ...scaleUnambiguousSpacing()];
  return {
    cacheSize: 500,
    theme: {
      animate: ["spin", "ping", "pulse", "bounce"],
      aspect: ["video"],
      blur: [isTshirtSize],
      breakpoint: [isTshirtSize],
      color: [isAny],
      container: [isTshirtSize],
      "drop-shadow": [isTshirtSize],
      ease: ["in", "out", "in-out"],
      font: [isAnyNonArbitrary],
      "font-weight": [
        "thin",
        "extralight",
        "light",
        "normal",
        "medium",
        "semibold",
        "bold",
        "extrabold",
        "black",
      ],
      "inset-shadow": [isTshirtSize],
      leading: ["none", "tight", "snug", "normal", "relaxed", "loose"],
      perspective: ["dramatic", "near", "normal", "midrange", "distant", "none"],
      radius: [isTshirtSize],
      shadow: [isTshirtSize],
      spacing: ["px", isNumber],
      text: [isTshirtSize],
      "text-shadow": [isTshirtSize],
      tracking: ["tighter", "tight", "normal", "wide", "wider", "widest"],
    },
    classGroups: {
      // --------------
      // --- Layout ---
      // --------------
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [
        {
          aspect: [
            "auto",
            "square",
            isFraction,
            isArbitraryValue,
            isArbitraryVariable,
            themeAspect,
          ],
        },
      ],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       * @deprecated since Tailwind CSS v4.0.0
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [
        {
          columns: [isNumber, isArbitraryValue, isArbitraryVariable, themeContainer],
        },
      ],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [
        {
          "break-after": scaleBreak(),
        },
      ],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [
        {
          "break-before": scaleBreak(),
        },
      ],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [
        {
          "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"],
        },
      ],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [
        {
          "box-decoration": ["slice", "clone"],
        },
      ],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [
        {
          box: ["border", "content"],
        },
      ],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: [
        "block",
        "inline-block",
        "inline",
        "flex",
        "inline-flex",
        "table",
        "inline-table",
        "table-caption",
        "table-cell",
        "table-column",
        "table-column-group",
        "table-footer-group",
        "table-header-group",
        "table-row-group",
        "table-row",
        "flow-root",
        "grid",
        "inline-grid",
        "contents",
        "list-item",
        "hidden",
      ],
      /**
       * Screen Reader Only
       * @see https://tailwindcss.com/docs/display#screen-reader-only
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [
        {
          float: ["right", "left", "none", "start", "end"],
        },
      ],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [
        {
          clear: ["left", "right", "both", "none", "start", "end"],
        },
      ],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [
        {
          object: ["contain", "cover", "fill", "none", "scale-down"],
        },
      ],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [
        {
          object: scalePositionWithArbitrary(),
        },
      ],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [
        {
          overflow: scaleOverflow(),
        },
      ],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [
        {
          "overflow-x": scaleOverflow(),
        },
      ],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [
        {
          "overflow-y": scaleOverflow(),
        },
      ],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [
        {
          overscroll: scaleOverscroll(),
        },
      ],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [
        {
          "overscroll-x": scaleOverscroll(),
        },
      ],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [
        {
          "overscroll-y": scaleOverscroll(),
        },
      ],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [
        {
          inset: scaleInset(),
        },
      ],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [
        {
          "inset-x": scaleInset(),
        },
      ],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [
        {
          "inset-y": scaleInset(),
        },
      ],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [
        {
          start: scaleInset(),
        },
      ],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [
        {
          end: scaleInset(),
        },
      ],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [
        {
          top: scaleInset(),
        },
      ],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [
        {
          right: scaleInset(),
        },
      ],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [
        {
          bottom: scaleInset(),
        },
      ],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [
        {
          left: scaleInset(),
        },
      ],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [
        {
          z: [isInteger, "auto", isArbitraryVariable, isArbitraryValue],
        },
      ],
      // ------------------------
      // --- Flexbox and Grid ---
      // ------------------------
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [
        {
          basis: [isFraction, "full", "auto", themeContainer, ...scaleUnambiguousSpacing()],
        },
      ],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [
        {
          flex: ["row", "row-reverse", "col", "col-reverse"],
        },
      ],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [
        {
          flex: ["nowrap", "wrap", "wrap-reverse"],
        },
      ],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [
        {
          flex: [isNumber, isFraction, "auto", "initial", "none", isArbitraryValue],
        },
      ],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [
        {
          grow: ["", isNumber, isArbitraryVariable, isArbitraryValue],
        },
      ],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [
        {
          shrink: ["", isNumber, isArbitraryVariable, isArbitraryValue],
        },
      ],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [
        {
          order: [isInteger, "first", "last", "none", isArbitraryVariable, isArbitraryValue],
        },
      ],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [
        {
          "grid-cols": scaleGridTemplateColsRows(),
        },
      ],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [
        {
          col: scaleGridColRowStartAndEnd(),
        },
      ],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [
        {
          "col-start": scaleGridColRowStartOrEnd(),
        },
      ],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [
        {
          "col-end": scaleGridColRowStartOrEnd(),
        },
      ],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [
        {
          "grid-rows": scaleGridTemplateColsRows(),
        },
      ],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [
        {
          row: scaleGridColRowStartAndEnd(),
        },
      ],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [
        {
          "row-start": scaleGridColRowStartOrEnd(),
        },
      ],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [
        {
          "row-end": scaleGridColRowStartOrEnd(),
        },
      ],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [
        {
          "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"],
        },
      ],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [
        {
          "auto-cols": scaleGridAutoColsRows(),
        },
      ],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [
        {
          "auto-rows": scaleGridAutoColsRows(),
        },
      ],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [
        {
          gap: scaleUnambiguousSpacing(),
        },
      ],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [
        {
          "gap-x": scaleUnambiguousSpacing(),
        },
      ],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [
        {
          "gap-y": scaleUnambiguousSpacing(),
        },
      ],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [
        {
          justify: [...scaleAlignPrimaryAxis(), "normal"],
        },
      ],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [
        {
          "justify-items": [...scaleAlignSecondaryAxis(), "normal"],
        },
      ],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [
        {
          "justify-self": ["auto", ...scaleAlignSecondaryAxis()],
        },
      ],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [
        {
          content: ["normal", ...scaleAlignPrimaryAxis()],
        },
      ],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [
        {
          items: [
            ...scaleAlignSecondaryAxis(),
            {
              baseline: ["", "last"],
            },
          ],
        },
      ],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [
        {
          self: [
            "auto",
            ...scaleAlignSecondaryAxis(),
            {
              baseline: ["", "last"],
            },
          ],
        },
      ],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [
        {
          "place-content": scaleAlignPrimaryAxis(),
        },
      ],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [
        {
          "place-items": [...scaleAlignSecondaryAxis(), "baseline"],
        },
      ],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [
        {
          "place-self": ["auto", ...scaleAlignSecondaryAxis()],
        },
      ],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [
        {
          p: scaleUnambiguousSpacing(),
        },
      ],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [
        {
          px: scaleUnambiguousSpacing(),
        },
      ],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [
        {
          py: scaleUnambiguousSpacing(),
        },
      ],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [
        {
          ps: scaleUnambiguousSpacing(),
        },
      ],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [
        {
          pe: scaleUnambiguousSpacing(),
        },
      ],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [
        {
          pt: scaleUnambiguousSpacing(),
        },
      ],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [
        {
          pr: scaleUnambiguousSpacing(),
        },
      ],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [
        {
          pb: scaleUnambiguousSpacing(),
        },
      ],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [
        {
          pl: scaleUnambiguousSpacing(),
        },
      ],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [
        {
          m: scaleMargin(),
        },
      ],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [
        {
          mx: scaleMargin(),
        },
      ],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [
        {
          my: scaleMargin(),
        },
      ],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [
        {
          ms: scaleMargin(),
        },
      ],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [
        {
          me: scaleMargin(),
        },
      ],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [
        {
          mt: scaleMargin(),
        },
      ],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [
        {
          mr: scaleMargin(),
        },
      ],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [
        {
          mb: scaleMargin(),
        },
      ],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [
        {
          ml: scaleMargin(),
        },
      ],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-x": [
        {
          "space-x": scaleUnambiguousSpacing(),
        },
      ],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-y": [
        {
          "space-y": scaleUnambiguousSpacing(),
        },
      ],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-y-reverse": ["space-y-reverse"],
      // --------------
      // --- Sizing ---
      // --------------
      /**
       * Size
       * @see https://tailwindcss.com/docs/width#setting-both-width-and-height
       */
      size: [
        {
          size: scaleSizing(),
        },
      ],
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [
        {
          w: [themeContainer, "screen", ...scaleSizing()],
        },
      ],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [
        {
          "min-w": [
            themeContainer,
            "screen",
            /** Deprecated. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
            "none",
            ...scaleSizing(),
          ],
        },
      ],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [
        {
          "max-w": [
            themeContainer,
            "screen",
            "none",
            /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
            "prose",
            /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
            {
              screen: [themeBreakpoint],
            },
            ...scaleSizing(),
          ],
        },
      ],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [
        {
          h: ["screen", "lh", ...scaleSizing()],
        },
      ],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [
        {
          "min-h": ["screen", "lh", "none", ...scaleSizing()],
        },
      ],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [
        {
          "max-h": ["screen", "lh", ...scaleSizing()],
        },
      ],
      // ------------------
      // --- Typography ---
      // ------------------
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [
        {
          text: ["base", themeText, isArbitraryVariableLength, isArbitraryLength],
        },
      ],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [
        {
          font: [themeFontWeight, isArbitraryVariable, isArbitraryNumber],
        },
      ],
      /**
       * Font Stretch
       * @see https://tailwindcss.com/docs/font-stretch
       */
      "font-stretch": [
        {
          "font-stretch": [
            "ultra-condensed",
            "extra-condensed",
            "condensed",
            "semi-condensed",
            "normal",
            "semi-expanded",
            "expanded",
            "extra-expanded",
            "ultra-expanded",
            isPercent,
            isArbitraryValue,
          ],
        },
      ],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [
        {
          font: [isArbitraryVariableFamilyName, isArbitraryValue, themeFont],
        },
      ],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [
        {
          tracking: [themeTracking, isArbitraryVariable, isArbitraryValue],
        },
      ],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [
        {
          "line-clamp": [isNumber, "none", isArbitraryVariable, isArbitraryNumber],
        },
      ],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [
        {
          leading: [
            /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
            themeLeading,
            ...scaleUnambiguousSpacing(),
          ],
        },
      ],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [
        {
          "list-image": ["none", isArbitraryVariable, isArbitraryValue],
        },
      ],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [
        {
          list: ["inside", "outside"],
        },
      ],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [
        {
          list: ["disc", "decimal", "none", isArbitraryVariable, isArbitraryValue],
        },
      ],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [
        {
          text: ["left", "center", "right", "justify", "start", "end"],
        },
      ],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://v3.tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [
        {
          placeholder: scaleColor(),
        },
      ],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [
        {
          text: scaleColor(),
        },
      ],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [
        {
          decoration: [...scaleLineStyle(), "wavy"],
        },
      ],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [
        {
          decoration: [isNumber, "from-font", "auto", isArbitraryVariable, isArbitraryLength],
        },
      ],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [
        {
          decoration: scaleColor(),
        },
      ],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [
        {
          "underline-offset": [isNumber, "auto", isArbitraryVariable, isArbitraryValue],
        },
      ],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [
        {
          text: ["wrap", "nowrap", "balance", "pretty"],
        },
      ],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [
        {
          indent: scaleUnambiguousSpacing(),
        },
      ],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [
        {
          align: [
            "baseline",
            "top",
            "middle",
            "bottom",
            "text-top",
            "text-bottom",
            "sub",
            "super",
            isArbitraryVariable,
            isArbitraryValue,
          ],
        },
      ],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [
        {
          whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"],
        },
      ],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [
        {
          break: ["normal", "words", "all", "keep"],
        },
      ],
      /**
       * Overflow Wrap
       * @see https://tailwindcss.com/docs/overflow-wrap
       */
      wrap: [
        {
          wrap: ["break-word", "anywhere", "normal"],
        },
      ],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [
        {
          hyphens: ["none", "manual", "auto"],
        },
      ],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [
        {
          content: ["none", isArbitraryVariable, isArbitraryValue],
        },
      ],
      // -------------------
      // --- Backgrounds ---
      // -------------------
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [
        {
          bg: ["fixed", "local", "scroll"],
        },
      ],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [
        {
          "bg-clip": ["border", "padding", "content", "text"],
        },
      ],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [
        {
          "bg-origin": ["border", "padding", "content"],
        },
      ],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [
        {
          bg: scaleBgPosition(),
        },
      ],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [
        {
          bg: scaleBgRepeat(),
        },
      ],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [
        {
          bg: scaleBgSize(),
        },
      ],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [
        {
          bg: [
            "none",
            {
              linear: [
                {
                  to: ["t", "tr", "r", "br", "b", "bl", "l", "tl"],
                },
                isInteger,
                isArbitraryVariable,
                isArbitraryValue,
              ],
              radial: ["", isArbitraryVariable, isArbitraryValue],
              conic: [isInteger, isArbitraryVariable, isArbitraryValue],
            },
            isArbitraryVariableImage,
            isArbitraryImage,
          ],
        },
      ],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [
        {
          bg: scaleColor(),
        },
      ],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [
        {
          from: scaleGradientStopPosition(),
        },
      ],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [
        {
          via: scaleGradientStopPosition(),
        },
      ],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [
        {
          to: scaleGradientStopPosition(),
        },
      ],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [
        {
          from: scaleColor(),
        },
      ],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [
        {
          via: scaleColor(),
        },
      ],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [
        {
          to: scaleColor(),
        },
      ],
      // ---------------
      // --- Borders ---
      // ---------------
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [
        {
          rounded: scaleRadius(),
        },
      ],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [
        {
          "rounded-s": scaleRadius(),
        },
      ],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [
        {
          "rounded-e": scaleRadius(),
        },
      ],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [
        {
          "rounded-t": scaleRadius(),
        },
      ],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [
        {
          "rounded-r": scaleRadius(),
        },
      ],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [
        {
          "rounded-b": scaleRadius(),
        },
      ],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [
        {
          "rounded-l": scaleRadius(),
        },
      ],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [
        {
          "rounded-ss": scaleRadius(),
        },
      ],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [
        {
          "rounded-se": scaleRadius(),
        },
      ],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [
        {
          "rounded-ee": scaleRadius(),
        },
      ],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [
        {
          "rounded-es": scaleRadius(),
        },
      ],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [
        {
          "rounded-tl": scaleRadius(),
        },
      ],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [
        {
          "rounded-tr": scaleRadius(),
        },
      ],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [
        {
          "rounded-br": scaleRadius(),
        },
      ],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [
        {
          "rounded-bl": scaleRadius(),
        },
      ],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [
        {
          border: scaleBorderWidth(),
        },
      ],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [
        {
          "border-x": scaleBorderWidth(),
        },
      ],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [
        {
          "border-y": scaleBorderWidth(),
        },
      ],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [
        {
          "border-s": scaleBorderWidth(),
        },
      ],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [
        {
          "border-e": scaleBorderWidth(),
        },
      ],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [
        {
          "border-t": scaleBorderWidth(),
        },
      ],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [
        {
          "border-r": scaleBorderWidth(),
        },
      ],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [
        {
          "border-b": scaleBorderWidth(),
        },
      ],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [
        {
          "border-l": scaleBorderWidth(),
        },
      ],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-x": [
        {
          "divide-x": scaleBorderWidth(),
        },
      ],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-y": [
        {
          "divide-y": scaleBorderWidth(),
        },
      ],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [
        {
          border: [...scaleLineStyle(), "hidden", "none"],
        },
      ],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/border-style#setting-the-divider-style
       */
      "divide-style": [
        {
          divide: [...scaleLineStyle(), "hidden", "none"],
        },
      ],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [
        {
          border: scaleColor(),
        },
      ],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [
        {
          "border-x": scaleColor(),
        },
      ],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [
        {
          "border-y": scaleColor(),
        },
      ],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [
        {
          "border-s": scaleColor(),
        },
      ],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [
        {
          "border-e": scaleColor(),
        },
      ],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [
        {
          "border-t": scaleColor(),
        },
      ],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [
        {
          "border-r": scaleColor(),
        },
      ],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [
        {
          "border-b": scaleColor(),
        },
      ],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [
        {
          "border-l": scaleColor(),
        },
      ],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [
        {
          divide: scaleColor(),
        },
      ],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [
        {
          outline: [...scaleLineStyle(), "none", "hidden"],
        },
      ],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [
        {
          "outline-offset": [isNumber, isArbitraryVariable, isArbitraryValue],
        },
      ],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [
        {
          outline: ["", isNumber, isArbitraryVariableLength, isArbitraryLength],
        },
      ],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [
        {
          outline: scaleColor(),
        },
      ],
      // ---------------
      // --- Effects ---
      // ---------------
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [
        {
          shadow: [
            // Deprecated since Tailwind CSS v4.0.0
            "",
            "none",
            themeShadow,
            isArbitraryVariableShadow,
            isArbitraryShadow,
          ],
        },
      ],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-shadow-color
       */
      "shadow-color": [
        {
          shadow: scaleColor(),
        },
      ],
      /**
       * Inset Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-shadow
       */
      "inset-shadow": [
        {
          "inset-shadow": ["none", themeInsetShadow, isArbitraryVariableShadow, isArbitraryShadow],
        },
      ],
      /**
       * Inset Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-shadow-color
       */
      "inset-shadow-color": [
        {
          "inset-shadow": scaleColor(),
        },
      ],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/box-shadow#adding-a-ring
       */
      "ring-w": [
        {
          ring: scaleBorderWidth(),
        },
      ],
      /**
       * Ring Width Inset
       * @see https://v3.tailwindcss.com/docs/ring-width#inset-rings
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-ring-color
       */
      "ring-color": [
        {
          ring: scaleColor(),
        },
      ],
      /**
       * Ring Offset Width
       * @see https://v3.tailwindcss.com/docs/ring-offset-width
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-offset-w": [
        {
          "ring-offset": [isNumber, isArbitraryLength],
        },
      ],
      /**
       * Ring Offset Color
       * @see https://v3.tailwindcss.com/docs/ring-offset-color
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-offset-color": [
        {
          "ring-offset": scaleColor(),
        },
      ],
      /**
       * Inset Ring Width
       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-ring
       */
      "inset-ring-w": [
        {
          "inset-ring": scaleBorderWidth(),
        },
      ],
      /**
       * Inset Ring Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-ring-color
       */
      "inset-ring-color": [
        {
          "inset-ring": scaleColor(),
        },
      ],
      /**
       * Text Shadow
       * @see https://tailwindcss.com/docs/text-shadow
       */
      "text-shadow": [
        {
          "text-shadow": ["none", themeTextShadow, isArbitraryVariableShadow, isArbitraryShadow],
        },
      ],
      /**
       * Text Shadow Color
       * @see https://tailwindcss.com/docs/text-shadow#setting-the-shadow-color
       */
      "text-shadow-color": [
        {
          "text-shadow": scaleColor(),
        },
      ],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [
        {
          opacity: [isNumber, isArbitraryVariable, isArbitraryValue],
        },
      ],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [
        {
          "mix-blend": [...scaleBlendMode(), "plus-darker", "plus-lighter"],
        },
      ],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [
        {
          "bg-blend": scaleBlendMode(),
        },
      ],
      /**
       * Mask Clip
       * @see https://tailwindcss.com/docs/mask-clip
       */
      "mask-clip": [
        {
          "mask-clip": ["border", "padding", "content", "fill", "stroke", "view"],
        },
        "mask-no-clip",
      ],
      /**
       * Mask Composite
       * @see https://tailwindcss.com/docs/mask-composite
       */
      "mask-composite": [
        {
          mask: ["add", "subtract", "intersect", "exclude"],
        },
      ],
      /**
       * Mask Image
       * @see https://tailwindcss.com/docs/mask-image
       */
      "mask-image-linear-pos": [
        {
          "mask-linear": [isNumber],
        },
      ],
      "mask-image-linear-from-pos": [
        {
          "mask-linear-from": scaleMaskImagePosition(),
        },
      ],
      "mask-image-linear-to-pos": [
        {
          "mask-linear-to": scaleMaskImagePosition(),
        },
      ],
      "mask-image-linear-from-color": [
        {
          "mask-linear-from": scaleColor(),
        },
      ],
      "mask-image-linear-to-color": [
        {
          "mask-linear-to": scaleColor(),
        },
      ],
      "mask-image-t-from-pos": [
        {
          "mask-t-from": scaleMaskImagePosition(),
        },
      ],
      "mask-image-t-to-pos": [
        {
          "mask-t-to": scaleMaskImagePosition(),
        },
      ],
      "mask-image-t-from-color": [
        {
          "mask-t-from": scaleColor(),
        },
      ],
      "mask-image-t-to-color": [
        {
          "mask-t-to": scaleColor(),
        },
      ],
      "mask-image-r-from-pos": [
        {
          "mask-r-from": scaleMaskImagePosition(),
        },
      ],
      "mask-image-r-to-pos": [
        {
          "mask-r-to": scaleMaskImagePosition(),
        },
      ],
      "mask-image-r-from-color": [
        {
          "mask-r-from": scaleColor(),
        },
      ],
      "mask-image-r-to-color": [
        {
          "mask-r-to": scaleColor(),
        },
      ],
      "mask-image-b-from-pos": [
        {
          "mask-b-from": scaleMaskImagePosition(),
        },
      ],
      "mask-image-b-to-pos": [
        {
          "mask-b-to": scaleMaskImagePosition(),
        },
      ],
      "mask-image-b-from-color": [
        {
          "mask-b-from": scaleColor(),
        },
      ],
      "mask-image-b-to-color": [
        {
          "mask-b-to": scaleColor(),
        },
      ],
      "mask-image-l-from-pos": [
        {
          "mask-l-from": scaleMaskImagePosition(),
        },
      ],
      "mask-image-l-to-pos": [
        {
          "mask-l-to": scaleMaskImagePosition(),
        },
      ],
      "mask-image-l-from-color": [
        {
          "mask-l-from": scaleColor(),
        },
      ],
      "mask-image-l-to-color": [
        {
          "mask-l-to": scaleColor(),
        },
      ],
      "mask-image-x-from-pos": [
        {
          "mask-x-from": scaleMaskImagePosition(),
        },
      ],
      "mask-image-x-to-pos": [
        {
          "mask-x-to": scaleMaskImagePosition(),
        },
      ],
      "mask-image-x-from-color": [
        {
          "mask-x-from": scaleColor(),
        },
      ],
      "mask-image-x-to-color": [
        {
          "mask-x-to": scaleColor(),
        },
      ],
      "mask-image-y-from-pos": [
        {
          "mask-y-from": scaleMaskImagePosition(),
        },
      ],
      "mask-image-y-to-pos": [
        {
          "mask-y-to": scaleMaskImagePosition(),
        },
      ],
      "mask-image-y-from-color": [
        {
          "mask-y-from": scaleColor(),
        },
      ],
      "mask-image-y-to-color": [
        {
          "mask-y-to": scaleColor(),
        },
      ],
      "mask-image-radial": [
        {
          "mask-radial": [isArbitraryVariable, isArbitraryValue],
        },
      ],
      "mask-image-radial-from-pos": [
        {
          "mask-radial-from": scaleMaskImagePosition(),
        },
      ],
      "mask-image-radial-to-pos": [
        {
          "mask-radial-to": scaleMaskImagePosition(),
        },
      ],
      "mask-image-radial-from-color": [
        {
          "mask-radial-from": scaleColor(),
        },
      ],
      "mask-image-radial-to-color": [
        {
          "mask-radial-to": scaleColor(),
        },
      ],
      "mask-image-radial-shape": [
        {
          "mask-radial": ["circle", "ellipse"],
        },
      ],
      "mask-image-radial-size": [
        {
          "mask-radial": [
            {
              closest: ["side", "corner"],
              farthest: ["side", "corner"],
            },
          ],
        },
      ],
      "mask-image-radial-pos": [
        {
          "mask-radial-at": scalePosition(),
        },
      ],
      "mask-image-conic-pos": [
        {
          "mask-conic": [isNumber],
        },
      ],
      "mask-image-conic-from-pos": [
        {
          "mask-conic-from": scaleMaskImagePosition(),
        },
      ],
      "mask-image-conic-to-pos": [
        {
          "mask-conic-to": scaleMaskImagePosition(),
        },
      ],
      "mask-image-conic-from-color": [
        {
          "mask-conic-from": scaleColor(),
        },
      ],
      "mask-image-conic-to-color": [
        {
          "mask-conic-to": scaleColor(),
        },
      ],
      /**
       * Mask Mode
       * @see https://tailwindcss.com/docs/mask-mode
       */
      "mask-mode": [
        {
          mask: ["alpha", "luminance", "match"],
        },
      ],
      /**
       * Mask Origin
       * @see https://tailwindcss.com/docs/mask-origin
       */
      "mask-origin": [
        {
          "mask-origin": ["border", "padding", "content", "fill", "stroke", "view"],
        },
      ],
      /**
       * Mask Position
       * @see https://tailwindcss.com/docs/mask-position
       */
      "mask-position": [
        {
          mask: scaleBgPosition(),
        },
      ],
      /**
       * Mask Repeat
       * @see https://tailwindcss.com/docs/mask-repeat
       */
      "mask-repeat": [
        {
          mask: scaleBgRepeat(),
        },
      ],
      /**
       * Mask Size
       * @see https://tailwindcss.com/docs/mask-size
       */
      "mask-size": [
        {
          mask: scaleBgSize(),
        },
      ],
      /**
       * Mask Type
       * @see https://tailwindcss.com/docs/mask-type
       */
      "mask-type": [
        {
          "mask-type": ["alpha", "luminance"],
        },
      ],
      /**
       * Mask Image
       * @see https://tailwindcss.com/docs/mask-image
       */
      "mask-image": [
        {
          mask: ["none", isArbitraryVariable, isArbitraryValue],
        },
      ],
      // ---------------
      // --- Filters ---
      // ---------------
      /**
       * Filter
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [
        {
          filter: [
            // Deprecated since Tailwind CSS v3.0.0
            "",
            "none",
            isArbitraryVariable,
            isArbitraryValue,
          ],
        },
      ],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [
        {
          blur: scaleBlur(),
        },
      ],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [
        {
          brightness: [isNumber, isArbitraryVariable, isArbitraryValue],
        },
      ],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [
        {
          contrast: [isNumber, isArbitraryVariable, isArbitraryValue],
        },
      ],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [
        {
          "drop-shadow": [
            // Deprecated since Tailwind CSS v4.0.0
            "",
            "none",
            themeDropShadow,
            isArbitraryVariableShadow,
            isArbitraryShadow,
          ],
        },
      ],
      /**
       * Drop Shadow Color
       * @see https://tailwindcss.com/docs/filter-drop-shadow#setting-the-shadow-color
       */
      "drop-shadow-color": [
        {
          "drop-shadow": scaleColor(),
        },
      ],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [
        {
          grayscale: ["", isNumber, isArbitraryVariable, isArbitraryValue],
        },
      ],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [
        {
          "hue-rotate": [isNumber, isArbitraryVariable, isArbitraryValue],
        },
      ],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [
        {
          invert: ["", isNumber, isArbitraryVariable, isArbitraryValue],
        },
      ],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [
        {
          saturate: [isNumber, isArbitraryVariable, isArbitraryValue],
        },
      ],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [
        {
          sepia: ["", isNumber, isArbitraryVariable, isArbitraryValue],
        },
      ],
      /**
       * Backdrop Filter
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [
        {
          "backdrop-filter": [
            // Deprecated since Tailwind CSS v3.0.0
            "",
            "none",
            isArbitraryVariable,
            isArbitraryValue,
          ],
        },
      ],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [
        {
          "backdrop-blur": scaleBlur(),
        },
      ],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [
        {
          "backdrop-brightness": [isNumber, isArbitraryVariable, isArbitraryValue],
        },
      ],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [
        {
          "backdrop-contrast": [isNumber, isArbitraryVariable, isArbitraryValue],
        },
      ],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [
        {
          "backdrop-grayscale": ["", isNumber, isArbitraryVariable, isArbitraryValue],
        },
      ],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [
        {
          "backdrop-hue-rotate": [isNumber, isArbitraryVariable, isArbitraryValue],
        },
      ],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [
        {
          "backdrop-invert": ["", isNumber, isArbitraryVariable, isArbitraryValue],
        },
      ],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [
        {
          "backdrop-opacity": [isNumber, isArbitraryVariable, isArbitraryValue],
        },
      ],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [
        {
          "backdrop-saturate": [isNumber, isArbitraryVariable, isArbitraryValue],
        },
      ],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [
        {
          "backdrop-sepia": ["", isNumber, isArbitraryVariable, isArbitraryValue],
        },
      ],
      // --------------
      // --- Tables ---
      // --------------
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [
        {
          border: ["collapse", "separate"],
        },
      ],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [
        {
          "border-spacing": scaleUnambiguousSpacing(),
        },
      ],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [
        {
          "border-spacing-x": scaleUnambiguousSpacing(),
        },
      ],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [
        {
          "border-spacing-y": scaleUnambiguousSpacing(),
        },
      ],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [
        {
          table: ["auto", "fixed"],
        },
      ],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [
        {
          caption: ["top", "bottom"],
        },
      ],
      // ---------------------------------
      // --- Transitions and Animation ---
      // ---------------------------------
      /**
       * Transition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [
        {
          transition: [
            "",
            "all",
            "colors",
            "opacity",
            "shadow",
            "transform",
            "none",
            isArbitraryVariable,
            isArbitraryValue,
          ],
        },
      ],
      /**
       * Transition Behavior
       * @see https://tailwindcss.com/docs/transition-behavior
       */
      "transition-behavior": [
        {
          transition: ["normal", "discrete"],
        },
      ],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [
        {
          duration: [isNumber, "initial", isArbitraryVariable, isArbitraryValue],
        },
      ],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [
        {
          ease: ["linear", "initial", themeEase, isArbitraryVariable, isArbitraryValue],
        },
      ],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [
        {
          delay: [isNumber, isArbitraryVariable, isArbitraryValue],
        },
      ],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [
        {
          animate: ["none", themeAnimate, isArbitraryVariable, isArbitraryValue],
        },
      ],
      // ------------------
      // --- Transforms ---
      // ------------------
      /**
       * Backface Visibility
       * @see https://tailwindcss.com/docs/backface-visibility
       */
      backface: [
        {
          backface: ["hidden", "visible"],
        },
      ],
      /**
       * Perspective
       * @see https://tailwindcss.com/docs/perspective
       */
      perspective: [
        {
          perspective: [themePerspective, isArbitraryVariable, isArbitraryValue],
        },
      ],
      /**
       * Perspective Origin
       * @see https://tailwindcss.com/docs/perspective-origin
       */
      "perspective-origin": [
        {
          "perspective-origin": scalePositionWithArbitrary(),
        },
      ],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [
        {
          rotate: scaleRotate(),
        },
      ],
      /**
       * Rotate X
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-x": [
        {
          "rotate-x": scaleRotate(),
        },
      ],
      /**
       * Rotate Y
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-y": [
        {
          "rotate-y": scaleRotate(),
        },
      ],
      /**
       * Rotate Z
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-z": [
        {
          "rotate-z": scaleRotate(),
        },
      ],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [
        {
          scale: scaleScale(),
        },
      ],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [
        {
          "scale-x": scaleScale(),
        },
      ],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [
        {
          "scale-y": scaleScale(),
        },
      ],
      /**
       * Scale Z
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-z": [
        {
          "scale-z": scaleScale(),
        },
      ],
      /**
       * Scale 3D
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-3d": ["scale-3d"],
      /**
       * Skew
       * @see https://tailwindcss.com/docs/skew
       */
      skew: [
        {
          skew: scaleSkew(),
        },
      ],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [
        {
          "skew-x": scaleSkew(),
        },
      ],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [
        {
          "skew-y": scaleSkew(),
        },
      ],
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [
        {
          transform: [isArbitraryVariable, isArbitraryValue, "", "none", "gpu", "cpu"],
        },
      ],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [
        {
          origin: scalePositionWithArbitrary(),
        },
      ],
      /**
       * Transform Style
       * @see https://tailwindcss.com/docs/transform-style
       */
      "transform-style": [
        {
          transform: ["3d", "flat"],
        },
      ],
      /**
       * Translate
       * @see https://tailwindcss.com/docs/translate
       */
      translate: [
        {
          translate: scaleTranslate(),
        },
      ],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [
        {
          "translate-x": scaleTranslate(),
        },
      ],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [
        {
          "translate-y": scaleTranslate(),
        },
      ],
      /**
       * Translate Z
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-z": [
        {
          "translate-z": scaleTranslate(),
        },
      ],
      /**
       * Translate None
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-none": ["translate-none"],
      // ---------------------
      // --- Interactivity ---
      // ---------------------
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [
        {
          accent: scaleColor(),
        },
      ],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [
        {
          appearance: ["none", "auto"],
        },
      ],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [
        {
          caret: scaleColor(),
        },
      ],
      /**
       * Color Scheme
       * @see https://tailwindcss.com/docs/color-scheme
       */
      "color-scheme": [
        {
          scheme: ["normal", "dark", "light", "light-dark", "only-dark", "only-light"],
        },
      ],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [
        {
          cursor: [
            "auto",
            "default",
            "pointer",
            "wait",
            "text",
            "move",
            "help",
            "not-allowed",
            "none",
            "context-menu",
            "progress",
            "cell",
            "crosshair",
            "vertical-text",
            "alias",
            "copy",
            "no-drop",
            "grab",
            "grabbing",
            "all-scroll",
            "col-resize",
            "row-resize",
            "n-resize",
            "e-resize",
            "s-resize",
            "w-resize",
            "ne-resize",
            "nw-resize",
            "se-resize",
            "sw-resize",
            "ew-resize",
            "ns-resize",
            "nesw-resize",
            "nwse-resize",
            "zoom-in",
            "zoom-out",
            isArbitraryVariable,
            isArbitraryValue,
          ],
        },
      ],
      /**
       * Field Sizing
       * @see https://tailwindcss.com/docs/field-sizing
       */
      "field-sizing": [
        {
          "field-sizing": ["fixed", "content"],
        },
      ],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [
        {
          "pointer-events": ["auto", "none"],
        },
      ],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [
        {
          resize: ["none", "", "y", "x"],
        },
      ],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [
        {
          scroll: ["auto", "smooth"],
        },
      ],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [
        {
          "scroll-m": scaleUnambiguousSpacing(),
        },
      ],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [
        {
          "scroll-mx": scaleUnambiguousSpacing(),
        },
      ],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [
        {
          "scroll-my": scaleUnambiguousSpacing(),
        },
      ],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [
        {
          "scroll-ms": scaleUnambiguousSpacing(),
        },
      ],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [
        {
          "scroll-me": scaleUnambiguousSpacing(),
        },
      ],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [
        {
          "scroll-mt": scaleUnambiguousSpacing(),
        },
      ],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [
        {
          "scroll-mr": scaleUnambiguousSpacing(),
        },
      ],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [
        {
          "scroll-mb": scaleUnambiguousSpacing(),
        },
      ],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [
        {
          "scroll-ml": scaleUnambiguousSpacing(),
        },
      ],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [
        {
          "scroll-p": scaleUnambiguousSpacing(),
        },
      ],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [
        {
          "scroll-px": scaleUnambiguousSpacing(),
        },
      ],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [
        {
          "scroll-py": scaleUnambiguousSpacing(),
        },
      ],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [
        {
          "scroll-ps": scaleUnambiguousSpacing(),
        },
      ],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [
        {
          "scroll-pe": scaleUnambiguousSpacing(),
        },
      ],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [
        {
          "scroll-pt": scaleUnambiguousSpacing(),
        },
      ],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [
        {
          "scroll-pr": scaleUnambiguousSpacing(),
        },
      ],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [
        {
          "scroll-pb": scaleUnambiguousSpacing(),
        },
      ],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [
        {
          "scroll-pl": scaleUnambiguousSpacing(),
        },
      ],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [
        {
          snap: ["start", "end", "center", "align-none"],
        },
      ],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [
        {
          snap: ["normal", "always"],
        },
      ],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [
        {
          snap: ["none", "x", "y", "both"],
        },
      ],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [
        {
          snap: ["mandatory", "proximity"],
        },
      ],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [
        {
          touch: ["auto", "none", "manipulation"],
        },
      ],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [
        {
          "touch-pan": ["x", "left", "right"],
        },
      ],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [
        {
          "touch-pan": ["y", "up", "down"],
        },
      ],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [
        {
          select: ["none", "text", "all", "auto"],
        },
      ],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [
        {
          "will-change": [
            "auto",
            "scroll",
            "contents",
            "transform",
            isArbitraryVariable,
            isArbitraryValue,
          ],
        },
      ],
      // -----------
      // --- SVG ---
      // -----------
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [
        {
          fill: ["none", ...scaleColor()],
        },
      ],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [
        {
          stroke: [isNumber, isArbitraryVariableLength, isArbitraryLength, isArbitraryNumber],
        },
      ],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [
        {
          stroke: ["none", ...scaleColor()],
        },
      ],
      // ---------------------
      // --- Accessibility ---
      // ---------------------
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [
        {
          "forced-color-adjust": ["auto", "none"],
        },
      ],
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": [
        "fvn-ordinal",
        "fvn-slashed-zero",
        "fvn-figure",
        "fvn-spacing",
        "fvn-fraction",
      ],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: [
        "rounded-s",
        "rounded-e",
        "rounded-t",
        "rounded-r",
        "rounded-b",
        "rounded-l",
        "rounded-ss",
        "rounded-se",
        "rounded-ee",
        "rounded-es",
        "rounded-tl",
        "rounded-tr",
        "rounded-br",
        "rounded-bl",
      ],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": [
        "border-w-x",
        "border-w-y",
        "border-w-s",
        "border-w-e",
        "border-w-t",
        "border-w-r",
        "border-w-b",
        "border-w-l",
      ],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": [
        "border-color-x",
        "border-color-y",
        "border-color-s",
        "border-color-e",
        "border-color-t",
        "border-color-r",
        "border-color-b",
        "border-color-l",
      ],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      translate: ["translate-x", "translate-y", "translate-none"],
      "translate-none": ["translate", "translate-x", "translate-y", "translate-z"],
      "scroll-m": [
        "scroll-mx",
        "scroll-my",
        "scroll-ms",
        "scroll-me",
        "scroll-mt",
        "scroll-mr",
        "scroll-mb",
        "scroll-ml",
      ],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": [
        "scroll-px",
        "scroll-py",
        "scroll-ps",
        "scroll-pe",
        "scroll-pt",
        "scroll-pr",
        "scroll-pb",
        "scroll-pl",
      ],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"],
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"],
    },
    orderSensitiveModifiers: [
      "*",
      "**",
      "after",
      "backdrop",
      "before",
      "details-content",
      "file",
      "first-letter",
      "first-line",
      "marker",
      "placeholder",
      "selection",
    ],
  };
};
const twMerge = /* @__PURE__ */ createTailwindMerge(getDefaultConfig);
function cn(...inputs) {
  return twMerge(clsx(inputs));
}
function DropdownMenu({ ...props }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(MenuRoot, {
    "data-slot": "dropdown-menu",
    ...props,
  });
}
function DropdownMenuTrigger({ ...props }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(MenuTrigger, {
    "data-slot": "dropdown-menu-trigger",
    ...props,
  });
}
function DropdownMenuContent({
  align = "start",
  alignOffset = 0,
  side = "bottom",
  sideOffset = 4,
  className,
  ...props
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(MenuPortal, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuPositioner, {
      className: "isolate z-50 outline-none",
      align,
      alignOffset,
      side,
      sideOffset,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuPopup, {
        "data-slot": "dropdown-menu-content",
        className: cn(
          "data-open:animate-in data-closed:animate-out data-closed:fade-out-0 data-open:fade-in-0 data-closed:zoom-out-95 data-open:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 ring-foreground/10 bg-popover text-popover-foreground min-w-32 rounded-none shadow-md ring-1 duration-100 z-50 max-h-(--available-height) w-(--anchor-width) origin-(--transform-origin) overflow-x-hidden overflow-y-auto outline-none data-closed:overflow-hidden",
          className,
        ),
        ...props,
      }),
    }),
  });
}
function DropdownMenuItem({ className, inset, variant = "default", ...props }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, {
    "data-slot": "dropdown-menu-item",
    "data-inset": inset,
    "data-variant": variant,
    className: cn(
      "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:text-destructive not-data-[variant=destructive]:focus:**:text-accent-foreground gap-2 rounded-none px-2 py-2 text-xs [&_svg:not([class*='size-'])]:size-4 group/dropdown-menu-item relative flex cursor-default items-center outline-hidden select-none data-disabled:pointer-events-none data-disabled:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0",
      className,
    ),
    ...props,
  });
}
const ScrollAreaRootContext = /* @__PURE__ */ reactExports.createContext(void 0);
function useScrollAreaRootContext() {
  const context = reactExports.useContext(ScrollAreaRootContext);
  if (context === void 0) {
    throw new Error(formatErrorMessage(53));
  }
  return context;
}
let ScrollAreaRootCssVars = /* @__PURE__ */ (function (ScrollAreaRootCssVars2) {
  ScrollAreaRootCssVars2["scrollAreaCornerHeight"] = "--scroll-area-corner-height";
  ScrollAreaRootCssVars2["scrollAreaCornerWidth"] = "--scroll-area-corner-width";
  return ScrollAreaRootCssVars2;
})({});
const SCROLL_TIMEOUT = 500;
const MIN_THUMB_SIZE = 16;
function getOffset(element, prop, axis) {
  if (!element) {
    return 0;
  }
  const styles = getComputedStyle(element);
  const propAxis = axis === "x" ? "Inline" : "Block";
  if (axis === "x" && prop === "margin") {
    return parseFloat(styles[`${prop}InlineStart`]) * 2;
  }
  return (
    parseFloat(styles[`${prop}${propAxis}Start`]) + parseFloat(styles[`${prop}${propAxis}End`])
  );
}
let ScrollAreaScrollbarDataAttributes = /* @__PURE__ */ (function (
  ScrollAreaScrollbarDataAttributes2,
) {
  ScrollAreaScrollbarDataAttributes2["orientation"] = "data-orientation";
  ScrollAreaScrollbarDataAttributes2["hovering"] = "data-hovering";
  ScrollAreaScrollbarDataAttributes2["scrolling"] = "data-scrolling";
  ScrollAreaScrollbarDataAttributes2["hasOverflowX"] = "data-has-overflow-x";
  ScrollAreaScrollbarDataAttributes2["hasOverflowY"] = "data-has-overflow-y";
  ScrollAreaScrollbarDataAttributes2["overflowXStart"] = "data-overflow-x-start";
  ScrollAreaScrollbarDataAttributes2["overflowXEnd"] = "data-overflow-x-end";
  ScrollAreaScrollbarDataAttributes2["overflowYStart"] = "data-overflow-y-start";
  ScrollAreaScrollbarDataAttributes2["overflowYEnd"] = "data-overflow-y-end";
  return ScrollAreaScrollbarDataAttributes2;
})({});
const DISABLE_SCROLLBAR_CLASS_NAME = "base-ui-disable-scrollbar";
const styleDisableScrollbar = {
  className: DISABLE_SCROLLBAR_CLASS_NAME,
  getElement(nonce) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("style", {
      nonce,
      href: DISABLE_SCROLLBAR_CLASS_NAME,
      precedence: "base-ui:low",
      children: `.${DISABLE_SCROLLBAR_CLASS_NAME}{scrollbar-width:none}.${DISABLE_SCROLLBAR_CLASS_NAME}::-webkit-scrollbar{display:none}`,
    });
  },
};
let ScrollAreaRootDataAttributes = /* @__PURE__ */ (function (ScrollAreaRootDataAttributes2) {
  ScrollAreaRootDataAttributes2["hasOverflowX"] = "data-has-overflow-x";
  ScrollAreaRootDataAttributes2["hasOverflowY"] = "data-has-overflow-y";
  ScrollAreaRootDataAttributes2["overflowXStart"] = "data-overflow-x-start";
  ScrollAreaRootDataAttributes2["overflowXEnd"] = "data-overflow-x-end";
  ScrollAreaRootDataAttributes2["overflowYStart"] = "data-overflow-y-start";
  ScrollAreaRootDataAttributes2["overflowYEnd"] = "data-overflow-y-end";
  return ScrollAreaRootDataAttributes2;
})({});
const scrollAreaStateAttributesMapping = {
  hasOverflowX: (value) =>
    value
      ? {
          [ScrollAreaRootDataAttributes.hasOverflowX]: "",
        }
      : null,
  hasOverflowY: (value) =>
    value
      ? {
          [ScrollAreaRootDataAttributes.hasOverflowY]: "",
        }
      : null,
  overflowXStart: (value) =>
    value
      ? {
          [ScrollAreaRootDataAttributes.overflowXStart]: "",
        }
      : null,
  overflowXEnd: (value) =>
    value
      ? {
          [ScrollAreaRootDataAttributes.overflowXEnd]: "",
        }
      : null,
  overflowYStart: (value) =>
    value
      ? {
          [ScrollAreaRootDataAttributes.overflowYStart]: "",
        }
      : null,
  overflowYEnd: (value) =>
    value
      ? {
          [ScrollAreaRootDataAttributes.overflowYEnd]: "",
        }
      : null,
  cornerHidden: () => null,
};
const CSPContext = /* @__PURE__ */ reactExports.createContext(void 0);
const DEFAULT_CSP_CONTEXT_VALUE = {
  disableStyleElements: false,
};
function useCSPContext() {
  return reactExports.useContext(CSPContext) ?? DEFAULT_CSP_CONTEXT_VALUE;
}
const DEFAULT_COORDS = {
  x: 0,
  y: 0,
};
const DEFAULT_SIZE = {
  width: 0,
  height: 0,
};
const DEFAULT_OVERFLOW_EDGES = {
  xStart: false,
  xEnd: false,
  yStart: false,
  yEnd: false,
};
const DEFAULT_HIDDEN_STATE = {
  x: false,
  y: false,
  corner: false,
};
const ScrollAreaRoot = /* @__PURE__ */ reactExports.forwardRef(
  function ScrollAreaRoot2(componentProps, forwardedRef) {
    const {
      render,
      className,
      overflowEdgeThreshold: overflowEdgeThresholdProp,
      ...elementProps
    } = componentProps;
    const overflowEdgeThreshold = normalizeOverflowEdgeThreshold(overflowEdgeThresholdProp);
    const rootId = useBaseUiId();
    const scrollYTimeout = useTimeout();
    const scrollXTimeout = useTimeout();
    const { nonce, disableStyleElements } = useCSPContext();
    const [hovering, setHovering] = reactExports.useState(false);
    const [scrollingX, setScrollingX] = reactExports.useState(false);
    const [scrollingY, setScrollingY] = reactExports.useState(false);
    const [touchModality, setTouchModality] = reactExports.useState(false);
    const [cornerSize, setCornerSize] = reactExports.useState(DEFAULT_SIZE);
    const [thumbSize, setThumbSize] = reactExports.useState(DEFAULT_SIZE);
    const [overflowEdges, setOverflowEdges] = reactExports.useState(DEFAULT_OVERFLOW_EDGES);
    const [hiddenState, setHiddenState] = reactExports.useState(DEFAULT_HIDDEN_STATE);
    const rootRef = reactExports.useRef(null);
    const viewportRef = reactExports.useRef(null);
    const scrollbarYRef = reactExports.useRef(null);
    const scrollbarXRef = reactExports.useRef(null);
    const thumbYRef = reactExports.useRef(null);
    const thumbXRef = reactExports.useRef(null);
    const cornerRef = reactExports.useRef(null);
    const thumbDraggingRef = reactExports.useRef(false);
    const startYRef = reactExports.useRef(0);
    const startXRef = reactExports.useRef(0);
    const startScrollTopRef = reactExports.useRef(0);
    const startScrollLeftRef = reactExports.useRef(0);
    const currentOrientationRef = reactExports.useRef("vertical");
    const scrollPositionRef = reactExports.useRef(DEFAULT_COORDS);
    const handleScroll = useStableCallback((scrollPosition) => {
      const offsetX = scrollPosition.x - scrollPositionRef.current.x;
      const offsetY = scrollPosition.y - scrollPositionRef.current.y;
      scrollPositionRef.current = scrollPosition;
      if (offsetY !== 0) {
        setScrollingY(true);
        scrollYTimeout.start(SCROLL_TIMEOUT, () => {
          setScrollingY(false);
        });
      }
      if (offsetX !== 0) {
        setScrollingX(true);
        scrollXTimeout.start(SCROLL_TIMEOUT, () => {
          setScrollingX(false);
        });
      }
    });
    const handlePointerDown = useStableCallback((event) => {
      if (event.button !== 0) {
        return;
      }
      thumbDraggingRef.current = true;
      startYRef.current = event.clientY;
      startXRef.current = event.clientX;
      currentOrientationRef.current = event.currentTarget.getAttribute(
        ScrollAreaScrollbarDataAttributes.orientation,
      );
      if (viewportRef.current) {
        startScrollTopRef.current = viewportRef.current.scrollTop;
        startScrollLeftRef.current = viewportRef.current.scrollLeft;
      }
      if (thumbYRef.current && currentOrientationRef.current === "vertical") {
        thumbYRef.current.setPointerCapture(event.pointerId);
      }
      if (thumbXRef.current && currentOrientationRef.current === "horizontal") {
        thumbXRef.current.setPointerCapture(event.pointerId);
      }
    });
    const handlePointerMove = useStableCallback((event) => {
      if (!thumbDraggingRef.current) {
        return;
      }
      const deltaY = event.clientY - startYRef.current;
      const deltaX = event.clientX - startXRef.current;
      if (viewportRef.current) {
        const scrollableContentHeight = viewportRef.current.scrollHeight;
        const viewportHeight = viewportRef.current.clientHeight;
        const scrollableContentWidth = viewportRef.current.scrollWidth;
        const viewportWidth = viewportRef.current.clientWidth;
        if (
          thumbYRef.current &&
          scrollbarYRef.current &&
          currentOrientationRef.current === "vertical"
        ) {
          const scrollbarYOffset = getOffset(scrollbarYRef.current, "padding", "y");
          const thumbYOffset = getOffset(thumbYRef.current, "margin", "y");
          const thumbHeight = thumbYRef.current.offsetHeight;
          const maxThumbOffsetY =
            scrollbarYRef.current.offsetHeight - thumbHeight - scrollbarYOffset - thumbYOffset;
          const scrollRatioY = deltaY / maxThumbOffsetY;
          viewportRef.current.scrollTop =
            startScrollTopRef.current + scrollRatioY * (scrollableContentHeight - viewportHeight);
          event.preventDefault();
          setScrollingY(true);
          scrollYTimeout.start(SCROLL_TIMEOUT, () => {
            setScrollingY(false);
          });
        }
        if (
          thumbXRef.current &&
          scrollbarXRef.current &&
          currentOrientationRef.current === "horizontal"
        ) {
          const scrollbarXOffset = getOffset(scrollbarXRef.current, "padding", "x");
          const thumbXOffset = getOffset(thumbXRef.current, "margin", "x");
          const thumbWidth = thumbXRef.current.offsetWidth;
          const maxThumbOffsetX =
            scrollbarXRef.current.offsetWidth - thumbWidth - scrollbarXOffset - thumbXOffset;
          const scrollRatioX = deltaX / maxThumbOffsetX;
          viewportRef.current.scrollLeft =
            startScrollLeftRef.current + scrollRatioX * (scrollableContentWidth - viewportWidth);
          event.preventDefault();
          setScrollingX(true);
          scrollXTimeout.start(SCROLL_TIMEOUT, () => {
            setScrollingX(false);
          });
        }
      }
    });
    const handlePointerUp = useStableCallback((event) => {
      thumbDraggingRef.current = false;
      if (thumbYRef.current && currentOrientationRef.current === "vertical") {
        thumbYRef.current.releasePointerCapture(event.pointerId);
      }
      if (thumbXRef.current && currentOrientationRef.current === "horizontal") {
        thumbXRef.current.releasePointerCapture(event.pointerId);
      }
    });
    function handleTouchModalityChange(event) {
      setTouchModality(event.pointerType === "touch");
    }
    function handlePointerEnterOrMove(event) {
      handleTouchModalityChange(event);
      if (event.pointerType !== "touch") {
        const isTargetRootChild = contains(rootRef.current, event.target);
        setHovering(isTargetRootChild);
      }
    }
    const state = reactExports.useMemo(
      () => ({
        hasOverflowX: !hiddenState.x,
        hasOverflowY: !hiddenState.y,
        overflowXStart: overflowEdges.xStart,
        overflowXEnd: overflowEdges.xEnd,
        overflowYStart: overflowEdges.yStart,
        overflowYEnd: overflowEdges.yEnd,
        cornerHidden: hiddenState.corner,
      }),
      [hiddenState.x, hiddenState.y, hiddenState.corner, overflowEdges],
    );
    const props = {
      role: "presentation",
      onPointerEnter: handlePointerEnterOrMove,
      onPointerMove: handlePointerEnterOrMove,
      onPointerDown: handleTouchModalityChange,
      onPointerLeave() {
        setHovering(false);
      },
      style: {
        position: "relative",
        [ScrollAreaRootCssVars.scrollAreaCornerHeight]: `${cornerSize.height}px`,
        [ScrollAreaRootCssVars.scrollAreaCornerWidth]: `${cornerSize.width}px`,
      },
    };
    const element = useRenderElement("div", componentProps, {
      state,
      ref: [forwardedRef, rootRef],
      props: [props, elementProps],
      stateAttributesMapping: scrollAreaStateAttributesMapping,
    });
    const contextValue = reactExports.useMemo(
      () => ({
        handlePointerDown,
        handlePointerMove,
        handlePointerUp,
        handleScroll,
        cornerSize,
        setCornerSize,
        thumbSize,
        setThumbSize,
        touchModality,
        cornerRef,
        scrollingX,
        setScrollingX,
        scrollingY,
        setScrollingY,
        hovering,
        setHovering,
        viewportRef,
        rootRef,
        scrollbarYRef,
        scrollbarXRef,
        thumbYRef,
        thumbXRef,
        rootId,
        hiddenState,
        setHiddenState,
        overflowEdges,
        setOverflowEdges,
        viewportState: state,
        overflowEdgeThreshold,
      }),
      [
        handlePointerDown,
        handlePointerMove,
        handlePointerUp,
        handleScroll,
        cornerSize,
        thumbSize,
        touchModality,
        scrollingX,
        setScrollingX,
        scrollingY,
        setScrollingY,
        hovering,
        setHovering,
        rootId,
        hiddenState,
        overflowEdges,
        state,
        overflowEdgeThreshold,
      ],
    );
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(ScrollAreaRootContext.Provider, {
      value: contextValue,
      children: [!disableStyleElements && styleDisableScrollbar.getElement(nonce), element],
    });
  },
);
function normalizeOverflowEdgeThreshold(threshold) {
  if (typeof threshold === "number") {
    const value = Math.max(0, threshold);
    return {
      xStart: value,
      xEnd: value,
      yStart: value,
      yEnd: value,
    };
  }
  return {
    xStart: Math.max(0, (threshold == null ? void 0 : threshold.xStart) || 0),
    xEnd: Math.max(0, (threshold == null ? void 0 : threshold.xEnd) || 0),
    yStart: Math.max(0, (threshold == null ? void 0 : threshold.yStart) || 0),
    yEnd: Math.max(0, (threshold == null ? void 0 : threshold.yEnd) || 0),
  };
}
const ScrollAreaViewportContext = /* @__PURE__ */ reactExports.createContext(void 0);
function clamp(val, min2 = Number.MIN_SAFE_INTEGER, max2 = Number.MAX_SAFE_INTEGER) {
  return Math.max(min2, Math.min(val, max2));
}
function onVisible(element, callback) {
  if (typeof IntersectionObserver === "undefined") {
    return () => {};
  }
  const observer = new IntersectionObserver((entries) => {
    entries.forEach((entry) => {
      if (entry.intersectionRatio > 0) {
        callback();
        observer.disconnect();
      }
    });
  });
  observer.observe(element);
  return () => {
    observer.disconnect();
  };
}
let ScrollAreaViewportCssVars = /* @__PURE__ */ (function (ScrollAreaViewportCssVars2) {
  ScrollAreaViewportCssVars2["scrollAreaOverflowXStart"] = "--scroll-area-overflow-x-start";
  ScrollAreaViewportCssVars2["scrollAreaOverflowXEnd"] = "--scroll-area-overflow-x-end";
  ScrollAreaViewportCssVars2["scrollAreaOverflowYStart"] = "--scroll-area-overflow-y-start";
  ScrollAreaViewportCssVars2["scrollAreaOverflowYEnd"] = "--scroll-area-overflow-y-end";
  return ScrollAreaViewportCssVars2;
})({});
let scrollAreaOverflowVarsRegistered = false;
function removeCSSVariableInheritance() {
  if (
    scrollAreaOverflowVarsRegistered || // When `inherits: false`, specifying `inherit` on child elements doesn't work
    // in Safari. To let CSS features work correctly, this optimization must be skipped.
    isWebKit
  ) {
    return;
  }
  if (typeof CSS !== "undefined" && "registerProperty" in CSS) {
    [
      ScrollAreaViewportCssVars.scrollAreaOverflowXStart,
      ScrollAreaViewportCssVars.scrollAreaOverflowXEnd,
      ScrollAreaViewportCssVars.scrollAreaOverflowYStart,
      ScrollAreaViewportCssVars.scrollAreaOverflowYEnd,
    ].forEach((name) => {
      try {
        CSS.registerProperty({
          name,
          syntax: "<length>",
          inherits: false,
          initialValue: "0px",
        });
      } catch {}
    });
  }
  scrollAreaOverflowVarsRegistered = true;
}
const ScrollAreaViewport = /* @__PURE__ */ reactExports.forwardRef(
  function ScrollAreaViewport2(componentProps, forwardedRef) {
    const { render, className, ...elementProps } = componentProps;
    const {
      viewportRef,
      scrollbarYRef,
      scrollbarXRef,
      thumbYRef,
      thumbXRef,
      cornerRef,
      cornerSize,
      setCornerSize,
      setThumbSize,
      rootId,
      setHiddenState,
      hiddenState,
      handleScroll,
      setHovering,
      setOverflowEdges,
      overflowEdges,
      overflowEdgeThreshold,
    } = useScrollAreaRootContext();
    const direction = useDirection();
    const programmaticScrollRef = reactExports.useRef(true);
    const scrollEndTimeout = useTimeout();
    const waitForAnimationsTimeout = useTimeout();
    const computeThumbPosition = useStableCallback(() => {
      const viewportEl = viewportRef.current;
      const scrollbarYEl = scrollbarYRef.current;
      const scrollbarXEl = scrollbarXRef.current;
      const thumbYEl = thumbYRef.current;
      const thumbXEl = thumbXRef.current;
      const cornerEl = cornerRef.current;
      if (!viewportEl) {
        return;
      }
      const scrollableContentHeight = viewportEl.scrollHeight;
      const scrollableContentWidth = viewportEl.scrollWidth;
      const viewportHeight = viewportEl.clientHeight;
      const viewportWidth = viewportEl.clientWidth;
      const scrollTop = viewportEl.scrollTop;
      const scrollLeft = viewportEl.scrollLeft;
      if (scrollableContentHeight === 0 || scrollableContentWidth === 0) {
        return;
      }
      const scrollbarYHidden = viewportHeight >= scrollableContentHeight;
      const scrollbarXHidden = viewportWidth >= scrollableContentWidth;
      const ratioX = viewportWidth / scrollableContentWidth;
      const ratioY = viewportHeight / scrollableContentHeight;
      const maxScrollLeft = Math.max(0, scrollableContentWidth - viewportWidth);
      const maxScrollTop = Math.max(0, scrollableContentHeight - viewportHeight);
      let scrollLeftFromStart = 0;
      let scrollLeftFromEnd = 0;
      if (!scrollbarXHidden) {
        if (direction === "rtl") {
          scrollLeftFromStart = clamp(-scrollLeft, 0, maxScrollLeft);
        } else {
          scrollLeftFromStart = clamp(scrollLeft, 0, maxScrollLeft);
        }
        scrollLeftFromEnd = maxScrollLeft - scrollLeftFromStart;
      }
      const scrollTopFromStart = !scrollbarYHidden ? clamp(scrollTop, 0, maxScrollTop) : 0;
      const scrollTopFromEnd = !scrollbarYHidden ? maxScrollTop - scrollTopFromStart : 0;
      const nextWidth = scrollbarXHidden ? 0 : viewportWidth;
      const nextHeight = scrollbarYHidden ? 0 : viewportHeight;
      let nextCornerWidth = 0;
      let nextCornerHeight = 0;
      if (!scrollbarXHidden && !scrollbarYHidden) {
        nextCornerWidth = (scrollbarYEl == null ? void 0 : scrollbarYEl.offsetWidth) || 0;
        nextCornerHeight = (scrollbarXEl == null ? void 0 : scrollbarXEl.offsetHeight) || 0;
      }
      const cornerNotYetSized = cornerSize.width === 0 && cornerSize.height === 0;
      const cornerWidthOffset = cornerNotYetSized ? nextCornerWidth : 0;
      const cornerHeightOffset = cornerNotYetSized ? nextCornerHeight : 0;
      const scrollbarXOffset = getOffset(scrollbarXEl, "padding", "x");
      const scrollbarYOffset = getOffset(scrollbarYEl, "padding", "y");
      const thumbXOffset = getOffset(thumbXEl, "margin", "x");
      const thumbYOffset = getOffset(thumbYEl, "margin", "y");
      const idealNextWidth = nextWidth - scrollbarXOffset - thumbXOffset;
      const idealNextHeight = nextHeight - scrollbarYOffset - thumbYOffset;
      const maxNextWidth = scrollbarXEl
        ? Math.min(scrollbarXEl.offsetWidth - cornerWidthOffset, idealNextWidth)
        : idealNextWidth;
      const maxNextHeight = scrollbarYEl
        ? Math.min(scrollbarYEl.offsetHeight - cornerHeightOffset, idealNextHeight)
        : idealNextHeight;
      const clampedNextWidth = Math.max(MIN_THUMB_SIZE, maxNextWidth * ratioX);
      const clampedNextHeight = Math.max(MIN_THUMB_SIZE, maxNextHeight * ratioY);
      setThumbSize((prevSize) => {
        if (prevSize.height === clampedNextHeight && prevSize.width === clampedNextWidth) {
          return prevSize;
        }
        return {
          width: clampedNextWidth,
          height: clampedNextHeight,
        };
      });
      if (scrollbarYEl && thumbYEl) {
        const maxThumbOffsetY =
          scrollbarYEl.offsetHeight - clampedNextHeight - scrollbarYOffset - thumbYOffset;
        const scrollRangeY = scrollableContentHeight - viewportHeight;
        const scrollRatioY = scrollRangeY === 0 ? 0 : scrollTop / scrollRangeY;
        const thumbOffsetY = Math.min(maxThumbOffsetY, Math.max(0, scrollRatioY * maxThumbOffsetY));
        thumbYEl.style.transform = `translate3d(0,${thumbOffsetY}px,0)`;
      }
      if (scrollbarXEl && thumbXEl) {
        const maxThumbOffsetX =
          scrollbarXEl.offsetWidth - clampedNextWidth - scrollbarXOffset - thumbXOffset;
        const scrollRangeX = scrollableContentWidth - viewportWidth;
        const scrollRatioX = scrollRangeX === 0 ? 0 : scrollLeft / scrollRangeX;
        const thumbOffsetX =
          direction === "rtl"
            ? clamp(scrollRatioX * maxThumbOffsetX, -maxThumbOffsetX, 0)
            : clamp(scrollRatioX * maxThumbOffsetX, 0, maxThumbOffsetX);
        thumbXEl.style.transform = `translate3d(${thumbOffsetX}px,0,0)`;
      }
      const clampedScrollLeftStart = clamp(scrollLeftFromStart, 0, maxScrollLeft);
      const clampedScrollLeftEnd = clamp(scrollLeftFromEnd, 0, maxScrollLeft);
      const clampedScrollTopStart = clamp(scrollTopFromStart, 0, maxScrollTop);
      const clampedScrollTopEnd = clamp(scrollTopFromEnd, 0, maxScrollTop);
      const overflowMetricsPx = [
        [ScrollAreaViewportCssVars.scrollAreaOverflowXStart, clampedScrollLeftStart],
        [ScrollAreaViewportCssVars.scrollAreaOverflowXEnd, clampedScrollLeftEnd],
        [ScrollAreaViewportCssVars.scrollAreaOverflowYStart, clampedScrollTopStart],
        [ScrollAreaViewportCssVars.scrollAreaOverflowYEnd, clampedScrollTopEnd],
      ];
      for (const [cssVar, value] of overflowMetricsPx) {
        viewportEl.style.setProperty(cssVar, `${value}px`);
      }
      if (cornerEl) {
        if (scrollbarXHidden || scrollbarYHidden) {
          setCornerSize({
            width: 0,
            height: 0,
          });
        } else if (!scrollbarXHidden && !scrollbarYHidden) {
          setCornerSize({
            width: nextCornerWidth,
            height: nextCornerHeight,
          });
        }
      }
      setHiddenState((prevState) => {
        const cornerHidden = scrollbarYHidden || scrollbarXHidden;
        if (
          prevState.y === scrollbarYHidden &&
          prevState.x === scrollbarXHidden &&
          prevState.corner === cornerHidden
        ) {
          return prevState;
        }
        return {
          y: scrollbarYHidden,
          x: scrollbarXHidden,
          corner: cornerHidden,
        };
      });
      const nextOverflowEdges = {
        xStart: !scrollbarXHidden && clampedScrollLeftStart > overflowEdgeThreshold.xStart,
        xEnd: !scrollbarXHidden && clampedScrollLeftEnd > overflowEdgeThreshold.xEnd,
        yStart: !scrollbarYHidden && clampedScrollTopStart > overflowEdgeThreshold.yStart,
        yEnd: !scrollbarYHidden && clampedScrollTopEnd > overflowEdgeThreshold.yEnd,
      };
      setOverflowEdges((prev) => {
        if (
          prev.xStart === nextOverflowEdges.xStart &&
          prev.xEnd === nextOverflowEdges.xEnd &&
          prev.yStart === nextOverflowEdges.yStart &&
          prev.yEnd === nextOverflowEdges.yEnd
        ) {
          return prev;
        }
        return nextOverflowEdges;
      });
    });
    useIsoLayoutEffect(() => {
      if (!viewportRef.current) {
        return void 0;
      }
      removeCSSVariableInheritance();
      let hasInitialized = false;
      return onVisible(viewportRef.current, () => {
        if (!hasInitialized) {
          hasInitialized = true;
          return;
        }
        computeThumbPosition();
      });
    }, [computeThumbPosition, viewportRef]);
    useIsoLayoutEffect(() => {
      queueMicrotask(computeThumbPosition);
    }, [computeThumbPosition, hiddenState, direction]);
    useIsoLayoutEffect(() => {
      var _a2;
      if ((_a2 = viewportRef.current) == null ? void 0 : _a2.matches(":hover")) {
        setHovering(true);
      }
    }, [viewportRef, setHovering]);
    reactExports.useEffect(() => {
      const viewport = viewportRef.current;
      if (typeof ResizeObserver === "undefined" || !viewport) {
        return void 0;
      }
      let hasInitialized = false;
      const ro = new ResizeObserver(() => {
        if (!hasInitialized) {
          hasInitialized = true;
          return;
        }
        computeThumbPosition();
      });
      ro.observe(viewport);
      waitForAnimationsTimeout.start(0, () => {
        const animations2 = viewport.getAnimations({
          subtree: true,
        });
        if (animations2.length === 0) {
          return;
        }
        Promise.all(animations2.map((animation) => animation.finished))
          .then(computeThumbPosition)
          .catch(() => {});
      });
      return () => {
        ro.disconnect();
        waitForAnimationsTimeout.clear();
      };
    }, [computeThumbPosition, viewportRef, waitForAnimationsTimeout]);
    function handleUserInteraction() {
      programmaticScrollRef.current = false;
    }
    const props = {
      role: "presentation",
      ...(rootId && {
        "data-id": `${rootId}-viewport`,
      }),
      // https://accessibilityinsights.io/info-examples/web/scrollable-region-focusable/
      ...((!hiddenState.x || !hiddenState.y) && {
        tabIndex: 0,
      }),
      className: styleDisableScrollbar.className,
      style: {
        overflow: "scroll",
      },
      onScroll() {
        if (!viewportRef.current) {
          return;
        }
        computeThumbPosition();
        if (!programmaticScrollRef.current) {
          handleScroll({
            x: viewportRef.current.scrollLeft,
            y: viewportRef.current.scrollTop,
          });
        }
        scrollEndTimeout.start(100, () => {
          programmaticScrollRef.current = true;
        });
      },
      onWheel: handleUserInteraction,
      onTouchMove: handleUserInteraction,
      onPointerMove: handleUserInteraction,
      onPointerEnter: handleUserInteraction,
      onKeyDown: handleUserInteraction,
    };
    const viewportState = reactExports.useMemo(
      () => ({
        hasOverflowX: !hiddenState.x,
        hasOverflowY: !hiddenState.y,
        overflowXStart: overflowEdges.xStart,
        overflowXEnd: overflowEdges.xEnd,
        overflowYStart: overflowEdges.yStart,
        overflowYEnd: overflowEdges.yEnd,
        cornerHidden: hiddenState.corner,
      }),
      [hiddenState.x, hiddenState.y, hiddenState.corner, overflowEdges],
    );
    const element = useRenderElement("div", componentProps, {
      ref: [forwardedRef, viewportRef],
      state: viewportState,
      props: [props, elementProps],
      stateAttributesMapping: scrollAreaStateAttributesMapping,
    });
    const contextValue = reactExports.useMemo(
      () => ({
        computeThumbPosition,
      }),
      [computeThumbPosition],
    );
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollAreaViewportContext.Provider, {
      value: contextValue,
      children: element,
    });
  },
);
const ScrollAreaScrollbarContext = /* @__PURE__ */ reactExports.createContext(void 0);
function useScrollAreaScrollbarContext() {
  const context = reactExports.useContext(ScrollAreaScrollbarContext);
  if (context === void 0) {
    throw new Error(formatErrorMessage(54));
  }
  return context;
}
let ScrollAreaScrollbarCssVars = /* @__PURE__ */ (function (ScrollAreaScrollbarCssVars2) {
  ScrollAreaScrollbarCssVars2["scrollAreaThumbHeight"] = "--scroll-area-thumb-height";
  ScrollAreaScrollbarCssVars2["scrollAreaThumbWidth"] = "--scroll-area-thumb-width";
  return ScrollAreaScrollbarCssVars2;
})({});
const ScrollAreaScrollbar = /* @__PURE__ */ reactExports.forwardRef(
  function ScrollAreaScrollbar2(componentProps, forwardedRef) {
    const {
      render,
      className,
      orientation = "vertical",
      keepMounted = false,
      ...elementProps
    } = componentProps;
    const {
      hovering,
      scrollingX,
      scrollingY,
      hiddenState,
      overflowEdges,
      scrollbarYRef,
      scrollbarXRef,
      viewportRef,
      thumbYRef,
      thumbXRef,
      handlePointerDown,
      handlePointerUp,
      rootId,
      thumbSize,
    } = useScrollAreaRootContext();
    const state = reactExports.useMemo(
      () => ({
        hovering,
        scrolling: {
          horizontal: scrollingX,
          vertical: scrollingY,
        }[orientation],
        orientation,
        hasOverflowX: !hiddenState.x,
        hasOverflowY: !hiddenState.y,
        overflowXStart: overflowEdges.xStart,
        overflowXEnd: overflowEdges.xEnd,
        overflowYStart: overflowEdges.yStart,
        overflowYEnd: overflowEdges.yEnd,
        cornerHidden: hiddenState.corner,
      }),
      [hovering, scrollingX, scrollingY, orientation, hiddenState, overflowEdges],
    );
    const direction = useDirection();
    reactExports.useEffect(() => {
      const viewportEl = viewportRef.current;
      const scrollbarEl =
        orientation === "vertical" ? scrollbarYRef.current : scrollbarXRef.current;
      if (!scrollbarEl) {
        return void 0;
      }
      function handleWheel(event) {
        if (!viewportEl || !scrollbarEl || event.ctrlKey) {
          return;
        }
        event.preventDefault();
        if (orientation === "vertical") {
          if (viewportEl.scrollTop === 0 && event.deltaY < 0) {
            return;
          }
        } else if (viewportEl.scrollLeft === 0 && event.deltaX < 0) {
          return;
        }
        if (orientation === "vertical") {
          if (
            viewportEl.scrollTop === viewportEl.scrollHeight - viewportEl.clientHeight &&
            event.deltaY > 0
          ) {
            return;
          }
        } else if (
          viewportEl.scrollLeft === viewportEl.scrollWidth - viewportEl.clientWidth &&
          event.deltaX > 0
        ) {
          return;
        }
        if (orientation === "vertical") {
          viewportEl.scrollTop += event.deltaY;
        } else {
          viewportEl.scrollLeft += event.deltaX;
        }
      }
      scrollbarEl.addEventListener("wheel", handleWheel, {
        passive: false,
      });
      return () => {
        scrollbarEl.removeEventListener("wheel", handleWheel);
      };
    }, [orientation, scrollbarXRef, scrollbarYRef, viewportRef]);
    const props = {
      ...(rootId && {
        "data-id": `${rootId}-scrollbar`,
      }),
      onPointerDown(event) {
        if (event.button !== 0) {
          return;
        }
        if (event.currentTarget !== event.target) {
          return;
        }
        if (!viewportRef.current) {
          return;
        }
        if (thumbYRef.current && scrollbarYRef.current && orientation === "vertical") {
          const thumbYOffset = getOffset(thumbYRef.current, "margin", "y");
          const scrollbarYOffset = getOffset(scrollbarYRef.current, "padding", "y");
          const thumbHeight = thumbYRef.current.offsetHeight;
          const trackRectY = scrollbarYRef.current.getBoundingClientRect();
          const clickY =
            event.clientY - trackRectY.top - thumbHeight / 2 - scrollbarYOffset + thumbYOffset / 2;
          const scrollableContentHeight = viewportRef.current.scrollHeight;
          const viewportHeight = viewportRef.current.clientHeight;
          const maxThumbOffsetY =
            scrollbarYRef.current.offsetHeight - thumbHeight - scrollbarYOffset - thumbYOffset;
          const scrollRatioY = clickY / maxThumbOffsetY;
          const newScrollTop = scrollRatioY * (scrollableContentHeight - viewportHeight);
          viewportRef.current.scrollTop = newScrollTop;
        }
        if (thumbXRef.current && scrollbarXRef.current && orientation === "horizontal") {
          const thumbXOffset = getOffset(thumbXRef.current, "margin", "x");
          const scrollbarXOffset = getOffset(scrollbarXRef.current, "padding", "x");
          const thumbWidth = thumbXRef.current.offsetWidth;
          const trackRectX = scrollbarXRef.current.getBoundingClientRect();
          const clickX =
            event.clientX - trackRectX.left - thumbWidth / 2 - scrollbarXOffset + thumbXOffset / 2;
          const scrollableContentWidth = viewportRef.current.scrollWidth;
          const viewportWidth = viewportRef.current.clientWidth;
          const maxThumbOffsetX =
            scrollbarXRef.current.offsetWidth - thumbWidth - scrollbarXOffset - thumbXOffset;
          const scrollRatioX = clickX / maxThumbOffsetX;
          let newScrollLeft;
          if (direction === "rtl") {
            newScrollLeft = (1 - scrollRatioX) * (scrollableContentWidth - viewportWidth);
            if (viewportRef.current.scrollLeft <= 0) {
              newScrollLeft = -newScrollLeft;
            }
          } else {
            newScrollLeft = scrollRatioX * (scrollableContentWidth - viewportWidth);
          }
          viewportRef.current.scrollLeft = newScrollLeft;
        }
        handlePointerDown(event);
      },
      onPointerUp: handlePointerUp,
      style: {
        position: "absolute",
        touchAction: "none",
        WebkitUserSelect: "none",
        userSelect: "none",
        ...(orientation === "vertical" && {
          top: 0,
          bottom: `var(${ScrollAreaRootCssVars.scrollAreaCornerHeight})`,
          insetInlineEnd: 0,
          [ScrollAreaScrollbarCssVars.scrollAreaThumbHeight]: `${thumbSize.height}px`,
        }),
        ...(orientation === "horizontal" && {
          insetInlineStart: 0,
          insetInlineEnd: `var(${ScrollAreaRootCssVars.scrollAreaCornerWidth})`,
          bottom: 0,
          [ScrollAreaScrollbarCssVars.scrollAreaThumbWidth]: `${thumbSize.width}px`,
        }),
      },
    };
    const element = useRenderElement("div", componentProps, {
      ref: [forwardedRef, orientation === "vertical" ? scrollbarYRef : scrollbarXRef],
      state,
      props: [props, elementProps],
      stateAttributesMapping: scrollAreaStateAttributesMapping,
    });
    const contextValue = reactExports.useMemo(
      () => ({
        orientation,
      }),
      [orientation],
    );
    const isHidden3 = orientation === "vertical" ? hiddenState.y : hiddenState.x;
    const shouldRender = keepMounted || !isHidden3;
    if (!shouldRender) {
      return null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollAreaScrollbarContext.Provider, {
      value: contextValue,
      children: element,
    });
  },
);
const ScrollAreaThumb = /* @__PURE__ */ reactExports.forwardRef(
  function ScrollAreaThumb2(componentProps, forwardedRef) {
    const { render, className, ...elementProps } = componentProps;
    const {
      thumbYRef,
      thumbXRef,
      handlePointerDown,
      handlePointerMove,
      handlePointerUp,
      setScrollingX,
      setScrollingY,
    } = useScrollAreaRootContext();
    const { orientation } = useScrollAreaScrollbarContext();
    const state = reactExports.useMemo(
      () => ({
        orientation,
      }),
      [orientation],
    );
    const element = useRenderElement("div", componentProps, {
      ref: [forwardedRef, orientation === "vertical" ? thumbYRef : thumbXRef],
      state,
      props: [
        {
          onPointerDown: handlePointerDown,
          onPointerMove: handlePointerMove,
          onPointerUp(event) {
            if (orientation === "vertical") {
              setScrollingY(false);
            }
            if (orientation === "horizontal") {
              setScrollingX(false);
            }
            handlePointerUp(event);
          },
          style: {
            ...(orientation === "vertical" && {
              height: `var(${ScrollAreaScrollbarCssVars.scrollAreaThumbHeight})`,
            }),
            ...(orientation === "horizontal" && {
              width: `var(${ScrollAreaScrollbarCssVars.scrollAreaThumbWidth})`,
            }),
          },
        },
        elementProps,
      ],
    });
    return element;
  },
);
const ScrollAreaCorner = /* @__PURE__ */ reactExports.forwardRef(
  function ScrollAreaCorner2(componentProps, forwardedRef) {
    const { render, className, ...elementProps } = componentProps;
    const { cornerRef, cornerSize, hiddenState } = useScrollAreaRootContext();
    const element = useRenderElement("div", componentProps, {
      ref: [forwardedRef, cornerRef],
      props: [
        {
          style: {
            position: "absolute",
            bottom: 0,
            insetInlineEnd: 0,
            width: cornerSize.width,
            height: cornerSize.height,
          },
        },
        elementProps,
      ],
    });
    if (hiddenState.corner) {
      return null;
    }
    return element;
  },
);
function ScrollArea({ className, children, ...props }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(ScrollAreaRoot, {
    "data-slot": "scroll-area",
    className: cn("relative", className),
    ...props,
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollAreaViewport, {
        "data-slot": "scroll-area-viewport",
        className:
          "focus-visible:ring-ring/50 size-full rounded-[inherit] transition-[color,box-shadow] outline-none focus-visible:ring-[3px] focus-visible:outline-1",
        children,
      }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollBar, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollBar, { orientation: "horizontal" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollAreaCorner, {}),
    ],
  });
}
function ScrollBar({ className, orientation = "vertical", ...props }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollAreaScrollbar, {
    "data-slot": "scroll-area-scrollbar",
    "data-orientation": orientation,
    orientation,
    className: cn(
      "data-horizontal:h-2.5 data-horizontal:flex-col data-horizontal:border-t data-horizontal:border-t-transparent data-vertical:h-full data-vertical:w-2.5 data-vertical:border-l data-vertical:border-l-transparent flex touch-none p-px transition-colors select-none",
      className,
    ),
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollAreaThumb, {
      "data-slot": "scroll-area-thumb",
      className: "rounded-none bg-border relative flex-1",
    }),
  });
}
const TabsRootContext = /* @__PURE__ */ reactExports.createContext(void 0);
function useTabsRootContext() {
  const context = reactExports.useContext(TabsRootContext);
  if (context === void 0) {
    throw new Error(formatErrorMessage(64));
  }
  return context;
}
let TabsRootDataAttributes = /* @__PURE__ */ (function (TabsRootDataAttributes2) {
  TabsRootDataAttributes2["activationDirection"] = "data-activation-direction";
  TabsRootDataAttributes2["orientation"] = "data-orientation";
  return TabsRootDataAttributes2;
})({});
const tabsStateAttributesMapping = {
  tabActivationDirection: (dir) => ({
    [TabsRootDataAttributes.activationDirection]: dir,
  }),
};
const TabsRoot = /* @__PURE__ */ reactExports.forwardRef(
  function TabsRoot2(componentProps, forwardedRef) {
    const {
      className,
      defaultValue: defaultValueProp = 0,
      onValueChange: onValueChangeProp,
      orientation = "horizontal",
      render,
      value: valueProp,
      ...elementProps
    } = componentProps;
    const direction = useDirection();
    const hasExplicitDefaultValueProp = Object.hasOwn(componentProps, "defaultValue");
    const tabPanelRefs = reactExports.useRef([]);
    const [mountedTabPanels, setMountedTabPanels] = reactExports.useState(
      () => /* @__PURE__ */ new Map(),
    );
    const [value, setValue] = useControlled({
      controlled: valueProp,
      default: defaultValueProp,
      name: "Tabs",
      state: "value",
    });
    const isControlled = valueProp !== void 0;
    const [tabMap, setTabMap] = reactExports.useState(() => /* @__PURE__ */ new Map());
    const [tabActivationDirection, setTabActivationDirection] = reactExports.useState("none");
    const onValueChange = useStableCallback((newValue, eventDetails) => {
      onValueChangeProp == null ? void 0 : onValueChangeProp(newValue, eventDetails);
      if (eventDetails.isCanceled) {
        return;
      }
      setValue(newValue);
      setTabActivationDirection(eventDetails.activationDirection);
    });
    const registerMountedTabPanel = useStableCallback((panelValue, panelId) => {
      setMountedTabPanels((prev) => {
        if (prev.get(panelValue) === panelId) {
          return prev;
        }
        const next = new Map(prev);
        next.set(panelValue, panelId);
        return next;
      });
    });
    const unregisterMountedTabPanel = useStableCallback((panelValue, panelId) => {
      setMountedTabPanels((prev) => {
        if (!prev.has(panelValue) || prev.get(panelValue) !== panelId) {
          return prev;
        }
        const next = new Map(prev);
        next.delete(panelValue);
        return next;
      });
    });
    const getTabPanelIdByValue = reactExports.useCallback(
      (tabValue) => {
        return mountedTabPanels.get(tabValue);
      },
      [mountedTabPanels],
    );
    const getTabIdByPanelValue = reactExports.useCallback(
      (tabPanelValue) => {
        for (const tabMetadata of tabMap.values()) {
          if (tabPanelValue === (tabMetadata == null ? void 0 : tabMetadata.value)) {
            return tabMetadata == null ? void 0 : tabMetadata.id;
          }
        }
        return void 0;
      },
      [tabMap],
    );
    const getTabElementBySelectedValue = reactExports.useCallback(
      (selectedValue) => {
        if (selectedValue === void 0) {
          return null;
        }
        for (const [tabElement, tabMetadata] of tabMap.entries()) {
          if (tabMetadata != null && selectedValue === (tabMetadata.value ?? tabMetadata.index)) {
            return tabElement;
          }
        }
        return null;
      },
      [tabMap],
    );
    const tabsContextValue = reactExports.useMemo(
      () => ({
        direction,
        getTabElementBySelectedValue,
        getTabIdByPanelValue,
        getTabPanelIdByValue,
        onValueChange,
        orientation,
        registerMountedTabPanel,
        setTabMap,
        unregisterMountedTabPanel,
        tabActivationDirection,
        value,
      }),
      [
        direction,
        getTabElementBySelectedValue,
        getTabIdByPanelValue,
        getTabPanelIdByValue,
        onValueChange,
        orientation,
        registerMountedTabPanel,
        setTabMap,
        unregisterMountedTabPanel,
        tabActivationDirection,
        value,
      ],
    );
    const selectedTabMetadata = reactExports.useMemo(() => {
      for (const tabMetadata of tabMap.values()) {
        if (tabMetadata != null && tabMetadata.value === value) {
          return tabMetadata;
        }
      }
      return void 0;
    }, [tabMap, value]);
    const firstEnabledTabValue = reactExports.useMemo(() => {
      for (const tabMetadata of tabMap.values()) {
        if (tabMetadata != null && !tabMetadata.disabled) {
          return tabMetadata.value;
        }
      }
      return void 0;
    }, [tabMap]);
    useIsoLayoutEffect(() => {
      if (isControlled || tabMap.size === 0) {
        return;
      }
      const selectionIsDisabled =
        selectedTabMetadata == null ? void 0 : selectedTabMetadata.disabled;
      const selectionIsMissing = selectedTabMetadata == null && value !== null;
      const shouldHonorExplicitDefaultSelection =
        hasExplicitDefaultValueProp && selectionIsDisabled && value === defaultValueProp;
      if (shouldHonorExplicitDefaultSelection) {
        return;
      }
      if (!selectionIsDisabled && !selectionIsMissing) {
        return;
      }
      const fallbackValue = firstEnabledTabValue ?? null;
      if (value === fallbackValue) {
        return;
      }
      setValue(fallbackValue);
      setTabActivationDirection("none");
    }, [
      defaultValueProp,
      firstEnabledTabValue,
      hasExplicitDefaultValueProp,
      isControlled,
      selectedTabMetadata,
      setTabActivationDirection,
      setValue,
      tabMap,
      value,
    ]);
    const state = {
      orientation,
      tabActivationDirection,
    };
    const element = useRenderElement("div", componentProps, {
      state,
      ref: forwardedRef,
      props: elementProps,
      stateAttributesMapping: tabsStateAttributesMapping,
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(TabsRootContext.Provider, {
      value: tabsContextValue,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(CompositeList, {
        elementsRef: tabPanelRefs,
        children: element,
      }),
    });
  },
);
const ACTIVE_COMPOSITE_ITEM = "data-composite-item-active";
const TabsListContext = /* @__PURE__ */ reactExports.createContext(void 0);
function useTabsListContext() {
  const context = reactExports.useContext(TabsListContext);
  if (context === void 0) {
    throw new Error(formatErrorMessage(65));
  }
  return context;
}
const TabsTab = /* @__PURE__ */ reactExports.forwardRef(
  function TabsTab2(componentProps, forwardedRef) {
    const {
      className,
      disabled: disabled2 = false,
      render,
      value,
      id: idProp,
      nativeButton = true,
      ...elementProps
    } = componentProps;
    const { value: activeTabValue, getTabPanelIdByValue, orientation } = useTabsRootContext();
    const {
      activateOnFocus,
      highlightedTabIndex,
      onTabActivation,
      setHighlightedTabIndex,
      tabsListElement,
    } = useTabsListContext();
    const id2 = useBaseUiId(idProp);
    const tabMetadata = reactExports.useMemo(
      () => ({
        disabled: disabled2,
        id: id2,
        value,
      }),
      [disabled2, id2, value],
    );
    const {
      compositeProps,
      compositeRef,
      index: index2,
      // hook is used instead of the CompositeItem component
      // because the index is needed for Tab internals
    } = useCompositeItem({
      metadata: tabMetadata,
    });
    const active = value === activeTabValue;
    const isNavigatingRef = reactExports.useRef(false);
    useIsoLayoutEffect(() => {
      if (isNavigatingRef.current) {
        isNavigatingRef.current = false;
        return;
      }
      if (!(active && index2 > -1 && highlightedTabIndex !== index2)) {
        return;
      }
      const listElement = tabsListElement;
      if (listElement != null) {
        const activeEl = activeElement(ownerDocument(listElement));
        if (activeEl && contains(listElement, activeEl)) {
          return;
        }
      }
      if (!disabled2) {
        setHighlightedTabIndex(index2);
      }
    }, [active, index2, highlightedTabIndex, setHighlightedTabIndex, disabled2, tabsListElement]);
    const { getButtonProps, buttonRef } = useButton({
      disabled: disabled2,
      native: nativeButton,
      focusableWhenDisabled: true,
    });
    const tabPanelId = getTabPanelIdByValue(value);
    const isPressingRef = reactExports.useRef(false);
    const isMainButtonRef = reactExports.useRef(false);
    function onClick(event) {
      if (active || disabled2) {
        return;
      }
      onTabActivation(
        value,
        createChangeEventDetails(none, event.nativeEvent, void 0, {
          activationDirection: "none",
        }),
      );
    }
    function onFocus(event) {
      if (active) {
        return;
      }
      if (index2 > -1 && !disabled2) {
        setHighlightedTabIndex(index2);
      }
      if (disabled2) {
        return;
      }
      if (
        activateOnFocus &&
        (!isPressingRef.current || // keyboard or touch focus
          (isPressingRef.current && isMainButtonRef.current))
      ) {
        onTabActivation(
          value,
          createChangeEventDetails(none, event.nativeEvent, void 0, {
            activationDirection: "none",
          }),
        );
      }
    }
    function onPointerDown(event) {
      if (active || disabled2) {
        return;
      }
      isPressingRef.current = true;
      function handlePointerUp() {
        isPressingRef.current = false;
        isMainButtonRef.current = false;
      }
      if (!event.button || event.button === 0) {
        isMainButtonRef.current = true;
        const doc = ownerDocument(event.currentTarget);
        doc.addEventListener("pointerup", handlePointerUp, {
          once: true,
        });
      }
    }
    const state = reactExports.useMemo(
      () => ({
        disabled: disabled2,
        active,
        orientation,
      }),
      [disabled2, active, orientation],
    );
    const element = useRenderElement("button", componentProps, {
      state,
      ref: [forwardedRef, buttonRef, compositeRef],
      props: [
        compositeProps,
        {
          role: "tab",
          "aria-controls": tabPanelId,
          "aria-selected": active,
          id: id2,
          onClick,
          onFocus,
          onPointerDown,
          [ACTIVE_COMPOSITE_ITEM]: active ? "" : void 0,
          onKeyDownCapture() {
            isNavigatingRef.current = true;
          },
        },
        elementProps,
        getButtonProps,
      ],
    });
    return element;
  },
);
let TabsPanelDataAttributes = /* @__PURE__ */ (function (TabsPanelDataAttributes2) {
  TabsPanelDataAttributes2["index"] = "data-index";
  TabsPanelDataAttributes2["activationDirection"] = "data-activation-direction";
  TabsPanelDataAttributes2["orientation"] = "data-orientation";
  TabsPanelDataAttributes2["hidden"] = "data-hidden";
  return TabsPanelDataAttributes2;
})({});
const TabsPanel = /* @__PURE__ */ reactExports.forwardRef(
  function TabPanel(componentProps, forwardedRef) {
    const { className, value, render, keepMounted = false, ...elementProps } = componentProps;
    const {
      value: selectedValue,
      getTabIdByPanelValue,
      orientation,
      tabActivationDirection,
      registerMountedTabPanel,
      unregisterMountedTabPanel,
    } = useTabsRootContext();
    const id2 = useBaseUiId();
    const metadata = reactExports.useMemo(
      () => ({
        id: id2,
        value,
      }),
      [id2, value],
    );
    const { ref: listItemRef, index: index2 } = useCompositeListItem({
      metadata,
    });
    const hidden = value !== selectedValue;
    const correspondingTabId = getTabIdByPanelValue(value);
    const state = reactExports.useMemo(
      () => ({
        hidden,
        orientation,
        tabActivationDirection,
      }),
      [hidden, orientation, tabActivationDirection],
    );
    const element = useRenderElement("div", componentProps, {
      state,
      ref: [forwardedRef, listItemRef],
      props: [
        {
          "aria-labelledby": correspondingTabId,
          hidden,
          id: id2 ?? void 0,
          role: "tabpanel",
          tabIndex: hidden ? -1 : 0,
          [TabsPanelDataAttributes.index]: index2,
        },
        elementProps,
      ],
      stateAttributesMapping: tabsStateAttributesMapping,
    });
    useIsoLayoutEffect(() => {
      if (hidden && !keepMounted) {
        return void 0;
      }
      if (id2 == null) {
        return void 0;
      }
      registerMountedTabPanel(value, id2);
      return () => {
        unregisterMountedTabPanel(value, id2);
      };
    }, [hidden, keepMounted, value, id2, registerMountedTabPanel, unregisterMountedTabPanel]);
    const shouldRender = !hidden || keepMounted;
    if (!shouldRender) {
      return null;
    }
    return element;
  },
);
function isElementDisabled(element) {
  return (
    element == null ||
    element.hasAttribute("disabled") ||
    element.getAttribute("aria-disabled") === "true"
  );
}
const EMPTY_ARRAY = [];
function useCompositeRoot(params) {
  const {
    itemSizes,
    cols = 1,
    loopFocus = true,
    dense = false,
    orientation = "both",
    direction,
    highlightedIndex: externalHighlightedIndex,
    onHighlightedIndexChange: externalSetHighlightedIndex,
    rootRef: externalRef,
    enableHomeAndEndKeys = false,
    stopEventPropagation = false,
    disabledIndices,
    modifierKeys = EMPTY_ARRAY,
  } = params;
  const [internalHighlightedIndex, internalSetHighlightedIndex] = reactExports.useState(0);
  const isGrid = cols > 1;
  const rootRef = reactExports.useRef(null);
  const mergedRef = useMergedRefs(rootRef, externalRef);
  const elementsRef = reactExports.useRef([]);
  const hasSetDefaultIndexRef = reactExports.useRef(false);
  const highlightedIndex = externalHighlightedIndex ?? internalHighlightedIndex;
  const onHighlightedIndexChange = useStableCallback((index2, shouldScrollIntoView = false) => {
    (externalSetHighlightedIndex ?? internalSetHighlightedIndex)(index2);
    if (shouldScrollIntoView) {
      const newActiveItem = elementsRef.current[index2];
      scrollIntoViewIfNeeded(rootRef.current, newActiveItem, direction, orientation);
    }
  });
  const onMapChange = useStableCallback((map) => {
    if (map.size === 0 || hasSetDefaultIndexRef.current) {
      return;
    }
    hasSetDefaultIndexRef.current = true;
    const sortedElements = Array.from(map.keys());
    const activeItem =
      sortedElements.find((compositeElement) =>
        compositeElement == null ? void 0 : compositeElement.hasAttribute(ACTIVE_COMPOSITE_ITEM),
      ) ?? null;
    const activeIndex = activeItem ? sortedElements.indexOf(activeItem) : -1;
    if (activeIndex !== -1) {
      onHighlightedIndexChange(activeIndex);
    }
    scrollIntoViewIfNeeded(rootRef.current, activeItem, direction, orientation);
  });
  const props = reactExports.useMemo(
    () => ({
      "aria-orientation": orientation === "both" ? void 0 : orientation,
      ref: mergedRef,
      onFocus(event) {
        const element = rootRef.current;
        if (!element || !isNativeInput(event.target)) {
          return;
        }
        event.target.setSelectionRange(0, event.target.value.length ?? 0);
      },
      onKeyDown(event) {
        const RELEVANT_KEYS = enableHomeAndEndKeys ? ALL_KEYS : ARROW_KEYS;
        if (!RELEVANT_KEYS.has(event.key)) {
          return;
        }
        if (isModifierKeySet(event, modifierKeys)) {
          return;
        }
        const element = rootRef.current;
        if (!element) {
          return;
        }
        const isRtl = direction === "rtl";
        const horizontalForwardKey = isRtl ? ARROW_LEFT : ARROW_RIGHT;
        const forwardKey = {
          horizontal: horizontalForwardKey,
          vertical: ARROW_DOWN,
          both: horizontalForwardKey,
        }[orientation];
        const horizontalBackwardKey = isRtl ? ARROW_RIGHT : ARROW_LEFT;
        const backwardKey = {
          horizontal: horizontalBackwardKey,
          vertical: ARROW_UP,
          both: horizontalBackwardKey,
        }[orientation];
        if (isNativeInput(event.target) && !isElementDisabled(event.target)) {
          const selectionStart = event.target.selectionStart;
          const selectionEnd = event.target.selectionEnd;
          const textContent = event.target.value ?? "";
          if (selectionStart == null || event.shiftKey || selectionStart !== selectionEnd) {
            return;
          }
          if (event.key !== backwardKey && selectionStart < textContent.length) {
            return;
          }
          if (event.key !== forwardKey && selectionStart > 0) {
            return;
          }
        }
        let nextIndex = highlightedIndex;
        const minIndex = getMinListIndex(elementsRef, disabledIndices);
        const maxIndex = getMaxListIndex(elementsRef, disabledIndices);
        if (isGrid) {
          const sizes =
            itemSizes ||
            Array.from(
              {
                length: elementsRef.current.length,
              },
              () => ({
                width: 1,
                height: 1,
              }),
            );
          const cellMap = createGridCellMap(sizes, cols, dense);
          const minGridIndex = cellMap.findIndex(
            (index2) =>
              index2 != null && !isListIndexDisabled(elementsRef, index2, disabledIndices),
          );
          const maxGridIndex = cellMap.reduce(
            (foundIndex, index2, cellIndex) =>
              index2 != null && !isListIndexDisabled(elementsRef, index2, disabledIndices)
                ? cellIndex
                : foundIndex,
            -1,
          );
          nextIndex =
            cellMap[
              getGridNavigatedIndex(
                {
                  current: cellMap.map((itemIndex) =>
                    itemIndex ? elementsRef.current[itemIndex] : null,
                  ),
                },
                {
                  event,
                  orientation,
                  loopFocus,
                  cols,
                  // treat undefined (empty grid spaces) as disabled indices so we
                  // don't end up in them
                  disabledIndices: getGridCellIndices(
                    [
                      ...(disabledIndices ||
                        elementsRef.current.map((_, index2) =>
                          isListIndexDisabled(elementsRef, index2) ? index2 : void 0,
                        )),
                      void 0,
                    ],
                    cellMap,
                  ),
                  minIndex: minGridIndex,
                  maxIndex: maxGridIndex,
                  prevIndex: getGridCellIndexOfCorner(
                    highlightedIndex > maxIndex ? minIndex : highlightedIndex,
                    sizes,
                    cellMap,
                    cols,
                    // use a corner matching the edge closest to the direction we're
                    // moving in so we don't end up in the same item. Prefer
                    // top/left over bottom/right.
                    // eslint-disable-next-line no-nested-ternary
                    event.key === ARROW_DOWN ? "bl" : event.key === ARROW_RIGHT ? "tr" : "tl",
                  ),
                  rtl: isRtl,
                },
              )
            ];
        }
        const forwardKeys = {
          horizontal: [horizontalForwardKey],
          vertical: [ARROW_DOWN],
          both: [horizontalForwardKey, ARROW_DOWN],
        }[orientation];
        const backwardKeys = {
          horizontal: [horizontalBackwardKey],
          vertical: [ARROW_UP],
          both: [horizontalBackwardKey, ARROW_UP],
        }[orientation];
        const preventedKeys = isGrid
          ? RELEVANT_KEYS
          : {
              horizontal: enableHomeAndEndKeys ? HORIZONTAL_KEYS_WITH_EXTRA_KEYS : HORIZONTAL_KEYS,
              vertical: enableHomeAndEndKeys ? VERTICAL_KEYS_WITH_EXTRA_KEYS : VERTICAL_KEYS,
              both: RELEVANT_KEYS,
            }[orientation];
        if (enableHomeAndEndKeys) {
          if (event.key === HOME) {
            nextIndex = minIndex;
          } else if (event.key === END) {
            nextIndex = maxIndex;
          }
        }
        if (
          nextIndex === highlightedIndex &&
          (forwardKeys.includes(event.key) || backwardKeys.includes(event.key))
        ) {
          if (loopFocus && nextIndex === maxIndex && forwardKeys.includes(event.key)) {
            nextIndex = minIndex;
          } else if (loopFocus && nextIndex === minIndex && backwardKeys.includes(event.key)) {
            nextIndex = maxIndex;
          } else {
            nextIndex = findNonDisabledListIndex(elementsRef, {
              startingIndex: nextIndex,
              decrement: backwardKeys.includes(event.key),
              disabledIndices,
            });
          }
        }
        if (nextIndex !== highlightedIndex && !isIndexOutOfListBounds(elementsRef, nextIndex)) {
          if (stopEventPropagation) {
            event.stopPropagation();
          }
          if (preventedKeys.has(event.key)) {
            event.preventDefault();
          }
          onHighlightedIndexChange(nextIndex, true);
          queueMicrotask(() => {
            var _a2;
            (_a2 = elementsRef.current[nextIndex]) == null ? void 0 : _a2.focus();
          });
        }
      },
    }),
    [
      cols,
      dense,
      direction,
      disabledIndices,
      elementsRef,
      enableHomeAndEndKeys,
      highlightedIndex,
      isGrid,
      itemSizes,
      loopFocus,
      mergedRef,
      modifierKeys,
      onHighlightedIndexChange,
      orientation,
      stopEventPropagation,
    ],
  );
  return reactExports.useMemo(
    () => ({
      props,
      highlightedIndex,
      onHighlightedIndexChange,
      elementsRef,
      disabledIndices,
      onMapChange,
      relayKeyboardEvent: props.onKeyDown,
    }),
    [props, highlightedIndex, onHighlightedIndexChange, elementsRef, disabledIndices, onMapChange],
  );
}
function isModifierKeySet(event, ignoredModifierKeys) {
  for (const key of MODIFIER_KEYS.values()) {
    if (ignoredModifierKeys.includes(key)) {
      continue;
    }
    if (event.getModifierState(key)) {
      return true;
    }
  }
  return false;
}
function CompositeRoot(componentProps) {
  const {
    render,
    className,
    refs = EMPTY_ARRAY$1,
    props = EMPTY_ARRAY$1,
    state = EMPTY_OBJECT,
    stateAttributesMapping: stateAttributesMapping2,
    highlightedIndex: highlightedIndexProp,
    onHighlightedIndexChange: onHighlightedIndexChangeProp,
    orientation,
    dense,
    itemSizes,
    loopFocus,
    cols,
    enableHomeAndEndKeys,
    onMapChange: onMapChangeProp,
    stopEventPropagation = true,
    rootRef,
    disabledIndices,
    modifierKeys,
    highlightItemOnHover = false,
    tag = "div",
    ...elementProps
  } = componentProps;
  const direction = useDirection();
  const {
    props: defaultProps,
    highlightedIndex,
    onHighlightedIndexChange,
    elementsRef,
    onMapChange: onMapChangeUnwrapped,
    relayKeyboardEvent,
  } = useCompositeRoot({
    itemSizes,
    cols,
    loopFocus,
    dense,
    orientation,
    highlightedIndex: highlightedIndexProp,
    onHighlightedIndexChange: onHighlightedIndexChangeProp,
    rootRef,
    stopEventPropagation,
    enableHomeAndEndKeys,
    direction,
    disabledIndices,
    modifierKeys,
  });
  const element = useRenderElement(tag, componentProps, {
    state,
    ref: refs,
    props: [defaultProps, ...props, elementProps],
    stateAttributesMapping: stateAttributesMapping2,
  });
  const contextValue = reactExports.useMemo(
    () => ({
      highlightedIndex,
      onHighlightedIndexChange,
      highlightItemOnHover,
      relayKeyboardEvent,
    }),
    [highlightedIndex, onHighlightedIndexChange, highlightItemOnHover, relayKeyboardEvent],
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CompositeRootContext.Provider, {
    value: contextValue,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(CompositeList, {
      elementsRef,
      onMapChange: (newMap) => {
        onMapChangeProp == null ? void 0 : onMapChangeProp(newMap);
        onMapChangeUnwrapped(newMap);
      },
      children: element,
    }),
  });
}
const TabsList$1 = /* @__PURE__ */ reactExports.forwardRef(
  function TabsList2(componentProps, forwardedRef) {
    const {
      activateOnFocus = false,
      className,
      loopFocus = true,
      render,
      ...elementProps
    } = componentProps;
    const {
      getTabElementBySelectedValue,
      onValueChange,
      orientation,
      value,
      setTabMap,
      tabActivationDirection,
    } = useTabsRootContext();
    const [highlightedTabIndex, setHighlightedTabIndex] = reactExports.useState(0);
    const [tabsListElement, setTabsListElement] = reactExports.useState(null);
    const detectActivationDirection = useActivationDirectionDetector(
      value,
      // the old value
      orientation,
      tabsListElement,
      getTabElementBySelectedValue,
    );
    const onTabActivation = useStableCallback((newValue, eventDetails) => {
      if (newValue !== value) {
        const activationDirection = detectActivationDirection(newValue);
        eventDetails.activationDirection = activationDirection;
        onValueChange(newValue, eventDetails);
      }
    });
    const state = reactExports.useMemo(
      () => ({
        orientation,
        tabActivationDirection,
      }),
      [orientation, tabActivationDirection],
    );
    const defaultProps = {
      "aria-orientation": orientation === "vertical" ? "vertical" : void 0,
      role: "tablist",
    };
    const tabsListContextValue = reactExports.useMemo(
      () => ({
        activateOnFocus,
        highlightedTabIndex,
        onTabActivation,
        setHighlightedTabIndex,
        tabsListElement,
        value,
      }),
      [
        activateOnFocus,
        highlightedTabIndex,
        onTabActivation,
        setHighlightedTabIndex,
        tabsListElement,
        value,
      ],
    );
    return /* @__PURE__ */ jsxRuntimeExports.jsx(TabsListContext.Provider, {
      value: tabsListContextValue,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(CompositeRoot, {
        render,
        className,
        state,
        refs: [forwardedRef, setTabsListElement],
        props: [defaultProps, elementProps],
        stateAttributesMapping: tabsStateAttributesMapping,
        highlightedIndex: highlightedTabIndex,
        enableHomeAndEndKeys: true,
        loopFocus,
        orientation,
        onHighlightedIndexChange: setHighlightedTabIndex,
        onMapChange: setTabMap,
        disabledIndices: EMPTY_ARRAY$1,
      }),
    });
  },
);
function getInset(tab, tabsList) {
  const { left: tabLeft, top: tabTop } = tab.getBoundingClientRect();
  const { left: listLeft, top: listTop } = tabsList.getBoundingClientRect();
  const left = tabLeft - listLeft;
  const top = tabTop - listTop;
  return {
    left,
    top,
  };
}
function useActivationDirectionDetector(
  activeTabValue,
  orientation,
  tabsListElement,
  getTabElement,
) {
  const [previousTabEdge, setPreviousTabEdge] = reactExports.useState(null);
  useIsoLayoutEffect(() => {
    if (activeTabValue == null || tabsListElement == null) {
      setPreviousTabEdge(null);
      return;
    }
    const activeTab = getTabElement(activeTabValue);
    if (activeTab == null) {
      setPreviousTabEdge(null);
      return;
    }
    const { left, top } = getInset(activeTab, tabsListElement);
    setPreviousTabEdge(orientation === "horizontal" ? left : top);
  }, [orientation, getTabElement, tabsListElement, activeTabValue]);
  return reactExports.useCallback(
    (newValue) => {
      if (newValue === activeTabValue) {
        return "none";
      }
      if (newValue == null) {
        setPreviousTabEdge(null);
        return "none";
      }
      if (newValue != null && tabsListElement != null) {
        const activeTabElement = getTabElement(newValue);
        if (activeTabElement != null) {
          const { left, top } = getInset(activeTabElement, tabsListElement);
          if (previousTabEdge == null) {
            setPreviousTabEdge(orientation === "horizontal" ? left : top);
            return "none";
          }
          if (orientation === "horizontal") {
            if (left < previousTabEdge) {
              setPreviousTabEdge(left);
              return "left";
            }
            if (left > previousTabEdge) {
              setPreviousTabEdge(left);
              return "right";
            }
          } else if (top < previousTabEdge) {
            setPreviousTabEdge(top);
            return "up";
          } else if (top > previousTabEdge) {
            setPreviousTabEdge(top);
            return "down";
          }
        }
      }
      return "none";
    },
    [getTabElement, orientation, previousTabEdge, tabsListElement, activeTabValue],
  );
}
const falsyToString = (value) =>
  typeof value === "boolean" ? `${value}` : value === 0 ? "0" : value;
const cx = clsx;
const cva = (base, config) => (props) => {
  var _config_compoundVariants;
  if ((config === null || config === void 0 ? void 0 : config.variants) == null)
    return cx(
      base,
      props === null || props === void 0 ? void 0 : props.class,
      props === null || props === void 0 ? void 0 : props.className,
    );
  const { variants, defaultVariants } = config;
  const getVariantClassNames = Object.keys(variants).map((variant) => {
    const variantProp = props === null || props === void 0 ? void 0 : props[variant];
    const defaultVariantProp =
      defaultVariants === null || defaultVariants === void 0 ? void 0 : defaultVariants[variant];
    if (variantProp === null) return null;
    const variantKey = falsyToString(variantProp) || falsyToString(defaultVariantProp);
    return variants[variant][variantKey];
  });
  const propsWithoutUndefined =
    props &&
    Object.entries(props).reduce((acc, param) => {
      let [key, value] = param;
      if (value === void 0) {
        return acc;
      }
      acc[key] = value;
      return acc;
    }, {});
  const getCompoundVariantClassNames =
    config === null || config === void 0
      ? void 0
      : (_config_compoundVariants = config.compoundVariants) === null ||
          _config_compoundVariants === void 0
        ? void 0
        : _config_compoundVariants.reduce((acc, param) => {
            let { class: cvClass, className: cvClassName, ...compoundVariantOptions } = param;
            return Object.entries(compoundVariantOptions).every((param2) => {
              let [key, value] = param2;
              return Array.isArray(value)
                ? value.includes(
                    {
                      ...defaultVariants,
                      ...propsWithoutUndefined,
                    }[key],
                  )
                : {
                    ...defaultVariants,
                    ...propsWithoutUndefined,
                  }[key] === value;
            })
              ? [...acc, cvClass, cvClassName]
              : acc;
          }, []);
  return cx(
    base,
    getVariantClassNames,
    getCompoundVariantClassNames,
    props === null || props === void 0 ? void 0 : props.class,
    props === null || props === void 0 ? void 0 : props.className,
  );
};
function Tabs({ className, orientation = "horizontal", ...props }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TabsRoot, {
    "data-slot": "tabs",
    "data-orientation": orientation,
    className: cn("gap-2 group/tabs flex data-[orientation=horizontal]:flex-col", className),
    ...props,
  });
}
const tabsListVariants = cva(
  "rounded-none p-[3px] group-data-horizontal/tabs:h-8 data-[variant=line]:rounded-none group/tabs-list text-muted-foreground inline-flex w-fit items-center justify-center group-data-[orientation=vertical]/tabs:h-fit group-data-[orientation=vertical]/tabs:flex-col",
  {
    variants: {
      variant: {
        default: "bg-muted",
        line: "gap-1 bg-transparent",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  },
);
function TabsList({ className, variant = "default", ...props }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TabsList$1, {
    "data-slot": "tabs-list",
    "data-variant": variant,
    className: cn(tabsListVariants({ variant }), className),
    ...props,
  });
}
function TabsTrigger({ className, ...props }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TabsTab, {
    "data-slot": "tabs-trigger",
    className: cn(
      "gap-1.5 rounded-none border border-transparent px-1.5 py-0.5 text-xs font-medium group-data-vertical/tabs:py-[calc(--spacing(1.25))] [&_svg:not([class*='size-'])]:size-4 focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring text-foreground/60 hover:text-foreground dark:text-muted-foreground dark:hover:text-foreground relative inline-flex h-[calc(100%-1px)] flex-1 items-center justify-center whitespace-nowrap transition-all group-data-[orientation=vertical]/tabs:w-full group-data-[orientation=vertical]/tabs:justify-start focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0",
      "group-data-[variant=line]/tabs-list:bg-transparent group-data-[variant=line]/tabs-list:data-active:bg-transparent dark:group-data-[variant=line]/tabs-list:data-active:border-transparent dark:group-data-[variant=line]/tabs-list:data-active:bg-transparent",
      "data-active:bg-background dark:data-active:text-foreground dark:data-active:border-input dark:data-active:bg-input/30 data-active:text-foreground",
      "after:bg-foreground after:absolute after:opacity-0 after:transition-opacity group-data-[orientation=horizontal]/tabs:after:inset-x-0 group-data-[orientation=horizontal]/tabs:after:bottom-[-5px] group-data-[orientation=horizontal]/tabs:after:h-0.5 group-data-[orientation=vertical]/tabs:after:inset-y-0 group-data-[orientation=vertical]/tabs:after:-right-1 group-data-[orientation=vertical]/tabs:after:w-0.5 group-data-[variant=line]/tabs-list:data-active:after:opacity-100",
      className,
    ),
    ...props,
  });
}
function TabsContent({ className, ...props }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TabsPanel, {
    "data-slot": "tabs-content",
    className: cn("text-xs/relaxed flex-1 outline-none", className),
    ...props,
  });
}
const TooltipRootContext = /* @__PURE__ */ reactExports.createContext(void 0);
function useTooltipRootContext(optional) {
  const context = reactExports.useContext(TooltipRootContext);
  if (context === void 0 && !optional) {
    throw new Error(formatErrorMessage(72));
  }
  return context;
}
const selectors = {
  ...popupStoreSelectors,
  disabled: createSelector((state) => state.disabled),
  instantType: createSelector((state) => state.instantType),
  isInstantPhase: createSelector((state) => state.isInstantPhase),
  trackCursorAxis: createSelector((state) => state.trackCursorAxis),
  disableHoverablePopup: createSelector((state) => state.disableHoverablePopup),
  lastOpenChangeReason: createSelector((state) => state.openChangeReason),
  closeDelay: createSelector((state) => state.closeDelay),
  hasViewport: createSelector((state) => state.hasViewport),
};
class TooltipStore extends ReactStore {
  constructor(initialState) {
    super(
      {
        ...createInitialState(),
        ...initialState,
      },
      {
        popupRef: /* @__PURE__ */ reactExports.createRef(),
        onOpenChange: void 0,
        onOpenChangeComplete: void 0,
        triggerElements: new PopupTriggerMap(),
      },
      selectors,
    );
    __publicField(this, "setOpen", (nextOpen, eventDetails) => {
      var _a2, _b;
      const reason = eventDetails.reason;
      const isHover = reason === triggerHover;
      const isFocusOpen = nextOpen && reason === triggerFocus;
      const isDismissClose = !nextOpen && (reason === triggerPress || reason === escapeKey);
      eventDetails.preventUnmountOnClose = () => {
        this.set("preventUnmountingOnClose", true);
      };
      (_b = (_a2 = this.context).onOpenChange) == null
        ? void 0
        : _b.call(_a2, nextOpen, eventDetails);
      if (eventDetails.isCanceled) {
        return;
      }
      const changeState = () => {
        var _a3;
        const updatedState = {
          open: nextOpen,
          openChangeReason: reason,
        };
        if (isFocusOpen) {
          updatedState.instantType = "focus";
        } else if (isDismissClose) {
          updatedState.instantType = "dismiss";
        } else if (reason === triggerHover) {
          updatedState.instantType = void 0;
        }
        const newTriggerId = ((_a3 = eventDetails.trigger) == null ? void 0 : _a3.id) ?? null;
        if (newTriggerId || nextOpen) {
          updatedState.activeTriggerId = newTriggerId;
          updatedState.activeTriggerElement = eventDetails.trigger ?? null;
        }
        this.update(updatedState);
      };
      if (isHover) {
        reactDomExports.flushSync(changeState);
      } else {
        changeState();
      }
    });
  }
  static useStore(externalStore, initialState) {
    const internalStore = useRefWithInit(() => {
      return new TooltipStore(initialState);
    }).current;
    const store = externalStore ?? internalStore;
    const floatingRootContext = useSyncedFloatingRootContext({
      popupStore: store,
      onOpenChange: store.setOpen,
    });
    store.state.floatingRootContext = floatingRootContext;
    return store;
  }
}
function createInitialState() {
  return {
    ...createInitialPopupStoreState(),
    disabled: false,
    instantType: void 0,
    isInstantPhase: false,
    trackCursorAxis: "none",
    disableHoverablePopup: false,
    openChangeReason: null,
    closeDelay: 0,
    hasViewport: false,
  };
}
function TooltipRoot(props) {
  const {
    disabled: disabled$1 = false,
    defaultOpen = false,
    open: openProp,
    disableHoverablePopup = false,
    trackCursorAxis = "none",
    actionsRef,
    onOpenChange,
    onOpenChangeComplete,
    handle,
    triggerId: triggerIdProp,
    defaultTriggerId: defaultTriggerIdProp = null,
    children,
  } = props;
  const store = TooltipStore.useStore(handle == null ? void 0 : handle.store, {
    open: openProp ?? defaultOpen,
    activeTriggerId: triggerIdProp !== void 0 ? triggerIdProp : defaultTriggerIdProp,
  });
  store.useControlledProp("open", openProp, defaultOpen);
  store.useControlledProp("activeTriggerId", triggerIdProp, defaultTriggerIdProp);
  store.useContextCallback("onOpenChange", onOpenChange);
  store.useContextCallback("onOpenChangeComplete", onOpenChangeComplete);
  const openState = store.useState("open");
  const open = !disabled$1 && openState;
  const activeTriggerId = store.useState("activeTriggerId");
  const payload = store.useState("payload");
  store.useSyncedValues({
    trackCursorAxis,
    disableHoverablePopup,
  });
  useIsoLayoutEffect(() => {
    if (openState && disabled$1) {
      store.setOpen(false, createChangeEventDetails(disabled));
    }
  }, [openState, disabled$1, store]);
  store.useSyncedValue("disabled", disabled$1);
  useImplicitActiveTrigger(store);
  const { forceUnmount, transitionStatus } = useOpenStateTransitions(open, store);
  const isInstantPhase = store.useState("isInstantPhase");
  const instantType = store.useState("instantType");
  const lastOpenChangeReason = store.useState("lastOpenChangeReason");
  const previousInstantTypeRef = reactExports.useRef(null);
  useIsoLayoutEffect(() => {
    if (
      (transitionStatus === "ending" && lastOpenChangeReason === none) ||
      (transitionStatus !== "ending" && isInstantPhase)
    ) {
      if (instantType !== "delay") {
        previousInstantTypeRef.current = instantType;
      }
      store.set("instantType", "delay");
    } else if (previousInstantTypeRef.current !== null) {
      store.set("instantType", previousInstantTypeRef.current);
      previousInstantTypeRef.current = null;
    }
  }, [transitionStatus, isInstantPhase, lastOpenChangeReason, instantType, store]);
  useIsoLayoutEffect(() => {
    if (open) {
      if (activeTriggerId == null) {
        store.set("payload", void 0);
      }
    }
  }, [store, activeTriggerId, open]);
  const handleImperativeClose = reactExports.useCallback(() => {
    store.setOpen(false, createTooltipEventDetails(store, imperativeAction));
  }, [store]);
  reactExports.useImperativeHandle(
    actionsRef,
    () => ({
      unmount: forceUnmount,
      close: handleImperativeClose,
    }),
    [forceUnmount, handleImperativeClose],
  );
  const floatingRootContext = store.useState("floatingRootContext");
  const focus = useFocus(floatingRootContext, {
    enabled: !disabled$1,
  });
  const dismiss = useDismiss(floatingRootContext, {
    enabled: !disabled$1,
    referencePress: true,
  });
  const clientPoint = useClientPoint(floatingRootContext, {
    enabled: !disabled$1 && trackCursorAxis !== "none",
    axis: trackCursorAxis === "none" ? void 0 : trackCursorAxis,
  });
  const { getReferenceProps, getFloatingProps, getTriggerProps } = useInteractions([
    focus,
    dismiss,
    clientPoint,
  ]);
  const activeTriggerProps = reactExports.useMemo(() => getReferenceProps(), [getReferenceProps]);
  const inactiveTriggerProps = reactExports.useMemo(() => getTriggerProps(), [getTriggerProps]);
  const popupProps = reactExports.useMemo(() => getFloatingProps(), [getFloatingProps]);
  store.useSyncedValues({
    activeTriggerProps,
    inactiveTriggerProps,
    popupProps,
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipRootContext.Provider, {
    value: store,
    children:
      typeof children === "function"
        ? children({
            payload,
          })
        : children,
  });
}
function createTooltipEventDetails(store, reason) {
  const details = createChangeEventDetails(reason);
  details.preventUnmountOnClose = () => {
    store.set("preventUnmountingOnClose", true);
  };
  return details;
}
const TooltipProviderContext = /* @__PURE__ */ reactExports.createContext(void 0);
function useTooltipProviderContext() {
  return reactExports.useContext(TooltipProviderContext);
}
const OPEN_DELAY = 600;
const TooltipTrigger$1 = /* @__PURE__ */ reactExports.forwardRef(
  function TooltipTrigger2(componentProps, forwardedRef) {
    const {
      className,
      render,
      handle,
      payload,
      disabled: disabledProp,
      delay: delay2,
      closeDelay,
      id: idProp,
      ...elementProps
    } = componentProps;
    const rootContext = useTooltipRootContext(true);
    const store = (handle == null ? void 0 : handle.store) ?? rootContext;
    if (!store) {
      throw new Error(formatErrorMessage(82));
    }
    const thisTriggerId = useBaseUiId(idProp);
    const isTriggerActive = store.useState("isTriggerActive", thisTriggerId);
    const isOpenedByThisTrigger = store.useState("isOpenedByTrigger", thisTriggerId);
    const floatingRootContext = store.useState("floatingRootContext");
    const triggerElementRef = reactExports.useRef(null);
    const delayWithDefault = delay2 ?? OPEN_DELAY;
    const closeDelayWithDefault = closeDelay ?? 0;
    const { registerTrigger, isMountedByThisTrigger } = useTriggerDataForwarding(
      thisTriggerId,
      triggerElementRef,
      store,
      {
        payload,
        closeDelay: closeDelayWithDefault,
      },
    );
    const providerContext = useTooltipProviderContext();
    const { delayRef, isInstantPhase, hasProvider } = useDelayGroup(floatingRootContext, {
      open: isOpenedByThisTrigger,
    });
    store.useSyncedValue("isInstantPhase", isInstantPhase);
    const rootDisabled = store.useState("disabled");
    const disabled2 = disabledProp ?? rootDisabled;
    const trackCursorAxis = store.useState("trackCursorAxis");
    const disableHoverablePopup = store.useState("disableHoverablePopup");
    const hoverProps = useHoverReferenceInteraction(floatingRootContext, {
      enabled: !disabled2,
      mouseOnly: true,
      move: false,
      handleClose: !disableHoverablePopup && trackCursorAxis !== "both" ? safePolygon() : null,
      restMs() {
        const providerDelay = providerContext == null ? void 0 : providerContext.delay;
        const groupOpenValue =
          typeof delayRef.current === "object" ? delayRef.current.open : void 0;
        let computedRestMs = delayWithDefault;
        if (hasProvider) {
          if (groupOpenValue !== 0) {
            computedRestMs = delay2 ?? providerDelay ?? delayWithDefault;
          } else {
            computedRestMs = 0;
          }
        }
        return computedRestMs;
      },
      delay() {
        const closeValue = typeof delayRef.current === "object" ? delayRef.current.close : void 0;
        let computedCloseDelay = closeDelayWithDefault;
        if (closeDelay == null && hasProvider) {
          computedCloseDelay = closeValue;
        }
        return {
          close: computedCloseDelay,
        };
      },
      triggerElementRef,
      isActiveTrigger: isTriggerActive,
    });
    const state = reactExports.useMemo(
      () => ({
        open: isOpenedByThisTrigger,
      }),
      [isOpenedByThisTrigger],
    );
    const rootTriggerProps = store.useState("triggerProps", isMountedByThisTrigger);
    const element = useRenderElement("button", componentProps, {
      state,
      ref: [forwardedRef, registerTrigger, triggerElementRef],
      props: [
        hoverProps,
        rootTriggerProps,
        {
          id: thisTriggerId,
        },
        elementProps,
      ],
      stateAttributesMapping: triggerOpenStateMapping,
    });
    return element;
  },
);
const TooltipPortalContext = /* @__PURE__ */ reactExports.createContext(void 0);
function useTooltipPortalContext() {
  const value = reactExports.useContext(TooltipPortalContext);
  if (value === void 0) {
    throw new Error(formatErrorMessage(70));
  }
  return value;
}
const FloatingPortalLite = /* @__PURE__ */ reactExports.forwardRef(
  function FloatingPortalLite2(componentProps, forwardedRef) {
    const { children, container, className, render, ...elementProps } = componentProps;
    const { portalNode, portalSubtree } = useFloatingPortalNode({
      container,
      ref: forwardedRef,
      componentProps,
      elementProps,
    });
    if (!portalSubtree && !portalNode) {
      return null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
      children: [
        portalSubtree,
        portalNode && /* @__PURE__ */ reactDomExports.createPortal(children, portalNode),
      ],
    });
  },
);
const TooltipPortal = /* @__PURE__ */ reactExports.forwardRef(
  function TooltipPortal2(props, forwardedRef) {
    const { keepMounted = false, ...portalProps } = props;
    const store = useTooltipRootContext();
    const mounted = store.useState("mounted");
    const shouldRender = mounted || keepMounted;
    if (!shouldRender) {
      return null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipPortalContext.Provider, {
      value: keepMounted,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(FloatingPortalLite, {
        ref: forwardedRef,
        ...portalProps,
      }),
    });
  },
);
const TooltipPositionerContext = /* @__PURE__ */ reactExports.createContext(void 0);
function useTooltipPositionerContext() {
  const context = reactExports.useContext(TooltipPositionerContext);
  if (context === void 0) {
    throw new Error(formatErrorMessage(71));
  }
  return context;
}
const TooltipPositioner = /* @__PURE__ */ reactExports.forwardRef(
  function TooltipPositioner2(componentProps, forwardedRef) {
    const {
      render,
      className,
      anchor,
      positionMethod = "absolute",
      side = "top",
      align = "center",
      sideOffset = 0,
      alignOffset = 0,
      collisionBoundary = "clipping-ancestors",
      collisionPadding = 5,
      arrowPadding = 5,
      sticky = false,
      disableAnchorTracking = false,
      collisionAvoidance = POPUP_COLLISION_AVOIDANCE,
      ...elementProps
    } = componentProps;
    const store = useTooltipRootContext();
    const keepMounted = useTooltipPortalContext();
    const open = store.useState("open");
    const mounted = store.useState("mounted");
    const trackCursorAxis = store.useState("trackCursorAxis");
    const disableHoverablePopup = store.useState("disableHoverablePopup");
    const floatingRootContext = store.useState("floatingRootContext");
    const instantType = store.useState("instantType");
    const transitionStatus = store.useState("transitionStatus");
    const hasViewport = store.useState("hasViewport");
    const positioning = useAnchorPositioning({
      anchor,
      positionMethod,
      floatingRootContext,
      mounted,
      side,
      sideOffset,
      align,
      alignOffset,
      collisionBoundary,
      collisionPadding,
      sticky,
      arrowPadding,
      disableAnchorTracking,
      keepMounted,
      collisionAvoidance,
      adaptiveOrigin: hasViewport ? adaptiveOrigin : void 0,
    });
    const defaultProps = reactExports.useMemo(() => {
      const hiddenStyles = {};
      if (!open || trackCursorAxis === "both" || disableHoverablePopup) {
        hiddenStyles.pointerEvents = "none";
      }
      return {
        role: "presentation",
        hidden: !mounted,
        style: {
          ...positioning.positionerStyles,
          ...hiddenStyles,
        },
      };
    }, [open, trackCursorAxis, disableHoverablePopup, mounted, positioning.positionerStyles]);
    const state = reactExports.useMemo(
      () => ({
        open,
        side: positioning.side,
        align: positioning.align,
        anchorHidden: positioning.anchorHidden,
        instant: trackCursorAxis !== "none" ? "tracking-cursor" : instantType,
      }),
      [
        open,
        positioning.side,
        positioning.align,
        positioning.anchorHidden,
        trackCursorAxis,
        instantType,
      ],
    );
    const contextValue = reactExports.useMemo(
      () => ({
        ...state,
        arrowRef: positioning.arrowRef,
        arrowStyles: positioning.arrowStyles,
        arrowUncentered: positioning.arrowUncentered,
      }),
      [state, positioning.arrowRef, positioning.arrowStyles, positioning.arrowUncentered],
    );
    const element = useRenderElement("div", componentProps, {
      state,
      props: [defaultProps, getDisabledMountTransitionStyles(transitionStatus), elementProps],
      ref: [forwardedRef, store.useStateSetter("positionerElement")],
      stateAttributesMapping: popupStateMapping,
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipPositionerContext.Provider, {
      value: contextValue,
      children: element,
    });
  },
);
const stateAttributesMapping$1 = {
  ...popupStateMapping,
  ...transitionStatusMapping,
};
const TooltipPopup = /* @__PURE__ */ reactExports.forwardRef(
  function TooltipPopup2(componentProps, forwardedRef) {
    const { className, render, ...elementProps } = componentProps;
    const store = useTooltipRootContext();
    const { side, align } = useTooltipPositionerContext();
    const open = store.useState("open");
    const instantType = store.useState("instantType");
    const transitionStatus = store.useState("transitionStatus");
    const popupProps = store.useState("popupProps");
    const floatingContext = store.useState("floatingRootContext");
    useOpenChangeComplete({
      open,
      ref: store.context.popupRef,
      onComplete() {
        var _a2, _b;
        if (open) {
          (_b = (_a2 = store.context).onOpenChangeComplete) == null ? void 0 : _b.call(_a2, true);
        }
      },
    });
    const disabled2 = store.useState("disabled");
    const closeDelay = store.useState("closeDelay");
    useHoverFloatingInteraction(floatingContext, {
      enabled: !disabled2,
      closeDelay,
    });
    const state = reactExports.useMemo(
      () => ({
        open,
        side,
        align,
        instant: instantType,
        transitionStatus,
      }),
      [open, side, align, instantType, transitionStatus],
    );
    const element = useRenderElement("div", componentProps, {
      state,
      ref: [forwardedRef, store.context.popupRef, store.useStateSetter("popupElement")],
      props: [popupProps, getDisabledMountTransitionStyles(transitionStatus), elementProps],
      stateAttributesMapping: stateAttributesMapping$1,
    });
    return element;
  },
);
const TooltipArrow = /* @__PURE__ */ reactExports.forwardRef(
  function TooltipArrow2(componentProps, forwardedRef) {
    const { className, render, ...elementProps } = componentProps;
    const store = useTooltipRootContext();
    const instantType = store.useState("instantType");
    const { open, arrowRef, side, align, arrowUncentered, arrowStyles } =
      useTooltipPositionerContext();
    const state = reactExports.useMemo(
      () => ({
        open,
        side,
        align,
        uncentered: arrowUncentered,
        instant: instantType,
      }),
      [open, side, align, arrowUncentered, instantType],
    );
    const element = useRenderElement("div", componentProps, {
      state,
      ref: [forwardedRef, arrowRef],
      props: [
        {
          style: arrowStyles,
          "aria-hidden": true,
        },
        elementProps,
      ],
      stateAttributesMapping: popupStateMapping,
    });
    return element;
  },
);
const TooltipProvider$1 = function TooltipProvider2(props) {
  const { delay: delay2, closeDelay, timeout = 400 } = props;
  const contextValue = reactExports.useMemo(
    () => ({
      delay: delay2,
      closeDelay,
    }),
    [delay2, closeDelay],
  );
  const delayValue = reactExports.useMemo(
    () => ({
      open: delay2,
      close: closeDelay,
    }),
    [delay2, closeDelay],
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipProviderContext.Provider, {
    value: contextValue,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(FloatingDelayGroup, {
      delay: delayValue,
      timeoutMs: timeout,
      children: props.children,
    }),
  });
};
function TooltipProvider({ delay: delay2 = 0, ...props }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipProvider$1, {
    "data-slot": "tooltip-provider",
    delay: delay2,
    ...props,
  });
}
function Tooltip({ delay: delay2, ...props }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipProvider, {
    delay: delay2,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipRoot, {
      "data-slot": "tooltip",
      ...props,
    }),
  });
}
function TooltipTrigger({ ...props }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipTrigger$1, {
    "data-slot": "tooltip-trigger",
    ...props,
  });
}
function TooltipContent({
  className,
  side = "top",
  sideOffset = 4,
  align = "center",
  alignOffset = 0,
  children,
  ...props
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipPortal, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipPositioner, {
      align,
      alignOffset,
      side,
      sideOffset,
      className: "isolate z-50",
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(TooltipPopup, {
        "data-slot": "tooltip-content",
        className: cn(
          "data-open:animate-in data-open:fade-in-0 data-open:zoom-in-95 data-[state=delayed-open]:animate-in data-[state=delayed-open]:fade-in-0 data-[state=delayed-open]:zoom-in-95 data-closed:animate-out data-closed:fade-out-0 data-closed:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 rounded-none px-3 py-1.5 text-xs bg-foreground text-background z-50 w-fit max-w-xs origin-(--transform-origin)",
          className,
        ),
        ...props,
        children: [
          children,
          /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipArrow, {
            className:
              "size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-none bg-foreground fill-foreground z-50 data-[side=bottom]:top-1 data-[side=left]:top-1/2! data-[side=left]:-right-1 data-[side=left]:-translate-y-1/2 data-[side=right]:top-1/2! data-[side=right]:-left-1 data-[side=right]:-translate-y-1/2 data-[side=top]:-bottom-2.5",
          }),
        ],
      }),
    }),
  });
}
function searchToStack(search) {
  if (!search) return DEFAULT_STACK;
  return {
    ecosystem: search.eco ?? DEFAULT_STACK.ecosystem,
    projectName: search.name ?? DEFAULT_STACK.projectName,
    webFrontend: search["fe-w"] ?? DEFAULT_STACK.webFrontend,
    nativeFrontend: search["fe-n"] ?? DEFAULT_STACK.nativeFrontend,
    astroIntegration: search.ai ?? DEFAULT_STACK.astroIntegration,
    cssFramework: search.css ?? DEFAULT_STACK.cssFramework,
    uiLibrary: search.ui ?? DEFAULT_STACK.uiLibrary,
    runtime: search.rt ?? DEFAULT_STACK.runtime,
    backend: search.be ?? DEFAULT_STACK.backend,
    api: search.api ?? DEFAULT_STACK.api,
    database: search.db ?? DEFAULT_STACK.database,
    orm: search.orm ?? DEFAULT_STACK.orm,
    dbSetup: search.dbs ?? DEFAULT_STACK.dbSetup,
    auth: search.au ?? DEFAULT_STACK.auth,
    payments: search.pay ?? DEFAULT_STACK.payments,
    email: search.em ?? DEFAULT_STACK.email,
    fileUpload: search.fu ?? DEFAULT_STACK.fileUpload,
    logging: search.log ?? DEFAULT_STACK.logging,
    observability: search.obs ?? DEFAULT_STACK.observability,
    backendLibraries: search.bl ?? DEFAULT_STACK.backendLibraries,
    stateManagement: search.sm ?? DEFAULT_STACK.stateManagement,
    validation: search.val ?? DEFAULT_STACK.validation,
    testing: search.tst ?? DEFAULT_STACK.testing,
    realtime: search.rt2 ?? DEFAULT_STACK.realtime,
    jobQueue: search.jq ?? DEFAULT_STACK.jobQueue,
    caching: search.cache ?? DEFAULT_STACK.caching,
    animation: search.anim ?? DEFAULT_STACK.animation,
    cms: search.cms ?? DEFAULT_STACK.cms,
    codeQuality: search.cq ?? DEFAULT_STACK.codeQuality,
    documentation: search.doc ?? DEFAULT_STACK.documentation,
    appPlatforms: search.ap ?? DEFAULT_STACK.appPlatforms,
    packageManager: search.pm ?? DEFAULT_STACK.packageManager,
    examples: search.ex ?? DEFAULT_STACK.examples,
    aiSdk: search.aisdk ?? DEFAULT_STACK.aiSdk,
    git: search.git ?? DEFAULT_STACK.git,
    install: search.i ?? DEFAULT_STACK.install,
    webDeploy: search.wd ?? DEFAULT_STACK.webDeploy,
    serverDeploy: search.sd ?? DEFAULT_STACK.serverDeploy,
    yolo: search.yolo ?? DEFAULT_STACK.yolo,
    // Rust ecosystem fields
    rustWebFramework: search.rwf ?? DEFAULT_STACK.rustWebFramework,
    rustFrontend: search.rfe ?? DEFAULT_STACK.rustFrontend,
    rustOrm: search.rorm ?? DEFAULT_STACK.rustOrm,
    rustApi: search.rapi ?? DEFAULT_STACK.rustApi,
    rustCli: search.rcli ?? DEFAULT_STACK.rustCli,
    rustLibraries: search.rlib ?? DEFAULT_STACK.rustLibraries,
  };
}
function useStackState() {
  const [stack, setStackState] = reactExports.useState(DEFAULT_STACK);
  const [viewMode, setViewModeState] = reactExports.useState("command");
  const [selectedFile, setSelectedFileState] = reactExports.useState("");
  const initialized = reactExports.useRef(false);
  const search = useSearch({ from: "/new", strict: false });
  reactExports.useEffect(() => {
    if (!initialized.current && search) {
      initialized.current = true;
      const initialStack = searchToStack(search);
      setStackState(initialStack);
      setViewModeState(search.view || "command");
      setSelectedFileState(search.file || "");
    }
  }, [search]);
  const updateStack = reactExports.useCallback((updates) => {
    console.log("[useStackState] updateStack called with:", updates);
    setStackState((currentStack) => {
      const newUpdates = typeof updates === "function" ? updates(currentStack) : updates;
      console.log("[useStackState] newUpdates:", newUpdates);
      const merged = { ...currentStack, ...newUpdates };
      console.log("[useStackState] merged result:", merged);
      return merged;
    });
  }, []);
  const setViewMode = reactExports.useCallback((mode) => {
    setViewModeState(mode);
  }, []);
  const setSelectedFile = reactExports.useCallback((filePath) => {
    setSelectedFileState(filePath || "");
  }, []);
  return [stack, updateStack, viewMode, setViewMode, selectedFile, setSelectedFile];
}
const stackUrlKeys = {
  ecosystem: "eco",
  projectName: "name",
  webFrontend: "fe-w",
  nativeFrontend: "fe-n",
  astroIntegration: "ai",
  cssFramework: "css",
  uiLibrary: "ui",
  runtime: "rt",
  backend: "be",
  api: "api",
  database: "db",
  orm: "orm",
  dbSetup: "dbs",
  auth: "au",
  payments: "pay",
  email: "em",
  fileUpload: "fu",
  logging: "log",
  observability: "obs",
  backendLibraries: "bl",
  stateManagement: "sm",
  validation: "val",
  testing: "tst",
  realtime: "rt2",
  jobQueue: "jq",
  caching: "cache",
  animation: "anim",
  cms: "cms",
  codeQuality: "cq",
  documentation: "doc",
  appPlatforms: "ap",
  packageManager: "pm",
  examples: "ex",
  aiSdk: "aisdk",
  git: "git",
  install: "i",
  webDeploy: "wd",
  serverDeploy: "sd",
  yolo: "yolo",
  rustWebFramework: "rwf",
  rustFrontend: "rfe",
  rustOrm: "rorm",
  rustApi: "rapi",
  rustCli: "rcli",
  rustLibraries: "rlib",
};
const TYPESCRIPT_CATEGORY_ORDER = [
  "webFrontend",
  "nativeFrontend",
  "astroIntegration",
  "cssFramework",
  "uiLibrary",
  "backend",
  "backendLibraries",
  "runtime",
  "api",
  "database",
  "orm",
  "dbSetup",
  "webDeploy",
  "serverDeploy",
  "auth",
  "payments",
  "email",
  "fileUpload",
  "logging",
  "observability",
  "cms",
  "codeQuality",
  "documentation",
  "appPlatforms",
  "packageManager",
  "examples",
  "git",
  "install",
];
const RUST_CATEGORY_ORDER = [
  "rustWebFramework",
  "rustFrontend",
  "rustOrm",
  "rustApi",
  "rustCli",
  "rustLibraries",
  "git",
  "install",
];
const CATEGORY_ORDER = [
  ...TYPESCRIPT_CATEGORY_ORDER,
  // Rust categories (excluding duplicates like git, install)
  "rustWebFramework",
  "rustFrontend",
  "rustOrm",
  "rustApi",
  "rustCli",
  "rustLibraries",
];
function generateStackCommand(stack) {
  const projectName = stack.projectName || "my-better-t-app";
  if (stack.ecosystem === "rust") {
    return generateRustCommand(stack, projectName);
  }
  const packageManagerCommands = {
    npm: "npx create-better-t-stack@latest",
    pnpm: "pnpm create better-t-stack@latest",
    default: "bun create better-t-stack@latest",
  };
  const base = packageManagerCommands[stack.packageManager] || packageManagerCommands.default;
  const isStackDefaultExceptProjectName = Object.entries(DEFAULT_STACK).every(
    ([key]) => key === "projectName" || isStackDefault(stack, key, stack[key]),
  );
  if (isStackDefaultExceptProjectName) {
    return `${base} ${projectName} --yes`;
  }
  const mapBackendToCli = (backend) => {
    if (backend === "self-next" || backend === "self-tanstack-start" || backend === "self-astro") {
      return "self";
    }
    return backend;
  };
  const flags = [
    `--frontend ${[...stack.webFrontend, ...stack.nativeFrontend].filter((v, _, arr) => v !== "none" || arr.length === 1).join(" ") || "none"}`,
    // Add astro-integration flag only when Astro is selected
    ...(stack.webFrontend.includes("astro") && stack.astroIntegration !== "none"
      ? [`--astro-integration ${stack.astroIntegration}`]
      : []),
    `--css-framework ${stack.cssFramework}`,
    `--ui-library ${stack.uiLibrary}`,
    `--backend ${mapBackendToCli(stack.backend)}`,
    `--runtime ${stack.runtime}`,
    `--api ${stack.api}`,
    `--auth ${stack.auth}`,
    `--payments ${stack.payments}`,
    `--email ${stack.email}`,
    `--file-upload ${stack.fileUpload}`,
    `--logging ${stack.logging}`,
    `--observability ${stack.observability}`,
    `--job-queue ${stack.jobQueue}`,
    `--cms ${stack.cms}`,
    `--effect ${stack.backendLibraries}`,
    `--database ${stack.database}`,
    `--orm ${stack.orm}`,
    `--db-setup ${stack.dbSetup}`,
    `--package-manager ${stack.packageManager}`,
    stack.git === "false" ? "--no-git" : "--git",
    `--web-deploy ${stack.webDeploy}`,
    `--server-deploy ${stack.serverDeploy}`,
    stack.install === "false" ? "--no-install" : "--install",
    `--addons ${
      [...stack.codeQuality, ...stack.documentation, ...stack.appPlatforms].length > 0
        ? [...stack.codeQuality, ...stack.documentation, ...stack.appPlatforms]
            .filter((addon) =>
              [
                "pwa",
                "tauri",
                "starlight",
                "biome",
                "lefthook",
                "husky",
                "turborepo",
                "ultracite",
                "fumadocs",
                "oxlint",
                "ruler",
                "opentui",
                "wxt",
              ].includes(addon),
            )
            .join(" ") || "none"
        : "none"
    }`,
    `--examples ${stack.examples.join(" ") || "none"}`,
  ];
  if (stack.yolo === "true") {
    flags.push("--yolo");
  }
  return `${base} ${projectName} ${flags.join(" ")}`;
}
function generateRustCommand(stack, projectName) {
  const flags = [];
  if (stack.rustWebFramework !== "none") {
    flags.push(`--web-framework ${stack.rustWebFramework}`);
  }
  if (stack.rustFrontend !== "none") {
    flags.push(`--frontend ${stack.rustFrontend}`);
  }
  if (stack.rustOrm !== "none") {
    flags.push(`--orm ${stack.rustOrm}`);
  }
  if (stack.rustApi !== "none") {
    flags.push(`--api ${stack.rustApi}`);
  }
  if (stack.rustCli !== "none") {
    flags.push(`--cli ${stack.rustCli}`);
  }
  if (stack.rustLibraries !== "none" && stack.rustLibraries !== "serde") {
    flags.push(`--libraries ${stack.rustLibraries}`);
  }
  if (stack.git === "false") {
    flags.push("--no-git");
  }
  const base = "cargo new";
  const flagStr = flags.length > 0 ? ` # Options: ${flags.join(" ")}` : "";
  return `${base} ${projectName}${flagStr}`;
}
function generateStackSharingUrl(stack, baseUrl) {
  const origin = "https://better-t-stack.dev";
  const stackParams = new URLSearchParams();
  Object.entries(stackUrlKeys).forEach(([stackKey, urlKey]) => {
    const value = stack[stackKey];
    if (value !== void 0) {
      stackParams.set(urlKey, Array.isArray(value) ? value.join(",") : String(value));
    }
  });
  const searchString = stackParams.toString();
  return `${origin}/stack${searchString ? `?${searchString}` : ""}`;
}
function ActionButtons({ onReset, onRandom, onSave, onLoad, hasSavedStack }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
    className: "flex gap-1",
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("button", {
        type: "button",
        onClick: onReset,
        className:
          "flex flex-1 items-center justify-center gap-1.5 rounded-md border border-border bg-fd-background px-2 py-1.5 font-medium text-muted-foreground text-xs transition-all hover:border-muted-foreground/30 hover:bg-muted hover:text-foreground",
        title: "Reset to defaults",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(RefreshCw, { className: "h-3 w-3" }),
          "Reset",
        ],
      }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("button", {
        type: "button",
        onClick: onRandom,
        className:
          "flex flex-1 items-center justify-center gap-1.5 rounded-md border border-border bg-fd-background px-2 py-1.5 font-medium text-muted-foreground text-xs transition-all hover:border-muted-foreground/30 hover:bg-muted hover:text-foreground",
        title: "Generate a random stack",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Shuffle, { className: "h-3 w-3" }),
          "Random",
        ],
      }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("button", {
        type: "button",
        onClick: onSave,
        className:
          "flex flex-1 items-center justify-center gap-1.5 rounded-md border border-border bg-fd-background px-2 py-1.5 font-medium text-muted-foreground text-xs transition-all hover:border-muted-foreground/30 hover:bg-muted hover:text-foreground",
        title: "Save current preferences",
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx(Star, { className: "h-3 w-3" }), "Save"],
      }),
      hasSavedStack &&
        /* @__PURE__ */ jsxRuntimeExports.jsxs("button", {
          type: "button",
          onClick: onLoad,
          className:
            "flex flex-1 items-center justify-center gap-1.5 rounded-md border border-border bg-fd-background px-2 py-1.5 font-medium text-muted-foreground text-xs transition-all hover:border-muted-foreground/30 hover:bg-muted hover:text-foreground",
          title: "Load saved preferences",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Settings, { className: "h-3 w-3" }),
            "Load",
          ],
        }),
    ],
  });
}
const getBadgeColors = (category) => {
  switch (category) {
    case "webFrontend":
    case "nativeFrontend":
      return "border-primary/30 bg-primary/10 text-primary";
    case "runtime":
      return "border-accent/30 bg-accent/10 text-accent";
    case "backend":
      return "border-primary/40 bg-primary/15 text-primary";
    case "api":
      return "border-primary/50 bg-primary/20 text-primary";
    case "database":
      return "border-accent/40 bg-accent/15 text-accent";
    case "orm":
      return "border-primary/35 bg-primary/12 text-primary";
    case "auth":
      return "border-accent/35 bg-accent/12 text-accent";
    case "payments":
      return "border-purple-500/30 bg-purple-500/10 text-purple-600 dark:text-purple-400";
    case "email":
      return "border-gray-500/30 bg-gray-500/10 text-gray-600 dark:text-gray-400";
    case "dbSetup":
      return "border-primary/30 bg-primary/10 text-primary";
    case "cssFramework":
      return "border-cyan-500/30 bg-cyan-500/10 text-cyan-600 dark:text-cyan-400";
    case "uiLibrary":
      return "border-violet-500/30 bg-violet-500/10 text-violet-600 dark:text-violet-400";
    case "backendLibraries":
      return "border-indigo-500/30 bg-indigo-500/10 text-indigo-600 dark:text-indigo-400";
    case "codeQuality":
      return "border-emerald-500/30 bg-emerald-500/10 text-emerald-600 dark:text-emerald-400";
    case "documentation":
      return "border-amber-500/30 bg-amber-500/10 text-amber-600 dark:text-amber-400";
    case "appPlatforms":
      return "border-accent/50 bg-accent/20 text-accent";
    case "examples":
      return "border-primary/40 bg-primary/15 text-primary";
    case "packageManager":
      return "border-muted-foreground/30 bg-muted text-muted-foreground";
    case "git":
    case "webDeploy":
    case "serverDeploy":
    case "install":
      return "border-muted-foreground/30 bg-muted text-muted-foreground";
    default:
      return "border-muted-foreground/30 bg-muted text-muted-foreground";
  }
};
function PresetDropdown({ onApplyPreset }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(DropdownMenu, {
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(DropdownMenuTrigger, {
        render: /* @__PURE__ */ jsxRuntimeExports.jsx("button", {
          type: "button",
          className:
            "flex flex-1 items-center justify-center gap-1.5 rounded-md border border-border bg-fd-background px-2 py-1.5 font-medium text-muted-foreground text-xs transition-all hover:border-muted-foreground/30 hover:bg-muted hover:text-foreground",
        }),
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Zap, { className: "h-3 w-3" }),
          "Presets",
          /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronDown, { className: "ml-auto h-3 w-3" }),
        ],
      }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(DropdownMenuContent, {
        align: "end",
        className: "w-64 bg-fd-background",
        children: PRESET_TEMPLATES.map((preset) =>
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            DropdownMenuItem,
            {
              onClick: () => onApplyPreset(preset.id),
              className: "flex flex-col items-start gap-1 p-3",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
                  className: "font-medium text-sm",
                  children: preset.name,
                }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
                  className: "text-xs",
                  children: preset.description,
                }),
              ],
            },
            preset.id,
          ),
        ),
      }),
    ],
  });
}
function ShareButton({ stackUrl }) {
  const [copied, setCopied] = reactExports.useState(false);
  const copyToClipboard = async () => {
    try {
      await navigator.clipboard.writeText(stackUrl);
      setCopied(true);
      setTimeout(() => setCopied(false), 2e3);
    } catch (err) {
      console.error("Failed to copy:", err);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("button", {
    type: "button",
    onClick: copyToClipboard,
    className:
      "flex flex-1 items-center justify-center gap-1.5 rounded-md border border-border bg-fd-background px-2 py-1.5 font-medium text-muted-foreground text-xs transition-all hover:border-muted-foreground/30 hover:bg-muted hover:text-foreground",
    title: copied ? "Copied!" : "Copy share link",
    children: copied
      ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Check, { className: "h-3 w-3 text-green-500" }),
            "Copied",
          ],
        })
      : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Share2, { className: "h-3 w-3" }),
            "Share",
          ],
        }),
  });
}
function TechIcon({ icon, name, className }) {
  if (!icon) return null;
  if (icon.startsWith("https://") || icon.startsWith("/")) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("img", {
      src: icon,
      alt: `${name} icon`,
      width: 20,
      height: 20,
      className: cn("inline-block", className),
    });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
    className: cn("inline-flex items-center text-lg", className),
    children: icon,
  });
}
function validateProjectName(name) {
  const INVALID_CHARS = ["<", ">", ":", '"', "|", "?", "*"];
  const MAX_LENGTH = 255;
  if (name === ".") return void 0;
  if (!name) return "Project name cannot be empty";
  if (name.length > MAX_LENGTH) {
    return `Project name must be less than ${MAX_LENGTH} characters`;
  }
  if (INVALID_CHARS.some((char) => name.includes(char))) {
    return "Project name contains invalid characters";
  }
  if (name.startsWith(".") || name.startsWith("-")) {
    return "Project name cannot start with a dot or dash";
  }
  if (name.toLowerCase() === "node_modules" || name.toLowerCase() === "favicon.ico") {
    return "Project name is reserved";
  }
  return void 0;
}
const hasPWACompatibleFrontend = (webFrontend) =>
  webFrontend.some((f) =>
    ["tanstack-router", "react-router", "solid", "next", "astro"].includes(f),
  );
const hasTauriCompatibleFrontend = (webFrontend) =>
  webFrontend.some((f) =>
    ["tanstack-router", "react-router", "nuxt", "svelte", "solid", "next", "astro"].includes(f),
  );
const getCategoryDisplayName = (categoryKey) => {
  const rustCategoryNames = {
    rustWebFramework: "Rust Web Framework",
    rustFrontend: "Rust Frontend (WASM)",
    rustOrm: "Rust ORM / Database",
    rustApi: "Rust API Layer",
    rustCli: "Rust CLI Tools",
    rustLibraries: "Rust Core Libraries",
  };
  if (rustCategoryNames[categoryKey]) {
    return rustCategoryNames[categoryKey];
  }
  const result = categoryKey.replace(/([A-Z])/g, " $1");
  return result.charAt(0).toUpperCase() + result.slice(1);
};
const analyzeStackCompatibility = (stack) => {
  if (stack.yolo === "true") {
    return {
      adjustedStack: null,
      notes: {},
      changes: [],
    };
  }
  const nextStack = { ...stack };
  let changed = false;
  const notes = {};
  const changes = [];
  for (const cat of CATEGORY_ORDER) {
    notes[cat] = { notes: [], hasIssue: false };
  }
  if (nextStack.backend === "convex") {
    const convexOverrides = {
      runtime: "none",
      database: "none",
      orm: "none",
      api: "none",
      dbSetup: "none",
      serverDeploy: "none",
    };
    for (const [key, value] of Object.entries(convexOverrides)) {
      const catKey = key;
      if (nextStack[catKey] !== value) {
        nextStack[catKey] = value;
        changed = true;
        changes.push({
          category: "backend",
          message: `${getCategoryDisplayName(catKey)} set to '${value}' (Convex provides this)`,
        });
      }
    }
    if (nextStack.webFrontend.includes("solid")) {
      nextStack.webFrontend = nextStack.webFrontend.filter((f) => f !== "solid");
      if (nextStack.webFrontend.length === 0) nextStack.webFrontend = ["none"];
      changed = true;
      changes.push({ category: "backend", message: "Removed Solid (incompatible with Convex)" });
    }
    if (nextStack.webFrontend.includes("astro")) {
      nextStack.webFrontend = nextStack.webFrontend.filter((f) => f !== "astro");
      if (nextStack.webFrontend.length === 0) nextStack.webFrontend = ["none"];
      nextStack.astroIntegration = "none";
      changed = true;
      changes.push({ category: "backend", message: "Removed Astro (incompatible with Convex)" });
    }
    if (nextStack.examples.includes("ai")) {
      const hasIncompatibleFrontend = nextStack.webFrontend.some((f) =>
        ["solid", "svelte", "nuxt"].includes(f),
      );
      if (hasIncompatibleFrontend) {
        nextStack.examples = nextStack.examples.filter((e) => e !== "ai");
        if (nextStack.examples.length === 0) nextStack.examples = ["none"];
        changed = true;
        changes.push({
          category: "examples",
          message: "AI example removed (Convex AI only supports React-based frontends)",
        });
      }
    }
    if (nextStack.auth === "clerk") {
      const hasClerkCompatible =
        nextStack.webFrontend.some((f) =>
          ["tanstack-router", "react-router", "tanstack-start", "next"].includes(f),
        ) ||
        nextStack.nativeFrontend.some((f) =>
          ["native-bare", "native-uniwind", "native-unistyles"].includes(f),
        );
      if (!hasClerkCompatible) {
        nextStack.auth = "none";
        changed = true;
        changes.push({
          category: "auth",
          message: "Auth set to 'None' (Clerk requires compatible frontend)",
        });
      }
    }
    if (nextStack.auth === "better-auth") {
      const hasBetterAuthCompatible =
        nextStack.webFrontend.some((f) =>
          ["tanstack-router", "tanstack-start", "next"].includes(f),
        ) ||
        nextStack.nativeFrontend.some((f) =>
          ["native-bare", "native-uniwind", "native-unistyles"].includes(f),
        );
      if (!hasBetterAuthCompatible) {
        nextStack.auth = "none";
        changed = true;
        changes.push({
          category: "auth",
          message: "Auth set to 'None' (Better-Auth with Convex requires compatible frontend)",
        });
      }
    }
  }
  if (nextStack.backend === "none") {
    const noneOverrides = {
      runtime: "none",
      database: "none",
      orm: "none",
      api: "none",
      auth: "none",
      dbSetup: "none",
      serverDeploy: "none",
      payments: "none",
    };
    for (const [key, value] of Object.entries(noneOverrides)) {
      const catKey = key;
      if (nextStack[catKey] !== value) {
        nextStack[catKey] = value;
        changed = true;
        changes.push({
          category: "backend",
          message: `${getCategoryDisplayName(catKey)} set to '${value}' (no backend)`,
        });
      }
    }
    if (
      nextStack.examples.length > 0 &&
      !(nextStack.examples.length === 1 && nextStack.examples[0] === "none")
    ) {
      nextStack.examples = ["none"];
      changed = true;
      changes.push({ category: "backend", message: "Examples cleared (no backend)" });
    }
  }
  if (
    nextStack.backend === "self-next" ||
    nextStack.backend === "self-tanstack-start" ||
    nextStack.backend === "self-astro"
  ) {
    if (nextStack.runtime !== "none") {
      nextStack.runtime = "none";
      changed = true;
      changes.push({
        category: "backend",
        message: "Runtime set to 'None' (fullstack uses frontend's API routes)",
      });
    }
    if (nextStack.serverDeploy !== "none") {
      nextStack.serverDeploy = "none";
      changed = true;
      changes.push({
        category: "backend",
        message: "Server deploy set to 'None' (fullstack uses frontend deployment)",
      });
    }
    if (nextStack.backend === "self-next" && !nextStack.webFrontend.includes("next")) {
      nextStack.webFrontend = ["next"];
      changed = true;
      changes.push({
        category: "backend",
        message: "Frontend set to 'Next.js' (required for Next.js fullstack)",
      });
    }
    if (
      nextStack.backend === "self-tanstack-start" &&
      !nextStack.webFrontend.includes("tanstack-start")
    ) {
      nextStack.webFrontend = ["tanstack-start"];
      changed = true;
      changes.push({
        category: "backend",
        message: "Frontend set to 'TanStack Start' (required for TanStack Start fullstack)",
      });
    }
    if (nextStack.backend === "self-astro" && !nextStack.webFrontend.includes("astro")) {
      nextStack.webFrontend = ["astro"];
      if (nextStack.astroIntegration === "none") {
        nextStack.astroIntegration = "react";
      }
      changed = true;
      changes.push({
        category: "backend",
        message: "Frontend set to 'Astro' (required for Astro fullstack)",
      });
    }
  }
  if (nextStack.runtime === "workers" && nextStack.backend !== "hono") {
    nextStack.backend = "hono";
    changed = true;
    changes.push({ category: "runtime", message: "Backend set to 'Hono' (required for Workers)" });
  }
  if (nextStack.runtime === "workers" && nextStack.serverDeploy === "none") {
    nextStack.serverDeploy = "cloudflare";
    changed = true;
    changes.push({
      category: "runtime",
      message: "Server deploy set to 'Cloudflare' (required for Workers)",
    });
  }
  if (nextStack.runtime === "workers" && nextStack.database === "mongodb") {
    nextStack.database = "sqlite";
    nextStack.orm = "drizzle";
    nextStack.dbSetup = "d1";
    changed = true;
    changes.push({
      category: "runtime",
      message: "Database changed to SQLite with D1 (MongoDB incompatible with Workers)",
    });
  }
  if (
    nextStack.runtime === "none" &&
    nextStack.backend !== "convex" &&
    nextStack.backend !== "none" &&
    nextStack.backend !== "self-next" &&
    nextStack.backend !== "self-tanstack-start" &&
    nextStack.backend !== "self-astro"
  ) {
    nextStack.runtime = DEFAULT_STACK.runtime;
    changed = true;
    changes.push({
      category: "runtime",
      message: `Runtime set to '${DEFAULT_STACK.runtime}' (required for this backend)`,
    });
  }
  if (nextStack.backend !== "convex" && nextStack.backend !== "none") {
    if (nextStack.database === "none") {
      if (nextStack.orm !== "none") {
        nextStack.orm = "none";
        changed = true;
        changes.push({ category: "database", message: "ORM set to 'None' (no database selected)" });
      }
      if (nextStack.dbSetup !== "none") {
        nextStack.dbSetup = "none";
        changed = true;
        changes.push({
          category: "database",
          message: "DB Setup set to 'None' (no database selected)",
        });
      }
    }
    if (nextStack.database === "mongodb") {
      if (nextStack.orm !== "prisma" && nextStack.orm !== "mongoose") {
        nextStack.orm = "prisma";
        changed = true;
        changes.push({
          category: "database",
          message: "ORM set to 'Prisma' (required for MongoDB)",
        });
      }
      if (
        nextStack.dbSetup !== "mongodb-atlas" &&
        nextStack.dbSetup !== "none" &&
        nextStack.dbSetup !== "docker"
      ) {
        nextStack.dbSetup = "none";
        changed = true;
        changes.push({
          category: "database",
          message: "DB Setup set to 'None' (incompatible with MongoDB)",
        });
      }
    }
    if (["sqlite", "postgres", "mysql"].includes(nextStack.database)) {
      if (nextStack.orm === "none") {
        nextStack.orm = "drizzle";
        changed = true;
        changes.push({
          category: "database",
          message: "ORM set to 'Drizzle' (required for database)",
        });
      }
      if (nextStack.orm === "mongoose") {
        nextStack.orm = "drizzle";
        changed = true;
        changes.push({
          category: "database",
          message: "ORM set to 'Drizzle' (Mongoose only works with MongoDB)",
        });
      }
    }
    if (nextStack.orm !== "none" && nextStack.database === "none") {
      if (nextStack.orm === "mongoose") {
        nextStack.database = "mongodb";
        changed = true;
        changes.push({
          category: "orm",
          message: "Database set to 'MongoDB' (required for Mongoose)",
        });
      } else {
        nextStack.database = "sqlite";
        changed = true;
        changes.push({ category: "orm", message: "Database set to 'SQLite' (required for ORM)" });
      }
    }
    if (nextStack.dbSetup === "turso" && nextStack.database !== "sqlite") {
      nextStack.database = "sqlite";
      changed = true;
      changes.push({
        category: "dbSetup",
        message: "Database set to 'SQLite' (required for Turso)",
      });
    }
    if (nextStack.dbSetup === "d1") {
      if (nextStack.database !== "sqlite") {
        nextStack.database = "sqlite";
        changed = true;
        changes.push({
          category: "dbSetup",
          message: "Database set to 'SQLite' (required for D1)",
        });
      }
      if (nextStack.runtime !== "workers") {
        nextStack.runtime = "workers";
        nextStack.backend = "hono";
        changed = true;
        changes.push({
          category: "dbSetup",
          message: "Runtime set to 'Workers' with 'Hono' (required for D1)",
        });
      }
    }
    if (nextStack.dbSetup === "neon" && nextStack.database !== "postgres") {
      nextStack.database = "postgres";
      changed = true;
      changes.push({
        category: "dbSetup",
        message: "Database set to 'PostgreSQL' (required for Neon)",
      });
    }
    if (nextStack.dbSetup === "supabase" && nextStack.database !== "postgres") {
      nextStack.database = "postgres";
      changed = true;
      changes.push({
        category: "dbSetup",
        message: "Database set to 'PostgreSQL' (required for Supabase)",
      });
    }
    if (nextStack.dbSetup === "prisma-postgres" && nextStack.database !== "postgres") {
      nextStack.database = "postgres";
      changed = true;
      changes.push({
        category: "dbSetup",
        message: "Database set to 'PostgreSQL' (required for Prisma Postgres)",
      });
    }
    if (nextStack.dbSetup === "mongodb-atlas" && nextStack.database !== "mongodb") {
      nextStack.database = "mongodb";
      if (nextStack.orm !== "prisma" && nextStack.orm !== "mongoose") {
        nextStack.orm = "prisma";
      }
      changed = true;
      changes.push({
        category: "dbSetup",
        message: "Database set to 'MongoDB' (required for MongoDB Atlas)",
      });
    }
    if (
      nextStack.dbSetup === "planetscale" &&
      nextStack.database !== "postgres" &&
      nextStack.database !== "mysql"
    ) {
      nextStack.database = "postgres";
      changed = true;
      changes.push({
        category: "dbSetup",
        message: "Database set to 'PostgreSQL' (required for PlanetScale)",
      });
    }
    if (nextStack.dbSetup === "docker") {
      if (nextStack.database === "sqlite") {
        nextStack.dbSetup = "none";
        changed = true;
        changes.push({
          category: "dbSetup",
          message: "DB Setup set to 'None' (SQLite doesn't need Docker)",
        });
      }
      if (nextStack.runtime === "workers") {
        nextStack.dbSetup = "d1";
        changed = true;
        changes.push({
          category: "dbSetup",
          message: "DB Setup set to 'D1' (Docker incompatible with Workers)",
        });
      }
    }
  }
  if (nextStack.backend !== "convex" && nextStack.backend !== "none") {
    const needsOrpc = nextStack.webFrontend.some((f) => ["nuxt", "svelte", "solid"].includes(f));
    if (needsOrpc && nextStack.api === "trpc") {
      nextStack.api = "orpc";
      changed = true;
      changes.push({ category: "api", message: "API set to 'oRPC' (required for this frontend)" });
    }
    if (
      nextStack.webFrontend.includes("astro") &&
      nextStack.astroIntegration !== "react" &&
      nextStack.api === "trpc"
    ) {
      nextStack.api = "orpc";
      changed = true;
      changes.push({
        category: "api",
        message: "API set to 'oRPC' (tRPC requires React integration with Astro)",
      });
    }
  }
  if (!nextStack.webFrontend.includes("astro") && nextStack.astroIntegration !== "none") {
    nextStack.astroIntegration = "none";
    changed = true;
    changes.push({
      category: "astroIntegration",
      message: "Astro integration reset (Astro not selected)",
    });
  }
  if (nextStack.webFrontend.includes("astro") && nextStack.astroIntegration === "none") {
    if (nextStack.api === "trpc") {
      nextStack.astroIntegration = "react";
      changed = true;
      changes.push({
        category: "astroIntegration",
        message: "Astro integration set to 'React' (required for tRPC)",
      });
    }
  }
  if (nextStack.auth === "clerk" && nextStack.backend !== "convex") {
    nextStack.auth = "none";
    changed = true;
    changes.push({
      category: "auth",
      message: "Auth set to 'None' (Clerk only works with Convex)",
    });
  }
  if (nextStack.payments === "polar") {
    if (nextStack.auth !== "better-auth") {
      nextStack.payments = "none";
      changed = true;
      changes.push({
        category: "payments",
        message: "Payments set to 'None' (Polar requires Better Auth)",
      });
    }
    if (nextStack.backend === "convex") {
      nextStack.payments = "none";
      changed = true;
      changes.push({
        category: "payments",
        message: "Payments set to 'None' (Polar incompatible with Convex)",
      });
    }
    const hasWebFrontend = nextStack.webFrontend.some((f) => f !== "none");
    if (!hasWebFrontend) {
      nextStack.payments = "none";
      changed = true;
      changes.push({
        category: "payments",
        message: "Payments set to 'None' (Polar requires web frontend)",
      });
    }
  }
  if (nextStack.email !== "none") {
    if (nextStack.backend === "convex") {
      nextStack.email = "none";
      changed = true;
      changes.push({
        category: "email",
        message: "Email set to 'None' (incompatible with Convex)",
      });
    }
    if (nextStack.backend === "none") {
      nextStack.email = "none";
      changed = true;
      changes.push({
        category: "email",
        message: "Email set to 'None' (requires backend)",
      });
    }
  }
  if (!nextStack.webFrontend.some((f) => f !== "none")) {
    if (nextStack.cssFramework !== "none") {
      nextStack.cssFramework = "none";
      changed = true;
      changes.push({
        category: "cssFramework",
        message: "CSS framework set to 'None' (no web frontend)",
      });
    }
    if (nextStack.uiLibrary !== "none") {
      nextStack.uiLibrary = "none";
      changed = true;
      changes.push({
        category: "uiLibrary",
        message: "UI library set to 'None' (no web frontend)",
      });
    }
  }
  const requiresTailwind = ["shadcn-ui", "daisyui", "nextui"].includes(nextStack.uiLibrary);
  if (requiresTailwind && nextStack.cssFramework !== "tailwind") {
    nextStack.cssFramework = "tailwind";
    changed = true;
    changes.push({
      category: "cssFramework",
      message: `CSS framework set to 'Tailwind' (required by ${nextStack.uiLibrary})`,
    });
  }
  const reactOnlyLibraries = ["shadcn-ui", "radix-ui", "chakra-ui", "nextui"];
  const reactFrontends = ["tanstack-router", "react-router", "tanstack-start", "next"];
  if (reactOnlyLibraries.includes(nextStack.uiLibrary)) {
    const hasReactFrontend = nextStack.webFrontend.some((f) => reactFrontends.includes(f));
    const hasAstroReact =
      nextStack.webFrontend.includes("astro") && nextStack.astroIntegration === "react";
    if (!hasReactFrontend && !hasAstroReact && nextStack.webFrontend.some((f) => f !== "none")) {
      nextStack.uiLibrary = "daisyui";
      changed = true;
      changes.push({
        category: "uiLibrary",
        message:
          "UI library changed to 'daisyUI' (React-only library incompatible with this frontend)",
      });
    }
  }
  if (nextStack.uiLibrary === "headless-ui") {
    const hasReactFrontend = nextStack.webFrontend.some((f) => reactFrontends.includes(f));
    const hasVueFrontend = nextStack.webFrontend.includes("nuxt");
    const hasAstroReactOrVue =
      nextStack.webFrontend.includes("astro") &&
      ["react", "vue"].includes(nextStack.astroIntegration);
    if (!hasReactFrontend && !hasVueFrontend && !hasAstroReactOrVue) {
      nextStack.uiLibrary = "daisyui";
      changed = true;
      changes.push({
        category: "uiLibrary",
        message: "UI library changed to 'daisyUI' (Headless UI requires React or Vue)",
      });
    }
  }
  if (nextStack.uiLibrary === "park-ui") {
    const hasReactFrontend = nextStack.webFrontend.some((f) => reactFrontends.includes(f));
    const hasVueFrontend = nextStack.webFrontend.includes("nuxt");
    const hasSolidFrontend = nextStack.webFrontend.includes("solid");
    const hasAstroCompatible =
      nextStack.webFrontend.includes("astro") &&
      ["react", "vue", "solid"].includes(nextStack.astroIntegration);
    if (
      !hasReactFrontend &&
      !hasVueFrontend &&
      !hasSolidFrontend &&
      !hasAstroCompatible &&
      nextStack.webFrontend.some((f) => f !== "none")
    ) {
      nextStack.uiLibrary = "daisyui";
      changed = true;
      changes.push({
        category: "uiLibrary",
        message: "UI library changed to 'daisyUI' (Park UI requires React, Vue, or Solid)",
      });
    }
  }
  const pwaCompat = hasPWACompatibleFrontend(nextStack.webFrontend);
  const tauriCompat = hasTauriCompatibleFrontend(nextStack.webFrontend);
  if (!pwaCompat && nextStack.appPlatforms.includes("pwa")) {
    nextStack.appPlatforms = nextStack.appPlatforms.filter((a) => a !== "pwa");
    changed = true;
    changes.push({
      category: "appPlatforms",
      message: "PWA removed (requires compatible frontend)",
    });
  }
  if (!tauriCompat && nextStack.appPlatforms.includes("tauri")) {
    nextStack.appPlatforms = nextStack.appPlatforms.filter((a) => a !== "tauri");
    changed = true;
    changes.push({
      category: "appPlatforms",
      message: "Tauri removed (requires compatible frontend)",
    });
  }
  if (nextStack.examples.includes("todo") && nextStack.backend !== "convex") {
    const needsRemoval = nextStack.database === "none" || nextStack.api === "none";
    if (needsRemoval) {
      const reason = nextStack.database === "none" ? "requires database" : "requires API layer";
      nextStack.examples = nextStack.examples.filter((e) => e !== "todo");
      if (nextStack.examples.length === 0) nextStack.examples = ["none"];
      changed = true;
      changes.push({ category: "examples", message: `Todo removed (${reason})` });
    }
  }
  if (nextStack.examples.includes("ai")) {
    if (nextStack.webFrontend.includes("solid")) {
      nextStack.examples = nextStack.examples.filter((e) => e !== "ai");
      if (nextStack.examples.length === 0) nextStack.examples = ["none"];
      changed = true;
      changes.push({
        category: "examples",
        message: "AI removed (not compatible with Solid frontend)",
      });
    }
    if (nextStack.backend === "convex") {
      const hasIncompatibleFrontend = nextStack.webFrontend.some((f) =>
        ["svelte", "nuxt"].includes(f),
      );
      if (hasIncompatibleFrontend) {
        nextStack.examples = nextStack.examples.filter((e) => e !== "ai");
        if (nextStack.examples.length === 0) nextStack.examples = ["none"];
        changed = true;
        changes.push({
          category: "examples",
          message: "AI removed (Convex AI only supports React-based frontends)",
        });
      }
    }
  }
  if (nextStack.webDeploy !== "none" && !nextStack.webFrontend.some((f) => f !== "none")) {
    nextStack.webDeploy = "none";
    changed = true;
    changes.push({ category: "webDeploy", message: "Web deploy set to 'None' (no web frontend)" });
  }
  if (nextStack.serverDeploy === "cloudflare") {
    if (nextStack.runtime !== "workers" || nextStack.backend !== "hono") {
      nextStack.serverDeploy = "none";
      changed = true;
      changes.push({
        category: "serverDeploy",
        message: "Server deploy set to 'None' (Cloudflare requires Workers + Hono)",
      });
    }
  }
  if (
    nextStack.serverDeploy !== "none" &&
    ["none", "convex", "self-next", "self-tanstack-start", "self-astro"].includes(nextStack.backend)
  ) {
    nextStack.serverDeploy = "none";
    changed = true;
    changes.push({
      category: "serverDeploy",
      message: "Server deploy set to 'None' (not needed for this backend)",
    });
  }
  return {
    adjustedStack: changed ? nextStack : null,
    notes,
    changes,
  };
};
const getDisabledReason = (currentStack, category, optionId) => {
  if (currentStack.backend === "convex") {
    if (category === "runtime" && optionId !== "none") {
      return "Convex provides its own runtime";
    }
    if (category === "database" && optionId !== "none") {
      return "Convex provides its own database";
    }
    if (category === "orm" && optionId !== "none") {
      return "Convex has built-in data access";
    }
    if (category === "api" && optionId !== "none") {
      return "Convex provides its own API layer";
    }
    if (category === "dbSetup" && optionId !== "none") {
      return "Convex handles database setup";
    }
    if (category === "serverDeploy" && optionId !== "none") {
      return "Convex has its own deployment";
    }
    if (category === "auth" && optionId === "better-auth") {
      const compatible =
        currentStack.webFrontend.some((f) =>
          ["tanstack-router", "tanstack-start", "next"].includes(f),
        ) ||
        currentStack.nativeFrontend.some((f) =>
          ["native-bare", "native-uniwind", "native-unistyles"].includes(f),
        );
      if (!compatible) {
        return "Better-Auth with Convex requires TanStack Router, TanStack Start, Next.js, or React Native";
      }
    }
    if (category === "webFrontend" && optionId === "solid") {
      return "Solid is not compatible with Convex";
    }
    if (category === "webFrontend" && optionId === "astro") {
      return "Astro is not compatible with Convex";
    }
    if (category === "examples" && optionId === "ai") {
      const hasIncompatibleFrontend = currentStack.webFrontend.some((f) =>
        ["solid", "svelte", "nuxt"].includes(f),
      );
      if (hasIncompatibleFrontend) {
        const frontendName = currentStack.webFrontend.find((f) =>
          ["solid", "svelte", "nuxt"].includes(f),
        );
        return `Convex AI example only supports React-based frontends (not ${frontendName})`;
      }
    }
    if (category === "payments" && optionId === "polar") {
      return "Polar is not compatible with Convex";
    }
  }
  if (currentStack.backend === "none") {
    if (category === "runtime" && optionId !== "none") {
      return "No backend selected";
    }
    if (category === "database" && optionId !== "none") {
      return "No backend selected";
    }
    if (category === "orm" && optionId !== "none") {
      return "No backend selected";
    }
    if (category === "api" && optionId !== "none") {
      return "No backend selected";
    }
    if (category === "auth" && optionId !== "none") {
      return "No backend selected";
    }
    if (category === "dbSetup" && optionId !== "none") {
      return "No backend selected";
    }
    if (category === "serverDeploy" && optionId !== "none") {
      return "No backend selected";
    }
    if (category === "payments" && optionId !== "none") {
      return "No backend selected";
    }
    if (category === "examples" && optionId !== "none") {
      return "No backend selected";
    }
  }
  if (currentStack.backend === "self-next") {
    if (category === "runtime" && optionId !== "none") {
      return "Next.js fullstack uses built-in API routes";
    }
    if (category === "webFrontend" && optionId !== "next" && optionId !== "none") {
      return "Next.js fullstack requires Next.js frontend";
    }
    if (category === "serverDeploy" && optionId !== "none") {
      return "Fullstack uses frontend deployment";
    }
  }
  if (currentStack.backend === "self-tanstack-start") {
    if (category === "runtime" && optionId !== "none") {
      return "TanStack Start fullstack uses built-in API routes";
    }
    if (category === "webFrontend" && optionId !== "tanstack-start" && optionId !== "none") {
      return "TanStack Start fullstack requires TanStack Start frontend";
    }
    if (category === "serverDeploy" && optionId !== "none") {
      return "Fullstack uses frontend deployment";
    }
  }
  if (currentStack.backend === "self-astro") {
    if (category === "runtime" && optionId !== "none") {
      return "Astro fullstack uses built-in API routes";
    }
    if (category === "webFrontend" && optionId !== "astro" && optionId !== "none") {
      return "Astro fullstack requires Astro frontend";
    }
    if (category === "serverDeploy" && optionId !== "none") {
      return "Fullstack uses frontend deployment";
    }
  }
  if (category === "backend") {
    if (optionId === "self-next" && !currentStack.webFrontend.includes("next")) {
      return "Requires Next.js frontend";
    }
    if (
      optionId === "self-tanstack-start" &&
      !currentStack.webFrontend.includes("tanstack-start")
    ) {
      return "Requires TanStack Start frontend";
    }
    if (optionId === "self-astro" && !currentStack.webFrontend.includes("astro")) {
      return "Requires Astro frontend";
    }
    if (optionId === "convex" && currentStack.webFrontend.includes("solid")) {
      return "Convex is not compatible with Solid";
    }
    if (optionId === "convex" && currentStack.webFrontend.includes("astro")) {
      return "Convex is not compatible with Astro";
    }
    if (currentStack.runtime === "workers" && optionId !== "hono" && optionId !== "none") {
      return "Workers runtime only works with Hono";
    }
  }
  if (category === "runtime") {
    if (optionId === "workers" && currentStack.backend !== "hono") {
      return "Workers requires Hono backend";
    }
    if (optionId === "none") {
      const allowedBackends = ["convex", "none", "self-next", "self-tanstack-start", "self-astro"];
      if (!allowedBackends.includes(currentStack.backend)) {
        return "Runtime 'None' only for Convex or fullstack backends";
      }
    }
  }
  if (category === "database") {
    if (optionId === "mongodb" && currentStack.runtime === "workers") {
      return "MongoDB is not compatible with Workers runtime";
    }
  }
  if (category === "orm") {
    if (optionId === "mongoose") {
      if (currentStack.runtime === "workers") {
        return "Mongoose requires MongoDB, which is incompatible with Workers";
      }
      if (currentStack.database !== "none" && currentStack.database !== "mongodb") {
        return "Mongoose only works with MongoDB";
      }
    }
    if (optionId === "drizzle" && currentStack.database === "mongodb") {
      return "Drizzle does not support MongoDB";
    }
    if (optionId === "none" && currentStack.database !== "none") {
      return "Database requires an ORM";
    }
  }
  if (category === "dbSetup" && optionId !== "none") {
    if (currentStack.database === "none") {
      return "Select a database first";
    }
    if (optionId === "turso" && currentStack.database !== "sqlite") {
      return "Turso requires SQLite";
    }
    if (optionId === "d1") {
      if (currentStack.database !== "sqlite") return "D1 requires SQLite";
      if (currentStack.runtime !== "workers") return "D1 requires Workers runtime";
    }
    if (optionId === "neon" && currentStack.database !== "postgres") {
      return "Neon requires PostgreSQL";
    }
    if (optionId === "supabase" && currentStack.database !== "postgres") {
      return "Supabase requires PostgreSQL";
    }
    if (optionId === "prisma-postgres" && currentStack.database !== "postgres") {
      return "Prisma Postgres requires PostgreSQL";
    }
    if (optionId === "mongodb-atlas" && currentStack.database !== "mongodb") {
      return "MongoDB Atlas requires MongoDB";
    }
    if (
      optionId === "planetscale" &&
      currentStack.database !== "postgres" &&
      currentStack.database !== "mysql"
    ) {
      return "PlanetScale requires PostgreSQL or MySQL";
    }
    if (optionId === "docker") {
      if (currentStack.database === "sqlite") return "SQLite doesn't need Docker";
      if (currentStack.runtime === "workers") return "Docker is incompatible with Workers";
    }
  }
  if (category === "api" && optionId === "trpc") {
    const needsOrpc = currentStack.webFrontend.some((f) => ["nuxt", "svelte", "solid"].includes(f));
    if (needsOrpc) {
      const frontendName = currentStack.webFrontend.find((f) =>
        ["nuxt", "svelte", "solid"].includes(f),
      );
      return `${frontendName} requires oRPC, not tRPC`;
    }
    if (
      currentStack.webFrontend.includes("astro") &&
      currentStack.astroIntegration !== "react" &&
      currentStack.astroIntegration !== "none"
    ) {
      return `Astro with ${currentStack.astroIntegration} integration requires oRPC, not tRPC`;
    }
  }
  if (category === "astroIntegration") {
    if (!currentStack.webFrontend.includes("astro") && optionId !== "none") {
      return "Astro integration requires Astro frontend";
    }
    if (currentStack.api === "trpc" && optionId !== "react" && optionId !== "none") {
      return "tRPC requires React integration with Astro";
    }
  }
  if (category === "auth") {
    if (optionId === "clerk") {
      if (currentStack.backend !== "convex") {
        return "Clerk only works with Convex backend";
      }
      const hasClerkCompatibleFrontend =
        currentStack.webFrontend.some((f) =>
          ["react-router", "tanstack-router", "tanstack-start", "next"].includes(f),
        ) ||
        currentStack.nativeFrontend.some((f) =>
          ["native-bare", "native-uniwind", "native-unistyles"].includes(f),
        );
      if (!hasClerkCompatibleFrontend) {
        return "Clerk with Convex requires React Router, TanStack Router, TanStack Start, Next.js, or React Native";
      }
    }
  }
  if (category === "payments" && optionId === "polar") {
    if (currentStack.auth !== "better-auth") {
      return "Polar requires Better Auth";
    }
    if (!currentStack.webFrontend.some((f) => f !== "none")) {
      return "Polar requires a web frontend";
    }
  }
  if (category === "email" && optionId !== "none") {
    if (currentStack.backend === "convex") {
      return "Email integration is not available with Convex backend";
    }
    if (currentStack.backend === "none") {
      return "Email integration requires a backend";
    }
  }
  if (category === "appPlatforms") {
    if (optionId === "pwa" && !hasPWACompatibleFrontend(currentStack.webFrontend)) {
      return "PWA requires TanStack Router, React Router, Solid, Next.js, or Astro";
    }
    if (optionId === "tauri" && !hasTauriCompatibleFrontend(currentStack.webFrontend)) {
      return "Tauri requires TanStack Router, React Router, Nuxt, Svelte, Solid, Next.js, or Astro";
    }
  }
  if (category === "examples") {
    if (optionId === "todo" && currentStack.backend !== "convex") {
      if (currentStack.database === "none") {
        return "Todo example requires a database";
      }
      if (currentStack.api === "none") {
        return "Todo example requires an API layer (tRPC or oRPC)";
      }
    }
    if (optionId === "ai") {
      if (currentStack.webFrontend.includes("solid")) {
        return "AI example not compatible with Solid frontend";
      }
      if (currentStack.backend === "convex") {
        const hasIncompatibleFrontend = currentStack.webFrontend.some((f) =>
          ["svelte", "nuxt"].includes(f),
        );
        if (hasIncompatibleFrontend) {
          const frontendName = currentStack.webFrontend.find((f) => ["svelte", "nuxt"].includes(f));
          return `Convex AI example only supports React-based frontends (not ${frontendName})`;
        }
      }
    }
  }
  if (category === "cssFramework") {
    if (!currentStack.webFrontend.some((f) => f !== "none")) {
      if (optionId !== "none") {
        return "CSS framework requires a web frontend";
      }
    }
    const requiresTailwind = ["shadcn-ui", "daisyui", "nextui"].includes(currentStack.uiLibrary);
    if (requiresTailwind && optionId !== "tailwind") {
      return `${currentStack.uiLibrary === "shadcn-ui" ? "shadcn/ui" : currentStack.uiLibrary === "daisyui" ? "daisyUI" : "NextUI"} requires Tailwind CSS`;
    }
  }
  if (category === "uiLibrary") {
    if (!currentStack.webFrontend.some((f) => f !== "none")) {
      if (optionId !== "none") {
        return "UI library requires a web frontend";
      }
    }
    const reactOnlyLibraries = ["shadcn-ui", "radix-ui", "chakra-ui", "nextui"];
    const reactFrontends = ["tanstack-router", "react-router", "tanstack-start", "next"];
    if (reactOnlyLibraries.includes(optionId)) {
      const hasReactFrontend = currentStack.webFrontend.some((f) => reactFrontends.includes(f));
      const hasAstroReact =
        currentStack.webFrontend.includes("astro") && currentStack.astroIntegration === "react";
      if (!hasReactFrontend && !hasAstroReact) {
        const libraryName =
          optionId === "shadcn-ui"
            ? "shadcn/ui"
            : optionId === "radix-ui"
              ? "Radix UI"
              : optionId === "chakra-ui"
                ? "Chakra UI"
                : "NextUI";
        return `${libraryName} requires a React-based frontend`;
      }
    }
    if (optionId === "headless-ui") {
      const hasReactFrontend = currentStack.webFrontend.some((f) => reactFrontends.includes(f));
      const hasVueFrontend = currentStack.webFrontend.includes("nuxt");
      const hasAstroReactOrVue =
        currentStack.webFrontend.includes("astro") &&
        ["react", "vue"].includes(currentStack.astroIntegration);
      if (!hasReactFrontend && !hasVueFrontend && !hasAstroReactOrVue) {
        return "Headless UI requires React or Vue frontend";
      }
    }
    if (optionId === "park-ui") {
      const hasReactFrontend = currentStack.webFrontend.some((f) => reactFrontends.includes(f));
      const hasVueFrontend = currentStack.webFrontend.includes("nuxt");
      const hasSolidFrontend = currentStack.webFrontend.includes("solid");
      const hasAstroCompatible =
        currentStack.webFrontend.includes("astro") &&
        ["react", "vue", "solid"].includes(currentStack.astroIntegration);
      if (!hasReactFrontend && !hasVueFrontend && !hasSolidFrontend && !hasAstroCompatible) {
        return "Park UI requires React, Vue, or Solid frontend";
      }
      if (currentStack.cssFramework === "none") {
        return "Park UI requires a CSS framework";
      }
    }
    if (["shadcn-ui", "daisyui", "nextui"].includes(optionId)) {
      if (currentStack.cssFramework !== "tailwind") {
        const libraryName =
          optionId === "shadcn-ui" ? "shadcn/ui" : optionId === "daisyui" ? "daisyUI" : "NextUI";
        return `${libraryName} requires Tailwind CSS`;
      }
    }
  }
  if (category === "webDeploy" && optionId !== "none") {
    if (!currentStack.webFrontend.some((f) => f !== "none")) {
      return "Web deployment requires a web frontend";
    }
  }
  if (category === "serverDeploy") {
    if (optionId === "cloudflare") {
      if (currentStack.runtime !== "workers") return "Cloudflare requires Workers runtime";
      if (currentStack.backend !== "hono") return "Cloudflare requires Hono backend";
    }
    if (optionId !== "none") {
      const noServerDeploy = ["none", "convex", "self-next", "self-tanstack-start", "self-astro"];
      if (noServerDeploy.includes(currentStack.backend)) {
        return "Server deployment not needed for this backend";
      }
    }
    if (optionId === "none" && currentStack.runtime === "workers") {
      return "Workers requires server deployment";
    }
  }
  return null;
};
const isOptionCompatible = (currentStack, category, optionId) => {
  if (currentStack.yolo === "true") {
    return true;
  }
  return getDisabledReason(currentStack, category, optionId) === null;
};
const SwitchRootContext = /* @__PURE__ */ reactExports.createContext(void 0);
function useSwitchRootContext() {
  const context = reactExports.useContext(SwitchRootContext);
  if (context === void 0) {
    throw new Error(formatErrorMessage(63));
  }
  return context;
}
let FieldControlDataAttributes = /* @__PURE__ */ (function (FieldControlDataAttributes2) {
  FieldControlDataAttributes2["disabled"] = "data-disabled";
  FieldControlDataAttributes2["valid"] = "data-valid";
  FieldControlDataAttributes2["invalid"] = "data-invalid";
  FieldControlDataAttributes2["touched"] = "data-touched";
  FieldControlDataAttributes2["dirty"] = "data-dirty";
  FieldControlDataAttributes2["filled"] = "data-filled";
  FieldControlDataAttributes2["focused"] = "data-focused";
  return FieldControlDataAttributes2;
})({});
const DEFAULT_VALIDITY_STATE = {
  badInput: false,
  customError: false,
  patternMismatch: false,
  rangeOverflow: false,
  rangeUnderflow: false,
  stepMismatch: false,
  tooLong: false,
  tooShort: false,
  typeMismatch: false,
  valid: null,
  valueMissing: false,
};
const fieldValidityMapping = {
  valid(value) {
    if (value === null) {
      return null;
    }
    if (value) {
      return {
        [FieldControlDataAttributes.valid]: "",
      };
    }
    return {
      [FieldControlDataAttributes.invalid]: "",
    };
  },
};
let SwitchRootDataAttributes = /* @__PURE__ */ (function (SwitchRootDataAttributes2) {
  SwitchRootDataAttributes2["checked"] = "data-checked";
  SwitchRootDataAttributes2["unchecked"] = "data-unchecked";
  SwitchRootDataAttributes2["disabled"] = "data-disabled";
  SwitchRootDataAttributes2["readonly"] = "data-readonly";
  SwitchRootDataAttributes2["required"] = "data-required";
  SwitchRootDataAttributes2["valid"] = "data-valid";
  SwitchRootDataAttributes2["invalid"] = "data-invalid";
  SwitchRootDataAttributes2["touched"] = "data-touched";
  SwitchRootDataAttributes2["dirty"] = "data-dirty";
  SwitchRootDataAttributes2["filled"] = "data-filled";
  SwitchRootDataAttributes2["focused"] = "data-focused";
  return SwitchRootDataAttributes2;
})({});
const stateAttributesMapping = {
  ...fieldValidityMapping,
  checked(value) {
    if (value) {
      return {
        [SwitchRootDataAttributes.checked]: "",
      };
    }
    return {
      [SwitchRootDataAttributes.unchecked]: "",
    };
  },
};
function getCombinedFieldValidityData(validityData, invalid) {
  return {
    ...validityData,
    state: {
      ...validityData.state,
      valid: !invalid && validityData.state.valid,
    },
  };
}
const FormContext = /* @__PURE__ */ reactExports.createContext({
  formRef: {
    current: {
      fields: /* @__PURE__ */ new Map(),
    },
  },
  errors: {},
  clearErrors: NOOP,
  validationMode: "onSubmit",
  submitAttemptedRef: {
    current: false,
  },
});
function useFormContext() {
  return reactExports.useContext(FormContext);
}
const FieldRootContext = /* @__PURE__ */ reactExports.createContext({
  invalid: void 0,
  name: void 0,
  validityData: {
    state: DEFAULT_VALIDITY_STATE,
    errors: [],
    error: "",
    value: "",
    initialValue: null,
  },
  setValidityData: NOOP,
  disabled: void 0,
  touched: false,
  setTouched: NOOP,
  dirty: false,
  setDirty: NOOP,
  filled: false,
  setFilled: NOOP,
  focused: false,
  setFocused: NOOP,
  validate: () => null,
  validationMode: "onSubmit",
  validationDebounceTime: 0,
  shouldValidateOnChange: () => false,
  state: {
    disabled: false,
    valid: null,
    touched: false,
    dirty: false,
    filled: false,
    focused: false,
  },
  markedDirtyRef: {
    current: false,
  },
  validation: {
    getValidationProps: (props = EMPTY_OBJECT) => props,
    getInputValidationProps: (props = EMPTY_OBJECT) => props,
    inputRef: {
      current: null,
    },
    commit: async () => {},
  },
});
function useFieldRootContext(optional = true) {
  const context = reactExports.useContext(FieldRootContext);
  if (context.setValidityData === NOOP && !optional) {
    throw new Error(formatErrorMessage(28));
  }
  return context;
}
function useField(params) {
  const { enabled = true, value, id: id2, name, controlRef, commit } = params;
  const { formRef } = useFormContext();
  const { invalid, markedDirtyRef, validityData, setValidityData } = useFieldRootContext();
  const getValue = useStableCallback(params.getValue);
  useIsoLayoutEffect(() => {
    if (!enabled) {
      return;
    }
    let initialValue = value;
    if (initialValue === void 0) {
      initialValue = getValue();
    }
    if (validityData.initialValue === null && initialValue !== null) {
      setValidityData((prev) => ({
        ...prev,
        initialValue,
      }));
    }
  }, [enabled, setValidityData, value, validityData.initialValue, getValue]);
  useIsoLayoutEffect(() => {
    if (!enabled || !id2) {
      return;
    }
    formRef.current.fields.set(id2, {
      getValue,
      name,
      controlRef,
      validityData: getCombinedFieldValidityData(validityData, invalid),
      validate(flushSync = true) {
        let nextValue = value;
        if (nextValue === void 0) {
          nextValue = getValue();
        }
        markedDirtyRef.current = true;
        if (!flushSync) {
          commit(nextValue);
        } else {
          reactDomExports.flushSync(() => commit(nextValue));
        }
      },
    });
  }, [
    commit,
    controlRef,
    enabled,
    formRef,
    getValue,
    id2,
    invalid,
    markedDirtyRef,
    name,
    validityData,
    value,
  ]);
  useIsoLayoutEffect(() => {
    const fields = formRef.current.fields;
    return () => {
      if (id2) {
        fields.delete(id2);
      }
    };
  }, [formRef, id2]);
}
const LabelableContext = /* @__PURE__ */ reactExports.createContext({
  controlId: void 0,
  setControlId: NOOP,
  labelId: void 0,
  setLabelId: NOOP,
  messageIds: [],
  setMessageIds: NOOP,
  getDescriptionProps: (externalProps) => externalProps,
});
function useLabelableContext() {
  return reactExports.useContext(LabelableContext);
}
function useLabelableId(params = {}) {
  const { id: id2, implicit = false, controlRef } = params;
  const { controlId, setControlId } = useLabelableContext();
  const defaultId = useBaseUiId(id2);
  useIsoLayoutEffect(() => {
    if ((!implicit && !id2) || setControlId === NOOP) {
      return void 0;
    }
    if (implicit) {
      const elem = controlRef == null ? void 0 : controlRef.current;
      if (isElement(elem) && elem.closest("label") != null) {
        setControlId(id2 ?? null);
      } else {
        setControlId(controlId ?? defaultId);
      }
    } else if (id2) {
      setControlId(id2);
    }
    return () => {
      if (id2) {
        setControlId(void 0);
      }
    };
  }, [id2, controlRef, controlId, setControlId, implicit, defaultId]);
  return controlId ?? defaultId;
}
function useValueChanged(value, onChange) {
  const valueRef = reactExports.useRef(value);
  const onChangeCallback = useStableCallback(onChange);
  useIsoLayoutEffect(() => {
    if (valueRef.current === value) {
      return;
    }
    onChangeCallback(valueRef.current);
  }, [value, onChangeCallback]);
  useIsoLayoutEffect(() => {
    valueRef.current = value;
  }, [value]);
}
const SwitchRoot = /* @__PURE__ */ reactExports.forwardRef(
  function SwitchRoot2(componentProps, forwardedRef) {
    const {
      checked: checkedProp,
      className,
      defaultChecked,
      id: idProp,
      inputRef: externalInputRef,
      name: nameProp,
      nativeButton = false,
      onCheckedChange: onCheckedChangeProp,
      readOnly = false,
      required = false,
      disabled: disabledProp = false,
      render,
      uncheckedValue,
      value,
      ...elementProps
    } = componentProps;
    const { clearErrors } = useFormContext();
    const {
      state: fieldState,
      setTouched,
      setDirty,
      validityData,
      setFilled,
      setFocused,
      shouldValidateOnChange,
      validationMode,
      disabled: fieldDisabled,
      name: fieldName,
      validation,
    } = useFieldRootContext();
    const { labelId } = useLabelableContext();
    const disabled2 = fieldDisabled || disabledProp;
    const name = fieldName ?? nameProp;
    const onCheckedChange = useStableCallback(onCheckedChangeProp);
    const inputRef = reactExports.useRef(null);
    const handleInputRef = useMergedRefs(inputRef, externalInputRef, validation.inputRef);
    const switchRef = reactExports.useRef(null);
    const id2 = useBaseUiId();
    const controlId = useLabelableId({
      id: idProp,
      implicit: false,
      controlRef: switchRef,
    });
    const hiddenInputId = nativeButton ? void 0 : controlId;
    const [checked, setCheckedState] = useControlled({
      controlled: checkedProp,
      default: Boolean(defaultChecked),
      name: "Switch",
      state: "checked",
    });
    useField({
      id: id2,
      commit: validation.commit,
      value: checked,
      controlRef: switchRef,
      name,
      getValue: () => checked,
    });
    useIsoLayoutEffect(() => {
      if (inputRef.current) {
        setFilled(inputRef.current.checked);
      }
    }, [inputRef, setFilled]);
    useValueChanged(checked, () => {
      clearErrors(name);
      setDirty(checked !== validityData.initialValue);
      setFilled(checked);
      if (shouldValidateOnChange()) {
        validation.commit(checked);
      } else {
        validation.commit(checked, true);
      }
    });
    const { getButtonProps, buttonRef } = useButton({
      disabled: disabled2,
      native: nativeButton,
    });
    const rootProps = {
      id: nativeButton ? controlId : id2,
      role: "switch",
      "aria-checked": checked,
      "aria-readonly": readOnly || void 0,
      "aria-required": required || void 0,
      "aria-labelledby": labelId,
      onFocus() {
        if (!disabled2) {
          setFocused(true);
        }
      },
      onBlur() {
        const element2 = inputRef.current;
        if (!element2 || disabled2) {
          return;
        }
        setTouched(true);
        setFocused(false);
        if (validationMode === "onBlur") {
          validation.commit(element2.checked);
        }
      },
      onClick(event) {
        var _a2;
        if (readOnly || disabled2) {
          return;
        }
        event.preventDefault();
        (_a2 = inputRef == null ? void 0 : inputRef.current) == null ? void 0 : _a2.click();
      },
    };
    const inputProps = reactExports.useMemo(
      () =>
        mergeProps$1(
          {
            checked,
            disabled: disabled2,
            id: hiddenInputId,
            name,
            required,
            style: name ? visuallyHiddenInput : visuallyHidden,
            tabIndex: -1,
            type: "checkbox",
            "aria-hidden": true,
            ref: handleInputRef,
            onChange(event) {
              if (event.nativeEvent.defaultPrevented) {
                return;
              }
              const nextChecked = event.target.checked;
              const eventDetails = createChangeEventDetails(none, event.nativeEvent);
              onCheckedChange == null ? void 0 : onCheckedChange(nextChecked, eventDetails);
              if (eventDetails.isCanceled) {
                return;
              }
              setCheckedState(nextChecked);
            },
            onFocus() {
              var _a2;
              (_a2 = switchRef.current) == null ? void 0 : _a2.focus();
            },
          },
          validation.getInputValidationProps,
          // React <19 sets an empty value if `undefined` is passed explicitly
          // To avoid this, we only set the value if it's defined
          value !== void 0
            ? {
                value,
              }
            : EMPTY_OBJECT,
        ),
      [
        checked,
        disabled2,
        handleInputRef,
        hiddenInputId,
        name,
        onCheckedChange,
        required,
        setCheckedState,
        validation,
        value,
      ],
    );
    const state = reactExports.useMemo(
      () => ({
        ...fieldState,
        checked,
        disabled: disabled2,
        readOnly,
        required,
      }),
      [fieldState, checked, disabled2, readOnly, required],
    );
    const element = useRenderElement("span", componentProps, {
      state,
      ref: [forwardedRef, switchRef, buttonRef],
      props: [rootProps, validation.getValidationProps, elementProps, getButtonProps],
      stateAttributesMapping,
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(SwitchRootContext.Provider, {
      value: state,
      children: [
        element,
        !checked &&
          name &&
          uncheckedValue !== void 0 &&
          /* @__PURE__ */ jsxRuntimeExports.jsx("input", {
            type: "hidden",
            name,
            value: uncheckedValue,
          }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("input", {
          ...inputProps,
        }),
      ],
    });
  },
);
const SwitchThumb = /* @__PURE__ */ reactExports.forwardRef(
  function SwitchThumb2(componentProps, forwardedRef) {
    const { render, className, ...elementProps } = componentProps;
    const { state: fieldState } = useFieldRootContext();
    const state = useSwitchRootContext();
    const extendedState = {
      ...fieldState,
      ...state,
    };
    return useRenderElement("span", componentProps, {
      state: extendedState,
      ref: forwardedRef,
      stateAttributesMapping,
      props: elementProps,
    });
  },
);
function Switch({ className, size: size2 = "default", ...props }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SwitchRoot, {
    "data-slot": "switch",
    "data-size": size2,
    className: cn(
      "data-checked:bg-primary data-unchecked:bg-input focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:aria-invalid:border-destructive/50 dark:data-unchecked:bg-input/80 shrink-0 rounded-full border border-transparent focus-visible:ring-1 aria-invalid:ring-1 data-[size=default]:h-[18.4px] data-[size=default]:w-[32px] data-[size=sm]:h-[14px] data-[size=sm]:w-[24px] peer group/switch relative inline-flex items-center transition-all outline-none after:absolute after:-inset-x-3 after:-inset-y-2 data-disabled:cursor-not-allowed data-disabled:opacity-50",
      className,
    ),
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(SwitchThumb, {
      "data-slot": "switch-thumb",
      className:
        "bg-background dark:data-unchecked:bg-foreground dark:data-checked:bg-primary-foreground rounded-full group-data-[size=default]/switch:size-4 group-data-[size=sm]/switch:size-3 group-data-[size=default]/switch:data-checked:translate-x-[calc(100%-2px)] group-data-[size=sm]/switch:data-checked:translate-x-[calc(100%-2px)] group-data-[size=default]/switch:data-unchecked:translate-x-0 group-data-[size=sm]/switch:data-unchecked:translate-x-0 pointer-events-none block ring-0 transition-transform",
    }),
  });
}
function YoloToggle({ stack, onToggle }) {
  const isYoloEnabled = stack.yolo === "true";
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Tooltip, {
    delay: 100,
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(TooltipTrigger, {
        render: /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
          className: "flex w-full items-center gap-3 p-3",
        }),
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(TriangleAlert, { className: "h-4 w-4 shrink-0" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
            className: "flex flex-1 flex-col items-start",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
                className: "font-medium text-sm",
                children: "YOLO Mode",
              }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
                className: "text-muted-foreground text-xs",
                children: isYoloEnabled ? "Enabled" : "Disabled",
              }),
            ],
          }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Switch, {
            checked: isYoloEnabled,
            onCheckedChange: (checked) => onToggle(checked ? "true" : "false"),
            className: cn(isYoloEnabled && "data-[state=checked]:bg-destructive"),
          }),
        ],
      }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContent, {
        side: "top",
        align: "start",
        className: "max-w-xs",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", {
          className: "text-xs",
          children:
            "Disables all validation and adds --yolo flag to the command. Use at your own risk!",
        }),
      }),
    ],
  });
}
function formatProjectName(name) {
  return name.replace(/\s+/g, "-");
}
const StackBuilder = () => {
  const [stack, setStack, viewMode, setViewMode] = useStackState();
  reactExports.useEffect(() => {
    console.log("[StackBuilder] Stack state:", stack);
  }, [stack]);
  const [command, setCommand] = reactExports.useState("");
  const [copied, setCopied] = reactExports.useState(false);
  const [lastSavedStack, setLastSavedStack] = reactExports.useState(null);
  const [, setLastChanges] = reactExports.useState([]);
  const sectionRefs = reactExports.useRef({});
  const contentRef = reactExports.useRef(null);
  const scrollAreaRef = reactExports.useRef(null);
  const lastAppliedStackString = reactExports.useRef("");
  reactExports.useEffect(() => {
    if (scrollAreaRef.current) {
      const viewport = scrollAreaRef.current.querySelector('[data-slot="scroll-area-viewport"]');
      if (viewport) {
        contentRef.current = viewport;
      }
    }
  }, [viewMode]);
  const compatibilityAnalysis = analyzeStackCompatibility(stack);
  const projectNameError = validateProjectName(stack.projectName || "");
  const getStackUrl = () => {
    const stackToUse = compatibilityAnalysis.adjustedStack || stack;
    const projectName = stackToUse.projectName || "my-better-t-app";
    const formattedProjectName = formatProjectName(projectName);
    const stackWithProjectName = {
      ...stackToUse,
      projectName: formattedProjectName,
    };
    return generateStackSharingUrl(stackWithProjectName);
  };
  const getRandomStack = () => {
    var _a2;
    const randomStack = {};
    for (const category of CATEGORY_ORDER) {
      const options = TECH_OPTIONS[category] || [];
      if (options.length === 0) continue;
      const catKey = category;
      if (
        catKey === "webFrontend" ||
        catKey === "nativeFrontend" ||
        catKey === "codeQuality" ||
        catKey === "documentation" ||
        catKey === "appPlatforms" ||
        catKey === "examples"
      ) {
        if (catKey === "webFrontend" || catKey === "nativeFrontend") {
          const randomIndex = Math.floor(Math.random() * options.length);
          const selectedOption = options[randomIndex].id;
          randomStack[catKey] = [selectedOption];
        } else {
          const numToPick = Math.floor(Math.random() * Math.min(options.length, 4));
          if (numToPick === 0) {
            randomStack[catKey] = [];
          } else {
            const shuffledOptions = [...options]
              .filter((opt) => opt.id !== "none")
              .sort(() => 0.5 - Math.random())
              .slice(0, numToPick);
            randomStack[catKey] = shuffledOptions.map((opt) => opt.id);
          }
        }
      } else {
        const randomIndex = Math.floor(Math.random() * options.length);
        randomStack[catKey] = options[randomIndex].id;
      }
    }
    reactExports.startTransition(() => {
      setStack({
        ...randomStack,
        projectName: stack.projectName || "my-better-t-app",
      });
    });
    (_a2 = contentRef.current) == null ? void 0 : _a2.scrollTo(0, 0);
  };
  const selectedStackCards = (() => {
    const cards = [];
    const categoryOrder =
      stack.ecosystem === "rust" ? RUST_CATEGORY_ORDER : TYPESCRIPT_CATEGORY_ORDER;
    for (const category of categoryOrder) {
      const categoryKey = category;
      const options = TECH_OPTIONS[category];
      const selectedValue = stack[categoryKey];
      const categoryDisplayName = getCategoryDisplayName(category);
      if (!options) continue;
      if (Array.isArray(selectedValue)) {
        if (
          selectedValue.length === 0 ||
          (selectedValue.length === 1 && selectedValue[0] === "none")
        ) {
          continue;
        }
        for (const id2 of selectedValue) {
          if (id2 === "none") continue;
          const tech = options.find((opt) => opt.id === id2);
          if (tech) {
            cards.push(
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "div",
                {
                  className: cn(
                    "flex items-center gap-3 rounded-lg border p-2.5 transition-colors",
                    getBadgeColors(category),
                  ),
                  children: [
                    tech.icon !== "" &&
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
                        className:
                          "flex h-8 w-8 shrink-0 items-center justify-center rounded-md bg-muted/50",
                        children: /* @__PURE__ */ jsxRuntimeExports.jsx(TechIcon, {
                          icon: tech.icon,
                          name: tech.name,
                          className: cn("h-5 w-5", tech.className),
                        }),
                      }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
                      className: "min-w-0 flex-1",
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx("p", {
                          className:
                            "mb-0.5 truncate text-[10px] font-medium uppercase tracking-wider text-muted-foreground/70",
                          children: categoryDisplayName,
                        }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("p", {
                          className: "truncate font-medium text-foreground text-sm",
                          children: tech.name,
                        }),
                      ],
                    }),
                  ],
                },
                `${category}-${tech.id}`,
              ),
            );
          }
        }
      } else {
        const tech = options.find((opt) => opt.id === selectedValue);
        if (
          !tech ||
          tech.id === "none" ||
          tech.id === "false" ||
          ((category === "git" || category === "install" || category === "auth") &&
            tech.id === "true")
        ) {
          continue;
        }
        cards.push(
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              className: cn(
                "flex items-center gap-3 rounded-lg border p-2.5 transition-colors",
                getBadgeColors(category),
              ),
              children: [
                tech.icon !== "" &&
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
                    className:
                      "flex h-8 w-8 shrink-0 items-center justify-center rounded-md bg-muted/50",
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(TechIcon, {
                      icon: tech.icon,
                      name: tech.name,
                      className: cn("h-5 w-5", tech.className),
                    }),
                  }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
                  className: "min-w-0 flex-1",
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", {
                      className:
                        "mb-0.5 truncate text-[10px] font-medium uppercase tracking-wider text-muted-foreground/70",
                      children: categoryDisplayName,
                    }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", {
                      className: "truncate font-medium text-foreground text-sm",
                      children: tech.name,
                    }),
                  ],
                }),
              ],
            },
            `${category}-${tech.id}`,
          ),
        );
      }
    }
    return cards;
  })();
  reactExports.useEffect(() => {
    const savedStack = localStorage.getItem("betterTStackPreference");
    if (savedStack) {
      try {
        const parsedStack = JSON.parse(savedStack);
        setLastSavedStack(parsedStack);
      } catch (e) {
        console.error("Failed to parse saved stack", e);
        localStorage.removeItem("betterTStackPreference");
      }
    }
  }, []);
  reactExports.useEffect(() => {
    if (compatibilityAnalysis.adjustedStack) {
      const adjustedStackString = JSON.stringify(compatibilityAnalysis.adjustedStack);
      if (lastAppliedStackString.current !== adjustedStackString) {
        reactExports.startTransition(() => {
          if (compatibilityAnalysis.changes.length > 0) {
            if (compatibilityAnalysis.changes.length === 1) {
              toast.info(compatibilityAnalysis.changes[0].message, {
                duration: 4e3,
              });
            } else if (compatibilityAnalysis.changes.length > 1) {
              const message = `${compatibilityAnalysis.changes.length} compatibility adjustments made:
${compatibilityAnalysis.changes.map((c) => ` ${c.message}`).join("\n")}`;
              toast.info(message, {
                duration: 5e3,
              });
            }
          }
          setLastChanges(compatibilityAnalysis.changes);
          if (compatibilityAnalysis.adjustedStack) {
            setStack(compatibilityAnalysis.adjustedStack);
          }
          lastAppliedStackString.current = adjustedStackString;
        });
      }
    }
  }, [compatibilityAnalysis.adjustedStack, compatibilityAnalysis.changes, setStack]);
  reactExports.useEffect(() => {
    const stackToUse = compatibilityAnalysis.adjustedStack || stack;
    const projectName = stackToUse.projectName || "my-better-t-app";
    const formattedProjectName = formatProjectName(projectName);
    const stackWithProjectName = {
      ...stackToUse,
      projectName: formattedProjectName,
    };
    const cmd = generateStackCommand(stackWithProjectName);
    setCommand(cmd);
  }, [stack, compatibilityAnalysis.adjustedStack]);
  const handleTechSelect = (category, techId) => {
    console.log("[StackBuilder] handleTechSelect called:", { category, techId, stack });
    if (!isOptionCompatible(stack, category, techId)) {
      console.log("[StackBuilder] Option not compatible, returning early");
      return;
    }
    console.log("[StackBuilder] Option is compatible, updating state");
    reactExports.startTransition(() => {
      setStack((currentStack) => {
        const catKey = category;
        const update2 = {};
        const currentValue = currentStack[catKey];
        if (
          catKey === "webFrontend" ||
          catKey === "nativeFrontend" ||
          catKey === "codeQuality" ||
          catKey === "documentation" ||
          catKey === "appPlatforms" ||
          catKey === "examples"
        ) {
          const currentArray = Array.isArray(currentValue) ? [...currentValue] : [];
          let nextArray = [...currentArray];
          const isSelected = currentArray.includes(techId);
          if (catKey === "webFrontend") {
            if (techId === "none") {
              nextArray = ["none"];
            } else if (isSelected) {
              if (currentArray.length > 1) {
                nextArray = nextArray.filter((id2) => id2 !== techId);
              } else {
                nextArray = ["none"];
              }
            } else {
              nextArray = [techId];
            }
          } else if (catKey === "nativeFrontend") {
            if (techId === "none") {
              nextArray = ["none"];
            } else if (isSelected) {
              nextArray = ["none"];
            } else {
              nextArray = [techId];
            }
          } else {
            if (isSelected) {
              nextArray = nextArray.filter((id2) => id2 !== techId);
            } else {
              nextArray.push(techId);
            }
            if (nextArray.length > 1) {
              nextArray = nextArray.filter((id2) => id2 !== "none");
            }
            if (
              nextArray.length === 0 &&
              (catKey === "codeQuality" ||
                catKey === "documentation" ||
                catKey === "appPlatforms" ||
                catKey === "examples")
            );
            else if (nextArray.length === 0) {
              nextArray = ["none"];
            }
          }
          const uniqueNext = [...new Set(nextArray)].sort();
          const uniqueCurrent = [...new Set(currentArray)].sort();
          if (JSON.stringify(uniqueNext) !== JSON.stringify(uniqueCurrent)) {
            update2[catKey] = uniqueNext;
          }
        } else {
          if (currentValue !== techId) {
            update2[catKey] = techId;
          } else {
            if ((category === "git" || category === "install") && techId === "false") {
              update2[catKey] = "true";
            } else if ((category === "git" || category === "install") && techId === "true") {
              update2[catKey] = "false";
            }
          }
        }
        return Object.keys(update2).length > 0 ? update2 : {};
      });
    });
  };
  const copyToClipboard = () => {
    navigator.clipboard.writeText(command);
    setCopied(true);
    setTimeout(() => setCopied(false), 2e3);
  };
  const resetStack = () => {
    var _a2;
    reactExports.startTransition(() => {
      setStack(DEFAULT_STACK);
    });
    (_a2 = contentRef.current) == null ? void 0 : _a2.scrollTo(0, 0);
  };
  const saveCurrentStack = () => {
    const stackToUse = compatibilityAnalysis.adjustedStack || stack;
    const projectName = stackToUse.projectName || "my-better-t-app";
    const formattedProjectName = formatProjectName(projectName);
    const stackToSave = { ...stackToUse, projectName: formattedProjectName };
    localStorage.setItem("betterTStackPreference", JSON.stringify(stackToSave));
    setLastSavedStack(stackToSave);
    toast.success("Your stack configuration has been saved");
  };
  const loadSavedStack = () => {
    var _a2;
    if (lastSavedStack) {
      reactExports.startTransition(() => {
        setStack(lastSavedStack);
      });
      (_a2 = contentRef.current) == null ? void 0 : _a2.scrollTo(0, 0);
      toast.success("Saved configuration loaded");
    }
  };
  const applyPreset = (presetId) => {
    var _a2;
    const preset = PRESET_TEMPLATES.find((template) => template.id === presetId);
    if (preset) {
      reactExports.startTransition(() => {
        setStack({ ...DEFAULT_STACK, ...preset.stack });
      });
      (_a2 = contentRef.current) == null ? void 0 : _a2.scrollTo(0, 0);
      toast.success(`Applied preset: ${preset.name}`);
    }
  };
  const [mobileTab, setMobileTab] = reactExports.useState("configure");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipProvider, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
      className:
        "flex flex-col h-full w-full overflow-hidden border-border text-foreground sm:grid sm:grid-cols-[auto_1fr]",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
          className: "flex border-b border-border bg-fd-background pl-2 sm:hidden",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("button", {
              type: "button",
              onClick: () => setMobileTab("summary"),
              className: cn(
                "flex flex-1 items-center justify-center gap-2 border-b-2 px-1 py-3 text-xs font-medium transition-all hover:bg-muted/50",
                mobileTab === "summary"
                  ? "border-primary text-primary"
                  : "border-transparent text-muted-foreground hover:text-foreground",
              ),
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(List, { className: "h-4 w-4" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Summary" }),
              ],
            }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("button", {
              type: "button",
              onClick: () => setMobileTab("configure"),
              className: cn(
                "flex flex-1 items-center justify-center gap-2 border-b-2 px-1 py-3 text-xs font-medium transition-all hover:bg-muted/50",
                mobileTab === "configure"
                  ? "border-primary text-primary"
                  : "border-transparent text-muted-foreground hover:text-foreground",
              ),
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Terminal, { className: "h-4 w-4" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Configure" }),
              ],
            }),
          ],
        }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
          className: cn(
            "flex w-full flex-col border-border sm:border-r sm:max-w-3xs md:max-w-xs lg:max-w-sm",
            mobileTab === "summary" ? "flex" : "hidden sm:flex",
          ),
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollArea, {
            className: "flex-1",
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
              className: "flex h-full flex-col gap-3 p-3 sm:p-4 md:h-[calc(100vh-64px)]",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
                  className: "flex flex-1 flex-col gap-3 overflow-hidden",
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("label", {
                      className: "flex shrink-0 flex-col",
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
                          className: "mb-1 text-muted-foreground text-xs",
                          children: "Project Name:",
                        }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("input", {
                          type: "text",
                          value: stack.projectName || "",
                          onChange: (e) => {
                            setStack({ projectName: e.target.value });
                          },
                          className: cn(
                            "w-full rounded border px-2 py-1 text-sm focus:outline-none",
                            projectNameError
                              ? "border-destructive bg-destructive/10 text-destructive-foreground"
                              : "border-border focus:border-primary",
                          ),
                          placeholder: "my-better-t-app",
                        }),
                        projectNameError &&
                          /* @__PURE__ */ jsxRuntimeExports.jsx("p", {
                            className: "mt-1 text-destructive text-xs",
                            children: projectNameError,
                          }),
                        (stack.projectName || "my-better-t-app").includes(" ") &&
                          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", {
                            className: "mt-1 text-muted-foreground text-xs",
                            children: [
                              "Will be saved as:",
                              " ",
                              /* @__PURE__ */ jsxRuntimeExports.jsx("code", {
                                className: "rounded bg-muted px-1 py-0.5 text-xs",
                                children: (stack.projectName || "my-better-t-app").replace(
                                  /\s+/g,
                                  "-",
                                ),
                              }),
                            ],
                          }),
                      ],
                    }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
                      className: "shrink-0 rounded border border-border p-2",
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
                          className: "flex",
                          children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
                              className: "mr-2 select-none text-chart-4",
                              children: "$",
                            }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx("code", {
                              className: "block break-all text-muted-foreground text-xs sm:text-sm",
                              children: command,
                            }),
                          ],
                        }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
                          className: "mt-2 flex justify-end",
                          children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", {
                            type: "button",
                            onClick: copyToClipboard,
                            className: cn(
                              "flex items-center gap-1 rounded px-2 py-1 text-xs transition-colors",
                              copied
                                ? "bg-muted text-chart-4"
                                : "text-muted-foreground hover:bg-muted hover:text-foreground",
                            ),
                            title: copied ? "Copied!" : "Copy command",
                            children: copied
                              ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                                  children: [
                                    /* @__PURE__ */ jsxRuntimeExports.jsx(Check, {
                                      className: "h-3 w-3 shrink-0",
                                    }),
                                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
                                      className: "",
                                      children: "Copied",
                                    }),
                                  ],
                                })
                              : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                                  children: [
                                    /* @__PURE__ */ jsxRuntimeExports.jsx(ClipboardCopy, {
                                      className: "h-3 w-3 shrink-0",
                                    }),
                                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
                                      className: "",
                                      children: "Copy",
                                    }),
                                  ],
                                }),
                          }),
                        }),
                      ],
                    }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
                      className: "flex flex-1 flex-col overflow-hidden",
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsxs("h3", {
                          className: "mb-2 font-medium text-foreground text-sm",
                          children: ["Selected Stack (", selectedStackCards.length, ")"],
                        }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
                          className: "flex-1 overflow-y-auto pr-1",
                          children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
                            className: "flex flex-col gap-2 pb-2",
                            children: selectedStackCards,
                          }),
                        }),
                      ],
                    }),
                  ],
                }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
                  className: "mt-auto border-border border-t pt-4",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
                    className: "space-y-3",
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(ActionButtons, {
                        onReset: resetStack,
                        onRandom: getRandomStack,
                        onSave: saveCurrentStack,
                        onLoad: loadSavedStack,
                        hasSavedStack: !!lastSavedStack,
                      }),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
                        className: "flex gap-1",
                        children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx(ShareButton, {
                            stackUrl: getStackUrl(),
                          }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(PresetDropdown, {
                            onApplyPreset: applyPreset,
                          }),
                          /* @__PURE__ */ jsxRuntimeExports.jsxs(DropdownMenu, {
                            children: [
                              /* @__PURE__ */ jsxRuntimeExports.jsxs(DropdownMenuTrigger, {
                                render: /* @__PURE__ */ jsxRuntimeExports.jsx("button", {
                                  type: "button",
                                  className:
                                    "flex flex-1 items-center justify-center gap-1.5 rounded-md border border-border bg-fd-background px-2 py-1.5 font-medium text-muted-foreground text-xs transition-all hover:border-muted-foreground/30 hover:bg-muted hover:text-foreground",
                                }),
                                children: [
                                  /* @__PURE__ */ jsxRuntimeExports.jsx(Settings, {
                                    className: "h-3 w-3",
                                  }),
                                  "Settings",
                                  /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronDown, {
                                    className: "ml-auto h-3 w-3",
                                  }),
                                ],
                              }),
                              /* @__PURE__ */ jsxRuntimeExports.jsx(DropdownMenuContent, {
                                align: "end",
                                className: "w-64 bg-fd-background",
                                children: /* @__PURE__ */ jsxRuntimeExports.jsx(YoloToggle, {
                                  stack,
                                  onToggle: (yolo) => setStack({ yolo }),
                                }),
                              }),
                            ],
                          }),
                        ],
                      }),
                    ],
                  }),
                }),
              ],
            }),
          }),
        }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
          className: cn(
            "flex flex-1 flex-col overflow-hidden",
            mobileTab === "summary" ? "hidden sm:flex" : "flex",
          ),
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Tabs, {
              value: viewMode,
              onValueChange: (value) => {
                reactExports.startTransition(() => {
                  setViewMode(value);
                });
              },
              className: "hidden sm:flex sm:flex-col sm:flex-1 sm:overflow-hidden",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
                  className: "flex items-center border-b border-border bg-fd-background sm:px-2",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(TabsList, {
                    variant: "line",
                    className: "h-auto w-full justify-start gap-4 rounded-none bg-transparent p-0",
                    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(TabsTrigger, {
                      value: "command",
                      className:
                        "relative gap-2 rounded-none border-b-2 border-transparent bg-transparent px-2 py-3 text-xs font-medium text-muted-foreground transition-none data-active:border-primary data-active:bg-transparent data-active:text-foreground data-active:shadow-none hover:text-foreground",
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Terminal, {
                          className: "h-3.5 w-3.5",
                        }),
                        "Configure",
                      ],
                    }),
                  }),
                }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, {
                  value: "command",
                  className: "flex-1 min-h-0 overflow-hidden",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
                    ref: scrollAreaRef,
                    className: "h-full",
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollArea, {
                      className: "h-full overflow-hidden scroll-smooth",
                      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("main", {
                        className: "p-3 sm:p-4",
                        children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
                            className: "mb-6 sm:mb-8",
                            children: [
                              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
                                className:
                                  "mb-3 flex items-center border-border border-b pb-2 text-muted-foreground",
                                children: [
                                  /* @__PURE__ */ jsxRuntimeExports.jsx(Terminal, {
                                    className: "mr-2 h-4 w-4 shrink-0 sm:h-5 sm:w-5",
                                  }),
                                  /* @__PURE__ */ jsxRuntimeExports.jsx("h2", {
                                    className:
                                      "font-semibold font-mono text-foreground text-sm sm:text-base",
                                    children: "Ecosystem",
                                  }),
                                ],
                              }),
                              /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
                                className: "flex gap-3",
                                children: ECOSYSTEMS.map((ecosystem) => {
                                  const isSelected = stack.ecosystem === ecosystem.id;
                                  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                                    motion.button,
                                    {
                                      type: "button",
                                      className: cn(
                                        "group relative flex flex-1 cursor-pointer items-center gap-3 rounded-xl border-2 px-4 py-4 transition-all",
                                        isSelected
                                          ? "border-primary bg-primary/5 ring-2 ring-primary/20"
                                          : "border-border bg-fd-background hover:border-primary/30 hover:bg-muted/5",
                                      ),
                                      whileHover: { scale: 1.01 },
                                      whileTap: { scale: 0.99 },
                                      onClick: () => {
                                        reactExports.startTransition(() => {
                                          setStack({ ecosystem: ecosystem.id });
                                        });
                                      },
                                      children: [
                                        /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
                                          className: cn(
                                            "flex h-12 w-12 shrink-0 items-center justify-center rounded-lg transition-colors",
                                            isSelected
                                              ? "bg-primary/10"
                                              : "bg-muted/50 group-hover:bg-muted",
                                          ),
                                          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                                            TechIcon,
                                            {
                                              icon: ecosystem.icon,
                                              name: ecosystem.name,
                                              className: cn(
                                                "h-6 w-6",
                                                ecosystem.id === "rust" && "invert-0 dark:invert",
                                              ),
                                            },
                                          ),
                                        }),
                                        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
                                          className: "text-left",
                                          children: [
                                            /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
                                              className: cn(
                                                "block font-semibold text-base",
                                                isSelected ? "text-primary" : "text-foreground",
                                              ),
                                              children: ecosystem.name,
                                            }),
                                            /* @__PURE__ */ jsxRuntimeExports.jsx("p", {
                                              className: "text-muted-foreground text-xs",
                                              children: ecosystem.description,
                                            }),
                                          ],
                                        }),
                                      ],
                                    },
                                    ecosystem.id,
                                  );
                                }),
                              }),
                            ],
                          }),
                          (stack.ecosystem === "rust"
                            ? RUST_CATEGORY_ORDER
                            : TYPESCRIPT_CATEGORY_ORDER
                          ).map((categoryKey) => {
                            var _a2;
                            if (categoryKey === "astroIntegration") return null;
                            const categoryOptions = TECH_OPTIONS[categoryKey] || [];
                            const categoryDisplayName = getCategoryDisplayName(categoryKey);
                            const filteredOptions = categoryOptions;
                            if (filteredOptions.length === 0) return null;
                            return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                              "div",
                              {
                                children: [
                                  /* @__PURE__ */ jsxRuntimeExports.jsxs("section", {
                                    ref: (el) => {
                                      sectionRefs.current[categoryKey] = el;
                                    },
                                    id: `section-${categoryKey}`,
                                    className: "mb-6 scroll-mt-4 sm:mb-8",
                                    children: [
                                      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
                                        className:
                                          "mb-3 flex items-center border-border border-b pb-2 text-muted-foreground",
                                        children: [
                                          /* @__PURE__ */ jsxRuntimeExports.jsx(Terminal, {
                                            className: "mr-2 h-4 w-4 shrink-0 sm:h-5 sm:w-5",
                                          }),
                                          /* @__PURE__ */ jsxRuntimeExports.jsx("h2", {
                                            className:
                                              "font-semibold font-mono text-foreground text-sm sm:text-base",
                                            children: categoryDisplayName,
                                          }),
                                          ((_a2 = compatibilityAnalysis.notes[categoryKey]) == null
                                            ? void 0
                                            : _a2.hasIssue) &&
                                            /* @__PURE__ */ jsxRuntimeExports.jsxs(Tooltip, {
                                              delay: 100,
                                              children: [
                                                /* @__PURE__ */ jsxRuntimeExports.jsx(
                                                  TooltipTrigger,
                                                  {
                                                    render: /* @__PURE__ */ jsxRuntimeExports.jsx(
                                                      Info,
                                                      {
                                                        className:
                                                          "ml-2 h-4 w-4 shrink-0 cursor-help text-muted-foreground",
                                                      },
                                                    ),
                                                  },
                                                ),
                                                /* @__PURE__ */ jsxRuntimeExports.jsx(
                                                  TooltipContent,
                                                  {
                                                    side: "top",
                                                    align: "start",
                                                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                                                      "ul",
                                                      {
                                                        className:
                                                          "list-disc space-y-1 pl-4 text-xs",
                                                        children: compatibilityAnalysis.notes[
                                                          categoryKey
                                                        ].notes.map((note) =>
                                                          /* @__PURE__ */ jsxRuntimeExports.jsx(
                                                            "li",
                                                            { children: note },
                                                            note,
                                                          ),
                                                        ),
                                                      },
                                                    ),
                                                  },
                                                ),
                                              ],
                                            }),
                                        ],
                                      }),
                                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
                                        className:
                                          "grid grid-cols-1 gap-2 sm:grid-cols-2 sm:gap-3 lg:grid-cols-3 2xl:grid-cols-4",
                                        children: filteredOptions.map((tech) => {
                                          let isSelected = false;
                                          const category = categoryKey;
                                          const currentValue = stack[category];
                                          if (
                                            category === "codeQuality" ||
                                            category === "documentation" ||
                                            category === "appPlatforms" ||
                                            category === "examples" ||
                                            category === "webFrontend" ||
                                            category === "nativeFrontend"
                                          ) {
                                            isSelected = (currentValue || []).includes(tech.id);
                                          } else {
                                            isSelected = currentValue === tech.id;
                                          }
                                          const isDisabled = !isOptionCompatible(
                                            stack,
                                            categoryKey,
                                            tech.id,
                                          );
                                          const disabledReason = isDisabled
                                            ? getDisabledReason(stack, categoryKey, tech.id)
                                            : null;
                                          return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                                            motion.div,
                                            {
                                              className: cn(
                                                "group relative cursor-pointer rounded-lg border p-3 transition-all sm:p-4",
                                                isSelected
                                                  ? "border-primary bg-primary/5 ring-1 ring-primary/20"
                                                  : isDisabled
                                                    ? "border-destructive/30 bg-destructive/5 opacity-50 hover:opacity-75"
                                                    : "border-border bg-fd-background hover:border-primary/30 hover:bg-muted/5",
                                              ),
                                              whileHover: { scale: 1.01 },
                                              whileTap: { scale: 0.99 },
                                              onClick: (e) => {
                                                e.stopPropagation();
                                                handleTechSelect(categoryKey, tech.id);
                                              },
                                              title: disabledReason || void 0,
                                              children: [
                                                tech.default &&
                                                  !isSelected &&
                                                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
                                                    className:
                                                      "absolute top-2 right-2 rounded-full bg-muted px-2 py-0.5 font-medium text-[10px] text-muted-foreground",
                                                    children: "Default",
                                                  }),
                                                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
                                                  className: "flex items-start gap-3",
                                                  children: [
                                                    tech.icon !== "" &&
                                                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
                                                        className: cn(
                                                          "flex h-10 w-10 shrink-0 items-center justify-center rounded-lg transition-colors",
                                                          isSelected
                                                            ? "bg-primary/10"
                                                            : "bg-muted/50 group-hover:bg-muted",
                                                        ),
                                                        children:
                                                          /* @__PURE__ */ jsxRuntimeExports.jsx(
                                                            TechIcon,
                                                            {
                                                              icon: tech.icon,
                                                              name: tech.name,
                                                              className: cn(
                                                                "h-5 w-5",
                                                                tech.className,
                                                              ),
                                                            },
                                                          ),
                                                      }),
                                                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
                                                      className: "min-w-0 flex-1 pt-0.5",
                                                      children: [
                                                        /* @__PURE__ */ jsxRuntimeExports.jsx(
                                                          "span",
                                                          {
                                                            className: cn(
                                                              "block font-semibold text-sm",
                                                              isSelected
                                                                ? "text-primary"
                                                                : "text-foreground",
                                                            ),
                                                            children: tech.name,
                                                          },
                                                        ),
                                                        /* @__PURE__ */ jsxRuntimeExports.jsx("p", {
                                                          className:
                                                            "mt-0.5 line-clamp-2 text-muted-foreground text-xs leading-relaxed",
                                                          children: tech.description,
                                                        }),
                                                      ],
                                                    }),
                                                  ],
                                                }),
                                              ],
                                            },
                                            tech.id,
                                          );
                                        }),
                                      }),
                                    ],
                                  }),
                                  categoryKey === "webFrontend" &&
                                    /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, {
                                      children:
                                        stack.webFrontend.includes("astro") &&
                                        /* @__PURE__ */ jsxRuntimeExports.jsxs(motion.section, {
                                          initial: { opacity: 0, height: 0 },
                                          animate: { opacity: 1, height: "auto" },
                                          exit: { opacity: 0, height: 0 },
                                          transition: { duration: 0.3, ease: "easeInOut" },
                                          className: "mb-6 scroll-mt-4 sm:mb-8 overflow-hidden",
                                          children: [
                                            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
                                              className:
                                                "mb-3 flex items-center border-border border-b pb-2 text-muted-foreground",
                                              children: [
                                                /* @__PURE__ */ jsxRuntimeExports.jsx(Terminal, {
                                                  className: "mr-2 h-4 w-4 shrink-0 sm:h-5 sm:w-5",
                                                }),
                                                /* @__PURE__ */ jsxRuntimeExports.jsx("h2", {
                                                  className:
                                                    "font-semibold font-mono text-foreground text-sm sm:text-base",
                                                  children: "Astro Integration",
                                                }),
                                              ],
                                            }),
                                            /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
                                              className:
                                                "grid grid-cols-1 gap-2 sm:grid-cols-2 sm:gap-3 lg:grid-cols-3 2xl:grid-cols-4",
                                              children: (TECH_OPTIONS.astroIntegration || []).map(
                                                (tech) => {
                                                  const isSelected =
                                                    stack.astroIntegration === tech.id;
                                                  const isDisabled = !isOptionCompatible(
                                                    stack,
                                                    "astroIntegration",
                                                    tech.id,
                                                  );
                                                  const disabledReason = isDisabled
                                                    ? getDisabledReason(
                                                        stack,
                                                        "astroIntegration",
                                                        tech.id,
                                                      )
                                                    : null;
                                                  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                                                    motion.div,
                                                    {
                                                      className: cn(
                                                        "group relative cursor-pointer rounded-lg border p-3 transition-all sm:p-4",
                                                        isSelected
                                                          ? "border-primary bg-primary/5 ring-1 ring-primary/20"
                                                          : isDisabled
                                                            ? "border-destructive/30 bg-destructive/5 opacity-50 hover:opacity-75"
                                                            : "border-border bg-fd-background hover:border-primary/30 hover:bg-muted/5",
                                                      ),
                                                      whileHover: { scale: 1.01 },
                                                      whileTap: { scale: 0.99 },
                                                      onClick: (e) => {
                                                        e.stopPropagation();
                                                        handleTechSelect(
                                                          "astroIntegration",
                                                          tech.id,
                                                        );
                                                      },
                                                      title: disabledReason || void 0,
                                                      children: [
                                                        tech.default &&
                                                          !isSelected &&
                                                          /* @__PURE__ */ jsxRuntimeExports.jsx(
                                                            "span",
                                                            {
                                                              className:
                                                                "absolute top-2 right-2 rounded-full bg-muted px-2 py-0.5 font-medium text-[10px] text-muted-foreground",
                                                              children: "Default",
                                                            },
                                                          ),
                                                        /* @__PURE__ */ jsxRuntimeExports.jsxs(
                                                          "div",
                                                          {
                                                            className: "flex items-start gap-3",
                                                            children: [
                                                              tech.icon !== "" &&
                                                                /* @__PURE__ */ jsxRuntimeExports.jsx(
                                                                  "div",
                                                                  {
                                                                    className: cn(
                                                                      "flex h-10 w-10 shrink-0 items-center justify-center rounded-lg transition-colors",
                                                                      isSelected
                                                                        ? "bg-primary/10"
                                                                        : "bg-muted/50 group-hover:bg-muted",
                                                                    ),
                                                                    children:
                                                                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                                                                        TechIcon,
                                                                        {
                                                                          icon: tech.icon,
                                                                          name: tech.name,
                                                                          className: cn(
                                                                            "h-5 w-5",
                                                                            tech.className,
                                                                          ),
                                                                        },
                                                                      ),
                                                                  },
                                                                ),
                                                              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                                                                "div",
                                                                {
                                                                  className:
                                                                    "min-w-0 flex-1 pt-0.5",
                                                                  children: [
                                                                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                                                                      "span",
                                                                      {
                                                                        className: cn(
                                                                          "block font-semibold text-sm",
                                                                          isSelected
                                                                            ? "text-primary"
                                                                            : "text-foreground",
                                                                        ),
                                                                        children: tech.name,
                                                                      },
                                                                    ),
                                                                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                                                                      "p",
                                                                      {
                                                                        className:
                                                                          "mt-0.5 line-clamp-2 text-muted-foreground text-xs leading-relaxed",
                                                                        children: tech.description,
                                                                      },
                                                                    ),
                                                                  ],
                                                                },
                                                              ),
                                                            ],
                                                          },
                                                        ),
                                                      ],
                                                    },
                                                    tech.id,
                                                  );
                                                },
                                              ),
                                            }),
                                          ],
                                        }),
                                    }),
                                ],
                              },
                              categoryKey,
                            );
                          }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-10" }),
                        ],
                      }),
                    }),
                  }),
                }),
              ],
            }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
              className: "flex flex-1 flex-col overflow-hidden sm:hidden",
              children:
                mobileTab === "configure" &&
                /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollArea, {
                  className: "h-full overflow-hidden scroll-smooth",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsxs("main", {
                    className: "p-3",
                    children: [
                      CATEGORY_ORDER.map((categoryKey) => {
                        var _a2;
                        if (categoryKey === "astroIntegration") return null;
                        const categoryOptions = TECH_OPTIONS[categoryKey] || [];
                        const categoryDisplayName = getCategoryDisplayName(categoryKey);
                        const filteredOptions = categoryOptions;
                        if (filteredOptions.length === 0) return null;
                        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                          "div",
                          {
                            children: [
                              /* @__PURE__ */ jsxRuntimeExports.jsxs("section", {
                                id: `section-mobile-${categoryKey}`,
                                className: "mb-6 scroll-mt-4",
                                children: [
                                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
                                    className:
                                      "mb-3 flex items-center border-border border-b pb-2 text-muted-foreground",
                                    children: [
                                      /* @__PURE__ */ jsxRuntimeExports.jsx(Terminal, {
                                        className: "mr-2 h-4 w-4 shrink-0",
                                      }),
                                      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", {
                                        className:
                                          "font-semibold font-mono text-foreground text-sm",
                                        children: categoryDisplayName,
                                      }),
                                      ((_a2 = compatibilityAnalysis.notes[categoryKey]) == null
                                        ? void 0
                                        : _a2.hasIssue) &&
                                        /* @__PURE__ */ jsxRuntimeExports.jsxs(Tooltip, {
                                          delay: 100,
                                          children: [
                                            /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipTrigger, {
                                              render: /* @__PURE__ */ jsxRuntimeExports.jsx(Info, {
                                                className:
                                                  "ml-2 h-4 w-4 shrink-0 cursor-help text-muted-foreground",
                                              }),
                                            }),
                                            /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContent, {
                                              side: "top",
                                              align: "start",
                                              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                                                "ul",
                                                {
                                                  className: "list-disc space-y-1 pl-4 text-xs",
                                                  children: compatibilityAnalysis.notes[
                                                    categoryKey
                                                  ].notes.map((note) =>
                                                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                                                      "li",
                                                      { children: note },
                                                      note,
                                                    ),
                                                  ),
                                                },
                                              ),
                                            }),
                                          ],
                                        }),
                                    ],
                                  }),
                                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
                                    className: "grid grid-cols-1 gap-2",
                                    children: filteredOptions.map((tech) => {
                                      let isSelected = false;
                                      const category = categoryKey;
                                      const currentValue = stack[category];
                                      if (
                                        category === "codeQuality" ||
                                        category === "documentation" ||
                                        category === "appPlatforms" ||
                                        category === "examples" ||
                                        category === "webFrontend" ||
                                        category === "nativeFrontend"
                                      ) {
                                        isSelected = (currentValue || []).includes(tech.id);
                                      } else {
                                        isSelected = currentValue === tech.id;
                                      }
                                      const isDisabled = !isOptionCompatible(
                                        stack,
                                        categoryKey,
                                        tech.id,
                                      );
                                      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                                        motion.div,
                                        {
                                          className: cn(
                                            "group relative cursor-pointer rounded-lg border p-3 transition-all",
                                            isSelected
                                              ? "border-primary bg-primary/5 ring-1 ring-primary/20"
                                              : isDisabled
                                                ? "border-destructive/30 bg-destructive/5 opacity-50"
                                                : "border-border bg-fd-background hover:border-primary/30 hover:bg-muted/5",
                                          ),
                                          whileTap: { scale: 0.98 },
                                          onClick: () => handleTechSelect(categoryKey, tech.id),
                                          children: [
                                            tech.default &&
                                              !isSelected &&
                                              /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
                                                className:
                                                  "absolute top-2 right-2 rounded-full bg-muted px-2 py-0.5 font-medium text-[10px] text-muted-foreground",
                                                children: "Default",
                                              }),
                                            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
                                              className: "flex items-start gap-3",
                                              children: [
                                                tech.icon !== "" &&
                                                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
                                                    className: cn(
                                                      "flex h-10 w-10 shrink-0 items-center justify-center rounded-lg transition-colors",
                                                      isSelected ? "bg-primary/10" : "bg-muted/50",
                                                    ),
                                                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                                                      TechIcon,
                                                      {
                                                        icon: tech.icon,
                                                        name: tech.name,
                                                        className: cn("h-5 w-5", tech.className),
                                                      },
                                                    ),
                                                  }),
                                                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
                                                  className: "min-w-0 flex-1 pt-0.5",
                                                  children: [
                                                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
                                                      className: cn(
                                                        "block font-semibold text-sm",
                                                        isSelected
                                                          ? "text-primary"
                                                          : "text-foreground",
                                                      ),
                                                      children: tech.name,
                                                    }),
                                                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", {
                                                      className:
                                                        "mt-0.5 line-clamp-2 text-muted-foreground text-xs leading-relaxed",
                                                      children: tech.description,
                                                    }),
                                                  ],
                                                }),
                                              ],
                                            }),
                                          ],
                                        },
                                        tech.id,
                                      );
                                    }),
                                  }),
                                ],
                              }),
                              categoryKey === "webFrontend" &&
                                /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, {
                                  children:
                                    stack.webFrontend.includes("astro") &&
                                    /* @__PURE__ */ jsxRuntimeExports.jsxs(motion.section, {
                                      initial: { opacity: 0, height: 0 },
                                      animate: { opacity: 1, height: "auto" },
                                      exit: { opacity: 0, height: 0 },
                                      transition: { duration: 0.3, ease: "easeInOut" },
                                      className: "mb-6 scroll-mt-4 overflow-hidden",
                                      children: [
                                        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
                                          className:
                                            "mb-3 flex items-center border-border border-b pb-2 text-muted-foreground",
                                          children: [
                                            /* @__PURE__ */ jsxRuntimeExports.jsx(Terminal, {
                                              className: "mr-2 h-4 w-4 shrink-0",
                                            }),
                                            /* @__PURE__ */ jsxRuntimeExports.jsx("h2", {
                                              className:
                                                "font-semibold font-mono text-foreground text-sm",
                                              children: "Astro Integration",
                                            }),
                                          ],
                                        }),
                                        /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
                                          className: "grid grid-cols-1 gap-2",
                                          children: (TECH_OPTIONS.astroIntegration || []).map(
                                            (tech) => {
                                              const isSelected = stack.astroIntegration === tech.id;
                                              const isDisabled = !isOptionCompatible(
                                                stack,
                                                "astroIntegration",
                                                tech.id,
                                              );
                                              return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                                                motion.div,
                                                {
                                                  className: cn(
                                                    "group relative cursor-pointer rounded-lg border p-3 transition-all",
                                                    isSelected
                                                      ? "border-primary bg-primary/5 ring-1 ring-primary/20"
                                                      : isDisabled
                                                        ? "border-destructive/30 bg-destructive/5 opacity-50"
                                                        : "border-border bg-fd-background hover:border-primary/30 hover:bg-muted/5",
                                                  ),
                                                  whileTap: { scale: 0.98 },
                                                  onClick: () =>
                                                    handleTechSelect("astroIntegration", tech.id),
                                                  children: [
                                                    tech.default &&
                                                      !isSelected &&
                                                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                                                        "span",
                                                        {
                                                          className:
                                                            "absolute top-2 right-2 rounded-full bg-muted px-2 py-0.5 font-medium text-[10px] text-muted-foreground",
                                                          children: "Default",
                                                        },
                                                      ),
                                                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
                                                      className: "flex items-start gap-3",
                                                      children: [
                                                        tech.icon !== "" &&
                                                          /* @__PURE__ */ jsxRuntimeExports.jsx(
                                                            "div",
                                                            {
                                                              className: cn(
                                                                "flex h-10 w-10 shrink-0 items-center justify-center rounded-lg transition-colors",
                                                                isSelected
                                                                  ? "bg-primary/10"
                                                                  : "bg-muted/50",
                                                              ),
                                                              children:
                                                                /* @__PURE__ */ jsxRuntimeExports.jsx(
                                                                  TechIcon,
                                                                  {
                                                                    icon: tech.icon,
                                                                    name: tech.name,
                                                                    className: cn(
                                                                      "h-5 w-5",
                                                                      tech.className,
                                                                    ),
                                                                  },
                                                                ),
                                                            },
                                                          ),
                                                        /* @__PURE__ */ jsxRuntimeExports.jsxs(
                                                          "div",
                                                          {
                                                            className: "min-w-0 flex-1 pt-0.5",
                                                            children: [
                                                              /* @__PURE__ */ jsxRuntimeExports.jsx(
                                                                "span",
                                                                {
                                                                  className: cn(
                                                                    "block font-semibold text-sm",
                                                                    isSelected
                                                                      ? "text-primary"
                                                                      : "text-foreground",
                                                                  ),
                                                                  children: tech.name,
                                                                },
                                                              ),
                                                              /* @__PURE__ */ jsxRuntimeExports.jsx(
                                                                "p",
                                                                {
                                                                  className:
                                                                    "mt-0.5 line-clamp-2 text-muted-foreground text-xs leading-relaxed",
                                                                  children: tech.description,
                                                                },
                                                              ),
                                                            ],
                                                          },
                                                        ),
                                                      ],
                                                    }),
                                                  ],
                                                },
                                                tech.id,
                                              );
                                            },
                                          ),
                                        }),
                                      ],
                                    }),
                                }),
                            ],
                          },
                          categoryKey,
                        );
                      }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-10" }),
                    ],
                  }),
                }),
            }),
          ],
        }),
      ],
    }),
  });
};
export { StackBuilder as default };
